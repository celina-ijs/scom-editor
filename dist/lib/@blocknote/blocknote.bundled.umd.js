(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.blocknote = {}));
})(this, function(exports2) {
  "use strict";var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

  function OrderedMap(content2) {
    this.content = content2;
  }
  OrderedMap.prototype = {
    constructor: OrderedMap,
    find: function(key2) {
      for (var i2 = 0; i2 < this.content.length; i2 += 2)
        if (this.content[i2] === key2)
          return i2;
      return -1;
    },
    // :: (string) → ?any
    // Retrieve the value stored under `key`, or return undefined when
    // no such key exists.
    get: function(key2) {
      var found2 = this.find(key2);
      return found2 == -1 ? void 0 : this.content[found2 + 1];
    },
    // :: (string, any, ?string) → OrderedMap
    // Create a new map by replacing the value of `key` with a new
    // value, or adding a binding to the end of the map. If `newKey` is
    // given, the key of the binding will be replaced with that key.
    update: function(key2, value, newKey) {
      var self2 = newKey && newKey != key2 ? this.remove(newKey) : this;
      var found2 = self2.find(key2), content2 = self2.content.slice();
      if (found2 == -1) {
        content2.push(newKey || key2, value);
      } else {
        content2[found2 + 1] = value;
        if (newKey)
          content2[found2] = newKey;
      }
      return new OrderedMap(content2);
    },
    // :: (string) → OrderedMap
    // Return a map with the given key removed, if it existed.
    remove: function(key2) {
      var found2 = this.find(key2);
      if (found2 == -1)
        return this;
      var content2 = this.content.slice();
      content2.splice(found2, 2);
      return new OrderedMap(content2);
    },
    // :: (string, any) → OrderedMap
    // Add a new key to the start of the map.
    addToStart: function(key2, value) {
      return new OrderedMap([key2, value].concat(this.remove(key2).content));
    },
    // :: (string, any) → OrderedMap
    // Add a new key to the end of the map.
    addToEnd: function(key2, value) {
      var content2 = this.remove(key2).content.slice();
      content2.push(key2, value);
      return new OrderedMap(content2);
    },
    // :: (string, string, any) → OrderedMap
    // Add a key after the given key. If `place` is not found, the new
    // key is added to the end.
    addBefore: function(place, key2, value) {
      var without = this.remove(key2), content2 = without.content.slice();
      var found2 = without.find(place);
      content2.splice(found2 == -1 ? content2.length : found2, 0, key2, value);
      return new OrderedMap(content2);
    },
    // :: ((key: string, value: any))
    // Call the given function for each key/value pair in the map, in
    // order.
    forEach: function(f) {
      for (var i2 = 0; i2 < this.content.length; i2 += 2)
        f(this.content[i2], this.content[i2 + 1]);
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a new map by prepending the keys in this map that don't
    // appear in `map` before the keys in `map`.
    prepend: function(map2) {
      map2 = OrderedMap.from(map2);
      if (!map2.size)
        return this;
      return new OrderedMap(map2.content.concat(this.subtract(map2).content));
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a new map by appending the keys in this map that don't
    // appear in `map` after the keys in `map`.
    append: function(map2) {
      map2 = OrderedMap.from(map2);
      if (!map2.size)
        return this;
      return new OrderedMap(this.subtract(map2).content.concat(map2.content));
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a map containing all the keys in this map that don't
    // appear in `map`.
    subtract: function(map2) {
      var result = this;
      map2 = OrderedMap.from(map2);
      for (var i2 = 0; i2 < map2.content.length; i2 += 2)
        result = result.remove(map2.content[i2]);
      return result;
    },
    // :: () → Object
    // Turn ordered map into a plain object.
    toObject: function() {
      var result = {};
      this.forEach(function(key2, value) {
        result[key2] = value;
      });
      return result;
    },
    // :: number
    // The amount of keys in this map.
    get size() {
      return this.content.length >> 1;
    }
  };
  OrderedMap.from = function(value) {
    if (value instanceof OrderedMap)
      return value;
    var content2 = [];
    if (value)
      for (var prop in value)
        content2.push(prop, value[prop]);
    return new OrderedMap(content2);
  };
  function findDiffStart(a2, b, pos) {
    for (let i2 = 0; ; i2++) {
      if (i2 == a2.childCount || i2 == b.childCount)
        return a2.childCount == b.childCount ? null : pos;
      let childA = a2.child(i2), childB = b.child(i2);
      if (childA == childB) {
        pos += childA.nodeSize;
        continue;
      }
      if (!childA.sameMarkup(childB))
        return pos;
      if (childA.isText && childA.text != childB.text) {
        for (let j = 0; childA.text[j] == childB.text[j]; j++)
          pos++;
        return pos;
      }
      if (childA.content.size || childB.content.size) {
        let inner = findDiffStart(childA.content, childB.content, pos + 1);
        if (inner != null)
          return inner;
      }
      pos += childA.nodeSize;
    }
  }
  function findDiffEnd(a2, b, posA, posB) {
    for (let iA = a2.childCount, iB = b.childCount; ; ) {
      if (iA == 0 || iB == 0)
        return iA == iB ? null : { a: posA, b: posB };
      let childA = a2.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
      if (childA == childB) {
        posA -= size;
        posB -= size;
        continue;
      }
      if (!childA.sameMarkup(childB))
        return { a: posA, b: posB };
      if (childA.isText && childA.text != childB.text) {
        let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
        while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
          same++;
          posA--;
          posB--;
        }
        return { a: posA, b: posB };
      }
      if (childA.content.size || childB.content.size) {
        let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
        if (inner)
          return inner;
      }
      posA -= size;
      posB -= size;
    }
  }
  class Fragment {
    /**
    @internal
    */
    constructor(content2, size) {
      this.content = content2;
      this.size = size || 0;
      if (size == null)
        for (let i2 = 0; i2 < content2.length; i2++)
          this.size += content2[i2].nodeSize;
    }
    /**
    Invoke a callback for all descendant nodes between the given two
    positions (relative to start of this fragment). Doesn't descend
    into a node when the callback returns `false`.
    */
    nodesBetween(from2, to, f, nodeStart = 0, parent) {
      for (let i2 = 0, pos = 0; pos < to; i2++) {
        let child = this.content[i2], end = pos + child.nodeSize;
        if (end > from2 && f(child, nodeStart + pos, parent || null, i2) !== false && child.content.size) {
          let start = pos + 1;
          child.nodesBetween(Math.max(0, from2 - start), Math.min(child.content.size, to - start), f, nodeStart + start);
        }
        pos = end;
      }
    }
    /**
    Call the given callback for every descendant node. `pos` will be
    relative to the start of the fragment. The callback may return
    `false` to prevent traversal of a given node's children.
    */
    descendants(f) {
      this.nodesBetween(0, this.size, f);
    }
    /**
    Extract the text between `from` and `to`. See the same method on
    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
    */
    textBetween(from2, to, blockSeparator, leafText) {
      let text2 = "", separated = true;
      this.nodesBetween(from2, to, (node2, pos) => {
        if (node2.isText) {
          text2 += node2.text.slice(Math.max(from2, pos) - pos, to - pos);
          separated = !blockSeparator;
        } else if (node2.isLeaf) {
          if (leafText) {
            text2 += typeof leafText === "function" ? leafText(node2) : leafText;
          } else if (node2.type.spec.leafText) {
            text2 += node2.type.spec.leafText(node2);
          }
          separated = !blockSeparator;
        } else if (!separated && node2.isBlock) {
          text2 += blockSeparator;
          separated = true;
        }
      }, 0);
      return text2;
    }
    /**
    Create a new fragment containing the combined content of this
    fragment and the other.
    */
    append(other) {
      if (!other.size)
        return this;
      if (!this.size)
        return other;
      let last2 = this.lastChild, first2 = other.firstChild, content2 = this.content.slice(), i2 = 0;
      if (last2.isText && last2.sameMarkup(first2)) {
        content2[content2.length - 1] = last2.withText(last2.text + first2.text);
        i2 = 1;
      }
      for (; i2 < other.content.length; i2++)
        content2.push(other.content[i2]);
      return new Fragment(content2, this.size + other.size);
    }
    /**
    Cut out the sub-fragment between the two given positions.
    */
    cut(from2, to = this.size) {
      if (from2 == 0 && to == this.size)
        return this;
      let result = [], size = 0;
      if (to > from2)
        for (let i2 = 0, pos = 0; pos < to; i2++) {
          let child = this.content[i2], end = pos + child.nodeSize;
          if (end > from2) {
            if (pos < from2 || end > to) {
              if (child.isText)
                child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
              else
                child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
            }
            result.push(child);
            size += child.nodeSize;
          }
          pos = end;
        }
      return new Fragment(result, size);
    }
    /**
    @internal
    */
    cutByIndex(from2, to) {
      if (from2 == to)
        return Fragment.empty;
      if (from2 == 0 && to == this.content.length)
        return this;
      return new Fragment(this.content.slice(from2, to));
    }
    /**
    Create a new fragment in which the node at the given index is
    replaced by the given node.
    */
    replaceChild(index2, node2) {
      let current = this.content[index2];
      if (current == node2)
        return this;
      let copy2 = this.content.slice();
      let size = this.size + node2.nodeSize - current.nodeSize;
      copy2[index2] = node2;
      return new Fragment(copy2, size);
    }
    /**
    Create a new fragment by prepending the given node to this
    fragment.
    */
    addToStart(node2) {
      return new Fragment([node2].concat(this.content), this.size + node2.nodeSize);
    }
    /**
    Create a new fragment by appending the given node to this
    fragment.
    */
    addToEnd(node2) {
      return new Fragment(this.content.concat(node2), this.size + node2.nodeSize);
    }
    /**
    Compare this fragment to another one.
    */
    eq(other) {
      if (this.content.length != other.content.length)
        return false;
      for (let i2 = 0; i2 < this.content.length; i2++)
        if (!this.content[i2].eq(other.content[i2]))
          return false;
      return true;
    }
    /**
    The first child of the fragment, or `null` if it is empty.
    */
    get firstChild() {
      return this.content.length ? this.content[0] : null;
    }
    /**
    The last child of the fragment, or `null` if it is empty.
    */
    get lastChild() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    }
    /**
    The number of child nodes in this fragment.
    */
    get childCount() {
      return this.content.length;
    }
    /**
    Get the child node at the given index. Raise an error when the
    index is out of range.
    */
    child(index2) {
      let found2 = this.content[index2];
      if (!found2)
        throw new RangeError("Index " + index2 + " out of range for " + this);
      return found2;
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index2) {
      return this.content[index2] || null;
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f) {
      for (let i2 = 0, p2 = 0; i2 < this.content.length; i2++) {
        let child = this.content[i2];
        f(child, p2, i2);
        p2 += child.nodeSize;
      }
    }
    /**
    Find the first position at which this fragment and another
    fragment differ, or `null` if they are the same.
    */
    findDiffStart(other, pos = 0) {
      return findDiffStart(this, other, pos);
    }
    /**
    Find the first position, searching from the end, at which this
    fragment and the given fragment differ, or `null` if they are
    the same. Since this position will not be the same in both
    nodes, an object with two separate positions is returned.
    */
    findDiffEnd(other, pos = this.size, otherPos = other.size) {
      return findDiffEnd(this, other, pos, otherPos);
    }
    /**
    Find the index and inner offset corresponding to a given relative
    position in this fragment. The result object will be reused
    (overwritten) the next time the function is called. (Not public.)
    */
    findIndex(pos, round = -1) {
      if (pos == 0)
        return retIndex(0, pos);
      if (pos == this.size)
        return retIndex(this.content.length, pos);
      if (pos > this.size || pos < 0)
        throw new RangeError(`Position ${pos} outside of fragment (${this})`);
      for (let i2 = 0, curPos = 0; ; i2++) {
        let cur = this.child(i2), end = curPos + cur.nodeSize;
        if (end >= pos) {
          if (end == pos || round > 0)
            return retIndex(i2 + 1, end);
          return retIndex(i2, curPos);
        }
        curPos = end;
      }
    }
    /**
    Return a debugging string that describes this fragment.
    */
    toString() {
      return "<" + this.toStringInner() + ">";
    }
    /**
    @internal
    */
    toStringInner() {
      return this.content.join(", ");
    }
    /**
    Create a JSON-serializeable representation of this fragment.
    */
    toJSON() {
      return this.content.length ? this.content.map((n) => n.toJSON()) : null;
    }
    /**
    Deserialize a fragment from its JSON representation.
    */
    static fromJSON(schema, value) {
      if (!value)
        return Fragment.empty;
      if (!Array.isArray(value))
        throw new RangeError("Invalid input for Fragment.fromJSON");
      return new Fragment(value.map(schema.nodeFromJSON));
    }
    /**
    Build a fragment from an array of nodes. Ensures that adjacent
    text nodes with the same marks are joined together.
    */
    static fromArray(array) {
      if (!array.length)
        return Fragment.empty;
      let joined, size = 0;
      for (let i2 = 0; i2 < array.length; i2++) {
        let node2 = array[i2];
        size += node2.nodeSize;
        if (i2 && node2.isText && array[i2 - 1].sameMarkup(node2)) {
          if (!joined)
            joined = array.slice(0, i2);
          joined[joined.length - 1] = node2.withText(joined[joined.length - 1].text + node2.text);
        } else if (joined) {
          joined.push(node2);
        }
      }
      return new Fragment(joined || array, size);
    }
    /**
    Create a fragment from something that can be interpreted as a
    set of nodes. For `null`, it returns the empty fragment. For a
    fragment, the fragment itself. For a node or array of nodes, a
    fragment containing those nodes.
    */
    static from(nodes) {
      if (!nodes)
        return Fragment.empty;
      if (nodes instanceof Fragment)
        return nodes;
      if (Array.isArray(nodes))
        return this.fromArray(nodes);
      if (nodes.attrs)
        return new Fragment([nodes], nodes.nodeSize);
      throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    }
  }
  Fragment.empty = new Fragment([], 0);
  const found = { index: 0, offset: 0 };
  function retIndex(index2, offset) {
    found.index = index2;
    found.offset = offset;
    return found;
  }
  function compareDeep(a2, b) {
    if (a2 === b)
      return true;
    if (!(a2 && typeof a2 == "object") || !(b && typeof b == "object"))
      return false;
    let array = Array.isArray(a2);
    if (Array.isArray(b) != array)
      return false;
    if (array) {
      if (a2.length != b.length)
        return false;
      for (let i2 = 0; i2 < a2.length; i2++)
        if (!compareDeep(a2[i2], b[i2]))
          return false;
    } else {
      for (let p2 in a2)
        if (!(p2 in b) || !compareDeep(a2[p2], b[p2]))
          return false;
      for (let p2 in b)
        if (!(p2 in a2))
          return false;
    }
    return true;
  }
  let Mark$1 = class Mark2 {
    /**
    @internal
    */
    constructor(type, attrs) {
      this.type = type;
      this.attrs = attrs;
    }
    /**
    Given a set of marks, create a new set which contains this one as
    well, in the right position. If this mark is already in the set,
    the set itself is returned. If any marks that are set to be
    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
    those are replaced by this one.
    */
    addToSet(set) {
      let copy2, placed = false;
      for (let i2 = 0; i2 < set.length; i2++) {
        let other = set[i2];
        if (this.eq(other))
          return set;
        if (this.type.excludes(other.type)) {
          if (!copy2)
            copy2 = set.slice(0, i2);
        } else if (other.type.excludes(this.type)) {
          return set;
        } else {
          if (!placed && other.type.rank > this.type.rank) {
            if (!copy2)
              copy2 = set.slice(0, i2);
            copy2.push(this);
            placed = true;
          }
          if (copy2)
            copy2.push(other);
        }
      }
      if (!copy2)
        copy2 = set.slice();
      if (!placed)
        copy2.push(this);
      return copy2;
    }
    /**
    Remove this mark from the given set, returning a new set. If this
    mark is not in the set, the set itself is returned.
    */
    removeFromSet(set) {
      for (let i2 = 0; i2 < set.length; i2++)
        if (this.eq(set[i2]))
          return set.slice(0, i2).concat(set.slice(i2 + 1));
      return set;
    }
    /**
    Test whether this mark is in the given set of marks.
    */
    isInSet(set) {
      for (let i2 = 0; i2 < set.length; i2++)
        if (this.eq(set[i2]))
          return true;
      return false;
    }
    /**
    Test whether this mark has the same type and attributes as
    another mark.
    */
    eq(other) {
      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
    }
    /**
    Convert this mark to a JSON-serializeable representation.
    */
    toJSON() {
      let obj = { type: this.type.name };
      for (let _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      return obj;
    }
    /**
    Deserialize a mark from JSON.
    */
    static fromJSON(schema, json) {
      if (!json)
        throw new RangeError("Invalid input for Mark.fromJSON");
      let type = schema.marks[json.type];
      if (!type)
        throw new RangeError(`There is no mark type ${json.type} in this schema`);
      return type.create(json.attrs);
    }
    /**
    Test whether two sets of marks are identical.
    */
    static sameSet(a2, b) {
      if (a2 == b)
        return true;
      if (a2.length != b.length)
        return false;
      for (let i2 = 0; i2 < a2.length; i2++)
        if (!a2[i2].eq(b[i2]))
          return false;
      return true;
    }
    /**
    Create a properly sorted mark set from null, a single mark, or an
    unsorted array of marks.
    */
    static setFrom(marks) {
      if (!marks || Array.isArray(marks) && marks.length == 0)
        return Mark2.none;
      if (marks instanceof Mark2)
        return [marks];
      let copy2 = marks.slice();
      copy2.sort((a2, b) => a2.type.rank - b.type.rank);
      return copy2;
    }
  };
  Mark$1.none = [];
  class ReplaceError extends Error {
  }
  class Slice {
    /**
    Create a slice. When specifying a non-zero open depth, you must
    make sure that there are nodes of at least that depth at the
    appropriate side of the fragment—i.e. if the fragment is an
    empty paragraph node, `openStart` and `openEnd` can't be greater
    than 1.
    
    It is not necessary for the content of open nodes to conform to
    the schema's content constraints, though it should be a valid
    start/end/middle for such a node, depending on which sides are
    open.
    */
    constructor(content2, openStart, openEnd) {
      this.content = content2;
      this.openStart = openStart;
      this.openEnd = openEnd;
    }
    /**
    The size this slice would add when inserted into a document.
    */
    get size() {
      return this.content.size - this.openStart - this.openEnd;
    }
    /**
    @internal
    */
    insertAt(pos, fragment) {
      let content2 = insertInto(this.content, pos + this.openStart, fragment);
      return content2 && new Slice(content2, this.openStart, this.openEnd);
    }
    /**
    @internal
    */
    removeBetween(from2, to) {
      return new Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
    }
    /**
    Tests whether this slice is equal to another slice.
    */
    eq(other) {
      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
    }
    /**
    @internal
    */
    toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    }
    /**
    Convert a slice to a JSON-serializable representation.
    */
    toJSON() {
      if (!this.content.size)
        return null;
      let json = { content: this.content.toJSON() };
      if (this.openStart > 0)
        json.openStart = this.openStart;
      if (this.openEnd > 0)
        json.openEnd = this.openEnd;
      return json;
    }
    /**
    Deserialize a slice from its JSON representation.
    */
    static fromJSON(schema, json) {
      if (!json)
        return Slice.empty;
      let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
      if (typeof openStart != "number" || typeof openEnd != "number")
        throw new RangeError("Invalid input for Slice.fromJSON");
      return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
    }
    /**
    Create a slice from a fragment by taking the maximum possible
    open value on both side of the fragment.
    */
    static maxOpen(fragment, openIsolating = true) {
      let openStart = 0, openEnd = 0;
      for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
        openStart++;
      for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
        openEnd++;
      return new Slice(fragment, openStart, openEnd);
    }
  }
  Slice.empty = new Slice(Fragment.empty, 0, 0);
  function removeRange(content2, from2, to) {
    let { index: index2, offset } = content2.findIndex(from2), child = content2.maybeChild(index2);
    let { index: indexTo, offset: offsetTo } = content2.findIndex(to);
    if (offset == from2 || child.isText) {
      if (offsetTo != to && !content2.child(indexTo).isText)
        throw new RangeError("Removing non-flat range");
      return content2.cut(0, from2).append(content2.cut(to));
    }
    if (index2 != indexTo)
      throw new RangeError("Removing non-flat range");
    return content2.replaceChild(index2, child.copy(removeRange(child.content, from2 - offset - 1, to - offset - 1)));
  }
  function insertInto(content2, dist, insert, parent) {
    let { index: index2, offset } = content2.findIndex(dist), child = content2.maybeChild(index2);
    if (offset == dist || child.isText) {
      if (parent && !parent.canReplace(index2, index2, insert))
        return null;
      return content2.cut(0, dist).append(insert).append(content2.cut(dist));
    }
    let inner = insertInto(child.content, dist - offset - 1, insert);
    return inner && content2.replaceChild(index2, child.copy(inner));
  }
  function replace$1($from, $to, slice) {
    if (slice.openStart > $from.depth)
      throw new ReplaceError("Inserted content deeper than insertion position");
    if ($from.depth - slice.openStart != $to.depth - slice.openEnd)
      throw new ReplaceError("Inconsistent open depths");
    return replaceOuter($from, $to, slice, 0);
  }
  function replaceOuter($from, $to, slice, depth) {
    let index2 = $from.index(depth), node2 = $from.node(depth);
    if (index2 == $to.index(depth) && depth < $from.depth - slice.openStart) {
      let inner = replaceOuter($from, $to, slice, depth + 1);
      return node2.copy(node2.content.replaceChild(index2, inner));
    } else if (!slice.content.size) {
      return close(node2, replaceTwoWay($from, $to, depth));
    } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
      let parent = $from.parent, content2 = parent.content;
      return close(parent, content2.cut(0, $from.parentOffset).append(slice.content).append(content2.cut($to.parentOffset)));
    } else {
      let { start, end } = prepareSliceForReplace(slice, $from);
      return close(node2, replaceThreeWay($from, start, end, $to, depth));
    }
  }
  function checkJoin(main, sub) {
    if (!sub.type.compatibleContent(main.type))
      throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
  }
  function joinable$1($before, $after, depth) {
    let node2 = $before.node(depth);
    checkJoin(node2, $after.node(depth));
    return node2;
  }
  function addNode(child, target) {
    let last2 = target.length - 1;
    if (last2 >= 0 && child.isText && child.sameMarkup(target[last2]))
      target[last2] = child.withText(target[last2].text + child.text);
    else
      target.push(child);
  }
  function addRange($start, $end, depth, target) {
    let node2 = ($end || $start).node(depth);
    let startIndex = 0, endIndex = $end ? $end.index(depth) : node2.childCount;
    if ($start) {
      startIndex = $start.index(depth);
      if ($start.depth > depth) {
        startIndex++;
      } else if ($start.textOffset) {
        addNode($start.nodeAfter, target);
        startIndex++;
      }
    }
    for (let i2 = startIndex; i2 < endIndex; i2++)
      addNode(node2.child(i2), target);
    if ($end && $end.depth == depth && $end.textOffset)
      addNode($end.nodeBefore, target);
  }
  function close(node2, content2) {
    node2.type.checkContent(content2);
    return node2.copy(content2);
  }
  function replaceThreeWay($from, $start, $end, $to, depth) {
    let openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
    let openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
    let content2 = [];
    addRange(null, $from, depth, content2);
    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
      checkJoin(openStart, openEnd);
      addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content2);
    } else {
      if (openStart)
        addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content2);
      addRange($start, $end, depth, content2);
      if (openEnd)
        addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content2);
    }
    addRange($to, null, depth, content2);
    return new Fragment(content2);
  }
  function replaceTwoWay($from, $to, depth) {
    let content2 = [];
    addRange(null, $from, depth, content2);
    if ($from.depth > depth) {
      let type = joinable$1($from, $to, depth + 1);
      addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content2);
    }
    addRange($to, null, depth, content2);
    return new Fragment(content2);
  }
  function prepareSliceForReplace(slice, $along) {
    let extra = $along.depth - slice.openStart, parent = $along.node(extra);
    let node2 = parent.copy(slice.content);
    for (let i2 = extra - 1; i2 >= 0; i2--)
      node2 = $along.node(i2).copy(Fragment.from(node2));
    return {
      start: node2.resolveNoCache(slice.openStart + extra),
      end: node2.resolveNoCache(node2.content.size - slice.openEnd - extra)
    };
  }
  class ResolvedPos {
    /**
    @internal
    */
    constructor(pos, path2, parentOffset) {
      this.pos = pos;
      this.path = path2;
      this.parentOffset = parentOffset;
      this.depth = path2.length / 3 - 1;
    }
    /**
    @internal
    */
    resolveDepth(val) {
      if (val == null)
        return this.depth;
      if (val < 0)
        return this.depth + val;
      return val;
    }
    /**
    The parent node that the position points into. Note that even if
    a position points into a text node, that node is not considered
    the parent—text nodes are ‘flat’ in this model, and have no content.
    */
    get parent() {
      return this.node(this.depth);
    }
    /**
    The root node in which the position was resolved.
    */
    get doc() {
      return this.node(0);
    }
    /**
    The ancestor node at the given level. `p.node(p.depth)` is the
    same as `p.parent`.
    */
    node(depth) {
      return this.path[this.resolveDepth(depth) * 3];
    }
    /**
    The index into the ancestor at the given level. If this points
    at the 3rd node in the 2nd paragraph on the top level, for
    example, `p.index(0)` is 1 and `p.index(1)` is 2.
    */
    index(depth) {
      return this.path[this.resolveDepth(depth) * 3 + 1];
    }
    /**
    The index pointing after this position into the ancestor at the
    given level.
    */
    indexAfter(depth) {
      depth = this.resolveDepth(depth);
      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
    }
    /**
    The (absolute) position at the start of the node at the given
    level.
    */
    start(depth) {
      depth = this.resolveDepth(depth);
      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    }
    /**
    The (absolute) position at the end of the node at the given
    level.
    */
    end(depth) {
      depth = this.resolveDepth(depth);
      return this.start(depth) + this.node(depth).content.size;
    }
    /**
    The (absolute) position directly before the wrapping node at the
    given level, or, when `depth` is `this.depth + 1`, the original
    position.
    */
    before(depth) {
      depth = this.resolveDepth(depth);
      if (!depth)
        throw new RangeError("There is no position before the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
    }
    /**
    The (absolute) position directly after the wrapping node at the
    given level, or the original position when `depth` is `this.depth + 1`.
    */
    after(depth) {
      depth = this.resolveDepth(depth);
      if (!depth)
        throw new RangeError("There is no position after the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
    }
    /**
    When this position points into a text node, this returns the
    distance between the position and the start of the text node.
    Will be zero for positions that point between nodes.
    */
    get textOffset() {
      return this.pos - this.path[this.path.length - 1];
    }
    /**
    Get the node directly after the position, if any. If the position
    points into a text node, only the part of that node after the
    position is returned.
    */
    get nodeAfter() {
      let parent = this.parent, index2 = this.index(this.depth);
      if (index2 == parent.childCount)
        return null;
      let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index2);
      return dOff ? parent.child(index2).cut(dOff) : child;
    }
    /**
    Get the node directly before the position, if any. If the
    position points into a text node, only the part of that node
    before the position is returned.
    */
    get nodeBefore() {
      let index2 = this.index(this.depth);
      let dOff = this.pos - this.path[this.path.length - 1];
      if (dOff)
        return this.parent.child(index2).cut(0, dOff);
      return index2 == 0 ? null : this.parent.child(index2 - 1);
    }
    /**
    Get the position at the given index in the parent node at the
    given depth (which defaults to `this.depth`).
    */
    posAtIndex(index2, depth) {
      depth = this.resolveDepth(depth);
      let node2 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      for (let i2 = 0; i2 < index2; i2++)
        pos += node2.child(i2).nodeSize;
      return pos;
    }
    /**
    Get the marks at this position, factoring in the surrounding
    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
    position is at the start of a non-empty node, the marks of the
    node after it (if any) are returned.
    */
    marks() {
      let parent = this.parent, index2 = this.index();
      if (parent.content.size == 0)
        return Mark$1.none;
      if (this.textOffset)
        return parent.child(index2).marks;
      let main = parent.maybeChild(index2 - 1), other = parent.maybeChild(index2);
      if (!main) {
        let tmp = main;
        main = other;
        other = tmp;
      }
      let marks = main.marks;
      for (var i2 = 0; i2 < marks.length; i2++)
        if (marks[i2].type.spec.inclusive === false && (!other || !marks[i2].isInSet(other.marks)))
          marks = marks[i2--].removeFromSet(marks);
      return marks;
    }
    /**
    Get the marks after the current position, if any, except those
    that are non-inclusive and not present at position `$end`. This
    is mostly useful for getting the set of marks to preserve after a
    deletion. Will return `null` if this position is at the end of
    its parent node or its parent node isn't a textblock (in which
    case no marks should be preserved).
    */
    marksAcross($end) {
      let after = this.parent.maybeChild(this.index());
      if (!after || !after.isInline)
        return null;
      let marks = after.marks, next = $end.parent.maybeChild($end.index());
      for (var i2 = 0; i2 < marks.length; i2++)
        if (marks[i2].type.spec.inclusive === false && (!next || !marks[i2].isInSet(next.marks)))
          marks = marks[i2--].removeFromSet(marks);
      return marks;
    }
    /**
    The depth up to which this position and the given (non-resolved)
    position share the same parent nodes.
    */
    sharedDepth(pos) {
      for (let depth = this.depth; depth > 0; depth--)
        if (this.start(depth) <= pos && this.end(depth) >= pos)
          return depth;
      return 0;
    }
    /**
    Returns a range based on the place where this position and the
    given position diverge around block content. If both point into
    the same textblock, for example, a range around that textblock
    will be returned. If they point into different blocks, the range
    around those blocks in their shared ancestor is returned. You can
    pass in an optional predicate that will be called with a parent
    node to see if a range into that parent is acceptable.
    */
    blockRange(other = this, pred) {
      if (other.pos < this.pos)
        return other.blockRange(this);
      for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
        if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
          return new NodeRange(this, other, d);
      return null;
    }
    /**
    Query whether the given position shares the same parent node.
    */
    sameParent(other) {
      return this.pos - this.parentOffset == other.pos - other.parentOffset;
    }
    /**
    Return the greater of this and the given position.
    */
    max(other) {
      return other.pos > this.pos ? other : this;
    }
    /**
    Return the smaller of this and the given position.
    */
    min(other) {
      return other.pos < this.pos ? other : this;
    }
    /**
    @internal
    */
    toString() {
      let str = "";
      for (let i2 = 1; i2 <= this.depth; i2++)
        str += (str ? "/" : "") + this.node(i2).type.name + "_" + this.index(i2 - 1);
      return str + ":" + this.parentOffset;
    }
    /**
    @internal
    */
    static resolve(doc2, pos) {
      if (!(pos >= 0 && pos <= doc2.content.size))
        throw new RangeError("Position " + pos + " out of range");
      let path2 = [];
      let start = 0, parentOffset = pos;
      for (let node2 = doc2; ; ) {
        let { index: index2, offset } = node2.content.findIndex(parentOffset);
        let rem = parentOffset - offset;
        path2.push(node2, index2, start + offset);
        if (!rem)
          break;
        node2 = node2.child(index2);
        if (node2.isText)
          break;
        parentOffset = rem - 1;
        start += offset + 1;
      }
      return new ResolvedPos(pos, path2, parentOffset);
    }
    /**
    @internal
    */
    static resolveCached(doc2, pos) {
      for (let i2 = 0; i2 < resolveCache.length; i2++) {
        let cached = resolveCache[i2];
        if (cached.pos == pos && cached.doc == doc2)
          return cached;
      }
      let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc2, pos);
      resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
      return result;
    }
  }
  let resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;
  class NodeRange {
    /**
    Construct a node range. `$from` and `$to` should point into the
    same node until at least the given `depth`, since a node range
    denotes an adjacent set of nodes in a single parent node.
    */
    constructor($from, $to, depth) {
      this.$from = $from;
      this.$to = $to;
      this.depth = depth;
    }
    /**
    The position at the start of the range.
    */
    get start() {
      return this.$from.before(this.depth + 1);
    }
    /**
    The position at the end of the range.
    */
    get end() {
      return this.$to.after(this.depth + 1);
    }
    /**
    The parent node that the range points into.
    */
    get parent() {
      return this.$from.node(this.depth);
    }
    /**
    The start index of the range in the parent node.
    */
    get startIndex() {
      return this.$from.index(this.depth);
    }
    /**
    The end index of the range in the parent node.
    */
    get endIndex() {
      return this.$to.indexAfter(this.depth);
    }
  }
  const emptyAttrs = /* @__PURE__ */ Object.create(null);
  let Node$1 = class Node2 {
    /**
    @internal
    */
    constructor(type, attrs, content2, marks = Mark$1.none) {
      this.type = type;
      this.attrs = attrs;
      this.marks = marks;
      this.content = content2 || Fragment.empty;
    }
    /**
    The size of this node, as defined by the integer-based [indexing
    scheme](/docs/guide/#doc.indexing). For text nodes, this is the
    amount of characters. For other leaf nodes, it is one. For
    non-leaf nodes, it is the size of the content plus two (the
    start and end token).
    */
    get nodeSize() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    }
    /**
    The number of children that the node has.
    */
    get childCount() {
      return this.content.childCount;
    }
    /**
    Get the child node at the given index. Raises an error when the
    index is out of range.
    */
    child(index2) {
      return this.content.child(index2);
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index2) {
      return this.content.maybeChild(index2);
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f) {
      this.content.forEach(f);
    }
    /**
    Invoke a callback for all descendant nodes recursively between
    the given two positions that are relative to start of this
    node's content. The callback is invoked with the node, its
    parent-relative position, its parent node, and its child index.
    When the callback returns false for a given node, that node's
    children will not be recursed over. The last parameter can be
    used to specify a starting position to count from.
    */
    nodesBetween(from2, to, f, startPos = 0) {
      this.content.nodesBetween(from2, to, f, startPos, this);
    }
    /**
    Call the given callback for every descendant node. Doesn't
    descend into a node when the callback returns `false`.
    */
    descendants(f) {
      this.nodesBetween(0, this.content.size, f);
    }
    /**
    Concatenates all the text nodes found in this fragment and its
    children.
    */
    get textContent() {
      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
    }
    /**
    Get all text between positions `from` and `to`. When
    `blockSeparator` is given, it will be inserted to separate text
    from different block nodes. If `leafText` is given, it'll be
    inserted for every non-text leaf node encountered, otherwise
    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
    */
    textBetween(from2, to, blockSeparator, leafText) {
      return this.content.textBetween(from2, to, blockSeparator, leafText);
    }
    /**
    Returns this node's first child, or `null` if there are no
    children.
    */
    get firstChild() {
      return this.content.firstChild;
    }
    /**
    Returns this node's last child, or `null` if there are no
    children.
    */
    get lastChild() {
      return this.content.lastChild;
    }
    /**
    Test whether two nodes represent the same piece of document.
    */
    eq(other) {
      return this == other || this.sameMarkup(other) && this.content.eq(other.content);
    }
    /**
    Compare the markup (type, attributes, and marks) of this node to
    those of another. Returns `true` if both have the same markup.
    */
    sameMarkup(other) {
      return this.hasMarkup(other.type, other.attrs, other.marks);
    }
    /**
    Check whether this node's markup correspond to the given type,
    attributes, and marks.
    */
    hasMarkup(type, attrs, marks) {
      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark$1.sameSet(this.marks, marks || Mark$1.none);
    }
    /**
    Create a new node with the same markup as this node, containing
    the given content (or empty, if no content is given).
    */
    copy(content2 = null) {
      if (content2 == this.content)
        return this;
      return new Node2(this.type, this.attrs, content2, this.marks);
    }
    /**
    Create a copy of this node, with the given set of marks instead
    of the node's own marks.
    */
    mark(marks) {
      return marks == this.marks ? this : new Node2(this.type, this.attrs, this.content, marks);
    }
    /**
    Create a copy of this node with only the content between the
    given positions. If `to` is not given, it defaults to the end of
    the node.
    */
    cut(from2, to = this.content.size) {
      if (from2 == 0 && to == this.content.size)
        return this;
      return this.copy(this.content.cut(from2, to));
    }
    /**
    Cut out the part of the document between the given positions, and
    return it as a `Slice` object.
    */
    slice(from2, to = this.content.size, includeParents = false) {
      if (from2 == to)
        return Slice.empty;
      let $from = this.resolve(from2), $to = this.resolve(to);
      let depth = includeParents ? 0 : $from.sharedDepth(to);
      let start = $from.start(depth), node2 = $from.node(depth);
      let content2 = node2.content.cut($from.pos - start, $to.pos - start);
      return new Slice(content2, $from.depth - depth, $to.depth - depth);
    }
    /**
    Replace the part of the document between the given positions with
    the given slice. The slice must 'fit', meaning its open sides
    must be able to connect to the surrounding content, and its
    content nodes must be valid children for the node they are placed
    into. If any of this is violated, an error of type
    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
    */
    replace(from2, to, slice) {
      return replace$1(this.resolve(from2), this.resolve(to), slice);
    }
    /**
    Find the node directly after the given position.
    */
    nodeAt(pos) {
      for (let node2 = this; ; ) {
        let { index: index2, offset } = node2.content.findIndex(pos);
        node2 = node2.maybeChild(index2);
        if (!node2)
          return null;
        if (offset == pos || node2.isText)
          return node2;
        pos -= offset + 1;
      }
    }
    /**
    Find the (direct) child node after the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childAfter(pos) {
      let { index: index2, offset } = this.content.findIndex(pos);
      return { node: this.content.maybeChild(index2), index: index2, offset };
    }
    /**
    Find the (direct) child node before the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childBefore(pos) {
      if (pos == 0)
        return { node: null, index: 0, offset: 0 };
      let { index: index2, offset } = this.content.findIndex(pos);
      if (offset < pos)
        return { node: this.content.child(index2), index: index2, offset };
      let node2 = this.content.child(index2 - 1);
      return { node: node2, index: index2 - 1, offset: offset - node2.nodeSize };
    }
    /**
    Resolve the given position in the document, returning an
    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
    */
    resolve(pos) {
      return ResolvedPos.resolveCached(this, pos);
    }
    /**
    @internal
    */
    resolveNoCache(pos) {
      return ResolvedPos.resolve(this, pos);
    }
    /**
    Test whether a given mark or mark type occurs in this document
    between the two given positions.
    */
    rangeHasMark(from2, to, type) {
      let found2 = false;
      if (to > from2)
        this.nodesBetween(from2, to, (node2) => {
          if (type.isInSet(node2.marks))
            found2 = true;
          return !found2;
        });
      return found2;
    }
    /**
    True when this is a block (non-inline node)
    */
    get isBlock() {
      return this.type.isBlock;
    }
    /**
    True when this is a textblock node, a block node with inline
    content.
    */
    get isTextblock() {
      return this.type.isTextblock;
    }
    /**
    True when this node allows inline content.
    */
    get inlineContent() {
      return this.type.inlineContent;
    }
    /**
    True when this is an inline node (a text node or a node that can
    appear among text).
    */
    get isInline() {
      return this.type.isInline;
    }
    /**
    True when this is a text node.
    */
    get isText() {
      return this.type.isText;
    }
    /**
    True when this is a leaf node.
    */
    get isLeaf() {
      return this.type.isLeaf;
    }
    /**
    True when this is an atom, i.e. when it does not have directly
    editable content. This is usually the same as `isLeaf`, but can
    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
    on a node's spec (typically used when the node is displayed as
    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
    */
    get isAtom() {
      return this.type.isAtom;
    }
    /**
    Return a string representation of this node for debugging
    purposes.
    */
    toString() {
      if (this.type.spec.toDebugString)
        return this.type.spec.toDebugString(this);
      let name = this.type.name;
      if (this.content.size)
        name += "(" + this.content.toStringInner() + ")";
      return wrapMarks(this.marks, name);
    }
    /**
    Get the content match in this node at the given index.
    */
    contentMatchAt(index2) {
      let match = this.type.contentMatch.matchFragment(this.content, 0, index2);
      if (!match)
        throw new Error("Called contentMatchAt on a node with invalid content");
      return match;
    }
    /**
    Test whether replacing the range between `from` and `to` (by
    child index) with the given replacement fragment (which defaults
    to the empty fragment) would leave the node's content valid. You
    can optionally pass `start` and `end` indices into the
    replacement fragment.
    */
    canReplace(from2, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
      let one2 = this.contentMatchAt(from2).matchFragment(replacement, start, end);
      let two = one2 && one2.matchFragment(this.content, to);
      if (!two || !two.validEnd)
        return false;
      for (let i2 = start; i2 < end; i2++)
        if (!this.type.allowsMarks(replacement.child(i2).marks))
          return false;
      return true;
    }
    /**
    Test whether replacing the range `from` to `to` (by index) with
    a node of the given type would leave the node's content valid.
    */
    canReplaceWith(from2, to, type, marks) {
      if (marks && !this.type.allowsMarks(marks))
        return false;
      let start = this.contentMatchAt(from2).matchType(type);
      let end = start && start.matchFragment(this.content, to);
      return end ? end.validEnd : false;
    }
    /**
    Test whether the given node's content could be appended to this
    node. If that node is empty, this will only return true if there
    is at least one node type that can appear in both nodes (to avoid
    merging completely incompatible nodes).
    */
    canAppend(other) {
      if (other.content.size)
        return this.canReplace(this.childCount, this.childCount, other.content);
      else
        return this.type.compatibleContent(other.type);
    }
    /**
    Check whether this node and its descendants conform to the
    schema, and raise error when they do not.
    */
    check() {
      this.type.checkContent(this.content);
      let copy2 = Mark$1.none;
      for (let i2 = 0; i2 < this.marks.length; i2++)
        copy2 = this.marks[i2].addToSet(copy2);
      if (!Mark$1.sameSet(copy2, this.marks))
        throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
      this.content.forEach((node2) => node2.check());
    }
    /**
    Return a JSON-serializeable representation of this node.
    */
    toJSON() {
      let obj = { type: this.type.name };
      for (let _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      if (this.content.size)
        obj.content = this.content.toJSON();
      if (this.marks.length)
        obj.marks = this.marks.map((n) => n.toJSON());
      return obj;
    }
    /**
    Deserialize a node from its JSON representation.
    */
    static fromJSON(schema, json) {
      if (!json)
        throw new RangeError("Invalid input for Node.fromJSON");
      let marks = null;
      if (json.marks) {
        if (!Array.isArray(json.marks))
          throw new RangeError("Invalid mark data for Node.fromJSON");
        marks = json.marks.map(schema.markFromJSON);
      }
      if (json.type == "text") {
        if (typeof json.text != "string")
          throw new RangeError("Invalid text node in JSON");
        return schema.text(json.text, marks);
      }
      let content2 = Fragment.fromJSON(schema, json.content);
      return schema.nodeType(json.type).create(json.attrs, content2, marks);
    }
  };
  Node$1.prototype.text = void 0;
  class TextNode extends Node$1 {
    /**
    @internal
    */
    constructor(type, attrs, content2, marks) {
      super(type, attrs, null, marks);
      if (!content2)
        throw new RangeError("Empty text nodes are not allowed");
      this.text = content2;
    }
    toString() {
      if (this.type.spec.toDebugString)
        return this.type.spec.toDebugString(this);
      return wrapMarks(this.marks, JSON.stringify(this.text));
    }
    get textContent() {
      return this.text;
    }
    textBetween(from2, to) {
      return this.text.slice(from2, to);
    }
    get nodeSize() {
      return this.text.length;
    }
    mark(marks) {
      return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
    }
    withText(text2) {
      if (text2 == this.text)
        return this;
      return new TextNode(this.type, this.attrs, text2, this.marks);
    }
    cut(from2 = 0, to = this.text.length) {
      if (from2 == 0 && to == this.text.length)
        return this;
      return this.withText(this.text.slice(from2, to));
    }
    eq(other) {
      return this.sameMarkup(other) && this.text == other.text;
    }
    toJSON() {
      let base2 = super.toJSON();
      base2.text = this.text;
      return base2;
    }
  }
  function wrapMarks(marks, str) {
    for (let i2 = marks.length - 1; i2 >= 0; i2--)
      str = marks[i2].type.name + "(" + str + ")";
    return str;
  }
  class ContentMatch {
    /**
    @internal
    */
    constructor(validEnd) {
      this.validEnd = validEnd;
      this.next = [];
      this.wrapCache = [];
    }
    /**
    @internal
    */
    static parse(string2, nodeTypes) {
      let stream = new TokenStream(string2, nodeTypes);
      if (stream.next == null)
        return ContentMatch.empty;
      let expr = parseExpr(stream);
      if (stream.next)
        stream.err("Unexpected trailing text");
      let match = dfa(nfa(expr));
      checkForDeadEnds(match, stream);
      return match;
    }
    /**
    Match a node type, returning a match after that node if
    successful.
    */
    matchType(type) {
      for (let i2 = 0; i2 < this.next.length; i2++)
        if (this.next[i2].type == type)
          return this.next[i2].next;
      return null;
    }
    /**
    Try to match a fragment. Returns the resulting match when
    successful.
    */
    matchFragment(frag, start = 0, end = frag.childCount) {
      let cur = this;
      for (let i2 = start; cur && i2 < end; i2++)
        cur = cur.matchType(frag.child(i2).type);
      return cur;
    }
    /**
    @internal
    */
    get inlineContent() {
      return this.next.length != 0 && this.next[0].type.isInline;
    }
    /**
    Get the first matching node type at this match position that can
    be generated.
    */
    get defaultType() {
      for (let i2 = 0; i2 < this.next.length; i2++) {
        let { type } = this.next[i2];
        if (!(type.isText || type.hasRequiredAttrs()))
          return type;
      }
      return null;
    }
    /**
    @internal
    */
    compatible(other) {
      for (let i2 = 0; i2 < this.next.length; i2++)
        for (let j = 0; j < other.next.length; j++)
          if (this.next[i2].type == other.next[j].type)
            return true;
      return false;
    }
    /**
    Try to match the given fragment, and if that fails, see if it can
    be made to match by inserting nodes in front of it. When
    successful, return a fragment of inserted nodes (which may be
    empty if nothing had to be inserted). When `toEnd` is true, only
    return a fragment if the resulting match goes to the end of the
    content expression.
    */
    fillBefore(after, toEnd = false, startIndex = 0) {
      let seen = [this];
      function search2(match, types2) {
        let finished = match.matchFragment(after, startIndex);
        if (finished && (!toEnd || finished.validEnd))
          return Fragment.from(types2.map((tp) => tp.createAndFill()));
        for (let i2 = 0; i2 < match.next.length; i2++) {
          let { type, next } = match.next[i2];
          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
            seen.push(next);
            let found2 = search2(next, types2.concat(type));
            if (found2)
              return found2;
          }
        }
        return null;
      }
      return search2(this, []);
    }
    /**
    Find a set of wrapping node types that would allow a node of the
    given type to appear at this position. The result may be empty
    (when it fits directly) and will be null when no such wrapping
    exists.
    */
    findWrapping(target) {
      for (let i2 = 0; i2 < this.wrapCache.length; i2 += 2)
        if (this.wrapCache[i2] == target)
          return this.wrapCache[i2 + 1];
      let computed = this.computeWrapping(target);
      this.wrapCache.push(target, computed);
      return computed;
    }
    /**
    @internal
    */
    computeWrapping(target) {
      let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
      while (active.length) {
        let current = active.shift(), match = current.match;
        if (match.matchType(target)) {
          let result = [];
          for (let obj = current; obj.type; obj = obj.via)
            result.push(obj.type);
          return result.reverse();
        }
        for (let i2 = 0; i2 < match.next.length; i2++) {
          let { type, next } = match.next[i2];
          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
            active.push({ match: type.contentMatch, type, via: current });
            seen[type.name] = true;
          }
        }
      }
      return null;
    }
    /**
    The number of outgoing edges this node has in the finite
    automaton that describes the content expression.
    */
    get edgeCount() {
      return this.next.length;
    }
    /**
    Get the _n_​th outgoing edge from this node in the finite
    automaton that describes the content expression.
    */
    edge(n) {
      if (n >= this.next.length)
        throw new RangeError(`There's no ${n}th edge in this content match`);
      return this.next[n];
    }
    /**
    @internal
    */
    toString() {
      let seen = [];
      function scan(m) {
        seen.push(m);
        for (let i2 = 0; i2 < m.next.length; i2++)
          if (seen.indexOf(m.next[i2].next) == -1)
            scan(m.next[i2].next);
      }
      scan(this);
      return seen.map((m, i2) => {
        let out = i2 + (m.validEnd ? "*" : " ") + " ";
        for (let i3 = 0; i3 < m.next.length; i3++)
          out += (i3 ? ", " : "") + m.next[i3].type.name + "->" + seen.indexOf(m.next[i3].next);
        return out;
      }).join("\n");
    }
  }
  ContentMatch.empty = new ContentMatch(true);
  class TokenStream {
    constructor(string2, nodeTypes) {
      this.string = string2;
      this.nodeTypes = nodeTypes;
      this.inline = null;
      this.pos = 0;
      this.tokens = string2.split(/\s*(?=\b|\W|$)/);
      if (this.tokens[this.tokens.length - 1] == "")
        this.tokens.pop();
      if (this.tokens[0] == "")
        this.tokens.shift();
    }
    get next() {
      return this.tokens[this.pos];
    }
    eat(tok) {
      return this.next == tok && (this.pos++ || true);
    }
    err(str) {
      throw new SyntaxError(str + " (in content expression '" + this.string + "')");
    }
  }
  function parseExpr(stream) {
    let exprs = [];
    do {
      exprs.push(parseExprSeq(stream));
    } while (stream.eat("|"));
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  }
  function parseExprSeq(stream) {
    let exprs = [];
    do {
      exprs.push(parseExprSubscript(stream));
    } while (stream.next && stream.next != ")" && stream.next != "|");
    return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
  }
  function parseExprSubscript(stream) {
    let expr = parseExprAtom(stream);
    for (; ; ) {
      if (stream.eat("+"))
        expr = { type: "plus", expr };
      else if (stream.eat("*"))
        expr = { type: "star", expr };
      else if (stream.eat("?"))
        expr = { type: "opt", expr };
      else if (stream.eat("{"))
        expr = parseExprRange(stream, expr);
      else
        break;
    }
    return expr;
  }
  function parseNum(stream) {
    if (/\D/.test(stream.next))
      stream.err("Expected number, got '" + stream.next + "'");
    let result = Number(stream.next);
    stream.pos++;
    return result;
  }
  function parseExprRange(stream, expr) {
    let min2 = parseNum(stream), max2 = min2;
    if (stream.eat(",")) {
      if (stream.next != "}")
        max2 = parseNum(stream);
      else
        max2 = -1;
    }
    if (!stream.eat("}"))
      stream.err("Unclosed braced range");
    return { type: "range", min: min2, max: max2, expr };
  }
  function resolveName(stream, name) {
    let types2 = stream.nodeTypes, type = types2[name];
    if (type)
      return [type];
    let result = [];
    for (let typeName in types2) {
      let type2 = types2[typeName];
      if (type2.groups.indexOf(name) > -1)
        result.push(type2);
    }
    if (result.length == 0)
      stream.err("No node type or group '" + name + "' found");
    return result;
  }
  function parseExprAtom(stream) {
    if (stream.eat("(")) {
      let expr = parseExpr(stream);
      if (!stream.eat(")"))
        stream.err("Missing closing paren");
      return expr;
    } else if (!/\W/.test(stream.next)) {
      let exprs = resolveName(stream, stream.next).map((type) => {
        if (stream.inline == null)
          stream.inline = type.isInline;
        else if (stream.inline != type.isInline)
          stream.err("Mixing inline and block content");
        return { type: "name", value: type };
      });
      stream.pos++;
      return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
    } else {
      stream.err("Unexpected token '" + stream.next + "'");
    }
  }
  function nfa(expr) {
    let nfa2 = [[]];
    connect(compile(expr, 0), node2());
    return nfa2;
    function node2() {
      return nfa2.push([]) - 1;
    }
    function edge(from2, to, term) {
      let edge2 = { term, to };
      nfa2[from2].push(edge2);
      return edge2;
    }
    function connect(edges, to) {
      edges.forEach((edge2) => edge2.to = to);
    }
    function compile(expr2, from2) {
      if (expr2.type == "choice") {
        return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
      } else if (expr2.type == "seq") {
        for (let i2 = 0; ; i2++) {
          let next = compile(expr2.exprs[i2], from2);
          if (i2 == expr2.exprs.length - 1)
            return next;
          connect(next, from2 = node2());
        }
      } else if (expr2.type == "star") {
        let loop = node2();
        edge(from2, loop);
        connect(compile(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "plus") {
        let loop = node2();
        connect(compile(expr2.expr, from2), loop);
        connect(compile(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "opt") {
        return [edge(from2)].concat(compile(expr2.expr, from2));
      } else if (expr2.type == "range") {
        let cur = from2;
        for (let i2 = 0; i2 < expr2.min; i2++) {
          let next = node2();
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
        if (expr2.max == -1) {
          connect(compile(expr2.expr, cur), cur);
        } else {
          for (let i2 = expr2.min; i2 < expr2.max; i2++) {
            let next = node2();
            edge(cur, next);
            connect(compile(expr2.expr, cur), next);
            cur = next;
          }
        }
        return [edge(cur)];
      } else if (expr2.type == "name") {
        return [edge(from2, void 0, expr2.value)];
      } else {
        throw new Error("Unknown expr type");
      }
    }
  }
  function cmp(a2, b) {
    return b - a2;
  }
  function nullFrom(nfa2, node2) {
    let result = [];
    scan(node2);
    return result.sort(cmp);
    function scan(node3) {
      let edges = nfa2[node3];
      if (edges.length == 1 && !edges[0].term)
        return scan(edges[0].to);
      result.push(node3);
      for (let i2 = 0; i2 < edges.length; i2++) {
        let { term, to } = edges[i2];
        if (!term && result.indexOf(to) == -1)
          scan(to);
      }
    }
  }
  function dfa(nfa2) {
    let labeled = /* @__PURE__ */ Object.create(null);
    return explore(nullFrom(nfa2, 0));
    function explore(states) {
      let out = [];
      states.forEach((node2) => {
        nfa2[node2].forEach(({ term, to }) => {
          if (!term)
            return;
          let set;
          for (let i2 = 0; i2 < out.length; i2++)
            if (out[i2][0] == term)
              set = out[i2][1];
          nullFrom(nfa2, to).forEach((node3) => {
            if (!set)
              out.push([term, set = []]);
            if (set.indexOf(node3) == -1)
              set.push(node3);
          });
        });
      });
      let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
      for (let i2 = 0; i2 < out.length; i2++) {
        let states2 = out[i2][1].sort(cmp);
        state.next.push({ type: out[i2][0], next: labeled[states2.join(",")] || explore(states2) });
      }
      return state;
    }
  }
  function checkForDeadEnds(match, stream) {
    for (let i2 = 0, work = [match]; i2 < work.length; i2++) {
      let state = work[i2], dead = !state.validEnd, nodes = [];
      for (let j = 0; j < state.next.length; j++) {
        let { type, next } = state.next[j];
        nodes.push(type.name);
        if (dead && !(type.isText || type.hasRequiredAttrs()))
          dead = false;
        if (work.indexOf(next) == -1)
          work.push(next);
      }
      if (dead)
        stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
  function defaultAttrs(attrs) {
    let defaults2 = /* @__PURE__ */ Object.create(null);
    for (let attrName in attrs) {
      let attr = attrs[attrName];
      if (!attr.hasDefault)
        return null;
      defaults2[attrName] = attr.default;
    }
    return defaults2;
  }
  function computeAttrs(attrs, value) {
    let built = /* @__PURE__ */ Object.create(null);
    for (let name in attrs) {
      let given = value && value[name];
      if (given === void 0) {
        let attr = attrs[name];
        if (attr.hasDefault)
          given = attr.default;
        else
          throw new RangeError("No value supplied for attribute " + name);
      }
      built[name] = given;
    }
    return built;
  }
  function initAttrs(attrs) {
    let result = /* @__PURE__ */ Object.create(null);
    if (attrs)
      for (let name in attrs)
        result[name] = new Attribute(attrs[name]);
    return result;
  }
  let NodeType$1 = class NodeType2 {
    /**
    @internal
    */
    constructor(name, schema, spec) {
      this.name = name;
      this.schema = schema;
      this.spec = spec;
      this.markSet = null;
      this.groups = spec.group ? spec.group.split(" ") : [];
      this.attrs = initAttrs(spec.attrs);
      this.defaultAttrs = defaultAttrs(this.attrs);
      this.contentMatch = null;
      this.inlineContent = null;
      this.isBlock = !(spec.inline || name == "text");
      this.isText = name == "text";
    }
    /**
    True if this is an inline type.
    */
    get isInline() {
      return !this.isBlock;
    }
    /**
    True if this is a textblock type, a block that contains inline
    content.
    */
    get isTextblock() {
      return this.isBlock && this.inlineContent;
    }
    /**
    True for node types that allow no content.
    */
    get isLeaf() {
      return this.contentMatch == ContentMatch.empty;
    }
    /**
    True when this node is an atom, i.e. when it does not have
    directly editable content.
    */
    get isAtom() {
      return this.isLeaf || !!this.spec.atom;
    }
    /**
    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
    */
    get whitespace() {
      return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
    }
    /**
    Tells you whether this node type has any required attributes.
    */
    hasRequiredAttrs() {
      for (let n in this.attrs)
        if (this.attrs[n].isRequired)
          return true;
      return false;
    }
    /**
    Indicates whether this node allows some of the same content as
    the given node type.
    */
    compatibleContent(other) {
      return this == other || this.contentMatch.compatible(other.contentMatch);
    }
    /**
    @internal
    */
    computeAttrs(attrs) {
      if (!attrs && this.defaultAttrs)
        return this.defaultAttrs;
      else
        return computeAttrs(this.attrs, attrs);
    }
    /**
    Create a `Node` of this type. The given attributes are
    checked and defaulted (you can pass `null` to use the type's
    defaults entirely, if no required attributes exist). `content`
    may be a `Fragment`, a node, an array of nodes, or
    `null`. Similarly `marks` may be `null` to default to the empty
    set of marks.
    */
    create(attrs = null, content2, marks) {
      if (this.isText)
        throw new Error("NodeType.create can't construct text nodes");
      return new Node$1(this, this.computeAttrs(attrs), Fragment.from(content2), Mark$1.setFrom(marks));
    }
    /**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
    against the node type's content restrictions, and throw an error
    if it doesn't match.
    */
    createChecked(attrs = null, content2, marks) {
      content2 = Fragment.from(content2);
      this.checkContent(content2);
      return new Node$1(this, this.computeAttrs(attrs), content2, Mark$1.setFrom(marks));
    }
    /**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
    necessary to add nodes to the start or end of the given fragment
    to make it fit the node. If no fitting wrapping can be found,
    return null. Note that, due to the fact that required nodes can
    always be created, this will always succeed if you pass null or
    `Fragment.empty` as content.
    */
    createAndFill(attrs = null, content2, marks) {
      attrs = this.computeAttrs(attrs);
      content2 = Fragment.from(content2);
      if (content2.size) {
        let before = this.contentMatch.fillBefore(content2);
        if (!before)
          return null;
        content2 = before.append(content2);
      }
      let matched = this.contentMatch.matchFragment(content2);
      let after = matched && matched.fillBefore(Fragment.empty, true);
      if (!after)
        return null;
      return new Node$1(this, attrs, content2.append(after), Mark$1.setFrom(marks));
    }
    /**
    Returns true if the given fragment is valid content for this node
    type with the given attributes.
    */
    validContent(content2) {
      let result = this.contentMatch.matchFragment(content2);
      if (!result || !result.validEnd)
        return false;
      for (let i2 = 0; i2 < content2.childCount; i2++)
        if (!this.allowsMarks(content2.child(i2).marks))
          return false;
      return true;
    }
    /**
    Throws a RangeError if the given fragment is not valid content for this
    node type.
    @internal
    */
    checkContent(content2) {
      if (!this.validContent(content2))
        throw new RangeError(`Invalid content for node ${this.name}: ${content2.toString().slice(0, 50)}`);
    }
    /**
    Check whether the given mark type is allowed in this node.
    */
    allowsMarkType(markType) {
      return this.markSet == null || this.markSet.indexOf(markType) > -1;
    }
    /**
    Test whether the given set of marks are allowed in this node.
    */
    allowsMarks(marks) {
      if (this.markSet == null)
        return true;
      for (let i2 = 0; i2 < marks.length; i2++)
        if (!this.allowsMarkType(marks[i2].type))
          return false;
      return true;
    }
    /**
    Removes the marks that are not allowed in this node from the given set.
    */
    allowedMarks(marks) {
      if (this.markSet == null)
        return marks;
      let copy2;
      for (let i2 = 0; i2 < marks.length; i2++) {
        if (!this.allowsMarkType(marks[i2].type)) {
          if (!copy2)
            copy2 = marks.slice(0, i2);
        } else if (copy2) {
          copy2.push(marks[i2]);
        }
      }
      return !copy2 ? marks : copy2.length ? copy2 : Mark$1.none;
    }
    /**
    @internal
    */
    static compile(nodes, schema) {
      let result = /* @__PURE__ */ Object.create(null);
      nodes.forEach((name, spec) => result[name] = new NodeType2(name, schema, spec));
      let topType = schema.spec.topNode || "doc";
      if (!result[topType])
        throw new RangeError("Schema is missing its top node type ('" + topType + "')");
      if (!result.text)
        throw new RangeError("Every schema needs a 'text' type");
      for (let _ in result.text.attrs)
        throw new RangeError("The text node type should not have attributes");
      return result;
    }
  };
  class Attribute {
    constructor(options) {
      this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
      this.default = options.default;
    }
    get isRequired() {
      return !this.hasDefault;
    }
  }
  class MarkType {
    /**
    @internal
    */
    constructor(name, rank, schema, spec) {
      this.name = name;
      this.rank = rank;
      this.schema = schema;
      this.spec = spec;
      this.attrs = initAttrs(spec.attrs);
      this.excluded = null;
      let defaults2 = defaultAttrs(this.attrs);
      this.instance = defaults2 ? new Mark$1(this, defaults2) : null;
    }
    /**
    Create a mark of this type. `attrs` may be `null` or an object
    containing only some of the mark's attributes. The others, if
    they have defaults, will be added.
    */
    create(attrs = null) {
      if (!attrs && this.instance)
        return this.instance;
      return new Mark$1(this, computeAttrs(this.attrs, attrs));
    }
    /**
    @internal
    */
    static compile(marks, schema) {
      let result = /* @__PURE__ */ Object.create(null), rank = 0;
      marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));
      return result;
    }
    /**
    When there is a mark of this type in the given set, a new set
    without it is returned. Otherwise, the input set is returned.
    */
    removeFromSet(set) {
      for (var i2 = 0; i2 < set.length; i2++)
        if (set[i2].type == this) {
          set = set.slice(0, i2).concat(set.slice(i2 + 1));
          i2--;
        }
      return set;
    }
    /**
    Tests whether there is a mark of this type in the given set.
    */
    isInSet(set) {
      for (let i2 = 0; i2 < set.length; i2++)
        if (set[i2].type == this)
          return set[i2];
    }
    /**
    Queries whether a given mark type is
    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
    */
    excludes(other) {
      return this.excluded.indexOf(other) > -1;
    }
  }
  let Schema$1 = class Schema {
    /**
    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
    */
    constructor(spec) {
      this.cached = /* @__PURE__ */ Object.create(null);
      let instanceSpec = this.spec = {};
      for (let prop in spec)
        instanceSpec[prop] = spec[prop];
      instanceSpec.nodes = OrderedMap.from(spec.nodes), instanceSpec.marks = OrderedMap.from(spec.marks || {}), this.nodes = NodeType$1.compile(this.spec.nodes, this);
      this.marks = MarkType.compile(this.spec.marks, this);
      let contentExprCache = /* @__PURE__ */ Object.create(null);
      for (let prop in this.nodes) {
        if (prop in this.marks)
          throw new RangeError(prop + " can not be both a node and a mark");
        let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
        type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
        type.inlineContent = type.contentMatch.inlineContent;
        type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
      }
      for (let prop in this.marks) {
        let type = this.marks[prop], excl = type.spec.excludes;
        type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
      }
      this.nodeFromJSON = this.nodeFromJSON.bind(this);
      this.markFromJSON = this.markFromJSON.bind(this);
      this.topNodeType = this.nodes[this.spec.topNode || "doc"];
      this.cached.wrappings = /* @__PURE__ */ Object.create(null);
    }
    /**
    Create a node in this schema. The `type` may be a string or a
    `NodeType` instance. Attributes will be extended with defaults,
    `content` may be a `Fragment`, `null`, a `Node`, or an array of
    nodes.
    */
    node(type, attrs = null, content2, marks) {
      if (typeof type == "string")
        type = this.nodeType(type);
      else if (!(type instanceof NodeType$1))
        throw new RangeError("Invalid node type: " + type);
      else if (type.schema != this)
        throw new RangeError("Node type from different schema used (" + type.name + ")");
      return type.createChecked(attrs, content2, marks);
    }
    /**
    Create a text node in the schema. Empty text nodes are not
    allowed.
    */
    text(text2, marks) {
      let type = this.nodes.text;
      return new TextNode(type, type.defaultAttrs, text2, Mark$1.setFrom(marks));
    }
    /**
    Create a mark with the given type and attributes.
    */
    mark(type, attrs) {
      if (typeof type == "string")
        type = this.marks[type];
      return type.create(attrs);
    }
    /**
    Deserialize a node from its JSON representation. This method is
    bound.
    */
    nodeFromJSON(json) {
      return Node$1.fromJSON(this, json);
    }
    /**
    Deserialize a mark from its JSON representation. This method is
    bound.
    */
    markFromJSON(json) {
      return Mark$1.fromJSON(this, json);
    }
    /**
    @internal
    */
    nodeType(name) {
      let found2 = this.nodes[name];
      if (!found2)
        throw new RangeError("Unknown node type: " + name);
      return found2;
    }
  };
  function gatherMarks(schema, marks) {
    let found2 = [];
    for (let i2 = 0; i2 < marks.length; i2++) {
      let name = marks[i2], mark2 = schema.marks[name], ok2 = mark2;
      if (mark2) {
        found2.push(mark2);
      } else {
        for (let prop in schema.marks) {
          let mark3 = schema.marks[prop];
          if (name == "_" || mark3.spec.group && mark3.spec.group.split(" ").indexOf(name) > -1)
            found2.push(ok2 = mark3);
        }
      }
      if (!ok2)
        throw new SyntaxError("Unknown mark type: '" + marks[i2] + "'");
    }
    return found2;
  }
  let DOMParser$1 = class DOMParser2 {
    /**
    Create a parser that targets the given schema, using the given
    parsing rules.
    */
    constructor(schema, rules) {
      this.schema = schema;
      this.rules = rules;
      this.tags = [];
      this.styles = [];
      rules.forEach((rule) => {
        if (rule.tag)
          this.tags.push(rule);
        else if (rule.style)
          this.styles.push(rule);
      });
      this.normalizeLists = !this.tags.some((r) => {
        if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
          return false;
        let node2 = schema.nodes[r.node];
        return node2.contentMatch.matchType(node2);
      });
    }
    /**
    Parse a document from the content of a DOM node.
    */
    parse(dom, options = {}) {
      let context = new ParseContext(this, options, false);
      context.addAll(dom, options.from, options.to);
      return context.finish();
    }
    /**
    Parses the content of the given DOM node, like
    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
    options. But unlike that method, which produces a whole node,
    this one returns a slice that is open at the sides, meaning that
    the schema constraints aren't applied to the start of nodes to
    the left of the input and the end of nodes at the end.
    */
    parseSlice(dom, options = {}) {
      let context = new ParseContext(this, options, true);
      context.addAll(dom, options.from, options.to);
      return Slice.maxOpen(context.finish());
    }
    /**
    @internal
    */
    matchTag(dom, context, after) {
      for (let i2 = after ? this.tags.indexOf(after) + 1 : 0; i2 < this.tags.length; i2++) {
        let rule = this.tags[i2];
        if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
          if (rule.getAttrs) {
            let result = rule.getAttrs(dom);
            if (result === false)
              continue;
            rule.attrs = result || void 0;
          }
          return rule;
        }
      }
    }
    /**
    @internal
    */
    matchStyle(prop, value, context, after) {
      for (let i2 = after ? this.styles.indexOf(after) + 1 : 0; i2 < this.styles.length; i2++) {
        let rule = this.styles[i2], style2 = rule.style;
        if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
        // or has an '=' sign after the prop, followed by the given
        // value.
        style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
          continue;
        if (rule.getAttrs) {
          let result = rule.getAttrs(value);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
    /**
    @internal
    */
    static schemaRules(schema) {
      let result = [];
      function insert(rule) {
        let priority = rule.priority == null ? 50 : rule.priority, i2 = 0;
        for (; i2 < result.length; i2++) {
          let next = result[i2], nextPriority = next.priority == null ? 50 : next.priority;
          if (nextPriority < priority)
            break;
        }
        result.splice(i2, 0, rule);
      }
      for (let name in schema.marks) {
        let rules = schema.marks[name].spec.parseDOM;
        if (rules)
          rules.forEach((rule) => {
            insert(rule = copy$1(rule));
            rule.mark = name;
          });
      }
      for (let name in schema.nodes) {
        let rules = schema.nodes[name].spec.parseDOM;
        if (rules)
          rules.forEach((rule) => {
            insert(rule = copy$1(rule));
            rule.node = name;
          });
      }
      return result;
    }
    /**
    Construct a DOM parser using the parsing rules listed in a
    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
    */
    static fromSchema(schema) {
      return schema.cached.domParser || (schema.cached.domParser = new DOMParser2(schema, DOMParser2.schemaRules(schema)));
    }
  };
  const blockTags = {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    canvas: true,
    dd: true,
    div: true,
    dl: true,
    fieldset: true,
    figcaption: true,
    figure: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    li: true,
    noscript: true,
    ol: true,
    output: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    tfoot: true,
    ul: true
  };
  const ignoreTags = {
    head: true,
    noscript: true,
    object: true,
    script: true,
    style: true,
    title: true
  };
  const listTags = { ol: true, ul: true };
  const OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
  function wsOptionsFor(type, preserveWhitespace, base2) {
    if (preserveWhitespace != null)
      return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
    return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
  }
  class NodeContext {
    constructor(type, attrs, marks, pendingMarks, solid, match, options) {
      this.type = type;
      this.attrs = attrs;
      this.marks = marks;
      this.pendingMarks = pendingMarks;
      this.solid = solid;
      this.options = options;
      this.content = [];
      this.activeMarks = Mark$1.none;
      this.stashMarks = [];
      this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
    }
    findWrapping(node2) {
      if (!this.match) {
        if (!this.type)
          return [];
        let fill = this.type.contentMatch.fillBefore(Fragment.from(node2));
        if (fill) {
          this.match = this.type.contentMatch.matchFragment(fill);
        } else {
          let start = this.type.contentMatch, wrap2;
          if (wrap2 = start.findWrapping(node2.type)) {
            this.match = start;
            return wrap2;
          } else {
            return null;
          }
        }
      }
      return this.match.findWrapping(node2.type);
    }
    finish(openEnd) {
      if (!(this.options & OPT_PRESERVE_WS)) {
        let last2 = this.content[this.content.length - 1], m;
        if (last2 && last2.isText && (m = /[ \t\r\n\u000c]+$/.exec(last2.text))) {
          let text2 = last2;
          if (last2.text.length == m[0].length)
            this.content.pop();
          else
            this.content[this.content.length - 1] = text2.withText(text2.text.slice(0, text2.text.length - m[0].length));
        }
      }
      let content2 = Fragment.from(this.content);
      if (!openEnd && this.match)
        content2 = content2.append(this.match.fillBefore(Fragment.empty, true));
      return this.type ? this.type.create(this.attrs, content2, this.marks) : content2;
    }
    popFromStashMark(mark2) {
      for (let i2 = this.stashMarks.length - 1; i2 >= 0; i2--)
        if (mark2.eq(this.stashMarks[i2]))
          return this.stashMarks.splice(i2, 1)[0];
    }
    applyPending(nextType) {
      for (let i2 = 0, pending = this.pendingMarks; i2 < pending.length; i2++) {
        let mark2 = pending[i2];
        if ((this.type ? this.type.allowsMarkType(mark2.type) : markMayApply(mark2.type, nextType)) && !mark2.isInSet(this.activeMarks)) {
          this.activeMarks = mark2.addToSet(this.activeMarks);
          this.pendingMarks = mark2.removeFromSet(this.pendingMarks);
        }
      }
    }
    inlineContext(node2) {
      if (this.type)
        return this.type.inlineContent;
      if (this.content.length)
        return this.content[0].isInline;
      return node2.parentNode && !blockTags.hasOwnProperty(node2.parentNode.nodeName.toLowerCase());
    }
  }
  class ParseContext {
    constructor(parser2, options, isOpen) {
      this.parser = parser2;
      this.options = options;
      this.isOpen = isOpen;
      this.open = 0;
      let topNode = options.topNode, topContext;
      let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
      if (topNode)
        topContext = new NodeContext(topNode.type, topNode.attrs, Mark$1.none, Mark$1.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
      else if (isOpen)
        topContext = new NodeContext(null, null, Mark$1.none, Mark$1.none, true, null, topOptions);
      else
        topContext = new NodeContext(parser2.schema.topNodeType, null, Mark$1.none, Mark$1.none, true, null, topOptions);
      this.nodes = [topContext];
      this.find = options.findPositions;
      this.needsBlock = false;
    }
    get top() {
      return this.nodes[this.open];
    }
    // Add a DOM node to the content. Text is inserted as text node,
    // otherwise, the node is passed to `addElement` or, if it has a
    // `style` attribute, `addElementWithStyles`.
    addDOM(dom) {
      if (dom.nodeType == 3) {
        this.addTextNode(dom);
      } else if (dom.nodeType == 1) {
        let style2 = dom.getAttribute("style");
        let marks = style2 ? this.readStyles(parseStyles(style2)) : null, top = this.top;
        if (marks != null)
          for (let i2 = 0; i2 < marks.length; i2++)
            this.addPendingMark(marks[i2]);
        this.addElement(dom);
        if (marks != null)
          for (let i2 = 0; i2 < marks.length; i2++)
            this.removePendingMark(marks[i2], top);
      }
    }
    addTextNode(dom) {
      let value = dom.nodeValue;
      let top = this.top;
      if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
        if (!(top.options & OPT_PRESERVE_WS)) {
          value = value.replace(/[ \t\r\n\u000c]+/g, " ");
          if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
            let nodeBefore = top.content[top.content.length - 1];
            let domNodeBefore = dom.previousSibling;
            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
              value = value.slice(1);
          }
        } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
          value = value.replace(/\r?\n|\r/g, " ");
        } else {
          value = value.replace(/\r\n?/g, "\n");
        }
        if (value)
          this.insertNode(this.parser.schema.text(value));
        this.findInText(dom);
      } else {
        this.findInside(dom);
      }
    }
    // Try to find a handler for the given tag and use that to parse. If
    // none is found, the element's content nodes are added directly.
    addElement(dom, matchAfter) {
      let name = dom.nodeName.toLowerCase(), ruleID;
      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
        normalizeList(dom);
      let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent)
          this.open = Math.max(0, this.open - 1);
        else if (rule && rule.skip.nodeType)
          dom = rule.skip;
        let sync, top = this.top, oldNeedsBlock = this.needsBlock;
        if (blockTags.hasOwnProperty(name)) {
          if (top.content.length && top.content[0].isInline && this.open) {
            this.open--;
            top = this.top;
          }
          sync = true;
          if (!top.type)
            this.needsBlock = true;
        } else if (!dom.firstChild) {
          this.leafFallback(dom);
          return;
        }
        this.addAll(dom);
        if (sync)
          this.sync(top);
        this.needsBlock = oldNeedsBlock;
      } else {
        this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : void 0);
      }
    }
    // Called for leaf DOM nodes that would otherwise be ignored
    leafFallback(dom) {
      if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
        this.addTextNode(dom.ownerDocument.createTextNode("\n"));
    }
    // Called for ignored nodes
    ignoreFallback(dom) {
      if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
        this.findPlace(this.parser.schema.text("-"));
    }
    // Run any style parser associated with the node's styles. Either
    // return an array of marks, or null to indicate some of the styles
    // had a rule with `ignore` set.
    readStyles(styles) {
      let marks = Mark$1.none;
      style:
        for (let i2 = 0; i2 < styles.length; i2 += 2) {
          for (let after = void 0; ; ) {
            let rule = this.parser.matchStyle(styles[i2], styles[i2 + 1], this, after);
            if (!rule)
              continue style;
            if (rule.ignore)
              return null;
            marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);
            if (rule.consuming === false)
              after = rule;
            else
              break;
          }
        }
      return marks;
    }
    // Look up a handler for the given node. If none are found, return
    // false. Otherwise, apply it, use its return value to drive the way
    // the node's content is wrapped, and return true.
    addElementByRule(dom, rule, continueAfter) {
      let sync, nodeType, mark2;
      if (rule.node) {
        nodeType = this.parser.schema.nodes[rule.node];
        if (!nodeType.isLeaf) {
          sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
        } else if (!this.insertNode(nodeType.create(rule.attrs))) {
          this.leafFallback(dom);
        }
      } else {
        let markType = this.parser.schema.marks[rule.mark];
        mark2 = markType.create(rule.attrs);
        this.addPendingMark(mark2);
      }
      let startIn = this.top;
      if (nodeType && nodeType.isLeaf) {
        this.findInside(dom);
      } else if (continueAfter) {
        this.addElement(dom, continueAfter);
      } else if (rule.getContent) {
        this.findInside(dom);
        rule.getContent(dom, this.parser.schema).forEach((node2) => this.insertNode(node2));
      } else {
        let contentDOM = dom;
        if (typeof rule.contentElement == "string")
          contentDOM = dom.querySelector(rule.contentElement);
        else if (typeof rule.contentElement == "function")
          contentDOM = rule.contentElement(dom);
        else if (rule.contentElement)
          contentDOM = rule.contentElement;
        this.findAround(dom, contentDOM, true);
        this.addAll(contentDOM);
      }
      if (sync && this.sync(startIn))
        this.open--;
      if (mark2)
        this.removePendingMark(mark2, startIn);
    }
    // Add all child nodes between `startIndex` and `endIndex` (or the
    // whole node, if not given). If `sync` is passed, use it to
    // synchronize after every block element.
    addAll(parent, startIndex, endIndex) {
      let index2 = startIndex || 0;
      for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index2) {
        this.findAtPoint(parent, index2);
        this.addDOM(dom);
      }
      this.findAtPoint(parent, index2);
    }
    // Try to find a way to fit the given node type into the current
    // context. May add intermediate wrappers and/or leave non-solid
    // nodes that we're in.
    findPlace(node2) {
      let route, sync;
      for (let depth = this.open; depth >= 0; depth--) {
        let cx = this.nodes[depth];
        let found2 = cx.findWrapping(node2);
        if (found2 && (!route || route.length > found2.length)) {
          route = found2;
          sync = cx;
          if (!found2.length)
            break;
        }
        if (cx.solid)
          break;
      }
      if (!route)
        return false;
      this.sync(sync);
      for (let i2 = 0; i2 < route.length; i2++)
        this.enterInner(route[i2], null, false);
      return true;
    }
    // Try to insert the given node, adjusting the context when needed.
    insertNode(node2) {
      if (node2.isInline && this.needsBlock && !this.top.type) {
        let block2 = this.textblockFromContext();
        if (block2)
          this.enterInner(block2);
      }
      if (this.findPlace(node2)) {
        this.closeExtra();
        let top = this.top;
        top.applyPending(node2.type);
        if (top.match)
          top.match = top.match.matchType(node2.type);
        let marks = top.activeMarks;
        for (let i2 = 0; i2 < node2.marks.length; i2++)
          if (!top.type || top.type.allowsMarkType(node2.marks[i2].type))
            marks = node2.marks[i2].addToSet(marks);
        top.content.push(node2.mark(marks));
        return true;
      }
      return false;
    }
    // Try to start a node of the given type, adjusting the context when
    // necessary.
    enter(type, attrs, preserveWS) {
      let ok2 = this.findPlace(type.create(attrs));
      if (ok2)
        this.enterInner(type, attrs, true, preserveWS);
      return ok2;
    }
    // Open a node of the given type
    enterInner(type, attrs = null, solid = false, preserveWS) {
      this.closeExtra();
      let top = this.top;
      top.applyPending(type);
      top.match = top.match && top.match.matchType(type);
      let options = wsOptionsFor(type, preserveWS, top.options);
      if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
        options |= OPT_OPEN_LEFT;
      this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));
      this.open++;
    }
    // Make sure all nodes above this.open are finished and added to
    // their parents
    closeExtra(openEnd = false) {
      let i2 = this.nodes.length - 1;
      if (i2 > this.open) {
        for (; i2 > this.open; i2--)
          this.nodes[i2 - 1].content.push(this.nodes[i2].finish(openEnd));
        this.nodes.length = this.open + 1;
      }
    }
    finish() {
      this.open = 0;
      this.closeExtra(this.isOpen);
      return this.nodes[0].finish(this.isOpen || this.options.topOpen);
    }
    sync(to) {
      for (let i2 = this.open; i2 >= 0; i2--)
        if (this.nodes[i2] == to) {
          this.open = i2;
          return true;
        }
      return false;
    }
    get currentPos() {
      this.closeExtra();
      let pos = 0;
      for (let i2 = this.open; i2 >= 0; i2--) {
        let content2 = this.nodes[i2].content;
        for (let j = content2.length - 1; j >= 0; j--)
          pos += content2[j].nodeSize;
        if (i2)
          pos++;
      }
      return pos;
    }
    findAtPoint(parent, offset) {
      if (this.find)
        for (let i2 = 0; i2 < this.find.length; i2++) {
          if (this.find[i2].node == parent && this.find[i2].offset == offset)
            this.find[i2].pos = this.currentPos;
        }
    }
    findInside(parent) {
      if (this.find)
        for (let i2 = 0; i2 < this.find.length; i2++) {
          if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node))
            this.find[i2].pos = this.currentPos;
        }
    }
    findAround(parent, content2, before) {
      if (parent != content2 && this.find)
        for (let i2 = 0; i2 < this.find.length; i2++) {
          if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node)) {
            let pos = content2.compareDocumentPosition(this.find[i2].node);
            if (pos & (before ? 2 : 4))
              this.find[i2].pos = this.currentPos;
          }
        }
    }
    findInText(textNode) {
      if (this.find)
        for (let i2 = 0; i2 < this.find.length; i2++) {
          if (this.find[i2].node == textNode)
            this.find[i2].pos = this.currentPos - (textNode.nodeValue.length - this.find[i2].offset);
        }
    }
    // Determines whether the given context string matches this context.
    matchesContext(context) {
      if (context.indexOf("|") > -1)
        return context.split(/\s*\|\s*/).some(this.matchesContext, this);
      let parts = context.split("/");
      let option2 = this.options.context;
      let useRoot = !this.isOpen && (!option2 || option2.parent.type == this.nodes[0].type);
      let minDepth = -(option2 ? option2.depth + 1 : 0) + (useRoot ? 0 : 1);
      let match = (i2, depth) => {
        for (; i2 >= 0; i2--) {
          let part = parts[i2];
          if (part == "") {
            if (i2 == parts.length - 1 || i2 == 0)
              continue;
            for (; depth >= minDepth; depth--)
              if (match(i2 - 1, depth))
                return true;
            return false;
          } else {
            let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option2 && depth >= minDepth ? option2.node(depth - minDepth).type : null;
            if (!next || next.name != part && next.groups.indexOf(part) == -1)
              return false;
            depth--;
          }
        }
        return true;
      };
      return match(parts.length - 1, this.open);
    }
    textblockFromContext() {
      let $context = this.options.context;
      if ($context)
        for (let d = $context.depth; d >= 0; d--) {
          let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
          if (deflt && deflt.isTextblock && deflt.defaultAttrs)
            return deflt;
        }
      for (let name in this.parser.schema.nodes) {
        let type = this.parser.schema.nodes[name];
        if (type.isTextblock && type.defaultAttrs)
          return type;
      }
    }
    addPendingMark(mark2) {
      let found2 = findSameMarkInSet(mark2, this.top.pendingMarks);
      if (found2)
        this.top.stashMarks.push(found2);
      this.top.pendingMarks = mark2.addToSet(this.top.pendingMarks);
    }
    removePendingMark(mark2, upto) {
      for (let depth = this.open; depth >= 0; depth--) {
        let level = this.nodes[depth];
        let found2 = level.pendingMarks.lastIndexOf(mark2);
        if (found2 > -1) {
          level.pendingMarks = mark2.removeFromSet(level.pendingMarks);
        } else {
          level.activeMarks = mark2.removeFromSet(level.activeMarks);
          let stashMark = level.popFromStashMark(mark2);
          if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
            level.activeMarks = stashMark.addToSet(level.activeMarks);
        }
        if (level == upto)
          break;
      }
    }
  }
  function normalizeList(dom) {
    for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
      let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
      if (name && listTags.hasOwnProperty(name) && prevItem) {
        prevItem.appendChild(child);
        child = prevItem;
      } else if (name == "li") {
        prevItem = child;
      } else if (name) {
        prevItem = null;
      }
    }
  }
  function matches(dom, selector) {
    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
  }
  function parseStyles(style2) {
    let re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
    while (m = re.exec(style2))
      result.push(m[1], m[2].trim());
    return result;
  }
  function copy$1(obj) {
    let copy2 = {};
    for (let prop in obj)
      copy2[prop] = obj[prop];
    return copy2;
  }
  function markMayApply(markType, nodeType) {
    let nodes = nodeType.schema.nodes;
    for (let name in nodes) {
      let parent = nodes[name];
      if (!parent.allowsMarkType(markType))
        continue;
      let seen = [], scan = (match) => {
        seen.push(match);
        for (let i2 = 0; i2 < match.edgeCount; i2++) {
          let { type, next } = match.edge(i2);
          if (type == nodeType)
            return true;
          if (seen.indexOf(next) < 0 && scan(next))
            return true;
        }
      };
      if (scan(parent.contentMatch))
        return true;
    }
  }
  function findSameMarkInSet(mark2, set) {
    for (let i2 = 0; i2 < set.length; i2++) {
      if (mark2.eq(set[i2]))
        return set[i2];
    }
  }
  class DOMSerializer {
    /**
    Create a serializer. `nodes` should map node names to functions
    that take a node and return a description of the corresponding
    DOM. `marks` does the same for mark names, but also gets an
    argument that tells it whether the mark's content is block or
    inline content (for typical use, it'll always be inline). A mark
    serializer may be `null` to indicate that marks of that type
    should not be serialized.
    */
    constructor(nodes, marks) {
      this.nodes = nodes;
      this.marks = marks;
    }
    /**
    Serialize the content of this fragment to a DOM fragment. When
    not in the browser, the `document` option, containing a DOM
    document, should be passed so that the serializer can create
    nodes.
    */
    serializeFragment(fragment, options = {}, target) {
      if (!target)
        target = doc$3(options).createDocumentFragment();
      let top = target, active = [];
      fragment.forEach((node2) => {
        if (active.length || node2.marks.length) {
          let keep = 0, rendered = 0;
          while (keep < active.length && rendered < node2.marks.length) {
            let next = node2.marks[rendered];
            if (!this.marks[next.type.name]) {
              rendered++;
              continue;
            }
            if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
              break;
            keep++;
            rendered++;
          }
          while (keep < active.length)
            top = active.pop()[1];
          while (rendered < node2.marks.length) {
            let add = node2.marks[rendered++];
            let markDOM = this.serializeMark(add, node2.isInline, options);
            if (markDOM) {
              active.push([add, top]);
              top.appendChild(markDOM.dom);
              top = markDOM.contentDOM || markDOM.dom;
            }
          }
        }
        top.appendChild(this.serializeNodeInner(node2, options));
      });
      return target;
    }
    /**
    @internal
    */
    serializeNodeInner(node2, options) {
      let { dom, contentDOM } = DOMSerializer.renderSpec(doc$3(options), this.nodes[node2.type.name](node2));
      if (contentDOM) {
        if (node2.isLeaf)
          throw new RangeError("Content hole not allowed in a leaf node spec");
        this.serializeFragment(node2.content, options, contentDOM);
      }
      return dom;
    }
    /**
    Serialize this node to a DOM node. This can be useful when you
    need to serialize a part of a document, as opposed to the whole
    document. To serialize a whole document, use
    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
    its [content](https://prosemirror.net/docs/ref/#model.Node.content).
    */
    serializeNode(node2, options = {}) {
      let dom = this.serializeNodeInner(node2, options);
      for (let i2 = node2.marks.length - 1; i2 >= 0; i2--) {
        let wrap2 = this.serializeMark(node2.marks[i2], node2.isInline, options);
        if (wrap2) {
          (wrap2.contentDOM || wrap2.dom).appendChild(dom);
          dom = wrap2.dom;
        }
      }
      return dom;
    }
    /**
    @internal
    */
    serializeMark(mark2, inline, options = {}) {
      let toDOM = this.marks[mark2.type.name];
      return toDOM && DOMSerializer.renderSpec(doc$3(options), toDOM(mark2, inline));
    }
    /**
    Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
    the spec has a hole (zero) in it, `contentDOM` will point at the
    node with the hole.
    */
    static renderSpec(doc2, structure, xmlNS = null) {
      if (typeof structure == "string")
        return { dom: doc2.createTextNode(structure) };
      if (structure.nodeType != null)
        return { dom: structure };
      if (structure.dom && structure.dom.nodeType != null)
        return structure;
      let tagName = structure[0], space2 = tagName.indexOf(" ");
      if (space2 > 0) {
        xmlNS = tagName.slice(0, space2);
        tagName = tagName.slice(space2 + 1);
      }
      let contentDOM;
      let dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
      let attrs = structure[1], start = 1;
      if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
        start = 2;
        for (let name in attrs)
          if (attrs[name] != null) {
            let space3 = name.indexOf(" ");
            if (space3 > 0)
              dom.setAttributeNS(name.slice(0, space3), name.slice(space3 + 1), attrs[name]);
            else
              dom.setAttribute(name, attrs[name]);
          }
      }
      for (let i2 = start; i2 < structure.length; i2++) {
        let child = structure[i2];
        if (child === 0) {
          if (i2 < structure.length - 1 || i2 > start)
            throw new RangeError("Content hole must be the only child of its parent node");
          return { dom, contentDOM: dom };
        } else {
          let { dom: inner, contentDOM: innerContent } = DOMSerializer.renderSpec(doc2, child, xmlNS);
          dom.appendChild(inner);
          if (innerContent) {
            if (contentDOM)
              throw new RangeError("Multiple content holes");
            contentDOM = innerContent;
          }
        }
      }
      return { dom, contentDOM };
    }
    /**
    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
    properties in a schema's node and mark specs.
    */
    static fromSchema(schema) {
      return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
    }
    /**
    Gather the serializers in a schema's node specs into an object.
    This can be useful as a base to build a custom serializer from.
    */
    static nodesFromSchema(schema) {
      let result = gatherToDOM(schema.nodes);
      if (!result.text)
        result.text = (node2) => node2.text;
      return result;
    }
    /**
    Gather the serializers in a schema's mark specs into an object.
    */
    static marksFromSchema(schema) {
      return gatherToDOM(schema.marks);
    }
  }
  function gatherToDOM(obj) {
    let result = {};
    for (let name in obj) {
      let toDOM = obj[name].spec.toDOM;
      if (toDOM)
        result[name] = toDOM;
    }
    return result;
  }
  function doc$3(options) {
    return options.document || window.document;
  }
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var unicode$3 = {};
  const UNDEFINED_CODE_POINTS = [
    65534,
    65535,
    131070,
    131071,
    196606,
    196607,
    262142,
    262143,
    327678,
    327679,
    393214,
    393215,
    458750,
    458751,
    524286,
    524287,
    589822,
    589823,
    655358,
    655359,
    720894,
    720895,
    786430,
    786431,
    851966,
    851967,
    917502,
    917503,
    983038,
    983039,
    1048574,
    1048575,
    1114110,
    1114111
  ];
  unicode$3.REPLACEMENT_CHARACTER = "�";
  unicode$3.CODE_POINTS = {
    EOF: -1,
    NULL: 0,
    TABULATION: 9,
    CARRIAGE_RETURN: 13,
    LINE_FEED: 10,
    FORM_FEED: 12,
    SPACE: 32,
    EXCLAMATION_MARK: 33,
    QUOTATION_MARK: 34,
    NUMBER_SIGN: 35,
    AMPERSAND: 38,
    APOSTROPHE: 39,
    HYPHEN_MINUS: 45,
    SOLIDUS: 47,
    DIGIT_0: 48,
    DIGIT_9: 57,
    SEMICOLON: 59,
    LESS_THAN_SIGN: 60,
    EQUALS_SIGN: 61,
    GREATER_THAN_SIGN: 62,
    QUESTION_MARK: 63,
    LATIN_CAPITAL_A: 65,
    LATIN_CAPITAL_F: 70,
    LATIN_CAPITAL_X: 88,
    LATIN_CAPITAL_Z: 90,
    RIGHT_SQUARE_BRACKET: 93,
    GRAVE_ACCENT: 96,
    LATIN_SMALL_A: 97,
    LATIN_SMALL_F: 102,
    LATIN_SMALL_X: 120,
    LATIN_SMALL_Z: 122,
    REPLACEMENT_CHARACTER: 65533
  };
  unicode$3.CODE_POINT_SEQUENCES = {
    DASH_DASH_STRING: [45, 45],
    //--
    DOCTYPE_STRING: [68, 79, 67, 84, 89, 80, 69],
    //DOCTYPE
    CDATA_START_STRING: [91, 67, 68, 65, 84, 65, 91],
    //[CDATA[
    SCRIPT_STRING: [115, 99, 114, 105, 112, 116],
    //script
    PUBLIC_STRING: [80, 85, 66, 76, 73, 67],
    //PUBLIC
    SYSTEM_STRING: [83, 89, 83, 84, 69, 77]
    //SYSTEM
  };
  unicode$3.isSurrogate = function(cp) {
    return cp >= 55296 && cp <= 57343;
  };
  unicode$3.isSurrogatePair = function(cp) {
    return cp >= 56320 && cp <= 57343;
  };
  unicode$3.getSurrogatePairCodePoint = function(cp1, cp2) {
    return (cp1 - 55296) * 1024 + 9216 + cp2;
  };
  unicode$3.isControlCodePoint = function(cp) {
    return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
  };
  unicode$3.isUndefinedCodePoint = function(cp) {
    return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.indexOf(cp) > -1;
  };
  var errorCodes = {
    controlCharacterInInputStream: "control-character-in-input-stream",
    noncharacterInInputStream: "noncharacter-in-input-stream",
    surrogateInInputStream: "surrogate-in-input-stream",
    nonVoidHtmlElementStartTagWithTrailingSolidus: "non-void-html-element-start-tag-with-trailing-solidus",
    endTagWithAttributes: "end-tag-with-attributes",
    endTagWithTrailingSolidus: "end-tag-with-trailing-solidus",
    unexpectedSolidusInTag: "unexpected-solidus-in-tag",
    unexpectedNullCharacter: "unexpected-null-character",
    unexpectedQuestionMarkInsteadOfTagName: "unexpected-question-mark-instead-of-tag-name",
    invalidFirstCharacterOfTagName: "invalid-first-character-of-tag-name",
    unexpectedEqualsSignBeforeAttributeName: "unexpected-equals-sign-before-attribute-name",
    missingEndTagName: "missing-end-tag-name",
    unexpectedCharacterInAttributeName: "unexpected-character-in-attribute-name",
    unknownNamedCharacterReference: "unknown-named-character-reference",
    missingSemicolonAfterCharacterReference: "missing-semicolon-after-character-reference",
    unexpectedCharacterAfterDoctypeSystemIdentifier: "unexpected-character-after-doctype-system-identifier",
    unexpectedCharacterInUnquotedAttributeValue: "unexpected-character-in-unquoted-attribute-value",
    eofBeforeTagName: "eof-before-tag-name",
    eofInTag: "eof-in-tag",
    missingAttributeValue: "missing-attribute-value",
    missingWhitespaceBetweenAttributes: "missing-whitespace-between-attributes",
    missingWhitespaceAfterDoctypePublicKeyword: "missing-whitespace-after-doctype-public-keyword",
    missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: "missing-whitespace-between-doctype-public-and-system-identifiers",
    missingWhitespaceAfterDoctypeSystemKeyword: "missing-whitespace-after-doctype-system-keyword",
    missingQuoteBeforeDoctypePublicIdentifier: "missing-quote-before-doctype-public-identifier",
    missingQuoteBeforeDoctypeSystemIdentifier: "missing-quote-before-doctype-system-identifier",
    missingDoctypePublicIdentifier: "missing-doctype-public-identifier",
    missingDoctypeSystemIdentifier: "missing-doctype-system-identifier",
    abruptDoctypePublicIdentifier: "abrupt-doctype-public-identifier",
    abruptDoctypeSystemIdentifier: "abrupt-doctype-system-identifier",
    cdataInHtmlContent: "cdata-in-html-content",
    incorrectlyOpenedComment: "incorrectly-opened-comment",
    eofInScriptHtmlCommentLikeText: "eof-in-script-html-comment-like-text",
    eofInDoctype: "eof-in-doctype",
    nestedComment: "nested-comment",
    abruptClosingOfEmptyComment: "abrupt-closing-of-empty-comment",
    eofInComment: "eof-in-comment",
    incorrectlyClosedComment: "incorrectly-closed-comment",
    eofInCdata: "eof-in-cdata",
    absenceOfDigitsInNumericCharacterReference: "absence-of-digits-in-numeric-character-reference",
    nullCharacterReference: "null-character-reference",
    surrogateCharacterReference: "surrogate-character-reference",
    characterReferenceOutsideUnicodeRange: "character-reference-outside-unicode-range",
    controlCharacterReference: "control-character-reference",
    noncharacterCharacterReference: "noncharacter-character-reference",
    missingWhitespaceBeforeDoctypeName: "missing-whitespace-before-doctype-name",
    missingDoctypeName: "missing-doctype-name",
    invalidCharacterSequenceAfterDoctypeName: "invalid-character-sequence-after-doctype-name",
    duplicateAttribute: "duplicate-attribute",
    nonConformingDoctype: "non-conforming-doctype",
    missingDoctype: "missing-doctype",
    misplacedDoctype: "misplaced-doctype",
    endTagWithoutMatchingOpenElement: "end-tag-without-matching-open-element",
    closingOfElementWithOpenChildElements: "closing-of-element-with-open-child-elements",
    disallowedContentInNoscriptInHead: "disallowed-content-in-noscript-in-head",
    openElementsLeftAfterEof: "open-elements-left-after-eof",
    abandonedHeadElementChild: "abandoned-head-element-child",
    misplacedStartTagForHeadElement: "misplaced-start-tag-for-head-element",
    nestedNoscriptInHead: "nested-noscript-in-head",
    eofInElementThatCanContainOnlyText: "eof-in-element-that-can-contain-only-text"
  };
  const unicode$2 = unicode$3;
  const ERR$2 = errorCodes;
  const $$6 = unicode$2.CODE_POINTS;
  const DEFAULT_BUFFER_WATERLINE = 1 << 16;
  let Preprocessor$1 = class Preprocessor {
    constructor() {
      this.html = null;
      this.pos = -1;
      this.lastGapPos = -1;
      this.lastCharPos = -1;
      this.gapStack = [];
      this.skipNextNewLine = false;
      this.lastChunkWritten = false;
      this.endOfChunkHit = false;
      this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
    }
    _err() {
    }
    _addGap() {
      this.gapStack.push(this.lastGapPos);
      this.lastGapPos = this.pos;
    }
    _processSurrogate(cp) {
      if (this.pos !== this.lastCharPos) {
        const nextCp = this.html.charCodeAt(this.pos + 1);
        if (unicode$2.isSurrogatePair(nextCp)) {
          this.pos++;
          this._addGap();
          return unicode$2.getSurrogatePairCodePoint(cp, nextCp);
        }
      } else if (!this.lastChunkWritten) {
        this.endOfChunkHit = true;
        return $$6.EOF;
      }
      this._err(ERR$2.surrogateInInputStream);
      return cp;
    }
    dropParsedChunk() {
      if (this.pos > this.bufferWaterline) {
        this.lastCharPos -= this.pos;
        this.html = this.html.substring(this.pos);
        this.pos = 0;
        this.lastGapPos = -1;
        this.gapStack = [];
      }
    }
    write(chunk, isLastChunk) {
      if (this.html) {
        this.html += chunk;
      } else {
        this.html = chunk;
      }
      this.lastCharPos = this.html.length - 1;
      this.endOfChunkHit = false;
      this.lastChunkWritten = isLastChunk;
    }
    insertHtmlAtCurrentPos(chunk) {
      this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);
      this.lastCharPos = this.html.length - 1;
      this.endOfChunkHit = false;
    }
    advance() {
      this.pos++;
      if (this.pos > this.lastCharPos) {
        this.endOfChunkHit = !this.lastChunkWritten;
        return $$6.EOF;
      }
      let cp = this.html.charCodeAt(this.pos);
      if (this.skipNextNewLine && cp === $$6.LINE_FEED) {
        this.skipNextNewLine = false;
        this._addGap();
        return this.advance();
      }
      if (cp === $$6.CARRIAGE_RETURN) {
        this.skipNextNewLine = true;
        return $$6.LINE_FEED;
      }
      this.skipNextNewLine = false;
      if (unicode$2.isSurrogate(cp)) {
        cp = this._processSurrogate(cp);
      }
      const isCommonValidRange = cp > 31 && cp < 127 || cp === $$6.LINE_FEED || cp === $$6.CARRIAGE_RETURN || cp > 159 && cp < 64976;
      if (!isCommonValidRange) {
        this._checkForProblematicCharacters(cp);
      }
      return cp;
    }
    _checkForProblematicCharacters(cp) {
      if (unicode$2.isControlCodePoint(cp)) {
        this._err(ERR$2.controlCharacterInInputStream);
      } else if (unicode$2.isUndefinedCodePoint(cp)) {
        this._err(ERR$2.noncharacterInInputStream);
      }
    }
    retreat() {
      if (this.pos === this.lastGapPos) {
        this.lastGapPos = this.gapStack.pop();
        this.pos--;
      }
      this.pos--;
    }
  };
  var preprocessor = Preprocessor$1;
  var namedEntityData = new Uint16Array([4, 52, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 106, 303, 412, 810, 1432, 1701, 1796, 1987, 2114, 2360, 2420, 2484, 3170, 3251, 4140, 4393, 4575, 4610, 5106, 5512, 5728, 6117, 6274, 6315, 6345, 6427, 6516, 7002, 7910, 8733, 9323, 9870, 10170, 10631, 10893, 11318, 11386, 11467, 12773, 13092, 14474, 14922, 15448, 15542, 16419, 17666, 18166, 18611, 19004, 19095, 19298, 19397, 4, 16, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 140, 150, 158, 169, 176, 194, 199, 210, 216, 222, 226, 242, 256, 266, 283, 294, 108, 105, 103, 5, 198, 1, 59, 148, 1, 198, 80, 5, 38, 1, 59, 156, 1, 38, 99, 117, 116, 101, 5, 193, 1, 59, 167, 1, 193, 114, 101, 118, 101, 59, 1, 258, 4, 2, 105, 121, 182, 191, 114, 99, 5, 194, 1, 59, 189, 1, 194, 59, 1, 1040, 114, 59, 3, 55349, 56580, 114, 97, 118, 101, 5, 192, 1, 59, 208, 1, 192, 112, 104, 97, 59, 1, 913, 97, 99, 114, 59, 1, 256, 100, 59, 1, 10835, 4, 2, 103, 112, 232, 237, 111, 110, 59, 1, 260, 102, 59, 3, 55349, 56632, 112, 108, 121, 70, 117, 110, 99, 116, 105, 111, 110, 59, 1, 8289, 105, 110, 103, 5, 197, 1, 59, 264, 1, 197, 4, 2, 99, 115, 272, 277, 114, 59, 3, 55349, 56476, 105, 103, 110, 59, 1, 8788, 105, 108, 100, 101, 5, 195, 1, 59, 292, 1, 195, 109, 108, 5, 196, 1, 59, 301, 1, 196, 4, 8, 97, 99, 101, 102, 111, 114, 115, 117, 321, 350, 354, 383, 388, 394, 400, 405, 4, 2, 99, 114, 327, 336, 107, 115, 108, 97, 115, 104, 59, 1, 8726, 4, 2, 118, 119, 342, 345, 59, 1, 10983, 101, 100, 59, 1, 8966, 121, 59, 1, 1041, 4, 3, 99, 114, 116, 362, 369, 379, 97, 117, 115, 101, 59, 1, 8757, 110, 111, 117, 108, 108, 105, 115, 59, 1, 8492, 97, 59, 1, 914, 114, 59, 3, 55349, 56581, 112, 102, 59, 3, 55349, 56633, 101, 118, 101, 59, 1, 728, 99, 114, 59, 1, 8492, 109, 112, 101, 113, 59, 1, 8782, 4, 14, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 442, 447, 456, 504, 542, 547, 569, 573, 577, 616, 678, 784, 790, 796, 99, 121, 59, 1, 1063, 80, 89, 5, 169, 1, 59, 454, 1, 169, 4, 3, 99, 112, 121, 464, 470, 497, 117, 116, 101, 59, 1, 262, 4, 2, 59, 105, 476, 478, 1, 8914, 116, 97, 108, 68, 105, 102, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8517, 108, 101, 121, 115, 59, 1, 8493, 4, 4, 97, 101, 105, 111, 514, 520, 530, 535, 114, 111, 110, 59, 1, 268, 100, 105, 108, 5, 199, 1, 59, 528, 1, 199, 114, 99, 59, 1, 264, 110, 105, 110, 116, 59, 1, 8752, 111, 116, 59, 1, 266, 4, 2, 100, 110, 553, 560, 105, 108, 108, 97, 59, 1, 184, 116, 101, 114, 68, 111, 116, 59, 1, 183, 114, 59, 1, 8493, 105, 59, 1, 935, 114, 99, 108, 101, 4, 4, 68, 77, 80, 84, 591, 596, 603, 609, 111, 116, 59, 1, 8857, 105, 110, 117, 115, 59, 1, 8854, 108, 117, 115, 59, 1, 8853, 105, 109, 101, 115, 59, 1, 8855, 111, 4, 2, 99, 115, 623, 646, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8754, 101, 67, 117, 114, 108, 121, 4, 2, 68, 81, 658, 671, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8221, 117, 111, 116, 101, 59, 1, 8217, 4, 4, 108, 110, 112, 117, 688, 701, 736, 753, 111, 110, 4, 2, 59, 101, 696, 698, 1, 8759, 59, 1, 10868, 4, 3, 103, 105, 116, 709, 717, 722, 114, 117, 101, 110, 116, 59, 1, 8801, 110, 116, 59, 1, 8751, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8750, 4, 2, 102, 114, 742, 745, 59, 1, 8450, 111, 100, 117, 99, 116, 59, 1, 8720, 110, 116, 101, 114, 67, 108, 111, 99, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8755, 111, 115, 115, 59, 1, 10799, 99, 114, 59, 3, 55349, 56478, 112, 4, 2, 59, 67, 803, 805, 1, 8915, 97, 112, 59, 1, 8781, 4, 11, 68, 74, 83, 90, 97, 99, 101, 102, 105, 111, 115, 834, 850, 855, 860, 865, 888, 903, 916, 921, 1011, 1415, 4, 2, 59, 111, 840, 842, 1, 8517, 116, 114, 97, 104, 100, 59, 1, 10513, 99, 121, 59, 1, 1026, 99, 121, 59, 1, 1029, 99, 121, 59, 1, 1039, 4, 3, 103, 114, 115, 873, 879, 883, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8609, 104, 118, 59, 1, 10980, 4, 2, 97, 121, 894, 900, 114, 111, 110, 59, 1, 270, 59, 1, 1044, 108, 4, 2, 59, 116, 910, 912, 1, 8711, 97, 59, 1, 916, 114, 59, 3, 55349, 56583, 4, 2, 97, 102, 927, 998, 4, 2, 99, 109, 933, 992, 114, 105, 116, 105, 99, 97, 108, 4, 4, 65, 68, 71, 84, 950, 957, 978, 985, 99, 117, 116, 101, 59, 1, 180, 111, 4, 2, 116, 117, 964, 967, 59, 1, 729, 98, 108, 101, 65, 99, 117, 116, 101, 59, 1, 733, 114, 97, 118, 101, 59, 1, 96, 105, 108, 100, 101, 59, 1, 732, 111, 110, 100, 59, 1, 8900, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8518, 4, 4, 112, 116, 117, 119, 1021, 1026, 1048, 1249, 102, 59, 3, 55349, 56635, 4, 3, 59, 68, 69, 1034, 1036, 1041, 1, 168, 111, 116, 59, 1, 8412, 113, 117, 97, 108, 59, 1, 8784, 98, 108, 101, 4, 6, 67, 68, 76, 82, 85, 86, 1065, 1082, 1101, 1189, 1211, 1236, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8751, 111, 4, 2, 116, 119, 1089, 1092, 59, 1, 168, 110, 65, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 101, 111, 1107, 1141, 102, 116, 4, 3, 65, 82, 84, 1117, 1124, 1136, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8660, 101, 101, 59, 1, 10980, 110, 103, 4, 2, 76, 82, 1149, 1177, 101, 102, 116, 4, 2, 65, 82, 1158, 1165, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10233, 105, 103, 104, 116, 4, 2, 65, 84, 1199, 1206, 114, 114, 111, 119, 59, 1, 8658, 101, 101, 59, 1, 8872, 112, 4, 2, 65, 68, 1218, 1225, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8741, 110, 4, 6, 65, 66, 76, 82, 84, 97, 1264, 1292, 1299, 1352, 1391, 1408, 114, 114, 111, 119, 4, 3, 59, 66, 85, 1276, 1278, 1283, 1, 8595, 97, 114, 59, 1, 10515, 112, 65, 114, 114, 111, 119, 59, 1, 8693, 114, 101, 118, 101, 59, 1, 785, 101, 102, 116, 4, 3, 82, 84, 86, 1310, 1323, 1334, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 1, 10576, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10590, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1345, 1347, 1, 8637, 97, 114, 59, 1, 10582, 105, 103, 104, 116, 4, 2, 84, 86, 1362, 1373, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10591, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1384, 1386, 1, 8641, 97, 114, 59, 1, 10583, 101, 101, 4, 2, 59, 65, 1399, 1401, 1, 8868, 114, 114, 111, 119, 59, 1, 8615, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 99, 116, 1421, 1426, 114, 59, 3, 55349, 56479, 114, 111, 107, 59, 1, 272, 4, 16, 78, 84, 97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115, 116, 117, 120, 1466, 1470, 1478, 1489, 1515, 1520, 1525, 1536, 1544, 1593, 1609, 1617, 1650, 1664, 1668, 1677, 71, 59, 1, 330, 72, 5, 208, 1, 59, 1476, 1, 208, 99, 117, 116, 101, 5, 201, 1, 59, 1487, 1, 201, 4, 3, 97, 105, 121, 1497, 1503, 1512, 114, 111, 110, 59, 1, 282, 114, 99, 5, 202, 1, 59, 1510, 1, 202, 59, 1, 1069, 111, 116, 59, 1, 278, 114, 59, 3, 55349, 56584, 114, 97, 118, 101, 5, 200, 1, 59, 1534, 1, 200, 101, 109, 101, 110, 116, 59, 1, 8712, 4, 2, 97, 112, 1550, 1555, 99, 114, 59, 1, 274, 116, 121, 4, 2, 83, 86, 1563, 1576, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9723, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9643, 4, 2, 103, 112, 1599, 1604, 111, 110, 59, 1, 280, 102, 59, 3, 55349, 56636, 115, 105, 108, 111, 110, 59, 1, 917, 117, 4, 2, 97, 105, 1624, 1640, 108, 4, 2, 59, 84, 1631, 1633, 1, 10869, 105, 108, 100, 101, 59, 1, 8770, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8652, 4, 2, 99, 105, 1656, 1660, 114, 59, 1, 8496, 109, 59, 1, 10867, 97, 59, 1, 919, 109, 108, 5, 203, 1, 59, 1675, 1, 203, 4, 2, 105, 112, 1683, 1689, 115, 116, 115, 59, 1, 8707, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 1, 8519, 4, 5, 99, 102, 105, 111, 115, 1713, 1717, 1722, 1762, 1791, 121, 59, 1, 1060, 114, 59, 3, 55349, 56585, 108, 108, 101, 100, 4, 2, 83, 86, 1732, 1745, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9724, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9642, 4, 3, 112, 114, 117, 1770, 1775, 1781, 102, 59, 3, 55349, 56637, 65, 108, 108, 59, 1, 8704, 114, 105, 101, 114, 116, 114, 102, 59, 1, 8497, 99, 114, 59, 1, 8497, 4, 12, 74, 84, 97, 98, 99, 100, 102, 103, 111, 114, 115, 116, 1822, 1827, 1834, 1848, 1855, 1877, 1882, 1887, 1890, 1896, 1978, 1984, 99, 121, 59, 1, 1027, 5, 62, 1, 59, 1832, 1, 62, 109, 109, 97, 4, 2, 59, 100, 1843, 1845, 1, 915, 59, 1, 988, 114, 101, 118, 101, 59, 1, 286, 4, 3, 101, 105, 121, 1863, 1869, 1874, 100, 105, 108, 59, 1, 290, 114, 99, 59, 1, 284, 59, 1, 1043, 111, 116, 59, 1, 288, 114, 59, 3, 55349, 56586, 59, 1, 8921, 112, 102, 59, 3, 55349, 56638, 101, 97, 116, 101, 114, 4, 6, 69, 70, 71, 76, 83, 84, 1915, 1933, 1944, 1953, 1959, 1971, 113, 117, 97, 108, 4, 2, 59, 76, 1925, 1927, 1, 8805, 101, 115, 115, 59, 1, 8923, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8807, 114, 101, 97, 116, 101, 114, 59, 1, 10914, 101, 115, 115, 59, 1, 8823, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10878, 105, 108, 100, 101, 59, 1, 8819, 99, 114, 59, 3, 55349, 56482, 59, 1, 8811, 4, 8, 65, 97, 99, 102, 105, 111, 115, 117, 2005, 2012, 2026, 2032, 2036, 2049, 2073, 2089, 82, 68, 99, 121, 59, 1, 1066, 4, 2, 99, 116, 2018, 2023, 101, 107, 59, 1, 711, 59, 1, 94, 105, 114, 99, 59, 1, 292, 114, 59, 1, 8460, 108, 98, 101, 114, 116, 83, 112, 97, 99, 101, 59, 1, 8459, 4, 2, 112, 114, 2055, 2059, 102, 59, 1, 8461, 105, 122, 111, 110, 116, 97, 108, 76, 105, 110, 101, 59, 1, 9472, 4, 2, 99, 116, 2079, 2083, 114, 59, 1, 8459, 114, 111, 107, 59, 1, 294, 109, 112, 4, 2, 68, 69, 2097, 2107, 111, 119, 110, 72, 117, 109, 112, 59, 1, 8782, 113, 117, 97, 108, 59, 1, 8783, 4, 14, 69, 74, 79, 97, 99, 100, 102, 103, 109, 110, 111, 115, 116, 117, 2144, 2149, 2155, 2160, 2171, 2189, 2194, 2198, 2209, 2245, 2307, 2329, 2334, 2341, 99, 121, 59, 1, 1045, 108, 105, 103, 59, 1, 306, 99, 121, 59, 1, 1025, 99, 117, 116, 101, 5, 205, 1, 59, 2169, 1, 205, 4, 2, 105, 121, 2177, 2186, 114, 99, 5, 206, 1, 59, 2184, 1, 206, 59, 1, 1048, 111, 116, 59, 1, 304, 114, 59, 1, 8465, 114, 97, 118, 101, 5, 204, 1, 59, 2207, 1, 204, 4, 3, 59, 97, 112, 2217, 2219, 2238, 1, 8465, 4, 2, 99, 103, 2225, 2229, 114, 59, 1, 298, 105, 110, 97, 114, 121, 73, 59, 1, 8520, 108, 105, 101, 115, 59, 1, 8658, 4, 2, 116, 118, 2251, 2281, 4, 2, 59, 101, 2257, 2259, 1, 8748, 4, 2, 103, 114, 2265, 2271, 114, 97, 108, 59, 1, 8747, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8898, 105, 115, 105, 98, 108, 101, 4, 2, 67, 84, 2293, 2300, 111, 109, 109, 97, 59, 1, 8291, 105, 109, 101, 115, 59, 1, 8290, 4, 3, 103, 112, 116, 2315, 2320, 2325, 111, 110, 59, 1, 302, 102, 59, 3, 55349, 56640, 97, 59, 1, 921, 99, 114, 59, 1, 8464, 105, 108, 100, 101, 59, 1, 296, 4, 2, 107, 109, 2347, 2352, 99, 121, 59, 1, 1030, 108, 5, 207, 1, 59, 2358, 1, 207, 4, 5, 99, 102, 111, 115, 117, 2372, 2386, 2391, 2397, 2414, 4, 2, 105, 121, 2378, 2383, 114, 99, 59, 1, 308, 59, 1, 1049, 114, 59, 3, 55349, 56589, 112, 102, 59, 3, 55349, 56641, 4, 2, 99, 101, 2403, 2408, 114, 59, 3, 55349, 56485, 114, 99, 121, 59, 1, 1032, 107, 99, 121, 59, 1, 1028, 4, 7, 72, 74, 97, 99, 102, 111, 115, 2436, 2441, 2446, 2452, 2467, 2472, 2478, 99, 121, 59, 1, 1061, 99, 121, 59, 1, 1036, 112, 112, 97, 59, 1, 922, 4, 2, 101, 121, 2458, 2464, 100, 105, 108, 59, 1, 310, 59, 1, 1050, 114, 59, 3, 55349, 56590, 112, 102, 59, 3, 55349, 56642, 99, 114, 59, 3, 55349, 56486, 4, 11, 74, 84, 97, 99, 101, 102, 108, 109, 111, 115, 116, 2508, 2513, 2520, 2562, 2585, 2981, 2986, 3004, 3011, 3146, 3167, 99, 121, 59, 1, 1033, 5, 60, 1, 59, 2518, 1, 60, 4, 5, 99, 109, 110, 112, 114, 2532, 2538, 2544, 2548, 2558, 117, 116, 101, 59, 1, 313, 98, 100, 97, 59, 1, 923, 103, 59, 1, 10218, 108, 97, 99, 101, 116, 114, 102, 59, 1, 8466, 114, 59, 1, 8606, 4, 3, 97, 101, 121, 2570, 2576, 2582, 114, 111, 110, 59, 1, 317, 100, 105, 108, 59, 1, 315, 59, 1, 1051, 4, 2, 102, 115, 2591, 2907, 116, 4, 10, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114, 2614, 2663, 2672, 2728, 2735, 2760, 2820, 2870, 2888, 2895, 4, 2, 110, 114, 2620, 2633, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10216, 114, 111, 119, 4, 3, 59, 66, 82, 2644, 2646, 2651, 1, 8592, 97, 114, 59, 1, 8676, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8646, 101, 105, 108, 105, 110, 103, 59, 1, 8968, 111, 4, 2, 117, 119, 2679, 2692, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10214, 110, 4, 2, 84, 86, 2699, 2710, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10593, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2721, 2723, 1, 8643, 97, 114, 59, 1, 10585, 108, 111, 111, 114, 59, 1, 8970, 105, 103, 104, 116, 4, 2, 65, 86, 2745, 2752, 114, 114, 111, 119, 59, 1, 8596, 101, 99, 116, 111, 114, 59, 1, 10574, 4, 2, 101, 114, 2766, 2792, 101, 4, 3, 59, 65, 86, 2775, 2777, 2784, 1, 8867, 114, 114, 111, 119, 59, 1, 8612, 101, 99, 116, 111, 114, 59, 1, 10586, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 2806, 2808, 2813, 1, 8882, 97, 114, 59, 1, 10703, 113, 117, 97, 108, 59, 1, 8884, 112, 4, 3, 68, 84, 86, 2829, 2841, 2852, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10577, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10592, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2863, 2865, 1, 8639, 97, 114, 59, 1, 10584, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2881, 2883, 1, 8636, 97, 114, 59, 1, 10578, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8660, 115, 4, 6, 69, 70, 71, 76, 83, 84, 2922, 2936, 2947, 2956, 2962, 2974, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8922, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8806, 114, 101, 97, 116, 101, 114, 59, 1, 8822, 101, 115, 115, 59, 1, 10913, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10877, 105, 108, 100, 101, 59, 1, 8818, 114, 59, 3, 55349, 56591, 4, 2, 59, 101, 2992, 2994, 1, 8920, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8666, 105, 100, 111, 116, 59, 1, 319, 4, 3, 110, 112, 119, 3019, 3110, 3115, 103, 4, 4, 76, 82, 108, 114, 3030, 3058, 3070, 3098, 101, 102, 116, 4, 2, 65, 82, 3039, 3046, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10231, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10230, 101, 102, 116, 4, 2, 97, 114, 3079, 3086, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10233, 102, 59, 3, 55349, 56643, 101, 114, 4, 2, 76, 82, 3123, 3134, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8601, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8600, 4, 3, 99, 104, 116, 3154, 3158, 3161, 114, 59, 1, 8466, 59, 1, 8624, 114, 111, 107, 59, 1, 321, 59, 1, 8810, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 3188, 3192, 3196, 3222, 3227, 3237, 3243, 3248, 112, 59, 1, 10501, 121, 59, 1, 1052, 4, 2, 100, 108, 3202, 3213, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8287, 108, 105, 110, 116, 114, 102, 59, 1, 8499, 114, 59, 3, 55349, 56592, 110, 117, 115, 80, 108, 117, 115, 59, 1, 8723, 112, 102, 59, 3, 55349, 56644, 99, 114, 59, 1, 8499, 59, 1, 924, 4, 9, 74, 97, 99, 101, 102, 111, 115, 116, 117, 3271, 3276, 3283, 3306, 3422, 3427, 4120, 4126, 4137, 99, 121, 59, 1, 1034, 99, 117, 116, 101, 59, 1, 323, 4, 3, 97, 101, 121, 3291, 3297, 3303, 114, 111, 110, 59, 1, 327, 100, 105, 108, 59, 1, 325, 59, 1, 1053, 4, 3, 103, 115, 119, 3314, 3380, 3415, 97, 116, 105, 118, 101, 4, 3, 77, 84, 86, 3327, 3340, 3365, 101, 100, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8203, 104, 105, 4, 2, 99, 110, 3348, 3357, 107, 83, 112, 97, 99, 101, 59, 1, 8203, 83, 112, 97, 99, 101, 59, 1, 8203, 101, 114, 121, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8203, 116, 101, 100, 4, 2, 71, 76, 3389, 3405, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8811, 101, 115, 115, 76, 101, 115, 115, 59, 1, 8810, 76, 105, 110, 101, 59, 1, 10, 114, 59, 3, 55349, 56593, 4, 4, 66, 110, 112, 116, 3437, 3444, 3460, 3464, 114, 101, 97, 107, 59, 1, 8288, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97, 99, 101, 59, 1, 160, 102, 59, 1, 8469, 4, 13, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84, 86, 3492, 3494, 3517, 3536, 3578, 3657, 3685, 3784, 3823, 3860, 3915, 4066, 4107, 1, 10988, 4, 2, 111, 117, 3500, 3510, 110, 103, 114, 117, 101, 110, 116, 59, 1, 8802, 112, 67, 97, 112, 59, 1, 8813, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8742, 4, 3, 108, 113, 120, 3544, 3552, 3571, 101, 109, 101, 110, 116, 59, 1, 8713, 117, 97, 108, 4, 2, 59, 84, 3561, 3563, 1, 8800, 105, 108, 100, 101, 59, 3, 8770, 824, 105, 115, 116, 115, 59, 1, 8708, 114, 101, 97, 116, 101, 114, 4, 7, 59, 69, 70, 71, 76, 83, 84, 3600, 3602, 3609, 3621, 3631, 3637, 3650, 1, 8815, 113, 117, 97, 108, 59, 1, 8817, 117, 108, 108, 69, 113, 117, 97, 108, 59, 3, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 3, 8811, 824, 101, 115, 115, 59, 1, 8825, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10878, 824, 105, 108, 100, 101, 59, 1, 8821, 117, 109, 112, 4, 2, 68, 69, 3666, 3677, 111, 119, 110, 72, 117, 109, 112, 59, 3, 8782, 824, 113, 117, 97, 108, 59, 3, 8783, 824, 101, 4, 2, 102, 115, 3692, 3724, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3709, 3711, 3717, 1, 8938, 97, 114, 59, 3, 10703, 824, 113, 117, 97, 108, 59, 1, 8940, 115, 4, 6, 59, 69, 71, 76, 83, 84, 3739, 3741, 3748, 3757, 3764, 3777, 1, 8814, 113, 117, 97, 108, 59, 1, 8816, 114, 101, 97, 116, 101, 114, 59, 1, 8824, 101, 115, 115, 59, 3, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10877, 824, 105, 108, 100, 101, 59, 1, 8820, 101, 115, 116, 101, 100, 4, 2, 71, 76, 3795, 3812, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 3, 10914, 824, 101, 115, 115, 76, 101, 115, 115, 59, 3, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 4, 3, 59, 69, 83, 3838, 3840, 3848, 1, 8832, 113, 117, 97, 108, 59, 3, 10927, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8928, 4, 2, 101, 105, 3866, 3881, 118, 101, 114, 115, 101, 69, 108, 101, 109, 101, 110, 116, 59, 1, 8716, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3900, 3902, 3908, 1, 8939, 97, 114, 59, 3, 10704, 824, 113, 117, 97, 108, 59, 1, 8941, 4, 2, 113, 117, 3921, 3973, 117, 97, 114, 101, 83, 117, 4, 2, 98, 112, 3933, 3952, 115, 101, 116, 4, 2, 59, 69, 3942, 3945, 3, 8847, 824, 113, 117, 97, 108, 59, 1, 8930, 101, 114, 115, 101, 116, 4, 2, 59, 69, 3963, 3966, 3, 8848, 824, 113, 117, 97, 108, 59, 1, 8931, 4, 3, 98, 99, 112, 3981, 4e3, 4045, 115, 101, 116, 4, 2, 59, 69, 3990, 3993, 3, 8834, 8402, 113, 117, 97, 108, 59, 1, 8840, 99, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 4015, 4017, 4025, 4037, 1, 8833, 113, 117, 97, 108, 59, 3, 10928, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8929, 105, 108, 100, 101, 59, 3, 8831, 824, 101, 114, 115, 101, 116, 4, 2, 59, 69, 4056, 4059, 3, 8835, 8402, 113, 117, 97, 108, 59, 1, 8841, 105, 108, 100, 101, 4, 4, 59, 69, 70, 84, 4080, 4082, 4089, 4100, 1, 8769, 113, 117, 97, 108, 59, 1, 8772, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8775, 105, 108, 100, 101, 59, 1, 8777, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8740, 99, 114, 59, 3, 55349, 56489, 105, 108, 100, 101, 5, 209, 1, 59, 4135, 1, 209, 59, 1, 925, 4, 14, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114, 115, 116, 117, 118, 4170, 4176, 4187, 4205, 4212, 4217, 4228, 4253, 4259, 4292, 4295, 4316, 4337, 4346, 108, 105, 103, 59, 1, 338, 99, 117, 116, 101, 5, 211, 1, 59, 4185, 1, 211, 4, 2, 105, 121, 4193, 4202, 114, 99, 5, 212, 1, 59, 4200, 1, 212, 59, 1, 1054, 98, 108, 97, 99, 59, 1, 336, 114, 59, 3, 55349, 56594, 114, 97, 118, 101, 5, 210, 1, 59, 4226, 1, 210, 4, 3, 97, 101, 105, 4236, 4241, 4246, 99, 114, 59, 1, 332, 103, 97, 59, 1, 937, 99, 114, 111, 110, 59, 1, 927, 112, 102, 59, 3, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 4, 2, 68, 81, 4272, 4285, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8220, 117, 111, 116, 101, 59, 1, 8216, 59, 1, 10836, 4, 2, 99, 108, 4301, 4306, 114, 59, 3, 55349, 56490, 97, 115, 104, 5, 216, 1, 59, 4314, 1, 216, 105, 4, 2, 108, 109, 4323, 4332, 100, 101, 5, 213, 1, 59, 4330, 1, 213, 101, 115, 59, 1, 10807, 109, 108, 5, 214, 1, 59, 4344, 1, 214, 101, 114, 4, 2, 66, 80, 4354, 4380, 4, 2, 97, 114, 4360, 4364, 114, 59, 1, 8254, 97, 99, 4, 2, 101, 107, 4372, 4375, 59, 1, 9182, 101, 116, 59, 1, 9140, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9180, 4, 9, 97, 99, 102, 104, 105, 108, 111, 114, 115, 4413, 4422, 4426, 4431, 4435, 4438, 4448, 4471, 4561, 114, 116, 105, 97, 108, 68, 59, 1, 8706, 121, 59, 1, 1055, 114, 59, 3, 55349, 56595, 105, 59, 1, 934, 59, 1, 928, 117, 115, 77, 105, 110, 117, 115, 59, 1, 177, 4, 2, 105, 112, 4454, 4467, 110, 99, 97, 114, 101, 112, 108, 97, 110, 101, 59, 1, 8460, 102, 59, 1, 8473, 4, 4, 59, 101, 105, 111, 4481, 4483, 4526, 4531, 1, 10939, 99, 101, 100, 101, 115, 4, 4, 59, 69, 83, 84, 4498, 4500, 4507, 4519, 1, 8826, 113, 117, 97, 108, 59, 1, 10927, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8828, 105, 108, 100, 101, 59, 1, 8830, 109, 101, 59, 1, 8243, 4, 2, 100, 112, 4537, 4543, 117, 99, 116, 59, 1, 8719, 111, 114, 116, 105, 111, 110, 4, 2, 59, 97, 4555, 4557, 1, 8759, 108, 59, 1, 8733, 4, 2, 99, 105, 4567, 4572, 114, 59, 3, 55349, 56491, 59, 1, 936, 4, 4, 85, 102, 111, 115, 4585, 4594, 4599, 4604, 79, 84, 5, 34, 1, 59, 4592, 1, 34, 114, 59, 3, 55349, 56596, 112, 102, 59, 1, 8474, 99, 114, 59, 3, 55349, 56492, 4, 12, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117, 4636, 4642, 4650, 4681, 4704, 4763, 4767, 4771, 5047, 5069, 5081, 5094, 97, 114, 114, 59, 1, 10512, 71, 5, 174, 1, 59, 4648, 1, 174, 4, 3, 99, 110, 114, 4658, 4664, 4668, 117, 116, 101, 59, 1, 340, 103, 59, 1, 10219, 114, 4, 2, 59, 116, 4675, 4677, 1, 8608, 108, 59, 1, 10518, 4, 3, 97, 101, 121, 4689, 4695, 4701, 114, 111, 110, 59, 1, 344, 100, 105, 108, 59, 1, 342, 59, 1, 1056, 4, 2, 59, 118, 4710, 4712, 1, 8476, 101, 114, 115, 101, 4, 2, 69, 85, 4722, 4748, 4, 2, 108, 113, 4728, 4736, 101, 109, 101, 110, 116, 59, 1, 8715, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8651, 112, 69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10607, 114, 59, 1, 8476, 111, 59, 1, 929, 103, 104, 116, 4, 8, 65, 67, 68, 70, 84, 85, 86, 97, 4792, 4840, 4849, 4905, 4912, 4972, 5022, 5040, 4, 2, 110, 114, 4798, 4811, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10217, 114, 111, 119, 4, 3, 59, 66, 76, 4822, 4824, 4829, 1, 8594, 97, 114, 59, 1, 8677, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8644, 101, 105, 108, 105, 110, 103, 59, 1, 8969, 111, 4, 2, 117, 119, 4856, 4869, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10215, 110, 4, 2, 84, 86, 4876, 4887, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10589, 101, 99, 116, 111, 114, 4, 2, 59, 66, 4898, 4900, 1, 8642, 97, 114, 59, 1, 10581, 108, 111, 111, 114, 59, 1, 8971, 4, 2, 101, 114, 4918, 4944, 101, 4, 3, 59, 65, 86, 4927, 4929, 4936, 1, 8866, 114, 114, 111, 119, 59, 1, 8614, 101, 99, 116, 111, 114, 59, 1, 10587, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 4958, 4960, 4965, 1, 8883, 97, 114, 59, 1, 10704, 113, 117, 97, 108, 59, 1, 8885, 112, 4, 3, 68, 84, 86, 4981, 4993, 5004, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10575, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10588, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5015, 5017, 1, 8638, 97, 114, 59, 1, 10580, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5033, 5035, 1, 8640, 97, 114, 59, 1, 10579, 114, 114, 111, 119, 59, 1, 8658, 4, 2, 112, 117, 5053, 5057, 102, 59, 1, 8477, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 1, 10608, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8667, 4, 2, 99, 104, 5087, 5091, 114, 59, 1, 8475, 59, 1, 8625, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 1, 10740, 4, 13, 72, 79, 97, 99, 102, 104, 105, 109, 111, 113, 115, 116, 117, 5134, 5150, 5157, 5164, 5198, 5203, 5259, 5265, 5277, 5283, 5374, 5380, 5385, 4, 2, 67, 99, 5140, 5146, 72, 99, 121, 59, 1, 1065, 121, 59, 1, 1064, 70, 84, 99, 121, 59, 1, 1068, 99, 117, 116, 101, 59, 1, 346, 4, 5, 59, 97, 101, 105, 121, 5176, 5178, 5184, 5190, 5195, 1, 10940, 114, 111, 110, 59, 1, 352, 100, 105, 108, 59, 1, 350, 114, 99, 59, 1, 348, 59, 1, 1057, 114, 59, 3, 55349, 56598, 111, 114, 116, 4, 4, 68, 76, 82, 85, 5216, 5227, 5238, 5250, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8595, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8592, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8594, 112, 65, 114, 114, 111, 119, 59, 1, 8593, 103, 109, 97, 59, 1, 931, 97, 108, 108, 67, 105, 114, 99, 108, 101, 59, 1, 8728, 112, 102, 59, 3, 55349, 56650, 4, 2, 114, 117, 5289, 5293, 116, 59, 1, 8730, 97, 114, 101, 4, 4, 59, 73, 83, 85, 5306, 5308, 5322, 5367, 1, 9633, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8851, 117, 4, 2, 98, 112, 5329, 5347, 115, 101, 116, 4, 2, 59, 69, 5338, 5340, 1, 8847, 113, 117, 97, 108, 59, 1, 8849, 101, 114, 115, 101, 116, 4, 2, 59, 69, 5358, 5360, 1, 8848, 113, 117, 97, 108, 59, 1, 8850, 110, 105, 111, 110, 59, 1, 8852, 99, 114, 59, 3, 55349, 56494, 97, 114, 59, 1, 8902, 4, 4, 98, 99, 109, 112, 5395, 5420, 5475, 5478, 4, 2, 59, 115, 5401, 5403, 1, 8912, 101, 116, 4, 2, 59, 69, 5411, 5413, 1, 8912, 113, 117, 97, 108, 59, 1, 8838, 4, 2, 99, 104, 5426, 5468, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 5440, 5442, 5449, 5461, 1, 8827, 113, 117, 97, 108, 59, 1, 10928, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8829, 105, 108, 100, 101, 59, 1, 8831, 84, 104, 97, 116, 59, 1, 8715, 59, 1, 8721, 4, 3, 59, 101, 115, 5486, 5488, 5507, 1, 8913, 114, 115, 101, 116, 4, 2, 59, 69, 5498, 5500, 1, 8835, 113, 117, 97, 108, 59, 1, 8839, 101, 116, 59, 1, 8913, 4, 11, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115, 5536, 5546, 5552, 5567, 5579, 5602, 5607, 5655, 5695, 5701, 5711, 79, 82, 78, 5, 222, 1, 59, 5544, 1, 222, 65, 68, 69, 59, 1, 8482, 4, 2, 72, 99, 5558, 5563, 99, 121, 59, 1, 1035, 121, 59, 1, 1062, 4, 2, 98, 117, 5573, 5576, 59, 1, 9, 59, 1, 932, 4, 3, 97, 101, 121, 5587, 5593, 5599, 114, 111, 110, 59, 1, 356, 100, 105, 108, 59, 1, 354, 59, 1, 1058, 114, 59, 3, 55349, 56599, 4, 2, 101, 105, 5613, 5631, 4, 2, 114, 116, 5619, 5627, 101, 102, 111, 114, 101, 59, 1, 8756, 97, 59, 1, 920, 4, 2, 99, 110, 5637, 5647, 107, 83, 112, 97, 99, 101, 59, 3, 8287, 8202, 83, 112, 97, 99, 101, 59, 1, 8201, 108, 100, 101, 4, 4, 59, 69, 70, 84, 5668, 5670, 5677, 5688, 1, 8764, 113, 117, 97, 108, 59, 1, 8771, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8773, 105, 108, 100, 101, 59, 1, 8776, 112, 102, 59, 3, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 1, 8411, 4, 2, 99, 116, 5717, 5722, 114, 59, 3, 55349, 56495, 114, 111, 107, 59, 1, 358, 4, 14, 97, 98, 99, 100, 102, 103, 109, 110, 111, 112, 114, 115, 116, 117, 5758, 5789, 5805, 5823, 5830, 5835, 5846, 5852, 5921, 5937, 6089, 6095, 6101, 6108, 4, 2, 99, 114, 5764, 5774, 117, 116, 101, 5, 218, 1, 59, 5772, 1, 218, 114, 4, 2, 59, 111, 5781, 5783, 1, 8607, 99, 105, 114, 59, 1, 10569, 114, 4, 2, 99, 101, 5796, 5800, 121, 59, 1, 1038, 118, 101, 59, 1, 364, 4, 2, 105, 121, 5811, 5820, 114, 99, 5, 219, 1, 59, 5818, 1, 219, 59, 1, 1059, 98, 108, 97, 99, 59, 1, 368, 114, 59, 3, 55349, 56600, 114, 97, 118, 101, 5, 217, 1, 59, 5844, 1, 217, 97, 99, 114, 59, 1, 362, 4, 2, 100, 105, 5858, 5905, 101, 114, 4, 2, 66, 80, 5866, 5892, 4, 2, 97, 114, 5872, 5876, 114, 59, 1, 95, 97, 99, 4, 2, 101, 107, 5884, 5887, 59, 1, 9183, 101, 116, 59, 1, 9141, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9181, 111, 110, 4, 2, 59, 80, 5913, 5915, 1, 8899, 108, 117, 115, 59, 1, 8846, 4, 2, 103, 112, 5927, 5932, 111, 110, 59, 1, 370, 102, 59, 3, 55349, 56652, 4, 8, 65, 68, 69, 84, 97, 100, 112, 115, 5955, 5985, 5996, 6009, 6026, 6033, 6044, 6075, 114, 114, 111, 119, 4, 3, 59, 66, 68, 5967, 5969, 5974, 1, 8593, 97, 114, 59, 1, 10514, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8645, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8597, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10606, 101, 101, 4, 2, 59, 65, 6017, 6019, 1, 8869, 114, 114, 111, 119, 59, 1, 8613, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 4, 2, 76, 82, 6052, 6063, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8598, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8599, 105, 4, 2, 59, 108, 6082, 6084, 1, 978, 111, 110, 59, 1, 933, 105, 110, 103, 59, 1, 366, 99, 114, 59, 3, 55349, 56496, 105, 108, 100, 101, 59, 1, 360, 109, 108, 5, 220, 1, 59, 6115, 1, 220, 4, 9, 68, 98, 99, 100, 101, 102, 111, 115, 118, 6137, 6143, 6148, 6152, 6166, 6250, 6255, 6261, 6267, 97, 115, 104, 59, 1, 8875, 97, 114, 59, 1, 10987, 121, 59, 1, 1042, 97, 115, 104, 4, 2, 59, 108, 6161, 6163, 1, 8873, 59, 1, 10982, 4, 2, 101, 114, 6172, 6175, 59, 1, 8897, 4, 3, 98, 116, 121, 6183, 6188, 6238, 97, 114, 59, 1, 8214, 4, 2, 59, 105, 6194, 6196, 1, 8214, 99, 97, 108, 4, 4, 66, 76, 83, 84, 6209, 6214, 6220, 6231, 97, 114, 59, 1, 8739, 105, 110, 101, 59, 1, 124, 101, 112, 97, 114, 97, 116, 111, 114, 59, 1, 10072, 105, 108, 100, 101, 59, 1, 8768, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8202, 114, 59, 3, 55349, 56601, 112, 102, 59, 3, 55349, 56653, 99, 114, 59, 3, 55349, 56497, 100, 97, 115, 104, 59, 1, 8874, 4, 5, 99, 101, 102, 111, 115, 6286, 6292, 6298, 6303, 6309, 105, 114, 99, 59, 1, 372, 100, 103, 101, 59, 1, 8896, 114, 59, 3, 55349, 56602, 112, 102, 59, 3, 55349, 56654, 99, 114, 59, 3, 55349, 56498, 4, 4, 102, 105, 111, 115, 6325, 6330, 6333, 6339, 114, 59, 3, 55349, 56603, 59, 1, 926, 112, 102, 59, 3, 55349, 56655, 99, 114, 59, 3, 55349, 56499, 4, 9, 65, 73, 85, 97, 99, 102, 111, 115, 117, 6365, 6370, 6375, 6380, 6391, 6405, 6410, 6416, 6422, 99, 121, 59, 1, 1071, 99, 121, 59, 1, 1031, 99, 121, 59, 1, 1070, 99, 117, 116, 101, 5, 221, 1, 59, 6389, 1, 221, 4, 2, 105, 121, 6397, 6402, 114, 99, 59, 1, 374, 59, 1, 1067, 114, 59, 3, 55349, 56604, 112, 102, 59, 3, 55349, 56656, 99, 114, 59, 3, 55349, 56500, 109, 108, 59, 1, 376, 4, 8, 72, 97, 99, 100, 101, 102, 111, 115, 6445, 6450, 6457, 6472, 6477, 6501, 6505, 6510, 99, 121, 59, 1, 1046, 99, 117, 116, 101, 59, 1, 377, 4, 2, 97, 121, 6463, 6469, 114, 111, 110, 59, 1, 381, 59, 1, 1047, 111, 116, 59, 1, 379, 4, 2, 114, 116, 6483, 6497, 111, 87, 105, 100, 116, 104, 83, 112, 97, 99, 101, 59, 1, 8203, 97, 59, 1, 918, 114, 59, 1, 8488, 112, 102, 59, 1, 8484, 99, 114, 59, 3, 55349, 56501, 4, 16, 97, 98, 99, 101, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 119, 6550, 6561, 6568, 6612, 6622, 6634, 6645, 6672, 6699, 6854, 6870, 6923, 6933, 6963, 6974, 6983, 99, 117, 116, 101, 5, 225, 1, 59, 6559, 1, 225, 114, 101, 118, 101, 59, 1, 259, 4, 6, 59, 69, 100, 105, 117, 121, 6582, 6584, 6588, 6591, 6600, 6609, 1, 8766, 59, 3, 8766, 819, 59, 1, 8767, 114, 99, 5, 226, 1, 59, 6598, 1, 226, 116, 101, 5, 180, 1, 59, 6607, 1, 180, 59, 1, 1072, 108, 105, 103, 5, 230, 1, 59, 6620, 1, 230, 4, 2, 59, 114, 6628, 6630, 1, 8289, 59, 3, 55349, 56606, 114, 97, 118, 101, 5, 224, 1, 59, 6643, 1, 224, 4, 2, 101, 112, 6651, 6667, 4, 2, 102, 112, 6657, 6663, 115, 121, 109, 59, 1, 8501, 104, 59, 1, 8501, 104, 97, 59, 1, 945, 4, 2, 97, 112, 6678, 6692, 4, 2, 99, 108, 6684, 6688, 114, 59, 1, 257, 103, 59, 1, 10815, 5, 38, 1, 59, 6697, 1, 38, 4, 2, 100, 103, 6705, 6737, 4, 5, 59, 97, 100, 115, 118, 6717, 6719, 6724, 6727, 6734, 1, 8743, 110, 100, 59, 1, 10837, 59, 1, 10844, 108, 111, 112, 101, 59, 1, 10840, 59, 1, 10842, 4, 7, 59, 101, 108, 109, 114, 115, 122, 6753, 6755, 6758, 6762, 6814, 6835, 6848, 1, 8736, 59, 1, 10660, 101, 59, 1, 8736, 115, 100, 4, 2, 59, 97, 6770, 6772, 1, 8737, 4, 8, 97, 98, 99, 100, 101, 102, 103, 104, 6790, 6793, 6796, 6799, 6802, 6805, 6808, 6811, 59, 1, 10664, 59, 1, 10665, 59, 1, 10666, 59, 1, 10667, 59, 1, 10668, 59, 1, 10669, 59, 1, 10670, 59, 1, 10671, 116, 4, 2, 59, 118, 6821, 6823, 1, 8735, 98, 4, 2, 59, 100, 6830, 6832, 1, 8894, 59, 1, 10653, 4, 2, 112, 116, 6841, 6845, 104, 59, 1, 8738, 59, 1, 197, 97, 114, 114, 59, 1, 9084, 4, 2, 103, 112, 6860, 6865, 111, 110, 59, 1, 261, 102, 59, 3, 55349, 56658, 4, 7, 59, 69, 97, 101, 105, 111, 112, 6886, 6888, 6891, 6897, 6900, 6904, 6908, 1, 8776, 59, 1, 10864, 99, 105, 114, 59, 1, 10863, 59, 1, 8778, 100, 59, 1, 8779, 115, 59, 1, 39, 114, 111, 120, 4, 2, 59, 101, 6917, 6919, 1, 8776, 113, 59, 1, 8778, 105, 110, 103, 5, 229, 1, 59, 6931, 1, 229, 4, 3, 99, 116, 121, 6941, 6946, 6949, 114, 59, 3, 55349, 56502, 59, 1, 42, 109, 112, 4, 2, 59, 101, 6957, 6959, 1, 8776, 113, 59, 1, 8781, 105, 108, 100, 101, 5, 227, 1, 59, 6972, 1, 227, 109, 108, 5, 228, 1, 59, 6981, 1, 228, 4, 2, 99, 105, 6989, 6997, 111, 110, 105, 110, 116, 59, 1, 8755, 110, 116, 59, 1, 10769, 4, 16, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112, 114, 115, 117, 7036, 7041, 7119, 7135, 7149, 7155, 7219, 7224, 7347, 7354, 7463, 7489, 7786, 7793, 7814, 7866, 111, 116, 59, 1, 10989, 4, 2, 99, 114, 7047, 7094, 107, 4, 4, 99, 101, 112, 115, 7058, 7064, 7073, 7080, 111, 110, 103, 59, 1, 8780, 112, 115, 105, 108, 111, 110, 59, 1, 1014, 114, 105, 109, 101, 59, 1, 8245, 105, 109, 4, 2, 59, 101, 7088, 7090, 1, 8765, 113, 59, 1, 8909, 4, 2, 118, 119, 7100, 7105, 101, 101, 59, 1, 8893, 101, 100, 4, 2, 59, 103, 7113, 7115, 1, 8965, 101, 59, 1, 8965, 114, 107, 4, 2, 59, 116, 7127, 7129, 1, 9141, 98, 114, 107, 59, 1, 9142, 4, 2, 111, 121, 7141, 7146, 110, 103, 59, 1, 8780, 59, 1, 1073, 113, 117, 111, 59, 1, 8222, 4, 5, 99, 109, 112, 114, 116, 7167, 7181, 7188, 7193, 7199, 97, 117, 115, 4, 2, 59, 101, 7176, 7178, 1, 8757, 59, 1, 8757, 112, 116, 121, 118, 59, 1, 10672, 115, 105, 59, 1, 1014, 110, 111, 117, 59, 1, 8492, 4, 3, 97, 104, 119, 7207, 7210, 7213, 59, 1, 946, 59, 1, 8502, 101, 101, 110, 59, 1, 8812, 114, 59, 3, 55349, 56607, 103, 4, 7, 99, 111, 115, 116, 117, 118, 119, 7241, 7262, 7288, 7305, 7328, 7335, 7340, 4, 3, 97, 105, 117, 7249, 7253, 7258, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 4, 3, 100, 112, 116, 7270, 7275, 7281, 111, 116, 59, 1, 10752, 108, 117, 115, 59, 1, 10753, 105, 109, 101, 115, 59, 1, 10754, 4, 2, 113, 116, 7294, 7300, 99, 117, 112, 59, 1, 10758, 97, 114, 59, 1, 9733, 114, 105, 97, 110, 103, 108, 101, 4, 2, 100, 117, 7318, 7324, 111, 119, 110, 59, 1, 9661, 112, 59, 1, 9651, 112, 108, 117, 115, 59, 1, 10756, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 97, 114, 111, 119, 59, 1, 10509, 4, 3, 97, 107, 111, 7362, 7436, 7458, 4, 2, 99, 110, 7368, 7432, 107, 4, 3, 108, 115, 116, 7377, 7386, 7394, 111, 122, 101, 110, 103, 101, 59, 1, 10731, 113, 117, 97, 114, 101, 59, 1, 9642, 114, 105, 97, 110, 103, 108, 101, 4, 4, 59, 100, 108, 114, 7411, 7413, 7419, 7425, 1, 9652, 111, 119, 110, 59, 1, 9662, 101, 102, 116, 59, 1, 9666, 105, 103, 104, 116, 59, 1, 9656, 107, 59, 1, 9251, 4, 2, 49, 51, 7442, 7454, 4, 2, 50, 52, 7448, 7451, 59, 1, 9618, 59, 1, 9617, 52, 59, 1, 9619, 99, 107, 59, 1, 9608, 4, 2, 101, 111, 7469, 7485, 4, 2, 59, 113, 7475, 7478, 3, 61, 8421, 117, 105, 118, 59, 3, 8801, 8421, 116, 59, 1, 8976, 4, 4, 112, 116, 119, 120, 7499, 7504, 7517, 7523, 102, 59, 3, 55349, 56659, 4, 2, 59, 116, 7510, 7512, 1, 8869, 111, 109, 59, 1, 8869, 116, 105, 101, 59, 1, 8904, 4, 12, 68, 72, 85, 86, 98, 100, 104, 109, 112, 116, 117, 118, 7549, 7571, 7597, 7619, 7655, 7660, 7682, 7708, 7715, 7721, 7728, 7750, 4, 4, 76, 82, 108, 114, 7559, 7562, 7565, 7568, 59, 1, 9559, 59, 1, 9556, 59, 1, 9558, 59, 1, 9555, 4, 5, 59, 68, 85, 100, 117, 7583, 7585, 7588, 7591, 7594, 1, 9552, 59, 1, 9574, 59, 1, 9577, 59, 1, 9572, 59, 1, 9575, 4, 4, 76, 82, 108, 114, 7607, 7610, 7613, 7616, 59, 1, 9565, 59, 1, 9562, 59, 1, 9564, 59, 1, 9561, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7635, 7637, 7640, 7643, 7646, 7649, 7652, 1, 9553, 59, 1, 9580, 59, 1, 9571, 59, 1, 9568, 59, 1, 9579, 59, 1, 9570, 59, 1, 9567, 111, 120, 59, 1, 10697, 4, 4, 76, 82, 108, 114, 7670, 7673, 7676, 7679, 59, 1, 9557, 59, 1, 9554, 59, 1, 9488, 59, 1, 9484, 4, 5, 59, 68, 85, 100, 117, 7694, 7696, 7699, 7702, 7705, 1, 9472, 59, 1, 9573, 59, 1, 9576, 59, 1, 9516, 59, 1, 9524, 105, 110, 117, 115, 59, 1, 8863, 108, 117, 115, 59, 1, 8862, 105, 109, 101, 115, 59, 1, 8864, 4, 4, 76, 82, 108, 114, 7738, 7741, 7744, 7747, 59, 1, 9563, 59, 1, 9560, 59, 1, 9496, 59, 1, 9492, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7766, 7768, 7771, 7774, 7777, 7780, 7783, 1, 9474, 59, 1, 9578, 59, 1, 9569, 59, 1, 9566, 59, 1, 9532, 59, 1, 9508, 59, 1, 9500, 114, 105, 109, 101, 59, 1, 8245, 4, 2, 101, 118, 7799, 7804, 118, 101, 59, 1, 728, 98, 97, 114, 5, 166, 1, 59, 7812, 1, 166, 4, 4, 99, 101, 105, 111, 7824, 7829, 7834, 7846, 114, 59, 3, 55349, 56503, 109, 105, 59, 1, 8271, 109, 4, 2, 59, 101, 7841, 7843, 1, 8765, 59, 1, 8909, 108, 4, 3, 59, 98, 104, 7855, 7857, 7860, 1, 92, 59, 1, 10693, 115, 117, 98, 59, 1, 10184, 4, 2, 108, 109, 7872, 7885, 108, 4, 2, 59, 101, 7879, 7881, 1, 8226, 116, 59, 1, 8226, 112, 4, 3, 59, 69, 101, 7894, 7896, 7899, 1, 8782, 59, 1, 10926, 4, 2, 59, 113, 7905, 7907, 1, 8783, 59, 1, 8783, 4, 15, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 116, 117, 119, 121, 7942, 8021, 8075, 8080, 8121, 8126, 8157, 8279, 8295, 8430, 8446, 8485, 8491, 8707, 8726, 4, 3, 99, 112, 114, 7950, 7956, 8007, 117, 116, 101, 59, 1, 263, 4, 6, 59, 97, 98, 99, 100, 115, 7970, 7972, 7977, 7984, 7998, 8003, 1, 8745, 110, 100, 59, 1, 10820, 114, 99, 117, 112, 59, 1, 10825, 4, 2, 97, 117, 7990, 7994, 112, 59, 1, 10827, 112, 59, 1, 10823, 111, 116, 59, 1, 10816, 59, 3, 8745, 65024, 4, 2, 101, 111, 8013, 8017, 116, 59, 1, 8257, 110, 59, 1, 711, 4, 4, 97, 101, 105, 117, 8031, 8046, 8056, 8061, 4, 2, 112, 114, 8037, 8041, 115, 59, 1, 10829, 111, 110, 59, 1, 269, 100, 105, 108, 5, 231, 1, 59, 8054, 1, 231, 114, 99, 59, 1, 265, 112, 115, 4, 2, 59, 115, 8069, 8071, 1, 10828, 109, 59, 1, 10832, 111, 116, 59, 1, 267, 4, 3, 100, 109, 110, 8088, 8097, 8104, 105, 108, 5, 184, 1, 59, 8095, 1, 184, 112, 116, 121, 118, 59, 1, 10674, 116, 5, 162, 2, 59, 101, 8112, 8114, 1, 162, 114, 100, 111, 116, 59, 1, 183, 114, 59, 3, 55349, 56608, 4, 3, 99, 101, 105, 8134, 8138, 8154, 121, 59, 1, 1095, 99, 107, 4, 2, 59, 109, 8146, 8148, 1, 10003, 97, 114, 107, 59, 1, 10003, 59, 1, 967, 114, 4, 7, 59, 69, 99, 101, 102, 109, 115, 8174, 8176, 8179, 8258, 8261, 8268, 8273, 1, 9675, 59, 1, 10691, 4, 3, 59, 101, 108, 8187, 8189, 8193, 1, 710, 113, 59, 1, 8791, 101, 4, 2, 97, 100, 8200, 8223, 114, 114, 111, 119, 4, 2, 108, 114, 8210, 8216, 101, 102, 116, 59, 1, 8634, 105, 103, 104, 116, 59, 1, 8635, 4, 5, 82, 83, 97, 99, 100, 8235, 8238, 8241, 8246, 8252, 59, 1, 174, 59, 1, 9416, 115, 116, 59, 1, 8859, 105, 114, 99, 59, 1, 8858, 97, 115, 104, 59, 1, 8861, 59, 1, 8791, 110, 105, 110, 116, 59, 1, 10768, 105, 100, 59, 1, 10991, 99, 105, 114, 59, 1, 10690, 117, 98, 115, 4, 2, 59, 117, 8288, 8290, 1, 9827, 105, 116, 59, 1, 9827, 4, 4, 108, 109, 110, 112, 8305, 8326, 8376, 8400, 111, 110, 4, 2, 59, 101, 8313, 8315, 1, 58, 4, 2, 59, 113, 8321, 8323, 1, 8788, 59, 1, 8788, 4, 2, 109, 112, 8332, 8344, 97, 4, 2, 59, 116, 8339, 8341, 1, 44, 59, 1, 64, 4, 3, 59, 102, 108, 8352, 8354, 8358, 1, 8705, 110, 59, 1, 8728, 101, 4, 2, 109, 120, 8365, 8371, 101, 110, 116, 59, 1, 8705, 101, 115, 59, 1, 8450, 4, 2, 103, 105, 8382, 8395, 4, 2, 59, 100, 8388, 8390, 1, 8773, 111, 116, 59, 1, 10861, 110, 116, 59, 1, 8750, 4, 3, 102, 114, 121, 8408, 8412, 8417, 59, 3, 55349, 56660, 111, 100, 59, 1, 8720, 5, 169, 2, 59, 115, 8424, 8426, 1, 169, 114, 59, 1, 8471, 4, 2, 97, 111, 8436, 8441, 114, 114, 59, 1, 8629, 115, 115, 59, 1, 10007, 4, 2, 99, 117, 8452, 8457, 114, 59, 3, 55349, 56504, 4, 2, 98, 112, 8463, 8474, 4, 2, 59, 101, 8469, 8471, 1, 10959, 59, 1, 10961, 4, 2, 59, 101, 8480, 8482, 1, 10960, 59, 1, 10962, 100, 111, 116, 59, 1, 8943, 4, 7, 100, 101, 108, 112, 114, 118, 119, 8507, 8522, 8536, 8550, 8600, 8697, 8702, 97, 114, 114, 4, 2, 108, 114, 8516, 8519, 59, 1, 10552, 59, 1, 10549, 4, 2, 112, 115, 8528, 8532, 114, 59, 1, 8926, 99, 59, 1, 8927, 97, 114, 114, 4, 2, 59, 112, 8545, 8547, 1, 8630, 59, 1, 10557, 4, 6, 59, 98, 99, 100, 111, 115, 8564, 8566, 8573, 8587, 8592, 8596, 1, 8746, 114, 99, 97, 112, 59, 1, 10824, 4, 2, 97, 117, 8579, 8583, 112, 59, 1, 10822, 112, 59, 1, 10826, 111, 116, 59, 1, 8845, 114, 59, 1, 10821, 59, 3, 8746, 65024, 4, 4, 97, 108, 114, 118, 8610, 8623, 8663, 8672, 114, 114, 4, 2, 59, 109, 8618, 8620, 1, 8631, 59, 1, 10556, 121, 4, 3, 101, 118, 119, 8632, 8651, 8656, 113, 4, 2, 112, 115, 8639, 8645, 114, 101, 99, 59, 1, 8926, 117, 99, 99, 59, 1, 8927, 101, 101, 59, 1, 8910, 101, 100, 103, 101, 59, 1, 8911, 101, 110, 5, 164, 1, 59, 8670, 1, 164, 101, 97, 114, 114, 111, 119, 4, 2, 108, 114, 8684, 8690, 101, 102, 116, 59, 1, 8630, 105, 103, 104, 116, 59, 1, 8631, 101, 101, 59, 1, 8910, 101, 100, 59, 1, 8911, 4, 2, 99, 105, 8713, 8721, 111, 110, 105, 110, 116, 59, 1, 8754, 110, 116, 59, 1, 8753, 108, 99, 116, 121, 59, 1, 9005, 4, 19, 65, 72, 97, 98, 99, 100, 101, 102, 104, 105, 106, 108, 111, 114, 115, 116, 117, 119, 122, 8773, 8778, 8783, 8821, 8839, 8854, 8887, 8914, 8930, 8944, 9036, 9041, 9058, 9197, 9227, 9258, 9281, 9297, 9305, 114, 114, 59, 1, 8659, 97, 114, 59, 1, 10597, 4, 4, 103, 108, 114, 115, 8793, 8799, 8805, 8809, 103, 101, 114, 59, 1, 8224, 101, 116, 104, 59, 1, 8504, 114, 59, 1, 8595, 104, 4, 2, 59, 118, 8816, 8818, 1, 8208, 59, 1, 8867, 4, 2, 107, 108, 8827, 8834, 97, 114, 111, 119, 59, 1, 10511, 97, 99, 59, 1, 733, 4, 2, 97, 121, 8845, 8851, 114, 111, 110, 59, 1, 271, 59, 1, 1076, 4, 3, 59, 97, 111, 8862, 8864, 8880, 1, 8518, 4, 2, 103, 114, 8870, 8876, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8650, 116, 115, 101, 113, 59, 1, 10871, 4, 3, 103, 108, 109, 8895, 8902, 8907, 5, 176, 1, 59, 8900, 1, 176, 116, 97, 59, 1, 948, 112, 116, 121, 118, 59, 1, 10673, 4, 2, 105, 114, 8920, 8926, 115, 104, 116, 59, 1, 10623, 59, 3, 55349, 56609, 97, 114, 4, 2, 108, 114, 8938, 8941, 59, 1, 8643, 59, 1, 8642, 4, 5, 97, 101, 103, 115, 118, 8956, 8986, 8989, 8996, 9001, 109, 4, 3, 59, 111, 115, 8965, 8967, 8983, 1, 8900, 110, 100, 4, 2, 59, 115, 8975, 8977, 1, 8900, 117, 105, 116, 59, 1, 9830, 59, 1, 9830, 59, 1, 168, 97, 109, 109, 97, 59, 1, 989, 105, 110, 59, 1, 8946, 4, 3, 59, 105, 111, 9009, 9011, 9031, 1, 247, 100, 101, 5, 247, 2, 59, 111, 9020, 9022, 1, 247, 110, 116, 105, 109, 101, 115, 59, 1, 8903, 110, 120, 59, 1, 8903, 99, 121, 59, 1, 1106, 99, 4, 2, 111, 114, 9048, 9053, 114, 110, 59, 1, 8990, 111, 112, 59, 1, 8973, 4, 5, 108, 112, 116, 117, 119, 9070, 9076, 9081, 9130, 9144, 108, 97, 114, 59, 1, 36, 102, 59, 3, 55349, 56661, 4, 5, 59, 101, 109, 112, 115, 9093, 9095, 9109, 9116, 9122, 1, 729, 113, 4, 2, 59, 100, 9102, 9104, 1, 8784, 111, 116, 59, 1, 8785, 105, 110, 117, 115, 59, 1, 8760, 108, 117, 115, 59, 1, 8724, 113, 117, 97, 114, 101, 59, 1, 8865, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 101, 59, 1, 8966, 110, 4, 3, 97, 100, 104, 9153, 9160, 9172, 114, 114, 111, 119, 59, 1, 8595, 111, 119, 110, 97, 114, 114, 111, 119, 115, 59, 1, 8650, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 9184, 9190, 101, 102, 116, 59, 1, 8643, 105, 103, 104, 116, 59, 1, 8642, 4, 2, 98, 99, 9203, 9211, 107, 97, 114, 111, 119, 59, 1, 10512, 4, 2, 111, 114, 9217, 9222, 114, 110, 59, 1, 8991, 111, 112, 59, 1, 8972, 4, 3, 99, 111, 116, 9235, 9248, 9252, 4, 2, 114, 121, 9241, 9245, 59, 3, 55349, 56505, 59, 1, 1109, 108, 59, 1, 10742, 114, 111, 107, 59, 1, 273, 4, 2, 100, 114, 9264, 9269, 111, 116, 59, 1, 8945, 105, 4, 2, 59, 102, 9276, 9278, 1, 9663, 59, 1, 9662, 4, 2, 97, 104, 9287, 9292, 114, 114, 59, 1, 8693, 97, 114, 59, 1, 10607, 97, 110, 103, 108, 101, 59, 1, 10662, 4, 2, 99, 105, 9311, 9315, 121, 59, 1, 1119, 103, 114, 97, 114, 114, 59, 1, 10239, 4, 18, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 9361, 9376, 9398, 9439, 9444, 9447, 9462, 9495, 9531, 9585, 9598, 9614, 9659, 9755, 9771, 9792, 9808, 9826, 4, 2, 68, 111, 9367, 9372, 111, 116, 59, 1, 10871, 116, 59, 1, 8785, 4, 2, 99, 115, 9382, 9392, 117, 116, 101, 5, 233, 1, 59, 9390, 1, 233, 116, 101, 114, 59, 1, 10862, 4, 4, 97, 105, 111, 121, 9408, 9414, 9430, 9436, 114, 111, 110, 59, 1, 283, 114, 4, 2, 59, 99, 9421, 9423, 1, 8790, 5, 234, 1, 59, 9428, 1, 234, 108, 111, 110, 59, 1, 8789, 59, 1, 1101, 111, 116, 59, 1, 279, 59, 1, 8519, 4, 2, 68, 114, 9453, 9458, 111, 116, 59, 1, 8786, 59, 3, 55349, 56610, 4, 3, 59, 114, 115, 9470, 9472, 9482, 1, 10906, 97, 118, 101, 5, 232, 1, 59, 9480, 1, 232, 4, 2, 59, 100, 9488, 9490, 1, 10902, 111, 116, 59, 1, 10904, 4, 4, 59, 105, 108, 115, 9505, 9507, 9515, 9518, 1, 10905, 110, 116, 101, 114, 115, 59, 1, 9191, 59, 1, 8467, 4, 2, 59, 100, 9524, 9526, 1, 10901, 111, 116, 59, 1, 10903, 4, 3, 97, 112, 115, 9539, 9544, 9564, 99, 114, 59, 1, 275, 116, 121, 4, 3, 59, 115, 118, 9554, 9556, 9561, 1, 8709, 101, 116, 59, 1, 8709, 59, 1, 8709, 112, 4, 2, 49, 59, 9571, 9583, 4, 2, 51, 52, 9577, 9580, 59, 1, 8196, 59, 1, 8197, 1, 8195, 4, 2, 103, 115, 9591, 9594, 59, 1, 331, 112, 59, 1, 8194, 4, 2, 103, 112, 9604, 9609, 111, 110, 59, 1, 281, 102, 59, 3, 55349, 56662, 4, 3, 97, 108, 115, 9622, 9635, 9640, 114, 4, 2, 59, 115, 9629, 9631, 1, 8917, 108, 59, 1, 10723, 117, 115, 59, 1, 10865, 105, 4, 3, 59, 108, 118, 9649, 9651, 9656, 1, 949, 111, 110, 59, 1, 949, 59, 1, 1013, 4, 4, 99, 115, 117, 118, 9669, 9686, 9716, 9747, 4, 2, 105, 111, 9675, 9680, 114, 99, 59, 1, 8790, 108, 111, 110, 59, 1, 8789, 4, 2, 105, 108, 9692, 9696, 109, 59, 1, 8770, 97, 110, 116, 4, 2, 103, 108, 9705, 9710, 116, 114, 59, 1, 10902, 101, 115, 115, 59, 1, 10901, 4, 3, 97, 101, 105, 9724, 9729, 9734, 108, 115, 59, 1, 61, 115, 116, 59, 1, 8799, 118, 4, 2, 59, 68, 9741, 9743, 1, 8801, 68, 59, 1, 10872, 112, 97, 114, 115, 108, 59, 1, 10725, 4, 2, 68, 97, 9761, 9766, 111, 116, 59, 1, 8787, 114, 114, 59, 1, 10609, 4, 3, 99, 100, 105, 9779, 9783, 9788, 114, 59, 1, 8495, 111, 116, 59, 1, 8784, 109, 59, 1, 8770, 4, 2, 97, 104, 9798, 9801, 59, 1, 951, 5, 240, 1, 59, 9806, 1, 240, 4, 2, 109, 114, 9814, 9822, 108, 5, 235, 1, 59, 9820, 1, 235, 111, 59, 1, 8364, 4, 3, 99, 105, 112, 9834, 9838, 9843, 108, 59, 1, 33, 115, 116, 59, 1, 8707, 4, 2, 101, 111, 9849, 9859, 99, 116, 97, 116, 105, 111, 110, 59, 1, 8496, 110, 101, 110, 116, 105, 97, 108, 101, 59, 1, 8519, 4, 12, 97, 99, 101, 102, 105, 106, 108, 110, 111, 112, 114, 115, 9896, 9910, 9914, 9921, 9954, 9960, 9967, 9989, 9994, 10027, 10036, 10164, 108, 108, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8786, 121, 59, 1, 1092, 109, 97, 108, 101, 59, 1, 9792, 4, 3, 105, 108, 114, 9929, 9935, 9950, 108, 105, 103, 59, 1, 64259, 4, 2, 105, 108, 9941, 9945, 103, 59, 1, 64256, 105, 103, 59, 1, 64260, 59, 3, 55349, 56611, 108, 105, 103, 59, 1, 64257, 108, 105, 103, 59, 3, 102, 106, 4, 3, 97, 108, 116, 9975, 9979, 9984, 116, 59, 1, 9837, 105, 103, 59, 1, 64258, 110, 115, 59, 1, 9649, 111, 102, 59, 1, 402, 4, 2, 112, 114, 1e4, 10005, 102, 59, 3, 55349, 56663, 4, 2, 97, 107, 10011, 10016, 108, 108, 59, 1, 8704, 4, 2, 59, 118, 10022, 10024, 1, 8916, 59, 1, 10969, 97, 114, 116, 105, 110, 116, 59, 1, 10765, 4, 2, 97, 111, 10042, 10159, 4, 2, 99, 115, 10048, 10155, 4, 6, 49, 50, 51, 52, 53, 55, 10062, 10102, 10114, 10135, 10139, 10151, 4, 6, 50, 51, 52, 53, 54, 56, 10076, 10083, 10086, 10093, 10096, 10099, 5, 189, 1, 59, 10081, 1, 189, 59, 1, 8531, 5, 188, 1, 59, 10091, 1, 188, 59, 1, 8533, 59, 1, 8537, 59, 1, 8539, 4, 2, 51, 53, 10108, 10111, 59, 1, 8532, 59, 1, 8534, 4, 3, 52, 53, 56, 10122, 10129, 10132, 5, 190, 1, 59, 10127, 1, 190, 59, 1, 8535, 59, 1, 8540, 53, 59, 1, 8536, 4, 2, 54, 56, 10145, 10148, 59, 1, 8538, 59, 1, 8541, 56, 59, 1, 8542, 108, 59, 1, 8260, 119, 110, 59, 1, 8994, 99, 114, 59, 3, 55349, 56507, 4, 17, 69, 97, 98, 99, 100, 101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 10206, 10217, 10247, 10254, 10268, 10273, 10358, 10363, 10374, 10380, 10385, 10406, 10458, 10464, 10470, 10497, 10610, 4, 2, 59, 108, 10212, 10214, 1, 8807, 59, 1, 10892, 4, 3, 99, 109, 112, 10225, 10231, 10244, 117, 116, 101, 59, 1, 501, 109, 97, 4, 2, 59, 100, 10239, 10241, 1, 947, 59, 1, 989, 59, 1, 10886, 114, 101, 118, 101, 59, 1, 287, 4, 2, 105, 121, 10260, 10265, 114, 99, 59, 1, 285, 59, 1, 1075, 111, 116, 59, 1, 289, 4, 4, 59, 108, 113, 115, 10283, 10285, 10288, 10308, 1, 8805, 59, 1, 8923, 4, 3, 59, 113, 115, 10296, 10298, 10301, 1, 8805, 59, 1, 8807, 108, 97, 110, 116, 59, 1, 10878, 4, 4, 59, 99, 100, 108, 10318, 10320, 10324, 10345, 1, 10878, 99, 59, 1, 10921, 111, 116, 4, 2, 59, 111, 10332, 10334, 1, 10880, 4, 2, 59, 108, 10340, 10342, 1, 10882, 59, 1, 10884, 4, 2, 59, 101, 10351, 10354, 3, 8923, 65024, 115, 59, 1, 10900, 114, 59, 3, 55349, 56612, 4, 2, 59, 103, 10369, 10371, 1, 8811, 59, 1, 8921, 109, 101, 108, 59, 1, 8503, 99, 121, 59, 1, 1107, 4, 4, 59, 69, 97, 106, 10395, 10397, 10400, 10403, 1, 8823, 59, 1, 10898, 59, 1, 10917, 59, 1, 10916, 4, 4, 69, 97, 101, 115, 10416, 10419, 10434, 10453, 59, 1, 8809, 112, 4, 2, 59, 112, 10426, 10428, 1, 10890, 114, 111, 120, 59, 1, 10890, 4, 2, 59, 113, 10440, 10442, 1, 10888, 4, 2, 59, 113, 10448, 10450, 1, 10888, 59, 1, 8809, 105, 109, 59, 1, 8935, 112, 102, 59, 3, 55349, 56664, 97, 118, 101, 59, 1, 96, 4, 2, 99, 105, 10476, 10480, 114, 59, 1, 8458, 109, 4, 3, 59, 101, 108, 10489, 10491, 10494, 1, 8819, 59, 1, 10894, 59, 1, 10896, 5, 62, 6, 59, 99, 100, 108, 113, 114, 10512, 10514, 10527, 10532, 10538, 10545, 1, 62, 4, 2, 99, 105, 10520, 10523, 59, 1, 10919, 114, 59, 1, 10874, 111, 116, 59, 1, 8919, 80, 97, 114, 59, 1, 10645, 117, 101, 115, 116, 59, 1, 10876, 4, 5, 97, 100, 101, 108, 115, 10557, 10574, 10579, 10599, 10605, 4, 2, 112, 114, 10563, 10570, 112, 114, 111, 120, 59, 1, 10886, 114, 59, 1, 10616, 111, 116, 59, 1, 8919, 113, 4, 2, 108, 113, 10586, 10592, 101, 115, 115, 59, 1, 8923, 108, 101, 115, 115, 59, 1, 10892, 101, 115, 115, 59, 1, 8823, 105, 109, 59, 1, 8819, 4, 2, 101, 110, 10616, 10626, 114, 116, 110, 101, 113, 113, 59, 3, 8809, 65024, 69, 59, 3, 8809, 65024, 4, 10, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 10653, 10658, 10713, 10718, 10724, 10760, 10765, 10786, 10850, 10875, 114, 114, 59, 1, 8660, 4, 4, 105, 108, 109, 114, 10668, 10674, 10678, 10684, 114, 115, 112, 59, 1, 8202, 102, 59, 1, 189, 105, 108, 116, 59, 1, 8459, 4, 2, 100, 114, 10690, 10695, 99, 121, 59, 1, 1098, 4, 3, 59, 99, 119, 10703, 10705, 10710, 1, 8596, 105, 114, 59, 1, 10568, 59, 1, 8621, 97, 114, 59, 1, 8463, 105, 114, 99, 59, 1, 293, 4, 3, 97, 108, 114, 10732, 10748, 10754, 114, 116, 115, 4, 2, 59, 117, 10741, 10743, 1, 9829, 105, 116, 59, 1, 9829, 108, 105, 112, 59, 1, 8230, 99, 111, 110, 59, 1, 8889, 114, 59, 3, 55349, 56613, 115, 4, 2, 101, 119, 10772, 10779, 97, 114, 111, 119, 59, 1, 10533, 97, 114, 111, 119, 59, 1, 10534, 4, 5, 97, 109, 111, 112, 114, 10798, 10803, 10809, 10839, 10844, 114, 114, 59, 1, 8703, 116, 104, 116, 59, 1, 8763, 107, 4, 2, 108, 114, 10816, 10827, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8617, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8618, 102, 59, 3, 55349, 56665, 98, 97, 114, 59, 1, 8213, 4, 3, 99, 108, 116, 10858, 10863, 10869, 114, 59, 3, 55349, 56509, 97, 115, 104, 59, 1, 8463, 114, 111, 107, 59, 1, 295, 4, 2, 98, 112, 10881, 10887, 117, 108, 108, 59, 1, 8259, 104, 101, 110, 59, 1, 8208, 4, 15, 97, 99, 101, 102, 103, 105, 106, 109, 110, 111, 112, 113, 115, 116, 117, 10925, 10936, 10958, 10977, 10990, 11001, 11039, 11045, 11101, 11192, 11220, 11226, 11237, 11285, 11299, 99, 117, 116, 101, 5, 237, 1, 59, 10934, 1, 237, 4, 3, 59, 105, 121, 10944, 10946, 10955, 1, 8291, 114, 99, 5, 238, 1, 59, 10953, 1, 238, 59, 1, 1080, 4, 2, 99, 120, 10964, 10968, 121, 59, 1, 1077, 99, 108, 5, 161, 1, 59, 10975, 1, 161, 4, 2, 102, 114, 10983, 10986, 59, 1, 8660, 59, 3, 55349, 56614, 114, 97, 118, 101, 5, 236, 1, 59, 10999, 1, 236, 4, 4, 59, 105, 110, 111, 11011, 11013, 11028, 11034, 1, 8520, 4, 2, 105, 110, 11019, 11024, 110, 116, 59, 1, 10764, 116, 59, 1, 8749, 102, 105, 110, 59, 1, 10716, 116, 97, 59, 1, 8489, 108, 105, 103, 59, 1, 307, 4, 3, 97, 111, 112, 11053, 11092, 11096, 4, 3, 99, 103, 116, 11061, 11065, 11088, 114, 59, 1, 299, 4, 3, 101, 108, 112, 11073, 11076, 11082, 59, 1, 8465, 105, 110, 101, 59, 1, 8464, 97, 114, 116, 59, 1, 8465, 104, 59, 1, 305, 102, 59, 1, 8887, 101, 100, 59, 1, 437, 4, 5, 59, 99, 102, 111, 116, 11113, 11115, 11121, 11136, 11142, 1, 8712, 97, 114, 101, 59, 1, 8453, 105, 110, 4, 2, 59, 116, 11129, 11131, 1, 8734, 105, 101, 59, 1, 10717, 100, 111, 116, 59, 1, 305, 4, 5, 59, 99, 101, 108, 112, 11154, 11156, 11161, 11179, 11186, 1, 8747, 97, 108, 59, 1, 8890, 4, 2, 103, 114, 11167, 11173, 101, 114, 115, 59, 1, 8484, 99, 97, 108, 59, 1, 8890, 97, 114, 104, 107, 59, 1, 10775, 114, 111, 100, 59, 1, 10812, 4, 4, 99, 103, 112, 116, 11202, 11206, 11211, 11216, 121, 59, 1, 1105, 111, 110, 59, 1, 303, 102, 59, 3, 55349, 56666, 97, 59, 1, 953, 114, 111, 100, 59, 1, 10812, 117, 101, 115, 116, 5, 191, 1, 59, 11235, 1, 191, 4, 2, 99, 105, 11243, 11248, 114, 59, 3, 55349, 56510, 110, 4, 5, 59, 69, 100, 115, 118, 11261, 11263, 11266, 11271, 11282, 1, 8712, 59, 1, 8953, 111, 116, 59, 1, 8949, 4, 2, 59, 118, 11277, 11279, 1, 8948, 59, 1, 8947, 59, 1, 8712, 4, 2, 59, 105, 11291, 11293, 1, 8290, 108, 100, 101, 59, 1, 297, 4, 2, 107, 109, 11305, 11310, 99, 121, 59, 1, 1110, 108, 5, 239, 1, 59, 11316, 1, 239, 4, 6, 99, 102, 109, 111, 115, 117, 11332, 11346, 11351, 11357, 11363, 11380, 4, 2, 105, 121, 11338, 11343, 114, 99, 59, 1, 309, 59, 1, 1081, 114, 59, 3, 55349, 56615, 97, 116, 104, 59, 1, 567, 112, 102, 59, 3, 55349, 56667, 4, 2, 99, 101, 11369, 11374, 114, 59, 3, 55349, 56511, 114, 99, 121, 59, 1, 1112, 107, 99, 121, 59, 1, 1108, 4, 8, 97, 99, 102, 103, 104, 106, 111, 115, 11404, 11418, 11433, 11438, 11445, 11450, 11455, 11461, 112, 112, 97, 4, 2, 59, 118, 11413, 11415, 1, 954, 59, 1, 1008, 4, 2, 101, 121, 11424, 11430, 100, 105, 108, 59, 1, 311, 59, 1, 1082, 114, 59, 3, 55349, 56616, 114, 101, 101, 110, 59, 1, 312, 99, 121, 59, 1, 1093, 99, 121, 59, 1, 1116, 112, 102, 59, 3, 55349, 56668, 99, 114, 59, 3, 55349, 56512, 4, 23, 65, 66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 11515, 11538, 11544, 11555, 11560, 11721, 11780, 11818, 11868, 12136, 12160, 12171, 12203, 12208, 12246, 12275, 12327, 12509, 12523, 12569, 12641, 12732, 12752, 4, 3, 97, 114, 116, 11523, 11528, 11532, 114, 114, 59, 1, 8666, 114, 59, 1, 8656, 97, 105, 108, 59, 1, 10523, 97, 114, 114, 59, 1, 10510, 4, 2, 59, 103, 11550, 11552, 1, 8806, 59, 1, 10891, 97, 114, 59, 1, 10594, 4, 9, 99, 101, 103, 109, 110, 112, 113, 114, 116, 11580, 11586, 11594, 11600, 11606, 11624, 11627, 11636, 11694, 117, 116, 101, 59, 1, 314, 109, 112, 116, 121, 118, 59, 1, 10676, 114, 97, 110, 59, 1, 8466, 98, 100, 97, 59, 1, 955, 103, 4, 3, 59, 100, 108, 11615, 11617, 11620, 1, 10216, 59, 1, 10641, 101, 59, 1, 10216, 59, 1, 10885, 117, 111, 5, 171, 1, 59, 11634, 1, 171, 114, 4, 8, 59, 98, 102, 104, 108, 112, 115, 116, 11655, 11657, 11669, 11673, 11677, 11681, 11685, 11690, 1, 8592, 4, 2, 59, 102, 11663, 11665, 1, 8676, 115, 59, 1, 10527, 115, 59, 1, 10525, 107, 59, 1, 8617, 112, 59, 1, 8619, 108, 59, 1, 10553, 105, 109, 59, 1, 10611, 108, 59, 1, 8610, 4, 3, 59, 97, 101, 11702, 11704, 11709, 1, 10923, 105, 108, 59, 1, 10521, 4, 2, 59, 115, 11715, 11717, 1, 10925, 59, 3, 10925, 65024, 4, 3, 97, 98, 114, 11729, 11734, 11739, 114, 114, 59, 1, 10508, 114, 107, 59, 1, 10098, 4, 2, 97, 107, 11745, 11758, 99, 4, 2, 101, 107, 11752, 11755, 59, 1, 123, 59, 1, 91, 4, 2, 101, 115, 11764, 11767, 59, 1, 10635, 108, 4, 2, 100, 117, 11774, 11777, 59, 1, 10639, 59, 1, 10637, 4, 4, 97, 101, 117, 121, 11790, 11796, 11811, 11815, 114, 111, 110, 59, 1, 318, 4, 2, 100, 105, 11802, 11807, 105, 108, 59, 1, 316, 108, 59, 1, 8968, 98, 59, 1, 123, 59, 1, 1083, 4, 4, 99, 113, 114, 115, 11828, 11832, 11845, 11864, 97, 59, 1, 10550, 117, 111, 4, 2, 59, 114, 11840, 11842, 1, 8220, 59, 1, 8222, 4, 2, 100, 117, 11851, 11857, 104, 97, 114, 59, 1, 10599, 115, 104, 97, 114, 59, 1, 10571, 104, 59, 1, 8626, 4, 5, 59, 102, 103, 113, 115, 11880, 11882, 12008, 12011, 12031, 1, 8804, 116, 4, 5, 97, 104, 108, 114, 116, 11895, 11913, 11935, 11947, 11996, 114, 114, 111, 119, 4, 2, 59, 116, 11905, 11907, 1, 8592, 97, 105, 108, 59, 1, 8610, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 11925, 11931, 111, 119, 110, 59, 1, 8637, 112, 59, 1, 8636, 101, 102, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8647, 105, 103, 104, 116, 4, 3, 97, 104, 115, 11959, 11974, 11984, 114, 114, 111, 119, 4, 2, 59, 115, 11969, 11971, 1, 8596, 59, 1, 8646, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8651, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8621, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8907, 59, 1, 8922, 4, 3, 59, 113, 115, 12019, 12021, 12024, 1, 8804, 59, 1, 8806, 108, 97, 110, 116, 59, 1, 10877, 4, 5, 59, 99, 100, 103, 115, 12043, 12045, 12049, 12070, 12083, 1, 10877, 99, 59, 1, 10920, 111, 116, 4, 2, 59, 111, 12057, 12059, 1, 10879, 4, 2, 59, 114, 12065, 12067, 1, 10881, 59, 1, 10883, 4, 2, 59, 101, 12076, 12079, 3, 8922, 65024, 115, 59, 1, 10899, 4, 5, 97, 100, 101, 103, 115, 12095, 12103, 12108, 12126, 12131, 112, 112, 114, 111, 120, 59, 1, 10885, 111, 116, 59, 1, 8918, 113, 4, 2, 103, 113, 12115, 12120, 116, 114, 59, 1, 8922, 103, 116, 114, 59, 1, 10891, 116, 114, 59, 1, 8822, 105, 109, 59, 1, 8818, 4, 3, 105, 108, 114, 12144, 12150, 12156, 115, 104, 116, 59, 1, 10620, 111, 111, 114, 59, 1, 8970, 59, 3, 55349, 56617, 4, 2, 59, 69, 12166, 12168, 1, 8822, 59, 1, 10897, 4, 2, 97, 98, 12177, 12198, 114, 4, 2, 100, 117, 12184, 12187, 59, 1, 8637, 4, 2, 59, 108, 12193, 12195, 1, 8636, 59, 1, 10602, 108, 107, 59, 1, 9604, 99, 121, 59, 1, 1113, 4, 5, 59, 97, 99, 104, 116, 12220, 12222, 12227, 12235, 12241, 1, 8810, 114, 114, 59, 1, 8647, 111, 114, 110, 101, 114, 59, 1, 8990, 97, 114, 100, 59, 1, 10603, 114, 105, 59, 1, 9722, 4, 2, 105, 111, 12252, 12258, 100, 111, 116, 59, 1, 320, 117, 115, 116, 4, 2, 59, 97, 12267, 12269, 1, 9136, 99, 104, 101, 59, 1, 9136, 4, 4, 69, 97, 101, 115, 12285, 12288, 12303, 12322, 59, 1, 8808, 112, 4, 2, 59, 112, 12295, 12297, 1, 10889, 114, 111, 120, 59, 1, 10889, 4, 2, 59, 113, 12309, 12311, 1, 10887, 4, 2, 59, 113, 12317, 12319, 1, 10887, 59, 1, 8808, 105, 109, 59, 1, 8934, 4, 8, 97, 98, 110, 111, 112, 116, 119, 122, 12345, 12359, 12364, 12421, 12446, 12467, 12474, 12490, 4, 2, 110, 114, 12351, 12355, 103, 59, 1, 10220, 114, 59, 1, 8701, 114, 107, 59, 1, 10214, 103, 4, 3, 108, 109, 114, 12373, 12401, 12409, 101, 102, 116, 4, 2, 97, 114, 12382, 12389, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10231, 97, 112, 115, 116, 111, 59, 1, 10236, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10230, 112, 97, 114, 114, 111, 119, 4, 2, 108, 114, 12433, 12439, 101, 102, 116, 59, 1, 8619, 105, 103, 104, 116, 59, 1, 8620, 4, 3, 97, 102, 108, 12454, 12458, 12462, 114, 59, 1, 10629, 59, 3, 55349, 56669, 117, 115, 59, 1, 10797, 105, 109, 101, 115, 59, 1, 10804, 4, 2, 97, 98, 12480, 12485, 115, 116, 59, 1, 8727, 97, 114, 59, 1, 95, 4, 3, 59, 101, 102, 12498, 12500, 12506, 1, 9674, 110, 103, 101, 59, 1, 9674, 59, 1, 10731, 97, 114, 4, 2, 59, 108, 12517, 12519, 1, 40, 116, 59, 1, 10643, 4, 5, 97, 99, 104, 109, 116, 12535, 12540, 12548, 12561, 12564, 114, 114, 59, 1, 8646, 111, 114, 110, 101, 114, 59, 1, 8991, 97, 114, 4, 2, 59, 100, 12556, 12558, 1, 8651, 59, 1, 10605, 59, 1, 8206, 114, 105, 59, 1, 8895, 4, 6, 97, 99, 104, 105, 113, 116, 12583, 12589, 12594, 12597, 12614, 12635, 113, 117, 111, 59, 1, 8249, 114, 59, 3, 55349, 56513, 59, 1, 8624, 109, 4, 3, 59, 101, 103, 12606, 12608, 12611, 1, 8818, 59, 1, 10893, 59, 1, 10895, 4, 2, 98, 117, 12620, 12623, 59, 1, 91, 111, 4, 2, 59, 114, 12630, 12632, 1, 8216, 59, 1, 8218, 114, 111, 107, 59, 1, 322, 5, 60, 8, 59, 99, 100, 104, 105, 108, 113, 114, 12660, 12662, 12675, 12680, 12686, 12692, 12698, 12705, 1, 60, 4, 2, 99, 105, 12668, 12671, 59, 1, 10918, 114, 59, 1, 10873, 111, 116, 59, 1, 8918, 114, 101, 101, 59, 1, 8907, 109, 101, 115, 59, 1, 8905, 97, 114, 114, 59, 1, 10614, 117, 101, 115, 116, 59, 1, 10875, 4, 2, 80, 105, 12711, 12716, 97, 114, 59, 1, 10646, 4, 3, 59, 101, 102, 12724, 12726, 12729, 1, 9667, 59, 1, 8884, 59, 1, 9666, 114, 4, 2, 100, 117, 12739, 12746, 115, 104, 97, 114, 59, 1, 10570, 104, 97, 114, 59, 1, 10598, 4, 2, 101, 110, 12758, 12768, 114, 116, 110, 101, 113, 113, 59, 3, 8808, 65024, 69, 59, 3, 8808, 65024, 4, 14, 68, 97, 99, 100, 101, 102, 104, 105, 108, 110, 111, 112, 115, 117, 12803, 12809, 12893, 12908, 12914, 12928, 12933, 12937, 13011, 13025, 13032, 13049, 13052, 13069, 68, 111, 116, 59, 1, 8762, 4, 4, 99, 108, 112, 114, 12819, 12827, 12849, 12887, 114, 5, 175, 1, 59, 12825, 1, 175, 4, 2, 101, 116, 12833, 12836, 59, 1, 9794, 4, 2, 59, 101, 12842, 12844, 1, 10016, 115, 101, 59, 1, 10016, 4, 2, 59, 115, 12855, 12857, 1, 8614, 116, 111, 4, 4, 59, 100, 108, 117, 12869, 12871, 12877, 12883, 1, 8614, 111, 119, 110, 59, 1, 8615, 101, 102, 116, 59, 1, 8612, 112, 59, 1, 8613, 107, 101, 114, 59, 1, 9646, 4, 2, 111, 121, 12899, 12905, 109, 109, 97, 59, 1, 10793, 59, 1, 1084, 97, 115, 104, 59, 1, 8212, 97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101, 59, 1, 8737, 114, 59, 3, 55349, 56618, 111, 59, 1, 8487, 4, 3, 99, 100, 110, 12945, 12954, 12985, 114, 111, 5, 181, 1, 59, 12952, 1, 181, 4, 4, 59, 97, 99, 100, 12964, 12966, 12971, 12976, 1, 8739, 115, 116, 59, 1, 42, 105, 114, 59, 1, 10992, 111, 116, 5, 183, 1, 59, 12983, 1, 183, 117, 115, 4, 3, 59, 98, 100, 12995, 12997, 13e3, 1, 8722, 59, 1, 8863, 4, 2, 59, 117, 13006, 13008, 1, 8760, 59, 1, 10794, 4, 2, 99, 100, 13017, 13021, 112, 59, 1, 10971, 114, 59, 1, 8230, 112, 108, 117, 115, 59, 1, 8723, 4, 2, 100, 112, 13038, 13044, 101, 108, 115, 59, 1, 8871, 102, 59, 3, 55349, 56670, 59, 1, 8723, 4, 2, 99, 116, 13058, 13063, 114, 59, 3, 55349, 56514, 112, 111, 115, 59, 1, 8766, 4, 3, 59, 108, 109, 13077, 13079, 13087, 1, 956, 116, 105, 109, 97, 112, 59, 1, 8888, 97, 112, 59, 1, 8888, 4, 24, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 109, 111, 112, 114, 115, 116, 117, 118, 119, 13142, 13165, 13217, 13229, 13247, 13330, 13359, 13414, 13420, 13508, 13513, 13579, 13602, 13626, 13631, 13762, 13767, 13855, 13936, 13995, 14214, 14285, 14312, 14432, 4, 2, 103, 116, 13148, 13152, 59, 3, 8921, 824, 4, 2, 59, 118, 13158, 13161, 3, 8811, 8402, 59, 3, 8811, 824, 4, 3, 101, 108, 116, 13173, 13200, 13204, 102, 116, 4, 2, 97, 114, 13181, 13188, 114, 114, 111, 119, 59, 1, 8653, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8654, 59, 3, 8920, 824, 4, 2, 59, 118, 13210, 13213, 3, 8810, 8402, 59, 3, 8810, 824, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8655, 4, 2, 68, 100, 13235, 13241, 97, 115, 104, 59, 1, 8879, 97, 115, 104, 59, 1, 8878, 4, 5, 98, 99, 110, 112, 116, 13259, 13264, 13270, 13275, 13308, 108, 97, 59, 1, 8711, 117, 116, 101, 59, 1, 324, 103, 59, 3, 8736, 8402, 4, 5, 59, 69, 105, 111, 112, 13287, 13289, 13293, 13298, 13302, 1, 8777, 59, 3, 10864, 824, 100, 59, 3, 8779, 824, 115, 59, 1, 329, 114, 111, 120, 59, 1, 8777, 117, 114, 4, 2, 59, 97, 13316, 13318, 1, 9838, 108, 4, 2, 59, 115, 13325, 13327, 1, 9838, 59, 1, 8469, 4, 2, 115, 117, 13336, 13344, 112, 5, 160, 1, 59, 13342, 1, 160, 109, 112, 4, 2, 59, 101, 13352, 13355, 3, 8782, 824, 59, 3, 8783, 824, 4, 5, 97, 101, 111, 117, 121, 13371, 13385, 13391, 13407, 13411, 4, 2, 112, 114, 13377, 13380, 59, 1, 10819, 111, 110, 59, 1, 328, 100, 105, 108, 59, 1, 326, 110, 103, 4, 2, 59, 100, 13399, 13401, 1, 8775, 111, 116, 59, 3, 10861, 824, 112, 59, 1, 10818, 59, 1, 1085, 97, 115, 104, 59, 1, 8211, 4, 7, 59, 65, 97, 100, 113, 115, 120, 13436, 13438, 13443, 13466, 13472, 13478, 13494, 1, 8800, 114, 114, 59, 1, 8663, 114, 4, 2, 104, 114, 13450, 13454, 107, 59, 1, 10532, 4, 2, 59, 111, 13460, 13462, 1, 8599, 119, 59, 1, 8599, 111, 116, 59, 3, 8784, 824, 117, 105, 118, 59, 1, 8802, 4, 2, 101, 105, 13484, 13489, 97, 114, 59, 1, 10536, 109, 59, 3, 8770, 824, 105, 115, 116, 4, 2, 59, 115, 13503, 13505, 1, 8708, 59, 1, 8708, 114, 59, 3, 55349, 56619, 4, 4, 69, 101, 115, 116, 13523, 13527, 13563, 13568, 59, 3, 8807, 824, 4, 3, 59, 113, 115, 13535, 13537, 13559, 1, 8817, 4, 3, 59, 113, 115, 13545, 13547, 13551, 1, 8817, 59, 3, 8807, 824, 108, 97, 110, 116, 59, 3, 10878, 824, 59, 3, 10878, 824, 105, 109, 59, 1, 8821, 4, 2, 59, 114, 13574, 13576, 1, 8815, 59, 1, 8815, 4, 3, 65, 97, 112, 13587, 13592, 13597, 114, 114, 59, 1, 8654, 114, 114, 59, 1, 8622, 97, 114, 59, 1, 10994, 4, 3, 59, 115, 118, 13610, 13612, 13623, 1, 8715, 4, 2, 59, 100, 13618, 13620, 1, 8956, 59, 1, 8954, 59, 1, 8715, 99, 121, 59, 1, 1114, 4, 7, 65, 69, 97, 100, 101, 115, 116, 13647, 13652, 13656, 13661, 13665, 13737, 13742, 114, 114, 59, 1, 8653, 59, 3, 8806, 824, 114, 114, 59, 1, 8602, 114, 59, 1, 8229, 4, 4, 59, 102, 113, 115, 13675, 13677, 13703, 13725, 1, 8816, 116, 4, 2, 97, 114, 13684, 13691, 114, 114, 111, 119, 59, 1, 8602, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8622, 4, 3, 59, 113, 115, 13711, 13713, 13717, 1, 8816, 59, 3, 8806, 824, 108, 97, 110, 116, 59, 3, 10877, 824, 4, 2, 59, 115, 13731, 13734, 3, 10877, 824, 59, 1, 8814, 105, 109, 59, 1, 8820, 4, 2, 59, 114, 13748, 13750, 1, 8814, 105, 4, 2, 59, 101, 13757, 13759, 1, 8938, 59, 1, 8940, 105, 100, 59, 1, 8740, 4, 2, 112, 116, 13773, 13778, 102, 59, 3, 55349, 56671, 5, 172, 3, 59, 105, 110, 13787, 13789, 13829, 1, 172, 110, 4, 4, 59, 69, 100, 118, 13800, 13802, 13806, 13812, 1, 8713, 59, 3, 8953, 824, 111, 116, 59, 3, 8949, 824, 4, 3, 97, 98, 99, 13820, 13823, 13826, 59, 1, 8713, 59, 1, 8951, 59, 1, 8950, 105, 4, 2, 59, 118, 13836, 13838, 1, 8716, 4, 3, 97, 98, 99, 13846, 13849, 13852, 59, 1, 8716, 59, 1, 8958, 59, 1, 8957, 4, 3, 97, 111, 114, 13863, 13892, 13899, 114, 4, 4, 59, 97, 115, 116, 13874, 13876, 13883, 13888, 1, 8742, 108, 108, 101, 108, 59, 1, 8742, 108, 59, 3, 11005, 8421, 59, 3, 8706, 824, 108, 105, 110, 116, 59, 1, 10772, 4, 3, 59, 99, 101, 13907, 13909, 13914, 1, 8832, 117, 101, 59, 1, 8928, 4, 2, 59, 99, 13920, 13923, 3, 10927, 824, 4, 2, 59, 101, 13929, 13931, 1, 8832, 113, 59, 3, 10927, 824, 4, 4, 65, 97, 105, 116, 13946, 13951, 13971, 13982, 114, 114, 59, 1, 8655, 114, 114, 4, 3, 59, 99, 119, 13961, 13963, 13967, 1, 8603, 59, 3, 10547, 824, 59, 3, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8603, 114, 105, 4, 2, 59, 101, 13990, 13992, 1, 8939, 59, 1, 8941, 4, 7, 99, 104, 105, 109, 112, 113, 117, 14011, 14036, 14060, 14080, 14085, 14090, 14106, 4, 4, 59, 99, 101, 114, 14021, 14023, 14028, 14032, 1, 8833, 117, 101, 59, 1, 8929, 59, 3, 10928, 824, 59, 3, 55349, 56515, 111, 114, 116, 4, 2, 109, 112, 14045, 14050, 105, 100, 59, 1, 8740, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8742, 109, 4, 2, 59, 101, 14067, 14069, 1, 8769, 4, 2, 59, 113, 14075, 14077, 1, 8772, 59, 1, 8772, 105, 100, 59, 1, 8740, 97, 114, 59, 1, 8742, 115, 117, 4, 2, 98, 112, 14098, 14102, 101, 59, 1, 8930, 101, 59, 1, 8931, 4, 3, 98, 99, 112, 14114, 14157, 14171, 4, 4, 59, 69, 101, 115, 14124, 14126, 14130, 14133, 1, 8836, 59, 3, 10949, 824, 59, 1, 8840, 101, 116, 4, 2, 59, 101, 14141, 14144, 3, 8834, 8402, 113, 4, 2, 59, 113, 14151, 14153, 1, 8840, 59, 3, 10949, 824, 99, 4, 2, 59, 101, 14164, 14166, 1, 8833, 113, 59, 3, 10928, 824, 4, 4, 59, 69, 101, 115, 14181, 14183, 14187, 14190, 1, 8837, 59, 3, 10950, 824, 59, 1, 8841, 101, 116, 4, 2, 59, 101, 14198, 14201, 3, 8835, 8402, 113, 4, 2, 59, 113, 14208, 14210, 1, 8841, 59, 3, 10950, 824, 4, 4, 103, 105, 108, 114, 14224, 14228, 14238, 14242, 108, 59, 1, 8825, 108, 100, 101, 5, 241, 1, 59, 14236, 1, 241, 103, 59, 1, 8824, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 14254, 14269, 101, 102, 116, 4, 2, 59, 101, 14263, 14265, 1, 8938, 113, 59, 1, 8940, 105, 103, 104, 116, 4, 2, 59, 101, 14279, 14281, 1, 8939, 113, 59, 1, 8941, 4, 2, 59, 109, 14291, 14293, 1, 957, 4, 3, 59, 101, 115, 14301, 14303, 14308, 1, 35, 114, 111, 59, 1, 8470, 112, 59, 1, 8199, 4, 9, 68, 72, 97, 100, 103, 105, 108, 114, 115, 14332, 14338, 14344, 14349, 14355, 14369, 14376, 14408, 14426, 97, 115, 104, 59, 1, 8877, 97, 114, 114, 59, 1, 10500, 112, 59, 3, 8781, 8402, 97, 115, 104, 59, 1, 8876, 4, 2, 101, 116, 14361, 14365, 59, 3, 8805, 8402, 59, 3, 62, 8402, 110, 102, 105, 110, 59, 1, 10718, 4, 3, 65, 101, 116, 14384, 14389, 14393, 114, 114, 59, 1, 10498, 59, 3, 8804, 8402, 4, 2, 59, 114, 14399, 14402, 3, 60, 8402, 105, 101, 59, 3, 8884, 8402, 4, 2, 65, 116, 14414, 14419, 114, 114, 59, 1, 10499, 114, 105, 101, 59, 3, 8885, 8402, 105, 109, 59, 3, 8764, 8402, 4, 3, 65, 97, 110, 14440, 14445, 14468, 114, 114, 59, 1, 8662, 114, 4, 2, 104, 114, 14452, 14456, 107, 59, 1, 10531, 4, 2, 59, 111, 14462, 14464, 1, 8598, 119, 59, 1, 8598, 101, 97, 114, 59, 1, 10535, 4, 18, 83, 97, 99, 100, 101, 102, 103, 104, 105, 108, 109, 111, 112, 114, 115, 116, 117, 118, 14512, 14515, 14535, 14560, 14597, 14603, 14618, 14643, 14657, 14662, 14701, 14741, 14747, 14769, 14851, 14877, 14907, 14916, 59, 1, 9416, 4, 2, 99, 115, 14521, 14531, 117, 116, 101, 5, 243, 1, 59, 14529, 1, 243, 116, 59, 1, 8859, 4, 2, 105, 121, 14541, 14557, 114, 4, 2, 59, 99, 14548, 14550, 1, 8858, 5, 244, 1, 59, 14555, 1, 244, 59, 1, 1086, 4, 5, 97, 98, 105, 111, 115, 14572, 14577, 14583, 14587, 14591, 115, 104, 59, 1, 8861, 108, 97, 99, 59, 1, 337, 118, 59, 1, 10808, 116, 59, 1, 8857, 111, 108, 100, 59, 1, 10684, 108, 105, 103, 59, 1, 339, 4, 2, 99, 114, 14609, 14614, 105, 114, 59, 1, 10687, 59, 3, 55349, 56620, 4, 3, 111, 114, 116, 14626, 14630, 14640, 110, 59, 1, 731, 97, 118, 101, 5, 242, 1, 59, 14638, 1, 242, 59, 1, 10689, 4, 2, 98, 109, 14649, 14654, 97, 114, 59, 1, 10677, 59, 1, 937, 110, 116, 59, 1, 8750, 4, 4, 97, 99, 105, 116, 14672, 14677, 14693, 14698, 114, 114, 59, 1, 8634, 4, 2, 105, 114, 14683, 14687, 114, 59, 1, 10686, 111, 115, 115, 59, 1, 10683, 110, 101, 59, 1, 8254, 59, 1, 10688, 4, 3, 97, 101, 105, 14709, 14714, 14719, 99, 114, 59, 1, 333, 103, 97, 59, 1, 969, 4, 3, 99, 100, 110, 14727, 14733, 14736, 114, 111, 110, 59, 1, 959, 59, 1, 10678, 117, 115, 59, 1, 8854, 112, 102, 59, 3, 55349, 56672, 4, 3, 97, 101, 108, 14755, 14759, 14764, 114, 59, 1, 10679, 114, 112, 59, 1, 10681, 117, 115, 59, 1, 8853, 4, 7, 59, 97, 100, 105, 111, 115, 118, 14785, 14787, 14792, 14831, 14837, 14841, 14848, 1, 8744, 114, 114, 59, 1, 8635, 4, 4, 59, 101, 102, 109, 14802, 14804, 14817, 14824, 1, 10845, 114, 4, 2, 59, 111, 14811, 14813, 1, 8500, 102, 59, 1, 8500, 5, 170, 1, 59, 14822, 1, 170, 5, 186, 1, 59, 14829, 1, 186, 103, 111, 102, 59, 1, 8886, 114, 59, 1, 10838, 108, 111, 112, 101, 59, 1, 10839, 59, 1, 10843, 4, 3, 99, 108, 111, 14859, 14863, 14873, 114, 59, 1, 8500, 97, 115, 104, 5, 248, 1, 59, 14871, 1, 248, 108, 59, 1, 8856, 105, 4, 2, 108, 109, 14884, 14893, 100, 101, 5, 245, 1, 59, 14891, 1, 245, 101, 115, 4, 2, 59, 97, 14901, 14903, 1, 8855, 115, 59, 1, 10806, 109, 108, 5, 246, 1, 59, 14914, 1, 246, 98, 97, 114, 59, 1, 9021, 4, 12, 97, 99, 101, 102, 104, 105, 108, 109, 111, 114, 115, 117, 14948, 14992, 14996, 15033, 15038, 15068, 15090, 15189, 15192, 15222, 15427, 15441, 114, 4, 4, 59, 97, 115, 116, 14959, 14961, 14976, 14989, 1, 8741, 5, 182, 2, 59, 108, 14968, 14970, 1, 182, 108, 101, 108, 59, 1, 8741, 4, 2, 105, 108, 14982, 14986, 109, 59, 1, 10995, 59, 1, 11005, 59, 1, 8706, 121, 59, 1, 1087, 114, 4, 5, 99, 105, 109, 112, 116, 15009, 15014, 15019, 15024, 15027, 110, 116, 59, 1, 37, 111, 100, 59, 1, 46, 105, 108, 59, 1, 8240, 59, 1, 8869, 101, 110, 107, 59, 1, 8241, 114, 59, 3, 55349, 56621, 4, 3, 105, 109, 111, 15046, 15057, 15063, 4, 2, 59, 118, 15052, 15054, 1, 966, 59, 1, 981, 109, 97, 116, 59, 1, 8499, 110, 101, 59, 1, 9742, 4, 3, 59, 116, 118, 15076, 15078, 15087, 1, 960, 99, 104, 102, 111, 114, 107, 59, 1, 8916, 59, 1, 982, 4, 2, 97, 117, 15096, 15119, 110, 4, 2, 99, 107, 15103, 15115, 107, 4, 2, 59, 104, 15110, 15112, 1, 8463, 59, 1, 8462, 118, 59, 1, 8463, 115, 4, 9, 59, 97, 98, 99, 100, 101, 109, 115, 116, 15140, 15142, 15148, 15151, 15156, 15168, 15171, 15179, 15184, 1, 43, 99, 105, 114, 59, 1, 10787, 59, 1, 8862, 105, 114, 59, 1, 10786, 4, 2, 111, 117, 15162, 15165, 59, 1, 8724, 59, 1, 10789, 59, 1, 10866, 110, 5, 177, 1, 59, 15177, 1, 177, 105, 109, 59, 1, 10790, 119, 111, 59, 1, 10791, 59, 1, 177, 4, 3, 105, 112, 117, 15200, 15208, 15213, 110, 116, 105, 110, 116, 59, 1, 10773, 102, 59, 3, 55349, 56673, 110, 100, 5, 163, 1, 59, 15220, 1, 163, 4, 10, 59, 69, 97, 99, 101, 105, 110, 111, 115, 117, 15244, 15246, 15249, 15253, 15258, 15334, 15347, 15367, 15416, 15421, 1, 8826, 59, 1, 10931, 112, 59, 1, 10935, 117, 101, 59, 1, 8828, 4, 2, 59, 99, 15264, 15266, 1, 10927, 4, 6, 59, 97, 99, 101, 110, 115, 15280, 15282, 15290, 15299, 15303, 15329, 1, 8826, 112, 112, 114, 111, 120, 59, 1, 10935, 117, 114, 108, 121, 101, 113, 59, 1, 8828, 113, 59, 1, 10927, 4, 3, 97, 101, 115, 15311, 15319, 15324, 112, 112, 114, 111, 120, 59, 1, 10937, 113, 113, 59, 1, 10933, 105, 109, 59, 1, 8936, 105, 109, 59, 1, 8830, 109, 101, 4, 2, 59, 115, 15342, 15344, 1, 8242, 59, 1, 8473, 4, 3, 69, 97, 115, 15355, 15358, 15362, 59, 1, 10933, 112, 59, 1, 10937, 105, 109, 59, 1, 8936, 4, 3, 100, 102, 112, 15375, 15378, 15404, 59, 1, 8719, 4, 3, 97, 108, 115, 15386, 15392, 15398, 108, 97, 114, 59, 1, 9006, 105, 110, 101, 59, 1, 8978, 117, 114, 102, 59, 1, 8979, 4, 2, 59, 116, 15410, 15412, 1, 8733, 111, 59, 1, 8733, 105, 109, 59, 1, 8830, 114, 101, 108, 59, 1, 8880, 4, 2, 99, 105, 15433, 15438, 114, 59, 3, 55349, 56517, 59, 1, 968, 110, 99, 115, 112, 59, 1, 8200, 4, 6, 102, 105, 111, 112, 115, 117, 15462, 15467, 15472, 15478, 15485, 15491, 114, 59, 3, 55349, 56622, 110, 116, 59, 1, 10764, 112, 102, 59, 3, 55349, 56674, 114, 105, 109, 101, 59, 1, 8279, 99, 114, 59, 3, 55349, 56518, 4, 3, 97, 101, 111, 15499, 15520, 15534, 116, 4, 2, 101, 105, 15506, 15515, 114, 110, 105, 111, 110, 115, 59, 1, 8461, 110, 116, 59, 1, 10774, 115, 116, 4, 2, 59, 101, 15528, 15530, 1, 63, 113, 59, 1, 8799, 116, 5, 34, 1, 59, 15540, 1, 34, 4, 21, 65, 66, 72, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 120, 15586, 15609, 15615, 15620, 15796, 15855, 15893, 15931, 15977, 16001, 16039, 16183, 16204, 16222, 16228, 16285, 16312, 16318, 16363, 16408, 16416, 4, 3, 97, 114, 116, 15594, 15599, 15603, 114, 114, 59, 1, 8667, 114, 59, 1, 8658, 97, 105, 108, 59, 1, 10524, 97, 114, 114, 59, 1, 10511, 97, 114, 59, 1, 10596, 4, 7, 99, 100, 101, 110, 113, 114, 116, 15636, 15651, 15656, 15664, 15687, 15696, 15770, 4, 2, 101, 117, 15642, 15646, 59, 3, 8765, 817, 116, 101, 59, 1, 341, 105, 99, 59, 1, 8730, 109, 112, 116, 121, 118, 59, 1, 10675, 103, 4, 4, 59, 100, 101, 108, 15675, 15677, 15680, 15683, 1, 10217, 59, 1, 10642, 59, 1, 10661, 101, 59, 1, 10217, 117, 111, 5, 187, 1, 59, 15694, 1, 187, 114, 4, 11, 59, 97, 98, 99, 102, 104, 108, 112, 115, 116, 119, 15721, 15723, 15727, 15739, 15742, 15746, 15750, 15754, 15758, 15763, 15767, 1, 8594, 112, 59, 1, 10613, 4, 2, 59, 102, 15733, 15735, 1, 8677, 115, 59, 1, 10528, 59, 1, 10547, 115, 59, 1, 10526, 107, 59, 1, 8618, 112, 59, 1, 8620, 108, 59, 1, 10565, 105, 109, 59, 1, 10612, 108, 59, 1, 8611, 59, 1, 8605, 4, 2, 97, 105, 15776, 15781, 105, 108, 59, 1, 10522, 111, 4, 2, 59, 110, 15788, 15790, 1, 8758, 97, 108, 115, 59, 1, 8474, 4, 3, 97, 98, 114, 15804, 15809, 15814, 114, 114, 59, 1, 10509, 114, 107, 59, 1, 10099, 4, 2, 97, 107, 15820, 15833, 99, 4, 2, 101, 107, 15827, 15830, 59, 1, 125, 59, 1, 93, 4, 2, 101, 115, 15839, 15842, 59, 1, 10636, 108, 4, 2, 100, 117, 15849, 15852, 59, 1, 10638, 59, 1, 10640, 4, 4, 97, 101, 117, 121, 15865, 15871, 15886, 15890, 114, 111, 110, 59, 1, 345, 4, 2, 100, 105, 15877, 15882, 105, 108, 59, 1, 343, 108, 59, 1, 8969, 98, 59, 1, 125, 59, 1, 1088, 4, 4, 99, 108, 113, 115, 15903, 15907, 15914, 15927, 97, 59, 1, 10551, 100, 104, 97, 114, 59, 1, 10601, 117, 111, 4, 2, 59, 114, 15922, 15924, 1, 8221, 59, 1, 8221, 104, 59, 1, 8627, 4, 3, 97, 99, 103, 15939, 15966, 15970, 108, 4, 4, 59, 105, 112, 115, 15950, 15952, 15957, 15963, 1, 8476, 110, 101, 59, 1, 8475, 97, 114, 116, 59, 1, 8476, 59, 1, 8477, 116, 59, 1, 9645, 5, 174, 1, 59, 15975, 1, 174, 4, 3, 105, 108, 114, 15985, 15991, 15997, 115, 104, 116, 59, 1, 10621, 111, 111, 114, 59, 1, 8971, 59, 3, 55349, 56623, 4, 2, 97, 111, 16007, 16028, 114, 4, 2, 100, 117, 16014, 16017, 59, 1, 8641, 4, 2, 59, 108, 16023, 16025, 1, 8640, 59, 1, 10604, 4, 2, 59, 118, 16034, 16036, 1, 961, 59, 1, 1009, 4, 3, 103, 110, 115, 16047, 16167, 16171, 104, 116, 4, 6, 97, 104, 108, 114, 115, 116, 16063, 16081, 16103, 16130, 16143, 16155, 114, 114, 111, 119, 4, 2, 59, 116, 16073, 16075, 1, 8594, 97, 105, 108, 59, 1, 8611, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 16093, 16099, 111, 119, 110, 59, 1, 8641, 112, 59, 1, 8640, 101, 102, 116, 4, 2, 97, 104, 16112, 16120, 114, 114, 111, 119, 115, 59, 1, 8644, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8652, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8649, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8605, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8908, 103, 59, 1, 730, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8787, 4, 3, 97, 104, 109, 16191, 16196, 16201, 114, 114, 59, 1, 8644, 97, 114, 59, 1, 8652, 59, 1, 8207, 111, 117, 115, 116, 4, 2, 59, 97, 16214, 16216, 1, 9137, 99, 104, 101, 59, 1, 9137, 109, 105, 100, 59, 1, 10990, 4, 4, 97, 98, 112, 116, 16238, 16252, 16257, 16278, 4, 2, 110, 114, 16244, 16248, 103, 59, 1, 10221, 114, 59, 1, 8702, 114, 107, 59, 1, 10215, 4, 3, 97, 102, 108, 16265, 16269, 16273, 114, 59, 1, 10630, 59, 3, 55349, 56675, 117, 115, 59, 1, 10798, 105, 109, 101, 115, 59, 1, 10805, 4, 2, 97, 112, 16291, 16304, 114, 4, 2, 59, 103, 16298, 16300, 1, 41, 116, 59, 1, 10644, 111, 108, 105, 110, 116, 59, 1, 10770, 97, 114, 114, 59, 1, 8649, 4, 4, 97, 99, 104, 113, 16328, 16334, 16339, 16342, 113, 117, 111, 59, 1, 8250, 114, 59, 3, 55349, 56519, 59, 1, 8625, 4, 2, 98, 117, 16348, 16351, 59, 1, 93, 111, 4, 2, 59, 114, 16358, 16360, 1, 8217, 59, 1, 8217, 4, 3, 104, 105, 114, 16371, 16377, 16383, 114, 101, 101, 59, 1, 8908, 109, 101, 115, 59, 1, 8906, 105, 4, 4, 59, 101, 102, 108, 16394, 16396, 16399, 16402, 1, 9657, 59, 1, 8885, 59, 1, 9656, 116, 114, 105, 59, 1, 10702, 108, 117, 104, 97, 114, 59, 1, 10600, 59, 1, 8478, 4, 19, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 111, 112, 113, 114, 115, 116, 117, 119, 122, 16459, 16466, 16472, 16572, 16590, 16672, 16687, 16746, 16844, 16850, 16924, 16963, 16988, 17115, 17121, 17154, 17206, 17614, 17656, 99, 117, 116, 101, 59, 1, 347, 113, 117, 111, 59, 1, 8218, 4, 10, 59, 69, 97, 99, 101, 105, 110, 112, 115, 121, 16494, 16496, 16499, 16513, 16518, 16531, 16536, 16556, 16564, 16569, 1, 8827, 59, 1, 10932, 4, 2, 112, 114, 16505, 16508, 59, 1, 10936, 111, 110, 59, 1, 353, 117, 101, 59, 1, 8829, 4, 2, 59, 100, 16524, 16526, 1, 10928, 105, 108, 59, 1, 351, 114, 99, 59, 1, 349, 4, 3, 69, 97, 115, 16544, 16547, 16551, 59, 1, 10934, 112, 59, 1, 10938, 105, 109, 59, 1, 8937, 111, 108, 105, 110, 116, 59, 1, 10771, 105, 109, 59, 1, 8831, 59, 1, 1089, 111, 116, 4, 3, 59, 98, 101, 16582, 16584, 16587, 1, 8901, 59, 1, 8865, 59, 1, 10854, 4, 7, 65, 97, 99, 109, 115, 116, 120, 16606, 16611, 16634, 16642, 16646, 16652, 16668, 114, 114, 59, 1, 8664, 114, 4, 2, 104, 114, 16618, 16622, 107, 59, 1, 10533, 4, 2, 59, 111, 16628, 16630, 1, 8600, 119, 59, 1, 8600, 116, 5, 167, 1, 59, 16640, 1, 167, 105, 59, 1, 59, 119, 97, 114, 59, 1, 10537, 109, 4, 2, 105, 110, 16659, 16665, 110, 117, 115, 59, 1, 8726, 59, 1, 8726, 116, 59, 1, 10038, 114, 4, 2, 59, 111, 16679, 16682, 3, 55349, 56624, 119, 110, 59, 1, 8994, 4, 4, 97, 99, 111, 121, 16697, 16702, 16716, 16739, 114, 112, 59, 1, 9839, 4, 2, 104, 121, 16708, 16713, 99, 121, 59, 1, 1097, 59, 1, 1096, 114, 116, 4, 2, 109, 112, 16724, 16729, 105, 100, 59, 1, 8739, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8741, 5, 173, 1, 59, 16744, 1, 173, 4, 2, 103, 109, 16752, 16770, 109, 97, 4, 3, 59, 102, 118, 16762, 16764, 16767, 1, 963, 59, 1, 962, 59, 1, 962, 4, 8, 59, 100, 101, 103, 108, 110, 112, 114, 16788, 16790, 16795, 16806, 16817, 16828, 16832, 16838, 1, 8764, 111, 116, 59, 1, 10858, 4, 2, 59, 113, 16801, 16803, 1, 8771, 59, 1, 8771, 4, 2, 59, 69, 16812, 16814, 1, 10910, 59, 1, 10912, 4, 2, 59, 69, 16823, 16825, 1, 10909, 59, 1, 10911, 101, 59, 1, 8774, 108, 117, 115, 59, 1, 10788, 97, 114, 114, 59, 1, 10610, 97, 114, 114, 59, 1, 8592, 4, 4, 97, 101, 105, 116, 16860, 16883, 16891, 16904, 4, 2, 108, 115, 16866, 16878, 108, 115, 101, 116, 109, 105, 110, 117, 115, 59, 1, 8726, 104, 112, 59, 1, 10803, 112, 97, 114, 115, 108, 59, 1, 10724, 4, 2, 100, 108, 16897, 16900, 59, 1, 8739, 101, 59, 1, 8995, 4, 2, 59, 101, 16910, 16912, 1, 10922, 4, 2, 59, 115, 16918, 16920, 1, 10924, 59, 3, 10924, 65024, 4, 3, 102, 108, 112, 16932, 16938, 16958, 116, 99, 121, 59, 1, 1100, 4, 2, 59, 98, 16944, 16946, 1, 47, 4, 2, 59, 97, 16952, 16954, 1, 10692, 114, 59, 1, 9023, 102, 59, 3, 55349, 56676, 97, 4, 2, 100, 114, 16970, 16985, 101, 115, 4, 2, 59, 117, 16978, 16980, 1, 9824, 105, 116, 59, 1, 9824, 59, 1, 8741, 4, 3, 99, 115, 117, 16996, 17028, 17089, 4, 2, 97, 117, 17002, 17015, 112, 4, 2, 59, 115, 17009, 17011, 1, 8851, 59, 3, 8851, 65024, 112, 4, 2, 59, 115, 17022, 17024, 1, 8852, 59, 3, 8852, 65024, 117, 4, 2, 98, 112, 17035, 17062, 4, 3, 59, 101, 115, 17043, 17045, 17048, 1, 8847, 59, 1, 8849, 101, 116, 4, 2, 59, 101, 17056, 17058, 1, 8847, 113, 59, 1, 8849, 4, 3, 59, 101, 115, 17070, 17072, 17075, 1, 8848, 59, 1, 8850, 101, 116, 4, 2, 59, 101, 17083, 17085, 1, 8848, 113, 59, 1, 8850, 4, 3, 59, 97, 102, 17097, 17099, 17112, 1, 9633, 114, 4, 2, 101, 102, 17106, 17109, 59, 1, 9633, 59, 1, 9642, 59, 1, 9642, 97, 114, 114, 59, 1, 8594, 4, 4, 99, 101, 109, 116, 17131, 17136, 17142, 17148, 114, 59, 3, 55349, 56520, 116, 109, 110, 59, 1, 8726, 105, 108, 101, 59, 1, 8995, 97, 114, 102, 59, 1, 8902, 4, 2, 97, 114, 17160, 17172, 114, 4, 2, 59, 102, 17167, 17169, 1, 9734, 59, 1, 9733, 4, 2, 97, 110, 17178, 17202, 105, 103, 104, 116, 4, 2, 101, 112, 17188, 17197, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 104, 105, 59, 1, 981, 115, 59, 1, 175, 4, 5, 98, 99, 109, 110, 112, 17218, 17351, 17420, 17423, 17427, 4, 9, 59, 69, 100, 101, 109, 110, 112, 114, 115, 17238, 17240, 17243, 17248, 17261, 17267, 17279, 17285, 17291, 1, 8834, 59, 1, 10949, 111, 116, 59, 1, 10941, 4, 2, 59, 100, 17254, 17256, 1, 8838, 111, 116, 59, 1, 10947, 117, 108, 116, 59, 1, 10945, 4, 2, 69, 101, 17273, 17276, 59, 1, 10955, 59, 1, 8842, 108, 117, 115, 59, 1, 10943, 97, 114, 114, 59, 1, 10617, 4, 3, 101, 105, 117, 17299, 17335, 17339, 116, 4, 3, 59, 101, 110, 17308, 17310, 17322, 1, 8834, 113, 4, 2, 59, 113, 17317, 17319, 1, 8838, 59, 1, 10949, 101, 113, 4, 2, 59, 113, 17330, 17332, 1, 8842, 59, 1, 10955, 109, 59, 1, 10951, 4, 2, 98, 112, 17345, 17348, 59, 1, 10965, 59, 1, 10963, 99, 4, 6, 59, 97, 99, 101, 110, 115, 17366, 17368, 17376, 17385, 17389, 17415, 1, 8827, 112, 112, 114, 111, 120, 59, 1, 10936, 117, 114, 108, 121, 101, 113, 59, 1, 8829, 113, 59, 1, 10928, 4, 3, 97, 101, 115, 17397, 17405, 17410, 112, 112, 114, 111, 120, 59, 1, 10938, 113, 113, 59, 1, 10934, 105, 109, 59, 1, 8937, 105, 109, 59, 1, 8831, 59, 1, 8721, 103, 59, 1, 9834, 4, 13, 49, 50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 17455, 17462, 17469, 17476, 17478, 17481, 17496, 17509, 17524, 17530, 17536, 17548, 17554, 5, 185, 1, 59, 17460, 1, 185, 5, 178, 1, 59, 17467, 1, 178, 5, 179, 1, 59, 17474, 1, 179, 1, 8835, 59, 1, 10950, 4, 2, 111, 115, 17487, 17491, 116, 59, 1, 10942, 117, 98, 59, 1, 10968, 4, 2, 59, 100, 17502, 17504, 1, 8839, 111, 116, 59, 1, 10948, 115, 4, 2, 111, 117, 17516, 17520, 108, 59, 1, 10185, 98, 59, 1, 10967, 97, 114, 114, 59, 1, 10619, 117, 108, 116, 59, 1, 10946, 4, 2, 69, 101, 17542, 17545, 59, 1, 10956, 59, 1, 8843, 108, 117, 115, 59, 1, 10944, 4, 3, 101, 105, 117, 17562, 17598, 17602, 116, 4, 3, 59, 101, 110, 17571, 17573, 17585, 1, 8835, 113, 4, 2, 59, 113, 17580, 17582, 1, 8839, 59, 1, 10950, 101, 113, 4, 2, 59, 113, 17593, 17595, 1, 8843, 59, 1, 10956, 109, 59, 1, 10952, 4, 2, 98, 112, 17608, 17611, 59, 1, 10964, 59, 1, 10966, 4, 3, 65, 97, 110, 17622, 17627, 17650, 114, 114, 59, 1, 8665, 114, 4, 2, 104, 114, 17634, 17638, 107, 59, 1, 10534, 4, 2, 59, 111, 17644, 17646, 1, 8601, 119, 59, 1, 8601, 119, 97, 114, 59, 1, 10538, 108, 105, 103, 5, 223, 1, 59, 17664, 1, 223, 4, 13, 97, 98, 99, 100, 101, 102, 104, 105, 111, 112, 114, 115, 119, 17694, 17709, 17714, 17737, 17742, 17749, 17754, 17860, 17905, 17957, 17964, 18090, 18122, 4, 2, 114, 117, 17700, 17706, 103, 101, 116, 59, 1, 8982, 59, 1, 964, 114, 107, 59, 1, 9140, 4, 3, 97, 101, 121, 17722, 17728, 17734, 114, 111, 110, 59, 1, 357, 100, 105, 108, 59, 1, 355, 59, 1, 1090, 111, 116, 59, 1, 8411, 108, 114, 101, 99, 59, 1, 8981, 114, 59, 3, 55349, 56625, 4, 4, 101, 105, 107, 111, 17764, 17805, 17836, 17851, 4, 2, 114, 116, 17770, 17786, 101, 4, 2, 52, 102, 17777, 17780, 59, 1, 8756, 111, 114, 101, 59, 1, 8756, 97, 4, 3, 59, 115, 118, 17795, 17797, 17802, 1, 952, 121, 109, 59, 1, 977, 59, 1, 977, 4, 2, 99, 110, 17811, 17831, 107, 4, 2, 97, 115, 17818, 17826, 112, 112, 114, 111, 120, 59, 1, 8776, 105, 109, 59, 1, 8764, 115, 112, 59, 1, 8201, 4, 2, 97, 115, 17842, 17846, 112, 59, 1, 8776, 105, 109, 59, 1, 8764, 114, 110, 5, 254, 1, 59, 17858, 1, 254, 4, 3, 108, 109, 110, 17868, 17873, 17901, 100, 101, 59, 1, 732, 101, 115, 5, 215, 3, 59, 98, 100, 17884, 17886, 17898, 1, 215, 4, 2, 59, 97, 17892, 17894, 1, 8864, 114, 59, 1, 10801, 59, 1, 10800, 116, 59, 1, 8749, 4, 3, 101, 112, 115, 17913, 17917, 17953, 97, 59, 1, 10536, 4, 4, 59, 98, 99, 102, 17927, 17929, 17934, 17939, 1, 8868, 111, 116, 59, 1, 9014, 105, 114, 59, 1, 10993, 4, 2, 59, 111, 17945, 17948, 3, 55349, 56677, 114, 107, 59, 1, 10970, 97, 59, 1, 10537, 114, 105, 109, 101, 59, 1, 8244, 4, 3, 97, 105, 112, 17972, 17977, 18082, 100, 101, 59, 1, 8482, 4, 7, 97, 100, 101, 109, 112, 115, 116, 17993, 18051, 18056, 18059, 18066, 18072, 18076, 110, 103, 108, 101, 4, 5, 59, 100, 108, 113, 114, 18009, 18011, 18017, 18032, 18035, 1, 9653, 111, 119, 110, 59, 1, 9663, 101, 102, 116, 4, 2, 59, 101, 18026, 18028, 1, 9667, 113, 59, 1, 8884, 59, 1, 8796, 105, 103, 104, 116, 4, 2, 59, 101, 18045, 18047, 1, 9657, 113, 59, 1, 8885, 111, 116, 59, 1, 9708, 59, 1, 8796, 105, 110, 117, 115, 59, 1, 10810, 108, 117, 115, 59, 1, 10809, 98, 59, 1, 10701, 105, 109, 101, 59, 1, 10811, 101, 122, 105, 117, 109, 59, 1, 9186, 4, 3, 99, 104, 116, 18098, 18111, 18116, 4, 2, 114, 121, 18104, 18108, 59, 3, 55349, 56521, 59, 1, 1094, 99, 121, 59, 1, 1115, 114, 111, 107, 59, 1, 359, 4, 2, 105, 111, 18128, 18133, 120, 116, 59, 1, 8812, 104, 101, 97, 100, 4, 2, 108, 114, 18143, 18154, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8606, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8608, 4, 18, 65, 72, 97, 98, 99, 100, 102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 18204, 18209, 18214, 18234, 18250, 18268, 18292, 18308, 18319, 18343, 18379, 18397, 18413, 18504, 18547, 18553, 18584, 18603, 114, 114, 59, 1, 8657, 97, 114, 59, 1, 10595, 4, 2, 99, 114, 18220, 18230, 117, 116, 101, 5, 250, 1, 59, 18228, 1, 250, 114, 59, 1, 8593, 114, 4, 2, 99, 101, 18241, 18245, 121, 59, 1, 1118, 118, 101, 59, 1, 365, 4, 2, 105, 121, 18256, 18265, 114, 99, 5, 251, 1, 59, 18263, 1, 251, 59, 1, 1091, 4, 3, 97, 98, 104, 18276, 18281, 18287, 114, 114, 59, 1, 8645, 108, 97, 99, 59, 1, 369, 97, 114, 59, 1, 10606, 4, 2, 105, 114, 18298, 18304, 115, 104, 116, 59, 1, 10622, 59, 3, 55349, 56626, 114, 97, 118, 101, 5, 249, 1, 59, 18317, 1, 249, 4, 2, 97, 98, 18325, 18338, 114, 4, 2, 108, 114, 18332, 18335, 59, 1, 8639, 59, 1, 8638, 108, 107, 59, 1, 9600, 4, 2, 99, 116, 18349, 18374, 4, 2, 111, 114, 18355, 18369, 114, 110, 4, 2, 59, 101, 18363, 18365, 1, 8988, 114, 59, 1, 8988, 111, 112, 59, 1, 8975, 114, 105, 59, 1, 9720, 4, 2, 97, 108, 18385, 18390, 99, 114, 59, 1, 363, 5, 168, 1, 59, 18395, 1, 168, 4, 2, 103, 112, 18403, 18408, 111, 110, 59, 1, 371, 102, 59, 3, 55349, 56678, 4, 6, 97, 100, 104, 108, 115, 117, 18427, 18434, 18445, 18470, 18475, 18494, 114, 114, 111, 119, 59, 1, 8593, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8597, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 18457, 18463, 101, 102, 116, 59, 1, 8639, 105, 103, 104, 116, 59, 1, 8638, 117, 115, 59, 1, 8846, 105, 4, 3, 59, 104, 108, 18484, 18486, 18489, 1, 965, 59, 1, 978, 111, 110, 59, 1, 965, 112, 97, 114, 114, 111, 119, 115, 59, 1, 8648, 4, 3, 99, 105, 116, 18512, 18537, 18542, 4, 2, 111, 114, 18518, 18532, 114, 110, 4, 2, 59, 101, 18526, 18528, 1, 8989, 114, 59, 1, 8989, 111, 112, 59, 1, 8974, 110, 103, 59, 1, 367, 114, 105, 59, 1, 9721, 99, 114, 59, 3, 55349, 56522, 4, 3, 100, 105, 114, 18561, 18566, 18572, 111, 116, 59, 1, 8944, 108, 100, 101, 59, 1, 361, 105, 4, 2, 59, 102, 18579, 18581, 1, 9653, 59, 1, 9652, 4, 2, 97, 109, 18590, 18595, 114, 114, 59, 1, 8648, 108, 5, 252, 1, 59, 18601, 1, 252, 97, 110, 103, 108, 101, 59, 1, 10663, 4, 15, 65, 66, 68, 97, 99, 100, 101, 102, 108, 110, 111, 112, 114, 115, 122, 18643, 18648, 18661, 18667, 18847, 18851, 18857, 18904, 18909, 18915, 18931, 18937, 18943, 18949, 18996, 114, 114, 59, 1, 8661, 97, 114, 4, 2, 59, 118, 18656, 18658, 1, 10984, 59, 1, 10985, 97, 115, 104, 59, 1, 8872, 4, 2, 110, 114, 18673, 18679, 103, 114, 116, 59, 1, 10652, 4, 7, 101, 107, 110, 112, 114, 115, 116, 18695, 18704, 18711, 18720, 18742, 18754, 18810, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 97, 112, 112, 97, 59, 1, 1008, 111, 116, 104, 105, 110, 103, 59, 1, 8709, 4, 3, 104, 105, 114, 18728, 18732, 18735, 105, 59, 1, 981, 59, 1, 982, 111, 112, 116, 111, 59, 1, 8733, 4, 2, 59, 104, 18748, 18750, 1, 8597, 111, 59, 1, 1009, 4, 2, 105, 117, 18760, 18766, 103, 109, 97, 59, 1, 962, 4, 2, 98, 112, 18772, 18791, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18784, 18787, 3, 8842, 65024, 59, 3, 10955, 65024, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18803, 18806, 3, 8843, 65024, 59, 3, 10956, 65024, 4, 2, 104, 114, 18816, 18822, 101, 116, 97, 59, 1, 977, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 18834, 18840, 101, 102, 116, 59, 1, 8882, 105, 103, 104, 116, 59, 1, 8883, 121, 59, 1, 1074, 97, 115, 104, 59, 1, 8866, 4, 3, 101, 108, 114, 18865, 18884, 18890, 4, 3, 59, 98, 101, 18873, 18875, 18880, 1, 8744, 97, 114, 59, 1, 8891, 113, 59, 1, 8794, 108, 105, 112, 59, 1, 8942, 4, 2, 98, 116, 18896, 18901, 97, 114, 59, 1, 124, 59, 1, 124, 114, 59, 3, 55349, 56627, 116, 114, 105, 59, 1, 8882, 115, 117, 4, 2, 98, 112, 18923, 18927, 59, 3, 8834, 8402, 59, 3, 8835, 8402, 112, 102, 59, 3, 55349, 56679, 114, 111, 112, 59, 1, 8733, 116, 114, 105, 59, 1, 8883, 4, 2, 99, 117, 18955, 18960, 114, 59, 3, 55349, 56523, 4, 2, 98, 112, 18966, 18981, 110, 4, 2, 69, 101, 18973, 18977, 59, 3, 10955, 65024, 59, 3, 8842, 65024, 110, 4, 2, 69, 101, 18988, 18992, 59, 3, 10956, 65024, 59, 3, 8843, 65024, 105, 103, 122, 97, 103, 59, 1, 10650, 4, 7, 99, 101, 102, 111, 112, 114, 115, 19020, 19026, 19061, 19066, 19072, 19075, 19089, 105, 114, 99, 59, 1, 373, 4, 2, 100, 105, 19032, 19055, 4, 2, 98, 103, 19038, 19043, 97, 114, 59, 1, 10847, 101, 4, 2, 59, 113, 19050, 19052, 1, 8743, 59, 1, 8793, 101, 114, 112, 59, 1, 8472, 114, 59, 3, 55349, 56628, 112, 102, 59, 3, 55349, 56680, 59, 1, 8472, 4, 2, 59, 101, 19081, 19083, 1, 8768, 97, 116, 104, 59, 1, 8768, 99, 114, 59, 3, 55349, 56524, 4, 14, 99, 100, 102, 104, 105, 108, 109, 110, 111, 114, 115, 117, 118, 119, 19125, 19146, 19152, 19157, 19173, 19176, 19192, 19197, 19202, 19236, 19252, 19269, 19286, 19291, 4, 3, 97, 105, 117, 19133, 19137, 19142, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 116, 114, 105, 59, 1, 9661, 114, 59, 3, 55349, 56629, 4, 2, 65, 97, 19163, 19168, 114, 114, 59, 1, 10234, 114, 114, 59, 1, 10231, 59, 1, 958, 4, 2, 65, 97, 19182, 19187, 114, 114, 59, 1, 10232, 114, 114, 59, 1, 10229, 97, 112, 59, 1, 10236, 105, 115, 59, 1, 8955, 4, 3, 100, 112, 116, 19210, 19215, 19230, 111, 116, 59, 1, 10752, 4, 2, 102, 108, 19221, 19225, 59, 3, 55349, 56681, 117, 115, 59, 1, 10753, 105, 109, 101, 59, 1, 10754, 4, 2, 65, 97, 19242, 19247, 114, 114, 59, 1, 10233, 114, 114, 59, 1, 10230, 4, 2, 99, 113, 19258, 19263, 114, 59, 3, 55349, 56525, 99, 117, 112, 59, 1, 10758, 4, 2, 112, 116, 19275, 19281, 108, 117, 115, 59, 1, 10756, 114, 105, 59, 1, 9651, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 19316, 19335, 19349, 19357, 19362, 19367, 19373, 19379, 99, 4, 2, 117, 121, 19323, 19332, 116, 101, 5, 253, 1, 59, 19330, 1, 253, 59, 1, 1103, 4, 2, 105, 121, 19341, 19346, 114, 99, 59, 1, 375, 59, 1, 1099, 110, 5, 165, 1, 59, 19355, 1, 165, 114, 59, 3, 55349, 56630, 99, 121, 59, 1, 1111, 112, 102, 59, 3, 55349, 56682, 99, 114, 59, 3, 55349, 56526, 4, 2, 99, 109, 19385, 19389, 121, 59, 1, 1102, 108, 5, 255, 1, 59, 19395, 1, 255, 4, 10, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 19419, 19426, 19441, 19446, 19462, 19467, 19472, 19480, 19486, 19492, 99, 117, 116, 101, 59, 1, 378, 4, 2, 97, 121, 19432, 19438, 114, 111, 110, 59, 1, 382, 59, 1, 1079, 111, 116, 59, 1, 380, 4, 2, 101, 116, 19452, 19458, 116, 114, 102, 59, 1, 8488, 97, 59, 1, 950, 114, 59, 3, 55349, 56631, 99, 121, 59, 1, 1078, 103, 114, 97, 114, 114, 59, 1, 8669, 112, 102, 59, 3, 55349, 56683, 99, 114, 59, 3, 55349, 56527, 4, 2, 106, 110, 19498, 19501, 59, 1, 8205, 106, 59, 1, 8204]);
  const Preprocessor = preprocessor;
  const unicode$1 = unicode$3;
  const neTree = namedEntityData;
  const ERR$1 = errorCodes;
  const $$5 = unicode$1.CODE_POINTS;
  const $$ = unicode$1.CODE_POINT_SEQUENCES;
  const C1_CONTROLS_REFERENCE_REPLACEMENTS = {
    128: 8364,
    130: 8218,
    131: 402,
    132: 8222,
    133: 8230,
    134: 8224,
    135: 8225,
    136: 710,
    137: 8240,
    138: 352,
    139: 8249,
    140: 338,
    142: 381,
    145: 8216,
    146: 8217,
    147: 8220,
    148: 8221,
    149: 8226,
    150: 8211,
    151: 8212,
    152: 732,
    153: 8482,
    154: 353,
    155: 8250,
    156: 339,
    158: 382,
    159: 376
  };
  const HAS_DATA_FLAG = 1 << 0;
  const DATA_DUPLET_FLAG = 1 << 1;
  const HAS_BRANCHES_FLAG = 1 << 2;
  const MAX_BRANCH_MARKER_VALUE = HAS_DATA_FLAG | DATA_DUPLET_FLAG | HAS_BRANCHES_FLAG;
  const DATA_STATE = "DATA_STATE";
  const RCDATA_STATE = "RCDATA_STATE";
  const RAWTEXT_STATE = "RAWTEXT_STATE";
  const SCRIPT_DATA_STATE = "SCRIPT_DATA_STATE";
  const PLAINTEXT_STATE = "PLAINTEXT_STATE";
  const TAG_OPEN_STATE = "TAG_OPEN_STATE";
  const END_TAG_OPEN_STATE = "END_TAG_OPEN_STATE";
  const TAG_NAME_STATE = "TAG_NAME_STATE";
  const RCDATA_LESS_THAN_SIGN_STATE = "RCDATA_LESS_THAN_SIGN_STATE";
  const RCDATA_END_TAG_OPEN_STATE = "RCDATA_END_TAG_OPEN_STATE";
  const RCDATA_END_TAG_NAME_STATE = "RCDATA_END_TAG_NAME_STATE";
  const RAWTEXT_LESS_THAN_SIGN_STATE = "RAWTEXT_LESS_THAN_SIGN_STATE";
  const RAWTEXT_END_TAG_OPEN_STATE = "RAWTEXT_END_TAG_OPEN_STATE";
  const RAWTEXT_END_TAG_NAME_STATE = "RAWTEXT_END_TAG_NAME_STATE";
  const SCRIPT_DATA_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_LESS_THAN_SIGN_STATE";
  const SCRIPT_DATA_END_TAG_OPEN_STATE = "SCRIPT_DATA_END_TAG_OPEN_STATE";
  const SCRIPT_DATA_END_TAG_NAME_STATE = "SCRIPT_DATA_END_TAG_NAME_STATE";
  const SCRIPT_DATA_ESCAPE_START_STATE = "SCRIPT_DATA_ESCAPE_START_STATE";
  const SCRIPT_DATA_ESCAPE_START_DASH_STATE = "SCRIPT_DATA_ESCAPE_START_DASH_STATE";
  const SCRIPT_DATA_ESCAPED_STATE = "SCRIPT_DATA_ESCAPED_STATE";
  const SCRIPT_DATA_ESCAPED_DASH_STATE = "SCRIPT_DATA_ESCAPED_DASH_STATE";
  const SCRIPT_DATA_ESCAPED_DASH_DASH_STATE = "SCRIPT_DATA_ESCAPED_DASH_DASH_STATE";
  const SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE";
  const SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE";
  const SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE = "SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE";
  const SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE = "SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE";
  const SCRIPT_DATA_DOUBLE_ESCAPED_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_STATE";
  const SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE";
  const SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE";
  const SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE";
  const SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE = "SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE";
  const BEFORE_ATTRIBUTE_NAME_STATE = "BEFORE_ATTRIBUTE_NAME_STATE";
  const ATTRIBUTE_NAME_STATE = "ATTRIBUTE_NAME_STATE";
  const AFTER_ATTRIBUTE_NAME_STATE = "AFTER_ATTRIBUTE_NAME_STATE";
  const BEFORE_ATTRIBUTE_VALUE_STATE = "BEFORE_ATTRIBUTE_VALUE_STATE";
  const ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE = "ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE";
  const ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE = "ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE";
  const ATTRIBUTE_VALUE_UNQUOTED_STATE = "ATTRIBUTE_VALUE_UNQUOTED_STATE";
  const AFTER_ATTRIBUTE_VALUE_QUOTED_STATE = "AFTER_ATTRIBUTE_VALUE_QUOTED_STATE";
  const SELF_CLOSING_START_TAG_STATE = "SELF_CLOSING_START_TAG_STATE";
  const BOGUS_COMMENT_STATE = "BOGUS_COMMENT_STATE";
  const MARKUP_DECLARATION_OPEN_STATE = "MARKUP_DECLARATION_OPEN_STATE";
  const COMMENT_START_STATE = "COMMENT_START_STATE";
  const COMMENT_START_DASH_STATE = "COMMENT_START_DASH_STATE";
  const COMMENT_STATE = "COMMENT_STATE";
  const COMMENT_LESS_THAN_SIGN_STATE = "COMMENT_LESS_THAN_SIGN_STATE";
  const COMMENT_LESS_THAN_SIGN_BANG_STATE = "COMMENT_LESS_THAN_SIGN_BANG_STATE";
  const COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE = "COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE";
  const COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE";
  const COMMENT_END_DASH_STATE = "COMMENT_END_DASH_STATE";
  const COMMENT_END_STATE = "COMMENT_END_STATE";
  const COMMENT_END_BANG_STATE = "COMMENT_END_BANG_STATE";
  const DOCTYPE_STATE = "DOCTYPE_STATE";
  const BEFORE_DOCTYPE_NAME_STATE = "BEFORE_DOCTYPE_NAME_STATE";
  const DOCTYPE_NAME_STATE = "DOCTYPE_NAME_STATE";
  const AFTER_DOCTYPE_NAME_STATE = "AFTER_DOCTYPE_NAME_STATE";
  const AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE = "AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE";
  const BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE";
  const DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE";
  const DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE";
  const AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE";
  const BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE";
  const AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE = "AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE";
  const BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE";
  const DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE";
  const DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE";
  const AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE";
  const BOGUS_DOCTYPE_STATE = "BOGUS_DOCTYPE_STATE";
  const CDATA_SECTION_STATE = "CDATA_SECTION_STATE";
  const CDATA_SECTION_BRACKET_STATE = "CDATA_SECTION_BRACKET_STATE";
  const CDATA_SECTION_END_STATE = "CDATA_SECTION_END_STATE";
  const CHARACTER_REFERENCE_STATE = "CHARACTER_REFERENCE_STATE";
  const NAMED_CHARACTER_REFERENCE_STATE = "NAMED_CHARACTER_REFERENCE_STATE";
  const AMBIGUOUS_AMPERSAND_STATE = "AMBIGUOS_AMPERSAND_STATE";
  const NUMERIC_CHARACTER_REFERENCE_STATE = "NUMERIC_CHARACTER_REFERENCE_STATE";
  const HEXADEMICAL_CHARACTER_REFERENCE_START_STATE = "HEXADEMICAL_CHARACTER_REFERENCE_START_STATE";
  const DECIMAL_CHARACTER_REFERENCE_START_STATE = "DECIMAL_CHARACTER_REFERENCE_START_STATE";
  const HEXADEMICAL_CHARACTER_REFERENCE_STATE = "HEXADEMICAL_CHARACTER_REFERENCE_STATE";
  const DECIMAL_CHARACTER_REFERENCE_STATE = "DECIMAL_CHARACTER_REFERENCE_STATE";
  const NUMERIC_CHARACTER_REFERENCE_END_STATE = "NUMERIC_CHARACTER_REFERENCE_END_STATE";
  function isWhitespace(cp) {
    return cp === $$5.SPACE || cp === $$5.LINE_FEED || cp === $$5.TABULATION || cp === $$5.FORM_FEED;
  }
  function isAsciiDigit(cp) {
    return cp >= $$5.DIGIT_0 && cp <= $$5.DIGIT_9;
  }
  function isAsciiUpper(cp) {
    return cp >= $$5.LATIN_CAPITAL_A && cp <= $$5.LATIN_CAPITAL_Z;
  }
  function isAsciiLower(cp) {
    return cp >= $$5.LATIN_SMALL_A && cp <= $$5.LATIN_SMALL_Z;
  }
  function isAsciiLetter(cp) {
    return isAsciiLower(cp) || isAsciiUpper(cp);
  }
  function isAsciiAlphaNumeric(cp) {
    return isAsciiLetter(cp) || isAsciiDigit(cp);
  }
  function isAsciiUpperHexDigit(cp) {
    return cp >= $$5.LATIN_CAPITAL_A && cp <= $$5.LATIN_CAPITAL_F;
  }
  function isAsciiLowerHexDigit(cp) {
    return cp >= $$5.LATIN_SMALL_A && cp <= $$5.LATIN_SMALL_F;
  }
  function isAsciiHexDigit(cp) {
    return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
  }
  function toAsciiLowerCodePoint(cp) {
    return cp + 32;
  }
  function toChar(cp) {
    if (cp <= 65535) {
      return String.fromCharCode(cp);
    }
    cp -= 65536;
    return String.fromCharCode(cp >>> 10 & 1023 | 55296) + String.fromCharCode(56320 | cp & 1023);
  }
  function toAsciiLowerChar(cp) {
    return String.fromCharCode(toAsciiLowerCodePoint(cp));
  }
  function findNamedEntityTreeBranch(nodeIx, cp) {
    const branchCount = neTree[++nodeIx];
    let lo = ++nodeIx;
    let hi = lo + branchCount - 1;
    while (lo <= hi) {
      const mid = lo + hi >>> 1;
      const midCp = neTree[mid];
      if (midCp < cp) {
        lo = mid + 1;
      } else if (midCp > cp) {
        hi = mid - 1;
      } else {
        return neTree[mid + branchCount];
      }
    }
    return -1;
  }
  let Tokenizer$4 = class Tokenizer2 {
    constructor() {
      this.preprocessor = new Preprocessor();
      this.tokenQueue = [];
      this.allowCDATA = false;
      this.state = DATA_STATE;
      this.returnState = "";
      this.charRefCode = -1;
      this.tempBuff = [];
      this.lastStartTagName = "";
      this.consumedAfterSnapshot = -1;
      this.active = false;
      this.currentCharacterToken = null;
      this.currentToken = null;
      this.currentAttr = null;
    }
    //Errors
    _err() {
    }
    _errOnNextCodePoint(err) {
      this._consume();
      this._err(err);
      this._unconsume();
    }
    //API
    getNextToken() {
      while (!this.tokenQueue.length && this.active) {
        this.consumedAfterSnapshot = 0;
        const cp = this._consume();
        if (!this._ensureHibernation()) {
          this[this.state](cp);
        }
      }
      return this.tokenQueue.shift();
    }
    write(chunk, isLastChunk) {
      this.active = true;
      this.preprocessor.write(chunk, isLastChunk);
    }
    insertHtmlAtCurrentPos(chunk) {
      this.active = true;
      this.preprocessor.insertHtmlAtCurrentPos(chunk);
    }
    //Hibernation
    _ensureHibernation() {
      if (this.preprocessor.endOfChunkHit) {
        for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--) {
          this.preprocessor.retreat();
        }
        this.active = false;
        this.tokenQueue.push({ type: Tokenizer2.HIBERNATION_TOKEN });
        return true;
      }
      return false;
    }
    //Consumption
    _consume() {
      this.consumedAfterSnapshot++;
      return this.preprocessor.advance();
    }
    _unconsume() {
      this.consumedAfterSnapshot--;
      this.preprocessor.retreat();
    }
    _reconsumeInState(state) {
      this.state = state;
      this._unconsume();
    }
    _consumeSequenceIfMatch(pattern, startCp, caseSensitive) {
      let consumedCount = 0;
      let isMatch = true;
      const patternLength = pattern.length;
      let patternPos = 0;
      let cp = startCp;
      let patternCp = void 0;
      for (; patternPos < patternLength; patternPos++) {
        if (patternPos > 0) {
          cp = this._consume();
          consumedCount++;
        }
        if (cp === $$5.EOF) {
          isMatch = false;
          break;
        }
        patternCp = pattern[patternPos];
        if (cp !== patternCp && (caseSensitive || cp !== toAsciiLowerCodePoint(patternCp))) {
          isMatch = false;
          break;
        }
      }
      if (!isMatch) {
        while (consumedCount--) {
          this._unconsume();
        }
      }
      return isMatch;
    }
    //Temp buffer
    _isTempBufferEqualToScriptString() {
      if (this.tempBuff.length !== $$.SCRIPT_STRING.length) {
        return false;
      }
      for (let i2 = 0; i2 < this.tempBuff.length; i2++) {
        if (this.tempBuff[i2] !== $$.SCRIPT_STRING[i2]) {
          return false;
        }
      }
      return true;
    }
    //Token creation
    _createStartTagToken() {
      this.currentToken = {
        type: Tokenizer2.START_TAG_TOKEN,
        tagName: "",
        selfClosing: false,
        ackSelfClosing: false,
        attrs: []
      };
    }
    _createEndTagToken() {
      this.currentToken = {
        type: Tokenizer2.END_TAG_TOKEN,
        tagName: "",
        selfClosing: false,
        attrs: []
      };
    }
    _createCommentToken() {
      this.currentToken = {
        type: Tokenizer2.COMMENT_TOKEN,
        data: ""
      };
    }
    _createDoctypeToken(initialName) {
      this.currentToken = {
        type: Tokenizer2.DOCTYPE_TOKEN,
        name: initialName,
        forceQuirks: false,
        publicId: null,
        systemId: null
      };
    }
    _createCharacterToken(type, ch) {
      this.currentCharacterToken = {
        type,
        chars: ch
      };
    }
    _createEOFToken() {
      this.currentToken = { type: Tokenizer2.EOF_TOKEN };
    }
    //Tag attributes
    _createAttr(attrNameFirstCh) {
      this.currentAttr = {
        name: attrNameFirstCh,
        value: ""
      };
    }
    _leaveAttrName(toState) {
      if (Tokenizer2.getTokenAttr(this.currentToken, this.currentAttr.name) === null) {
        this.currentToken.attrs.push(this.currentAttr);
      } else {
        this._err(ERR$1.duplicateAttribute);
      }
      this.state = toState;
    }
    _leaveAttrValue(toState) {
      this.state = toState;
    }
    //Token emission
    _emitCurrentToken() {
      this._emitCurrentCharacterToken();
      const ct = this.currentToken;
      this.currentToken = null;
      if (ct.type === Tokenizer2.START_TAG_TOKEN) {
        this.lastStartTagName = ct.tagName;
      } else if (ct.type === Tokenizer2.END_TAG_TOKEN) {
        if (ct.attrs.length > 0) {
          this._err(ERR$1.endTagWithAttributes);
        }
        if (ct.selfClosing) {
          this._err(ERR$1.endTagWithTrailingSolidus);
        }
      }
      this.tokenQueue.push(ct);
    }
    _emitCurrentCharacterToken() {
      if (this.currentCharacterToken) {
        this.tokenQueue.push(this.currentCharacterToken);
        this.currentCharacterToken = null;
      }
    }
    _emitEOFToken() {
      this._createEOFToken();
      this._emitCurrentToken();
    }
    //Characters emission
    //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
    //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
    //If we have a sequence of characters that belong to the same group, parser can process it
    //as a single solid character token.
    //So, there are 3 types of character tokens in parse5:
    //1)NULL_CHARACTER_TOKEN - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
    //2)WHITESPACE_CHARACTER_TOKEN - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
    //3)CHARACTER_TOKEN - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
    _appendCharToCurrentCharacterToken(type, ch) {
      if (this.currentCharacterToken && this.currentCharacterToken.type !== type) {
        this._emitCurrentCharacterToken();
      }
      if (this.currentCharacterToken) {
        this.currentCharacterToken.chars += ch;
      } else {
        this._createCharacterToken(type, ch);
      }
    }
    _emitCodePoint(cp) {
      let type = Tokenizer2.CHARACTER_TOKEN;
      if (isWhitespace(cp)) {
        type = Tokenizer2.WHITESPACE_CHARACTER_TOKEN;
      } else if (cp === $$5.NULL) {
        type = Tokenizer2.NULL_CHARACTER_TOKEN;
      }
      this._appendCharToCurrentCharacterToken(type, toChar(cp));
    }
    _emitSeveralCodePoints(codePoints) {
      for (let i2 = 0; i2 < codePoints.length; i2++) {
        this._emitCodePoint(codePoints[i2]);
      }
    }
    //NOTE: used then we emit character explicitly. This is always a non-whitespace and a non-null character.
    //So we can avoid additional checks here.
    _emitChars(ch) {
      this._appendCharToCurrentCharacterToken(Tokenizer2.CHARACTER_TOKEN, ch);
    }
    // Character reference helpers
    _matchNamedCharacterReference(startCp) {
      let result = null;
      let excess = 1;
      let i2 = findNamedEntityTreeBranch(0, startCp);
      this.tempBuff.push(startCp);
      while (i2 > -1) {
        const current = neTree[i2];
        const inNode = current < MAX_BRANCH_MARKER_VALUE;
        const nodeWithData = inNode && current & HAS_DATA_FLAG;
        if (nodeWithData) {
          result = current & DATA_DUPLET_FLAG ? [neTree[++i2], neTree[++i2]] : [neTree[++i2]];
          excess = 0;
        }
        const cp = this._consume();
        this.tempBuff.push(cp);
        excess++;
        if (cp === $$5.EOF) {
          break;
        }
        if (inNode) {
          i2 = current & HAS_BRANCHES_FLAG ? findNamedEntityTreeBranch(i2, cp) : -1;
        } else {
          i2 = cp === current ? ++i2 : -1;
        }
      }
      while (excess--) {
        this.tempBuff.pop();
        this._unconsume();
      }
      return result;
    }
    _isCharacterReferenceInAttribute() {
      return this.returnState === ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE || this.returnState === ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE || this.returnState === ATTRIBUTE_VALUE_UNQUOTED_STATE;
    }
    _isCharacterReferenceAttributeQuirk(withSemicolon) {
      if (!withSemicolon && this._isCharacterReferenceInAttribute()) {
        const nextCp = this._consume();
        this._unconsume();
        return nextCp === $$5.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);
      }
      return false;
    }
    _flushCodePointsConsumedAsCharacterReference() {
      if (this._isCharacterReferenceInAttribute()) {
        for (let i2 = 0; i2 < this.tempBuff.length; i2++) {
          this.currentAttr.value += toChar(this.tempBuff[i2]);
        }
      } else {
        this._emitSeveralCodePoints(this.tempBuff);
      }
      this.tempBuff = [];
    }
    // State machine
    // Data state
    //------------------------------------------------------------------
    [DATA_STATE](cp) {
      this.preprocessor.dropParsedChunk();
      if (cp === $$5.LESS_THAN_SIGN) {
        this.state = TAG_OPEN_STATE;
      } else if (cp === $$5.AMPERSAND) {
        this.returnState = DATA_STATE;
        this.state = CHARACTER_REFERENCE_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this._emitCodePoint(cp);
      } else if (cp === $$5.EOF) {
        this._emitEOFToken();
      } else {
        this._emitCodePoint(cp);
      }
    }
    //  RCDATA state
    //------------------------------------------------------------------
    [RCDATA_STATE](cp) {
      this.preprocessor.dropParsedChunk();
      if (cp === $$5.AMPERSAND) {
        this.returnState = RCDATA_STATE;
        this.state = CHARACTER_REFERENCE_STATE;
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.state = RCDATA_LESS_THAN_SIGN_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._emitEOFToken();
      } else {
        this._emitCodePoint(cp);
      }
    }
    // RAWTEXT state
    //------------------------------------------------------------------
    [RAWTEXT_STATE](cp) {
      this.preprocessor.dropParsedChunk();
      if (cp === $$5.LESS_THAN_SIGN) {
        this.state = RAWTEXT_LESS_THAN_SIGN_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._emitEOFToken();
      } else {
        this._emitCodePoint(cp);
      }
    }
    // Script data state
    //------------------------------------------------------------------
    [SCRIPT_DATA_STATE](cp) {
      this.preprocessor.dropParsedChunk();
      if (cp === $$5.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._emitEOFToken();
      } else {
        this._emitCodePoint(cp);
      }
    }
    // PLAINTEXT state
    //------------------------------------------------------------------
    [PLAINTEXT_STATE](cp) {
      this.preprocessor.dropParsedChunk();
      if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._emitEOFToken();
      } else {
        this._emitCodePoint(cp);
      }
    }
    // Tag open state
    //------------------------------------------------------------------
    [TAG_OPEN_STATE](cp) {
      if (cp === $$5.EXCLAMATION_MARK) {
        this.state = MARKUP_DECLARATION_OPEN_STATE;
      } else if (cp === $$5.SOLIDUS) {
        this.state = END_TAG_OPEN_STATE;
      } else if (isAsciiLetter(cp)) {
        this._createStartTagToken();
        this._reconsumeInState(TAG_NAME_STATE);
      } else if (cp === $$5.QUESTION_MARK) {
        this._err(ERR$1.unexpectedQuestionMarkInsteadOfTagName);
        this._createCommentToken();
        this._reconsumeInState(BOGUS_COMMENT_STATE);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofBeforeTagName);
        this._emitChars("<");
        this._emitEOFToken();
      } else {
        this._err(ERR$1.invalidFirstCharacterOfTagName);
        this._emitChars("<");
        this._reconsumeInState(DATA_STATE);
      }
    }
    // End tag open state
    //------------------------------------------------------------------
    [END_TAG_OPEN_STATE](cp) {
      if (isAsciiLetter(cp)) {
        this._createEndTagToken();
        this._reconsumeInState(TAG_NAME_STATE);
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.missingEndTagName);
        this.state = DATA_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofBeforeTagName);
        this._emitChars("</");
        this._emitEOFToken();
      } else {
        this._err(ERR$1.invalidFirstCharacterOfTagName);
        this._createCommentToken();
        this._reconsumeInState(BOGUS_COMMENT_STATE);
      }
    }
    // Tag name state
    //------------------------------------------------------------------
    [TAG_NAME_STATE](cp) {
      if (isWhitespace(cp)) {
        this.state = BEFORE_ATTRIBUTE_NAME_STATE;
      } else if (cp === $$5.SOLIDUS) {
        this.state = SELF_CLOSING_START_TAG_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentToken.tagName += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInTag);
        this._emitEOFToken();
      } else {
        this.currentToken.tagName += toChar(cp);
      }
    }
    // RCDATA less-than sign state
    //------------------------------------------------------------------
    [RCDATA_LESS_THAN_SIGN_STATE](cp) {
      if (cp === $$5.SOLIDUS) {
        this.tempBuff = [];
        this.state = RCDATA_END_TAG_OPEN_STATE;
      } else {
        this._emitChars("<");
        this._reconsumeInState(RCDATA_STATE);
      }
    }
    // RCDATA end tag open state
    //------------------------------------------------------------------
    [RCDATA_END_TAG_OPEN_STATE](cp) {
      if (isAsciiLetter(cp)) {
        this._createEndTagToken();
        this._reconsumeInState(RCDATA_END_TAG_NAME_STATE);
      } else {
        this._emitChars("</");
        this._reconsumeInState(RCDATA_STATE);
      }
    }
    // RCDATA end tag name state
    //------------------------------------------------------------------
    [RCDATA_END_TAG_NAME_STATE](cp) {
      if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
        this.tempBuff.push(cp);
      } else if (isAsciiLower(cp)) {
        this.currentToken.tagName += toChar(cp);
        this.tempBuff.push(cp);
      } else {
        if (this.lastStartTagName === this.currentToken.tagName) {
          if (isWhitespace(cp)) {
            this.state = BEFORE_ATTRIBUTE_NAME_STATE;
            return;
          }
          if (cp === $$5.SOLIDUS) {
            this.state = SELF_CLOSING_START_TAG_STATE;
            return;
          }
          if (cp === $$5.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            this._emitCurrentToken();
            return;
          }
        }
        this._emitChars("</");
        this._emitSeveralCodePoints(this.tempBuff);
        this._reconsumeInState(RCDATA_STATE);
      }
    }
    // RAWTEXT less-than sign state
    //------------------------------------------------------------------
    [RAWTEXT_LESS_THAN_SIGN_STATE](cp) {
      if (cp === $$5.SOLIDUS) {
        this.tempBuff = [];
        this.state = RAWTEXT_END_TAG_OPEN_STATE;
      } else {
        this._emitChars("<");
        this._reconsumeInState(RAWTEXT_STATE);
      }
    }
    // RAWTEXT end tag open state
    //------------------------------------------------------------------
    [RAWTEXT_END_TAG_OPEN_STATE](cp) {
      if (isAsciiLetter(cp)) {
        this._createEndTagToken();
        this._reconsumeInState(RAWTEXT_END_TAG_NAME_STATE);
      } else {
        this._emitChars("</");
        this._reconsumeInState(RAWTEXT_STATE);
      }
    }
    // RAWTEXT end tag name state
    //------------------------------------------------------------------
    [RAWTEXT_END_TAG_NAME_STATE](cp) {
      if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
        this.tempBuff.push(cp);
      } else if (isAsciiLower(cp)) {
        this.currentToken.tagName += toChar(cp);
        this.tempBuff.push(cp);
      } else {
        if (this.lastStartTagName === this.currentToken.tagName) {
          if (isWhitespace(cp)) {
            this.state = BEFORE_ATTRIBUTE_NAME_STATE;
            return;
          }
          if (cp === $$5.SOLIDUS) {
            this.state = SELF_CLOSING_START_TAG_STATE;
            return;
          }
          if (cp === $$5.GREATER_THAN_SIGN) {
            this._emitCurrentToken();
            this.state = DATA_STATE;
            return;
          }
        }
        this._emitChars("</");
        this._emitSeveralCodePoints(this.tempBuff);
        this._reconsumeInState(RAWTEXT_STATE);
      }
    }
    // Script data less-than sign state
    //------------------------------------------------------------------
    [SCRIPT_DATA_LESS_THAN_SIGN_STATE](cp) {
      if (cp === $$5.SOLIDUS) {
        this.tempBuff = [];
        this.state = SCRIPT_DATA_END_TAG_OPEN_STATE;
      } else if (cp === $$5.EXCLAMATION_MARK) {
        this.state = SCRIPT_DATA_ESCAPE_START_STATE;
        this._emitChars("<!");
      } else {
        this._emitChars("<");
        this._reconsumeInState(SCRIPT_DATA_STATE);
      }
    }
    // Script data end tag open state
    //------------------------------------------------------------------
    [SCRIPT_DATA_END_TAG_OPEN_STATE](cp) {
      if (isAsciiLetter(cp)) {
        this._createEndTagToken();
        this._reconsumeInState(SCRIPT_DATA_END_TAG_NAME_STATE);
      } else {
        this._emitChars("</");
        this._reconsumeInState(SCRIPT_DATA_STATE);
      }
    }
    // Script data end tag name state
    //------------------------------------------------------------------
    [SCRIPT_DATA_END_TAG_NAME_STATE](cp) {
      if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
        this.tempBuff.push(cp);
      } else if (isAsciiLower(cp)) {
        this.currentToken.tagName += toChar(cp);
        this.tempBuff.push(cp);
      } else {
        if (this.lastStartTagName === this.currentToken.tagName) {
          if (isWhitespace(cp)) {
            this.state = BEFORE_ATTRIBUTE_NAME_STATE;
            return;
          } else if (cp === $$5.SOLIDUS) {
            this.state = SELF_CLOSING_START_TAG_STATE;
            return;
          } else if (cp === $$5.GREATER_THAN_SIGN) {
            this._emitCurrentToken();
            this.state = DATA_STATE;
            return;
          }
        }
        this._emitChars("</");
        this._emitSeveralCodePoints(this.tempBuff);
        this._reconsumeInState(SCRIPT_DATA_STATE);
      }
    }
    // Script data escape start state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPE_START_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_ESCAPE_START_DASH_STATE;
        this._emitChars("-");
      } else {
        this._reconsumeInState(SCRIPT_DATA_STATE);
      }
    }
    // Script data escape start dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPE_START_DASH_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
        this._emitChars("-");
      } else {
        this._reconsumeInState(SCRIPT_DATA_STATE);
      }
    }
    // Script data escaped state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_ESCAPED_DASH_STATE;
        this._emitChars("-");
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
      } else {
        this._emitCodePoint(cp);
      }
    }
    // Script data escaped dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_DASH_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
        this._emitChars("-");
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.state = SCRIPT_DATA_ESCAPED_STATE;
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
      } else {
        this.state = SCRIPT_DATA_ESCAPED_STATE;
        this._emitCodePoint(cp);
      }
    }
    // Script data escaped dash dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_DASH_DASH_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this._emitChars("-");
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = SCRIPT_DATA_STATE;
        this._emitChars(">");
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.state = SCRIPT_DATA_ESCAPED_STATE;
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
      } else {
        this.state = SCRIPT_DATA_ESCAPED_STATE;
        this._emitCodePoint(cp);
      }
    }
    // Script data escaped less-than sign state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
      if (cp === $$5.SOLIDUS) {
        this.tempBuff = [];
        this.state = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;
      } else if (isAsciiLetter(cp)) {
        this.tempBuff = [];
        this._emitChars("<");
        this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE);
      } else {
        this._emitChars("<");
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
      }
    }
    // Script data escaped end tag open state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE](cp) {
      if (isAsciiLetter(cp)) {
        this._createEndTagToken();
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE);
      } else {
        this._emitChars("</");
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
      }
    }
    // Script data escaped end tag name state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE](cp) {
      if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
        this.tempBuff.push(cp);
      } else if (isAsciiLower(cp)) {
        this.currentToken.tagName += toChar(cp);
        this.tempBuff.push(cp);
      } else {
        if (this.lastStartTagName === this.currentToken.tagName) {
          if (isWhitespace(cp)) {
            this.state = BEFORE_ATTRIBUTE_NAME_STATE;
            return;
          }
          if (cp === $$5.SOLIDUS) {
            this.state = SELF_CLOSING_START_TAG_STATE;
            return;
          }
          if (cp === $$5.GREATER_THAN_SIGN) {
            this._emitCurrentToken();
            this.state = DATA_STATE;
            return;
          }
        }
        this._emitChars("</");
        this._emitSeveralCodePoints(this.tempBuff);
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
      }
    }
    // Script data double escape start state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE](cp) {
      if (isWhitespace(cp) || cp === $$5.SOLIDUS || cp === $$5.GREATER_THAN_SIGN) {
        this.state = this._isTempBufferEqualToScriptString() ? SCRIPT_DATA_DOUBLE_ESCAPED_STATE : SCRIPT_DATA_ESCAPED_STATE;
        this._emitCodePoint(cp);
      } else if (isAsciiUpper(cp)) {
        this.tempBuff.push(toAsciiLowerCodePoint(cp));
        this._emitCodePoint(cp);
      } else if (isAsciiLower(cp)) {
        this.tempBuff.push(cp);
        this._emitCodePoint(cp);
      } else {
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
      }
    }
    // Script data double escaped state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPED_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
        this._emitChars("-");
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
        this._emitChars("<");
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
      } else {
        this._emitCodePoint(cp);
      }
    }
    // Script data double escaped dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;
        this._emitChars("-");
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
        this._emitChars("<");
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
      } else {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitCodePoint(cp);
      }
    }
    // Script data double escaped dash dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this._emitChars("-");
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
        this._emitChars("<");
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = SCRIPT_DATA_STATE;
        this._emitChars(">");
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
      } else {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitCodePoint(cp);
      }
    }
    // Script data double escaped less-than sign state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
      if (cp === $$5.SOLIDUS) {
        this.tempBuff = [];
        this.state = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
        this._emitChars("/");
      } else {
        this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
      }
    }
    // Script data double escape end state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE](cp) {
      if (isWhitespace(cp) || cp === $$5.SOLIDUS || cp === $$5.GREATER_THAN_SIGN) {
        this.state = this._isTempBufferEqualToScriptString() ? SCRIPT_DATA_ESCAPED_STATE : SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitCodePoint(cp);
      } else if (isAsciiUpper(cp)) {
        this.tempBuff.push(toAsciiLowerCodePoint(cp));
        this._emitCodePoint(cp);
      } else if (isAsciiLower(cp)) {
        this.tempBuff.push(cp);
        this._emitCodePoint(cp);
      } else {
        this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
      }
    }
    // Before attribute name state
    //------------------------------------------------------------------
    [BEFORE_ATTRIBUTE_NAME_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (cp === $$5.SOLIDUS || cp === $$5.GREATER_THAN_SIGN || cp === $$5.EOF) {
        this._reconsumeInState(AFTER_ATTRIBUTE_NAME_STATE);
      } else if (cp === $$5.EQUALS_SIGN) {
        this._err(ERR$1.unexpectedEqualsSignBeforeAttributeName);
        this._createAttr("=");
        this.state = ATTRIBUTE_NAME_STATE;
      } else {
        this._createAttr("");
        this._reconsumeInState(ATTRIBUTE_NAME_STATE);
      }
    }
    // Attribute name state
    //------------------------------------------------------------------
    [ATTRIBUTE_NAME_STATE](cp) {
      if (isWhitespace(cp) || cp === $$5.SOLIDUS || cp === $$5.GREATER_THAN_SIGN || cp === $$5.EOF) {
        this._leaveAttrName(AFTER_ATTRIBUTE_NAME_STATE);
        this._unconsume();
      } else if (cp === $$5.EQUALS_SIGN) {
        this._leaveAttrName(BEFORE_ATTRIBUTE_VALUE_STATE);
      } else if (isAsciiUpper(cp)) {
        this.currentAttr.name += toAsciiLowerChar(cp);
      } else if (cp === $$5.QUOTATION_MARK || cp === $$5.APOSTROPHE || cp === $$5.LESS_THAN_SIGN) {
        this._err(ERR$1.unexpectedCharacterInAttributeName);
        this.currentAttr.name += toChar(cp);
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentAttr.name += unicode$1.REPLACEMENT_CHARACTER;
      } else {
        this.currentAttr.name += toChar(cp);
      }
    }
    // After attribute name state
    //------------------------------------------------------------------
    [AFTER_ATTRIBUTE_NAME_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (cp === $$5.SOLIDUS) {
        this.state = SELF_CLOSING_START_TAG_STATE;
      } else if (cp === $$5.EQUALS_SIGN) {
        this.state = BEFORE_ATTRIBUTE_VALUE_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInTag);
        this._emitEOFToken();
      } else {
        this._createAttr("");
        this._reconsumeInState(ATTRIBUTE_NAME_STATE);
      }
    }
    // Before attribute value state
    //------------------------------------------------------------------
    [BEFORE_ATTRIBUTE_VALUE_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (cp === $$5.QUOTATION_MARK) {
        this.state = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
      } else if (cp === $$5.APOSTROPHE) {
        this.state = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.missingAttributeValue);
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else {
        this._reconsumeInState(ATTRIBUTE_VALUE_UNQUOTED_STATE);
      }
    }
    // Attribute value (double-quoted) state
    //------------------------------------------------------------------
    [ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE](cp) {
      if (cp === $$5.QUOTATION_MARK) {
        this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
      } else if (cp === $$5.AMPERSAND) {
        this.returnState = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
        this.state = CHARACTER_REFERENCE_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInTag);
        this._emitEOFToken();
      } else {
        this.currentAttr.value += toChar(cp);
      }
    }
    // Attribute value (single-quoted) state
    //------------------------------------------------------------------
    [ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE](cp) {
      if (cp === $$5.APOSTROPHE) {
        this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
      } else if (cp === $$5.AMPERSAND) {
        this.returnState = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
        this.state = CHARACTER_REFERENCE_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInTag);
        this._emitEOFToken();
      } else {
        this.currentAttr.value += toChar(cp);
      }
    }
    // Attribute value (unquoted) state
    //------------------------------------------------------------------
    [ATTRIBUTE_VALUE_UNQUOTED_STATE](cp) {
      if (isWhitespace(cp)) {
        this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
      } else if (cp === $$5.AMPERSAND) {
        this.returnState = ATTRIBUTE_VALUE_UNQUOTED_STATE;
        this.state = CHARACTER_REFERENCE_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._leaveAttrValue(DATA_STATE);
        this._emitCurrentToken();
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.QUOTATION_MARK || cp === $$5.APOSTROPHE || cp === $$5.LESS_THAN_SIGN || cp === $$5.EQUALS_SIGN || cp === $$5.GRAVE_ACCENT) {
        this._err(ERR$1.unexpectedCharacterInUnquotedAttributeValue);
        this.currentAttr.value += toChar(cp);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInTag);
        this._emitEOFToken();
      } else {
        this.currentAttr.value += toChar(cp);
      }
    }
    // After attribute value (quoted) state
    //------------------------------------------------------------------
    [AFTER_ATTRIBUTE_VALUE_QUOTED_STATE](cp) {
      if (isWhitespace(cp)) {
        this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
      } else if (cp === $$5.SOLIDUS) {
        this._leaveAttrValue(SELF_CLOSING_START_TAG_STATE);
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._leaveAttrValue(DATA_STATE);
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInTag);
        this._emitEOFToken();
      } else {
        this._err(ERR$1.missingWhitespaceBetweenAttributes);
        this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
      }
    }
    // Self-closing start tag state
    //------------------------------------------------------------------
    [SELF_CLOSING_START_TAG_STATE](cp) {
      if (cp === $$5.GREATER_THAN_SIGN) {
        this.currentToken.selfClosing = true;
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInTag);
        this._emitEOFToken();
      } else {
        this._err(ERR$1.unexpectedSolidusInTag);
        this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
      }
    }
    // Bogus comment state
    //------------------------------------------------------------------
    [BOGUS_COMMENT_STATE](cp) {
      if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._emitCurrentToken();
        this._emitEOFToken();
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentToken.data += unicode$1.REPLACEMENT_CHARACTER;
      } else {
        this.currentToken.data += toChar(cp);
      }
    }
    // Markup declaration open state
    //------------------------------------------------------------------
    [MARKUP_DECLARATION_OPEN_STATE](cp) {
      if (this._consumeSequenceIfMatch($$.DASH_DASH_STRING, cp, true)) {
        this._createCommentToken();
        this.state = COMMENT_START_STATE;
      } else if (this._consumeSequenceIfMatch($$.DOCTYPE_STRING, cp, false)) {
        this.state = DOCTYPE_STATE;
      } else if (this._consumeSequenceIfMatch($$.CDATA_START_STRING, cp, true)) {
        if (this.allowCDATA) {
          this.state = CDATA_SECTION_STATE;
        } else {
          this._err(ERR$1.cdataInHtmlContent);
          this._createCommentToken();
          this.currentToken.data = "[CDATA[";
          this.state = BOGUS_COMMENT_STATE;
        }
      } else if (!this._ensureHibernation()) {
        this._err(ERR$1.incorrectlyOpenedComment);
        this._createCommentToken();
        this._reconsumeInState(BOGUS_COMMENT_STATE);
      }
    }
    // Comment start state
    //------------------------------------------------------------------
    [COMMENT_START_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = COMMENT_START_DASH_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.abruptClosingOfEmptyComment);
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else {
        this._reconsumeInState(COMMENT_STATE);
      }
    }
    // Comment start dash state
    //------------------------------------------------------------------
    [COMMENT_START_DASH_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = COMMENT_END_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.abruptClosingOfEmptyComment);
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInComment);
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.data += "-";
        this._reconsumeInState(COMMENT_STATE);
      }
    }
    // Comment state
    //------------------------------------------------------------------
    [COMMENT_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = COMMENT_END_DASH_STATE;
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.currentToken.data += "<";
        this.state = COMMENT_LESS_THAN_SIGN_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentToken.data += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInComment);
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.data += toChar(cp);
      }
    }
    // Comment less-than sign state
    //------------------------------------------------------------------
    [COMMENT_LESS_THAN_SIGN_STATE](cp) {
      if (cp === $$5.EXCLAMATION_MARK) {
        this.currentToken.data += "!";
        this.state = COMMENT_LESS_THAN_SIGN_BANG_STATE;
      } else if (cp === $$5.LESS_THAN_SIGN) {
        this.currentToken.data += "!";
      } else {
        this._reconsumeInState(COMMENT_STATE);
      }
    }
    // Comment less-than sign bang state
    //------------------------------------------------------------------
    [COMMENT_LESS_THAN_SIGN_BANG_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE;
      } else {
        this._reconsumeInState(COMMENT_STATE);
      }
    }
    // Comment less-than sign bang dash state
    //------------------------------------------------------------------
    [COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE;
      } else {
        this._reconsumeInState(COMMENT_END_DASH_STATE);
      }
    }
    // Comment less-than sign bang dash dash state
    //------------------------------------------------------------------
    [COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE](cp) {
      if (cp !== $$5.GREATER_THAN_SIGN && cp !== $$5.EOF) {
        this._err(ERR$1.nestedComment);
      }
      this._reconsumeInState(COMMENT_END_STATE);
    }
    // Comment end dash state
    //------------------------------------------------------------------
    [COMMENT_END_DASH_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.state = COMMENT_END_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInComment);
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.data += "-";
        this._reconsumeInState(COMMENT_STATE);
      }
    }
    // Comment end state
    //------------------------------------------------------------------
    [COMMENT_END_STATE](cp) {
      if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EXCLAMATION_MARK) {
        this.state = COMMENT_END_BANG_STATE;
      } else if (cp === $$5.HYPHEN_MINUS) {
        this.currentToken.data += "-";
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInComment);
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.data += "--";
        this._reconsumeInState(COMMENT_STATE);
      }
    }
    // Comment end bang state
    //------------------------------------------------------------------
    [COMMENT_END_BANG_STATE](cp) {
      if (cp === $$5.HYPHEN_MINUS) {
        this.currentToken.data += "--!";
        this.state = COMMENT_END_DASH_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.incorrectlyClosedComment);
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInComment);
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.data += "--!";
        this._reconsumeInState(COMMENT_STATE);
      }
    }
    // DOCTYPE state
    //------------------------------------------------------------------
    [DOCTYPE_STATE](cp) {
      if (isWhitespace(cp)) {
        this.state = BEFORE_DOCTYPE_NAME_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this._createDoctypeToken(null);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._err(ERR$1.missingWhitespaceBeforeDoctypeName);
        this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
      }
    }
    // Before DOCTYPE name state
    //------------------------------------------------------------------
    [BEFORE_DOCTYPE_NAME_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (isAsciiUpper(cp)) {
        this._createDoctypeToken(toAsciiLowerChar(cp));
        this.state = DOCTYPE_NAME_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this._createDoctypeToken(unicode$1.REPLACEMENT_CHARACTER);
        this.state = DOCTYPE_NAME_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.missingDoctypeName);
        this._createDoctypeToken(null);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this._createDoctypeToken(null);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._createDoctypeToken(toChar(cp));
        this.state = DOCTYPE_NAME_STATE;
      }
    }
    // DOCTYPE name state
    //------------------------------------------------------------------
    [DOCTYPE_NAME_STATE](cp) {
      if (isWhitespace(cp)) {
        this.state = AFTER_DOCTYPE_NAME_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (isAsciiUpper(cp)) {
        this.currentToken.name += toAsciiLowerChar(cp);
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentToken.name += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.name += toChar(cp);
      }
    }
    // After DOCTYPE name state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_NAME_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else if (this._consumeSequenceIfMatch($$.PUBLIC_STRING, cp, false)) {
        this.state = AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE;
      } else if (this._consumeSequenceIfMatch($$.SYSTEM_STRING, cp, false)) {
        this.state = AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE;
      } else if (!this._ensureHibernation()) {
        this._err(ERR$1.invalidCharacterSequenceAfterDoctypeName);
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
      }
    }
    // After DOCTYPE public keyword state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE](cp) {
      if (isWhitespace(cp)) {
        this.state = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
      } else if (cp === $$5.QUOTATION_MARK) {
        this._err(ERR$1.missingWhitespaceAfterDoctypePublicKeyword);
        this.currentToken.publicId = "";
        this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
      } else if (cp === $$5.APOSTROPHE) {
        this._err(ERR$1.missingWhitespaceAfterDoctypePublicKeyword);
        this.currentToken.publicId = "";
        this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.missingDoctypePublicIdentifier);
        this.currentToken.forceQuirks = true;
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._err(ERR$1.missingQuoteBeforeDoctypePublicIdentifier);
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
      }
    }
    // Before DOCTYPE public identifier state
    //------------------------------------------------------------------
    [BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (cp === $$5.QUOTATION_MARK) {
        this.currentToken.publicId = "";
        this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
      } else if (cp === $$5.APOSTROPHE) {
        this.currentToken.publicId = "";
        this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.missingDoctypePublicIdentifier);
        this.currentToken.forceQuirks = true;
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._err(ERR$1.missingQuoteBeforeDoctypePublicIdentifier);
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
      }
    }
    // DOCTYPE public identifier (double-quoted) state
    //------------------------------------------------------------------
    [DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
      if (cp === $$5.QUOTATION_MARK) {
        this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentToken.publicId += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.abruptDoctypePublicIdentifier);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.publicId += toChar(cp);
      }
    }
    // DOCTYPE public identifier (single-quoted) state
    //------------------------------------------------------------------
    [DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
      if (cp === $$5.APOSTROPHE) {
        this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentToken.publicId += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.abruptDoctypePublicIdentifier);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.publicId += toChar(cp);
      }
    }
    // After DOCTYPE public identifier state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
      if (isWhitespace(cp)) {
        this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.QUOTATION_MARK) {
        this._err(ERR$1.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        this.currentToken.systemId = "";
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
      } else if (cp === $$5.APOSTROPHE) {
        this._err(ERR$1.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        this.currentToken.systemId = "";
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
      }
    }
    // Between DOCTYPE public and system identifiers state
    //------------------------------------------------------------------
    [BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (cp === $$5.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
      } else if (cp === $$5.QUOTATION_MARK) {
        this.currentToken.systemId = "";
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
      } else if (cp === $$5.APOSTROPHE) {
        this.currentToken.systemId = "";
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
      }
    }
    // After DOCTYPE system keyword state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE](cp) {
      if (isWhitespace(cp)) {
        this.state = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
      } else if (cp === $$5.QUOTATION_MARK) {
        this._err(ERR$1.missingWhitespaceAfterDoctypeSystemKeyword);
        this.currentToken.systemId = "";
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
      } else if (cp === $$5.APOSTROPHE) {
        this._err(ERR$1.missingWhitespaceAfterDoctypeSystemKeyword);
        this.currentToken.systemId = "";
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.missingDoctypeSystemIdentifier);
        this.currentToken.forceQuirks = true;
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
      }
    }
    // Before DOCTYPE system identifier state
    //------------------------------------------------------------------
    [BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (cp === $$5.QUOTATION_MARK) {
        this.currentToken.systemId = "";
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
      } else if (cp === $$5.APOSTROPHE) {
        this.currentToken.systemId = "";
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.missingDoctypeSystemIdentifier);
        this.currentToken.forceQuirks = true;
        this.state = DATA_STATE;
        this._emitCurrentToken();
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
        this.currentToken.forceQuirks = true;
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
      }
    }
    // DOCTYPE system identifier (double-quoted) state
    //------------------------------------------------------------------
    [DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
      if (cp === $$5.QUOTATION_MARK) {
        this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentToken.systemId += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.abruptDoctypeSystemIdentifier);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.systemId += toChar(cp);
      }
    }
    // DOCTYPE system identifier (single-quoted) state
    //------------------------------------------------------------------
    [DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
      if (cp === $$5.APOSTROPHE) {
        this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
        this.currentToken.systemId += unicode$1.REPLACEMENT_CHARACTER;
      } else if (cp === $$5.GREATER_THAN_SIGN) {
        this._err(ERR$1.abruptDoctypeSystemIdentifier);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this.currentToken.systemId += toChar(cp);
      }
    }
    // After DOCTYPE system identifier state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
      if (isWhitespace(cp)) {
        return;
      }
      if (cp === $$5.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInDoctype);
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._emitEOFToken();
      } else {
        this._err(ERR$1.unexpectedCharacterAfterDoctypeSystemIdentifier);
        this._reconsumeInState(BOGUS_DOCTYPE_STATE);
      }
    }
    // Bogus DOCTYPE state
    //------------------------------------------------------------------
    [BOGUS_DOCTYPE_STATE](cp) {
      if (cp === $$5.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
      } else if (cp === $$5.NULL) {
        this._err(ERR$1.unexpectedNullCharacter);
      } else if (cp === $$5.EOF) {
        this._emitCurrentToken();
        this._emitEOFToken();
      }
    }
    // CDATA section state
    //------------------------------------------------------------------
    [CDATA_SECTION_STATE](cp) {
      if (cp === $$5.RIGHT_SQUARE_BRACKET) {
        this.state = CDATA_SECTION_BRACKET_STATE;
      } else if (cp === $$5.EOF) {
        this._err(ERR$1.eofInCdata);
        this._emitEOFToken();
      } else {
        this._emitCodePoint(cp);
      }
    }
    // CDATA section bracket state
    //------------------------------------------------------------------
    [CDATA_SECTION_BRACKET_STATE](cp) {
      if (cp === $$5.RIGHT_SQUARE_BRACKET) {
        this.state = CDATA_SECTION_END_STATE;
      } else {
        this._emitChars("]");
        this._reconsumeInState(CDATA_SECTION_STATE);
      }
    }
    // CDATA section end state
    //------------------------------------------------------------------
    [CDATA_SECTION_END_STATE](cp) {
      if (cp === $$5.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
      } else if (cp === $$5.RIGHT_SQUARE_BRACKET) {
        this._emitChars("]");
      } else {
        this._emitChars("]]");
        this._reconsumeInState(CDATA_SECTION_STATE);
      }
    }
    // Character reference state
    //------------------------------------------------------------------
    [CHARACTER_REFERENCE_STATE](cp) {
      this.tempBuff = [$$5.AMPERSAND];
      if (cp === $$5.NUMBER_SIGN) {
        this.tempBuff.push(cp);
        this.state = NUMERIC_CHARACTER_REFERENCE_STATE;
      } else if (isAsciiAlphaNumeric(cp)) {
        this._reconsumeInState(NAMED_CHARACTER_REFERENCE_STATE);
      } else {
        this._flushCodePointsConsumedAsCharacterReference();
        this._reconsumeInState(this.returnState);
      }
    }
    // Named character reference state
    //------------------------------------------------------------------
    [NAMED_CHARACTER_REFERENCE_STATE](cp) {
      const matchResult = this._matchNamedCharacterReference(cp);
      if (this._ensureHibernation()) {
        this.tempBuff = [$$5.AMPERSAND];
      } else if (matchResult) {
        const withSemicolon = this.tempBuff[this.tempBuff.length - 1] === $$5.SEMICOLON;
        if (!this._isCharacterReferenceAttributeQuirk(withSemicolon)) {
          if (!withSemicolon) {
            this._errOnNextCodePoint(ERR$1.missingSemicolonAfterCharacterReference);
          }
          this.tempBuff = matchResult;
        }
        this._flushCodePointsConsumedAsCharacterReference();
        this.state = this.returnState;
      } else {
        this._flushCodePointsConsumedAsCharacterReference();
        this.state = AMBIGUOUS_AMPERSAND_STATE;
      }
    }
    // Ambiguos ampersand state
    //------------------------------------------------------------------
    [AMBIGUOUS_AMPERSAND_STATE](cp) {
      if (isAsciiAlphaNumeric(cp)) {
        if (this._isCharacterReferenceInAttribute()) {
          this.currentAttr.value += toChar(cp);
        } else {
          this._emitCodePoint(cp);
        }
      } else {
        if (cp === $$5.SEMICOLON) {
          this._err(ERR$1.unknownNamedCharacterReference);
        }
        this._reconsumeInState(this.returnState);
      }
    }
    // Numeric character reference state
    //------------------------------------------------------------------
    [NUMERIC_CHARACTER_REFERENCE_STATE](cp) {
      this.charRefCode = 0;
      if (cp === $$5.LATIN_SMALL_X || cp === $$5.LATIN_CAPITAL_X) {
        this.tempBuff.push(cp);
        this.state = HEXADEMICAL_CHARACTER_REFERENCE_START_STATE;
      } else {
        this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_START_STATE);
      }
    }
    // Hexademical character reference start state
    //------------------------------------------------------------------
    [HEXADEMICAL_CHARACTER_REFERENCE_START_STATE](cp) {
      if (isAsciiHexDigit(cp)) {
        this._reconsumeInState(HEXADEMICAL_CHARACTER_REFERENCE_STATE);
      } else {
        this._err(ERR$1.absenceOfDigitsInNumericCharacterReference);
        this._flushCodePointsConsumedAsCharacterReference();
        this._reconsumeInState(this.returnState);
      }
    }
    // Decimal character reference start state
    //------------------------------------------------------------------
    [DECIMAL_CHARACTER_REFERENCE_START_STATE](cp) {
      if (isAsciiDigit(cp)) {
        this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_STATE);
      } else {
        this._err(ERR$1.absenceOfDigitsInNumericCharacterReference);
        this._flushCodePointsConsumedAsCharacterReference();
        this._reconsumeInState(this.returnState);
      }
    }
    // Hexademical character reference state
    //------------------------------------------------------------------
    [HEXADEMICAL_CHARACTER_REFERENCE_STATE](cp) {
      if (isAsciiUpperHexDigit(cp)) {
        this.charRefCode = this.charRefCode * 16 + cp - 55;
      } else if (isAsciiLowerHexDigit(cp)) {
        this.charRefCode = this.charRefCode * 16 + cp - 87;
      } else if (isAsciiDigit(cp)) {
        this.charRefCode = this.charRefCode * 16 + cp - 48;
      } else if (cp === $$5.SEMICOLON) {
        this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
      } else {
        this._err(ERR$1.missingSemicolonAfterCharacterReference);
        this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
      }
    }
    // Decimal character reference state
    //------------------------------------------------------------------
    [DECIMAL_CHARACTER_REFERENCE_STATE](cp) {
      if (isAsciiDigit(cp)) {
        this.charRefCode = this.charRefCode * 10 + cp - 48;
      } else if (cp === $$5.SEMICOLON) {
        this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
      } else {
        this._err(ERR$1.missingSemicolonAfterCharacterReference);
        this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
      }
    }
    // Numeric character reference end state
    //------------------------------------------------------------------
    [NUMERIC_CHARACTER_REFERENCE_END_STATE]() {
      if (this.charRefCode === $$5.NULL) {
        this._err(ERR$1.nullCharacterReference);
        this.charRefCode = $$5.REPLACEMENT_CHARACTER;
      } else if (this.charRefCode > 1114111) {
        this._err(ERR$1.characterReferenceOutsideUnicodeRange);
        this.charRefCode = $$5.REPLACEMENT_CHARACTER;
      } else if (unicode$1.isSurrogate(this.charRefCode)) {
        this._err(ERR$1.surrogateCharacterReference);
        this.charRefCode = $$5.REPLACEMENT_CHARACTER;
      } else if (unicode$1.isUndefinedCodePoint(this.charRefCode)) {
        this._err(ERR$1.noncharacterCharacterReference);
      } else if (unicode$1.isControlCodePoint(this.charRefCode) || this.charRefCode === $$5.CARRIAGE_RETURN) {
        this._err(ERR$1.controlCharacterReference);
        const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS[this.charRefCode];
        if (replacement) {
          this.charRefCode = replacement;
        }
      }
      this.tempBuff = [this.charRefCode];
      this._flushCodePointsConsumedAsCharacterReference();
      this._reconsumeInState(this.returnState);
    }
  };
  Tokenizer$4.CHARACTER_TOKEN = "CHARACTER_TOKEN";
  Tokenizer$4.NULL_CHARACTER_TOKEN = "NULL_CHARACTER_TOKEN";
  Tokenizer$4.WHITESPACE_CHARACTER_TOKEN = "WHITESPACE_CHARACTER_TOKEN";
  Tokenizer$4.START_TAG_TOKEN = "START_TAG_TOKEN";
  Tokenizer$4.END_TAG_TOKEN = "END_TAG_TOKEN";
  Tokenizer$4.COMMENT_TOKEN = "COMMENT_TOKEN";
  Tokenizer$4.DOCTYPE_TOKEN = "DOCTYPE_TOKEN";
  Tokenizer$4.EOF_TOKEN = "EOF_TOKEN";
  Tokenizer$4.HIBERNATION_TOKEN = "HIBERNATION_TOKEN";
  Tokenizer$4.MODE = {
    DATA: DATA_STATE,
    RCDATA: RCDATA_STATE,
    RAWTEXT: RAWTEXT_STATE,
    SCRIPT_DATA: SCRIPT_DATA_STATE,
    PLAINTEXT: PLAINTEXT_STATE
  };
  Tokenizer$4.getTokenAttr = function(token, attrName) {
    for (let i2 = token.attrs.length - 1; i2 >= 0; i2--) {
      if (token.attrs[i2].name === attrName) {
        return token.attrs[i2].value;
      }
    }
    return null;
  };
  var tokenizer = Tokenizer$4;
  var html$6 = {};
  const NS$3 = html$6.NAMESPACES = {
    HTML: "http://www.w3.org/1999/xhtml",
    MATHML: "http://www.w3.org/1998/Math/MathML",
    SVG: "http://www.w3.org/2000/svg",
    XLINK: "http://www.w3.org/1999/xlink",
    XML: "http://www.w3.org/XML/1998/namespace",
    XMLNS: "http://www.w3.org/2000/xmlns/"
  };
  html$6.ATTRS = {
    TYPE: "type",
    ACTION: "action",
    ENCODING: "encoding",
    PROMPT: "prompt",
    NAME: "name",
    COLOR: "color",
    FACE: "face",
    SIZE: "size"
  };
  html$6.DOCUMENT_MODE = {
    NO_QUIRKS: "no-quirks",
    QUIRKS: "quirks",
    LIMITED_QUIRKS: "limited-quirks"
  };
  const $$4 = html$6.TAG_NAMES = {
    A: "a",
    ADDRESS: "address",
    ANNOTATION_XML: "annotation-xml",
    APPLET: "applet",
    AREA: "area",
    ARTICLE: "article",
    ASIDE: "aside",
    B: "b",
    BASE: "base",
    BASEFONT: "basefont",
    BGSOUND: "bgsound",
    BIG: "big",
    BLOCKQUOTE: "blockquote",
    BODY: "body",
    BR: "br",
    BUTTON: "button",
    CAPTION: "caption",
    CENTER: "center",
    CODE: "code",
    COL: "col",
    COLGROUP: "colgroup",
    DD: "dd",
    DESC: "desc",
    DETAILS: "details",
    DIALOG: "dialog",
    DIR: "dir",
    DIV: "div",
    DL: "dl",
    DT: "dt",
    EM: "em",
    EMBED: "embed",
    FIELDSET: "fieldset",
    FIGCAPTION: "figcaption",
    FIGURE: "figure",
    FONT: "font",
    FOOTER: "footer",
    FOREIGN_OBJECT: "foreignObject",
    FORM: "form",
    FRAME: "frame",
    FRAMESET: "frameset",
    H1: "h1",
    H2: "h2",
    H3: "h3",
    H4: "h4",
    H5: "h5",
    H6: "h6",
    HEAD: "head",
    HEADER: "header",
    HGROUP: "hgroup",
    HR: "hr",
    HTML: "html",
    I: "i",
    IMG: "img",
    IMAGE: "image",
    INPUT: "input",
    IFRAME: "iframe",
    KEYGEN: "keygen",
    LABEL: "label",
    LI: "li",
    LINK: "link",
    LISTING: "listing",
    MAIN: "main",
    MALIGNMARK: "malignmark",
    MARQUEE: "marquee",
    MATH: "math",
    MENU: "menu",
    META: "meta",
    MGLYPH: "mglyph",
    MI: "mi",
    MO: "mo",
    MN: "mn",
    MS: "ms",
    MTEXT: "mtext",
    NAV: "nav",
    NOBR: "nobr",
    NOFRAMES: "noframes",
    NOEMBED: "noembed",
    NOSCRIPT: "noscript",
    OBJECT: "object",
    OL: "ol",
    OPTGROUP: "optgroup",
    OPTION: "option",
    P: "p",
    PARAM: "param",
    PLAINTEXT: "plaintext",
    PRE: "pre",
    RB: "rb",
    RP: "rp",
    RT: "rt",
    RTC: "rtc",
    RUBY: "ruby",
    S: "s",
    SCRIPT: "script",
    SECTION: "section",
    SELECT: "select",
    SOURCE: "source",
    SMALL: "small",
    SPAN: "span",
    STRIKE: "strike",
    STRONG: "strong",
    STYLE: "style",
    SUB: "sub",
    SUMMARY: "summary",
    SUP: "sup",
    TABLE: "table",
    TBODY: "tbody",
    TEMPLATE: "template",
    TEXTAREA: "textarea",
    TFOOT: "tfoot",
    TD: "td",
    TH: "th",
    THEAD: "thead",
    TITLE: "title",
    TR: "tr",
    TRACK: "track",
    TT: "tt",
    U: "u",
    UL: "ul",
    SVG: "svg",
    VAR: "var",
    WBR: "wbr",
    XMP: "xmp"
  };
  html$6.SPECIAL_ELEMENTS = {
    [NS$3.HTML]: {
      [$$4.ADDRESS]: true,
      [$$4.APPLET]: true,
      [$$4.AREA]: true,
      [$$4.ARTICLE]: true,
      [$$4.ASIDE]: true,
      [$$4.BASE]: true,
      [$$4.BASEFONT]: true,
      [$$4.BGSOUND]: true,
      [$$4.BLOCKQUOTE]: true,
      [$$4.BODY]: true,
      [$$4.BR]: true,
      [$$4.BUTTON]: true,
      [$$4.CAPTION]: true,
      [$$4.CENTER]: true,
      [$$4.COL]: true,
      [$$4.COLGROUP]: true,
      [$$4.DD]: true,
      [$$4.DETAILS]: true,
      [$$4.DIR]: true,
      [$$4.DIV]: true,
      [$$4.DL]: true,
      [$$4.DT]: true,
      [$$4.EMBED]: true,
      [$$4.FIELDSET]: true,
      [$$4.FIGCAPTION]: true,
      [$$4.FIGURE]: true,
      [$$4.FOOTER]: true,
      [$$4.FORM]: true,
      [$$4.FRAME]: true,
      [$$4.FRAMESET]: true,
      [$$4.H1]: true,
      [$$4.H2]: true,
      [$$4.H3]: true,
      [$$4.H4]: true,
      [$$4.H5]: true,
      [$$4.H6]: true,
      [$$4.HEAD]: true,
      [$$4.HEADER]: true,
      [$$4.HGROUP]: true,
      [$$4.HR]: true,
      [$$4.HTML]: true,
      [$$4.IFRAME]: true,
      [$$4.IMG]: true,
      [$$4.INPUT]: true,
      [$$4.LI]: true,
      [$$4.LINK]: true,
      [$$4.LISTING]: true,
      [$$4.MAIN]: true,
      [$$4.MARQUEE]: true,
      [$$4.MENU]: true,
      [$$4.META]: true,
      [$$4.NAV]: true,
      [$$4.NOEMBED]: true,
      [$$4.NOFRAMES]: true,
      [$$4.NOSCRIPT]: true,
      [$$4.OBJECT]: true,
      [$$4.OL]: true,
      [$$4.P]: true,
      [$$4.PARAM]: true,
      [$$4.PLAINTEXT]: true,
      [$$4.PRE]: true,
      [$$4.SCRIPT]: true,
      [$$4.SECTION]: true,
      [$$4.SELECT]: true,
      [$$4.SOURCE]: true,
      [$$4.STYLE]: true,
      [$$4.SUMMARY]: true,
      [$$4.TABLE]: true,
      [$$4.TBODY]: true,
      [$$4.TD]: true,
      [$$4.TEMPLATE]: true,
      [$$4.TEXTAREA]: true,
      [$$4.TFOOT]: true,
      [$$4.TH]: true,
      [$$4.THEAD]: true,
      [$$4.TITLE]: true,
      [$$4.TR]: true,
      [$$4.TRACK]: true,
      [$$4.UL]: true,
      [$$4.WBR]: true,
      [$$4.XMP]: true
    },
    [NS$3.MATHML]: {
      [$$4.MI]: true,
      [$$4.MO]: true,
      [$$4.MN]: true,
      [$$4.MS]: true,
      [$$4.MTEXT]: true,
      [$$4.ANNOTATION_XML]: true
    },
    [NS$3.SVG]: {
      [$$4.TITLE]: true,
      [$$4.FOREIGN_OBJECT]: true,
      [$$4.DESC]: true
    }
  };
  const HTML$3 = html$6;
  const $$3 = HTML$3.TAG_NAMES;
  const NS$2 = HTML$3.NAMESPACES;
  function isImpliedEndTagRequired(tn) {
    switch (tn.length) {
      case 1:
        return tn === $$3.P;
      case 2:
        return tn === $$3.RB || tn === $$3.RP || tn === $$3.RT || tn === $$3.DD || tn === $$3.DT || tn === $$3.LI;
      case 3:
        return tn === $$3.RTC;
      case 6:
        return tn === $$3.OPTION;
      case 8:
        return tn === $$3.OPTGROUP;
    }
    return false;
  }
  function isImpliedEndTagRequiredThoroughly(tn) {
    switch (tn.length) {
      case 1:
        return tn === $$3.P;
      case 2:
        return tn === $$3.RB || tn === $$3.RP || tn === $$3.RT || tn === $$3.DD || tn === $$3.DT || tn === $$3.LI || tn === $$3.TD || tn === $$3.TH || tn === $$3.TR;
      case 3:
        return tn === $$3.RTC;
      case 5:
        return tn === $$3.TBODY || tn === $$3.TFOOT || tn === $$3.THEAD;
      case 6:
        return tn === $$3.OPTION;
      case 7:
        return tn === $$3.CAPTION;
      case 8:
        return tn === $$3.OPTGROUP || tn === $$3.COLGROUP;
    }
    return false;
  }
  function isScopingElement(tn, ns) {
    switch (tn.length) {
      case 2:
        if (tn === $$3.TD || tn === $$3.TH) {
          return ns === NS$2.HTML;
        } else if (tn === $$3.MI || tn === $$3.MO || tn === $$3.MN || tn === $$3.MS) {
          return ns === NS$2.MATHML;
        }
        break;
      case 4:
        if (tn === $$3.HTML) {
          return ns === NS$2.HTML;
        } else if (tn === $$3.DESC) {
          return ns === NS$2.SVG;
        }
        break;
      case 5:
        if (tn === $$3.TABLE) {
          return ns === NS$2.HTML;
        } else if (tn === $$3.MTEXT) {
          return ns === NS$2.MATHML;
        } else if (tn === $$3.TITLE) {
          return ns === NS$2.SVG;
        }
        break;
      case 6:
        return (tn === $$3.APPLET || tn === $$3.OBJECT) && ns === NS$2.HTML;
      case 7:
        return (tn === $$3.CAPTION || tn === $$3.MARQUEE) && ns === NS$2.HTML;
      case 8:
        return tn === $$3.TEMPLATE && ns === NS$2.HTML;
      case 13:
        return tn === $$3.FOREIGN_OBJECT && ns === NS$2.SVG;
      case 14:
        return tn === $$3.ANNOTATION_XML && ns === NS$2.MATHML;
    }
    return false;
  }
  let OpenElementStack$1 = class OpenElementStack {
    constructor(document2, treeAdapter) {
      this.stackTop = -1;
      this.items = [];
      this.current = document2;
      this.currentTagName = null;
      this.currentTmplContent = null;
      this.tmplCount = 0;
      this.treeAdapter = treeAdapter;
    }
    //Index of element
    _indexOf(element2) {
      let idx = -1;
      for (let i2 = this.stackTop; i2 >= 0; i2--) {
        if (this.items[i2] === element2) {
          idx = i2;
          break;
        }
      }
      return idx;
    }
    //Update current element
    _isInTemplate() {
      return this.currentTagName === $$3.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS$2.HTML;
    }
    _updateCurrentElement() {
      this.current = this.items[this.stackTop];
      this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);
      this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;
    }
    //Mutations
    push(element2) {
      this.items[++this.stackTop] = element2;
      this._updateCurrentElement();
      if (this._isInTemplate()) {
        this.tmplCount++;
      }
    }
    pop() {
      this.stackTop--;
      if (this.tmplCount > 0 && this._isInTemplate()) {
        this.tmplCount--;
      }
      this._updateCurrentElement();
    }
    replace(oldElement, newElement) {
      const idx = this._indexOf(oldElement);
      this.items[idx] = newElement;
      if (idx === this.stackTop) {
        this._updateCurrentElement();
      }
    }
    insertAfter(referenceElement, newElement) {
      const insertionIdx = this._indexOf(referenceElement) + 1;
      this.items.splice(insertionIdx, 0, newElement);
      if (insertionIdx === ++this.stackTop) {
        this._updateCurrentElement();
      }
    }
    popUntilTagNamePopped(tagName) {
      while (this.stackTop > -1) {
        const tn = this.currentTagName;
        const ns = this.treeAdapter.getNamespaceURI(this.current);
        this.pop();
        if (tn === tagName && ns === NS$2.HTML) {
          break;
        }
      }
    }
    popUntilElementPopped(element2) {
      while (this.stackTop > -1) {
        const poppedElement = this.current;
        this.pop();
        if (poppedElement === element2) {
          break;
        }
      }
    }
    popUntilNumberedHeaderPopped() {
      while (this.stackTop > -1) {
        const tn = this.currentTagName;
        const ns = this.treeAdapter.getNamespaceURI(this.current);
        this.pop();
        if (tn === $$3.H1 || tn === $$3.H2 || tn === $$3.H3 || tn === $$3.H4 || tn === $$3.H5 || tn === $$3.H6 && ns === NS$2.HTML) {
          break;
        }
      }
    }
    popUntilTableCellPopped() {
      while (this.stackTop > -1) {
        const tn = this.currentTagName;
        const ns = this.treeAdapter.getNamespaceURI(this.current);
        this.pop();
        if (tn === $$3.TD || tn === $$3.TH && ns === NS$2.HTML) {
          break;
        }
      }
    }
    popAllUpToHtmlElement() {
      this.stackTop = 0;
      this._updateCurrentElement();
    }
    clearBackToTableContext() {
      while (this.currentTagName !== $$3.TABLE && this.currentTagName !== $$3.TEMPLATE && this.currentTagName !== $$3.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS$2.HTML) {
        this.pop();
      }
    }
    clearBackToTableBodyContext() {
      while (this.currentTagName !== $$3.TBODY && this.currentTagName !== $$3.TFOOT && this.currentTagName !== $$3.THEAD && this.currentTagName !== $$3.TEMPLATE && this.currentTagName !== $$3.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS$2.HTML) {
        this.pop();
      }
    }
    clearBackToTableRowContext() {
      while (this.currentTagName !== $$3.TR && this.currentTagName !== $$3.TEMPLATE && this.currentTagName !== $$3.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS$2.HTML) {
        this.pop();
      }
    }
    remove(element2) {
      for (let i2 = this.stackTop; i2 >= 0; i2--) {
        if (this.items[i2] === element2) {
          this.items.splice(i2, 1);
          this.stackTop--;
          this._updateCurrentElement();
          break;
        }
      }
    }
    //Search
    tryPeekProperlyNestedBodyElement() {
      const element2 = this.items[1];
      return element2 && this.treeAdapter.getTagName(element2) === $$3.BODY ? element2 : null;
    }
    contains(element2) {
      return this._indexOf(element2) > -1;
    }
    getCommonAncestor(element2) {
      let elementIdx = this._indexOf(element2);
      return --elementIdx >= 0 ? this.items[elementIdx] : null;
    }
    isRootHtmlElementCurrent() {
      return this.stackTop === 0 && this.currentTagName === $$3.HTML;
    }
    //Element in scope
    hasInScope(tagName) {
      for (let i2 = this.stackTop; i2 >= 0; i2--) {
        const tn = this.treeAdapter.getTagName(this.items[i2]);
        const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
        if (tn === tagName && ns === NS$2.HTML) {
          return true;
        }
        if (isScopingElement(tn, ns)) {
          return false;
        }
      }
      return true;
    }
    hasNumberedHeaderInScope() {
      for (let i2 = this.stackTop; i2 >= 0; i2--) {
        const tn = this.treeAdapter.getTagName(this.items[i2]);
        const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
        if ((tn === $$3.H1 || tn === $$3.H2 || tn === $$3.H3 || tn === $$3.H4 || tn === $$3.H5 || tn === $$3.H6) && ns === NS$2.HTML) {
          return true;
        }
        if (isScopingElement(tn, ns)) {
          return false;
        }
      }
      return true;
    }
    hasInListItemScope(tagName) {
      for (let i2 = this.stackTop; i2 >= 0; i2--) {
        const tn = this.treeAdapter.getTagName(this.items[i2]);
        const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
        if (tn === tagName && ns === NS$2.HTML) {
          return true;
        }
        if ((tn === $$3.UL || tn === $$3.OL) && ns === NS$2.HTML || isScopingElement(tn, ns)) {
          return false;
        }
      }
      return true;
    }
    hasInButtonScope(tagName) {
      for (let i2 = this.stackTop; i2 >= 0; i2--) {
        const tn = this.treeAdapter.getTagName(this.items[i2]);
        const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
        if (tn === tagName && ns === NS$2.HTML) {
          return true;
        }
        if (tn === $$3.BUTTON && ns === NS$2.HTML || isScopingElement(tn, ns)) {
          return false;
        }
      }
      return true;
    }
    hasInTableScope(tagName) {
      for (let i2 = this.stackTop; i2 >= 0; i2--) {
        const tn = this.treeAdapter.getTagName(this.items[i2]);
        const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
        if (ns !== NS$2.HTML) {
          continue;
        }
        if (tn === tagName) {
          return true;
        }
        if (tn === $$3.TABLE || tn === $$3.TEMPLATE || tn === $$3.HTML) {
          return false;
        }
      }
      return true;
    }
    hasTableBodyContextInTableScope() {
      for (let i2 = this.stackTop; i2 >= 0; i2--) {
        const tn = this.treeAdapter.getTagName(this.items[i2]);
        const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
        if (ns !== NS$2.HTML) {
          continue;
        }
        if (tn === $$3.TBODY || tn === $$3.THEAD || tn === $$3.TFOOT) {
          return true;
        }
        if (tn === $$3.TABLE || tn === $$3.HTML) {
          return false;
        }
      }
      return true;
    }
    hasInSelectScope(tagName) {
      for (let i2 = this.stackTop; i2 >= 0; i2--) {
        const tn = this.treeAdapter.getTagName(this.items[i2]);
        const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
        if (ns !== NS$2.HTML) {
          continue;
        }
        if (tn === tagName) {
          return true;
        }
        if (tn !== $$3.OPTION && tn !== $$3.OPTGROUP) {
          return false;
        }
      }
      return true;
    }
    //Implied end tags
    generateImpliedEndTags() {
      while (isImpliedEndTagRequired(this.currentTagName)) {
        this.pop();
      }
    }
    generateImpliedEndTagsThoroughly() {
      while (isImpliedEndTagRequiredThoroughly(this.currentTagName)) {
        this.pop();
      }
    }
    generateImpliedEndTagsWithExclusion(exclusionTagName) {
      while (isImpliedEndTagRequired(this.currentTagName) && this.currentTagName !== exclusionTagName) {
        this.pop();
      }
    }
  };
  var openElementStack = OpenElementStack$1;
  const NOAH_ARK_CAPACITY = 3;
  let FormattingElementList$1 = class FormattingElementList2 {
    constructor(treeAdapter) {
      this.length = 0;
      this.entries = [];
      this.treeAdapter = treeAdapter;
      this.bookmark = null;
    }
    //Noah Ark's condition
    //OPTIMIZATION: at first we try to find possible candidates for exclusion using
    //lightweight heuristics without thorough attributes check.
    _getNoahArkConditionCandidates(newElement) {
      const candidates = [];
      if (this.length >= NOAH_ARK_CAPACITY) {
        const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;
        const neTagName = this.treeAdapter.getTagName(newElement);
        const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
        for (let i2 = this.length - 1; i2 >= 0; i2--) {
          const entry = this.entries[i2];
          if (entry.type === FormattingElementList2.MARKER_ENTRY) {
            break;
          }
          const element2 = entry.element;
          const elementAttrs = this.treeAdapter.getAttrList(element2);
          const isCandidate = this.treeAdapter.getTagName(element2) === neTagName && this.treeAdapter.getNamespaceURI(element2) === neNamespaceURI && elementAttrs.length === neAttrsLength;
          if (isCandidate) {
            candidates.push({ idx: i2, attrs: elementAttrs });
          }
        }
      }
      return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;
    }
    _ensureNoahArkCondition(newElement) {
      const candidates = this._getNoahArkConditionCandidates(newElement);
      let cLength = candidates.length;
      if (cLength) {
        const neAttrs = this.treeAdapter.getAttrList(newElement);
        const neAttrsLength = neAttrs.length;
        const neAttrsMap = /* @__PURE__ */ Object.create(null);
        for (let i2 = 0; i2 < neAttrsLength; i2++) {
          const neAttr = neAttrs[i2];
          neAttrsMap[neAttr.name] = neAttr.value;
        }
        for (let i2 = 0; i2 < neAttrsLength; i2++) {
          for (let j = 0; j < cLength; j++) {
            const cAttr = candidates[j].attrs[i2];
            if (neAttrsMap[cAttr.name] !== cAttr.value) {
              candidates.splice(j, 1);
              cLength--;
            }
            if (candidates.length < NOAH_ARK_CAPACITY) {
              return;
            }
          }
        }
        for (let i2 = cLength - 1; i2 >= NOAH_ARK_CAPACITY - 1; i2--) {
          this.entries.splice(candidates[i2].idx, 1);
          this.length--;
        }
      }
    }
    //Mutations
    insertMarker() {
      this.entries.push({ type: FormattingElementList2.MARKER_ENTRY });
      this.length++;
    }
    pushElement(element2, token) {
      this._ensureNoahArkCondition(element2);
      this.entries.push({
        type: FormattingElementList2.ELEMENT_ENTRY,
        element: element2,
        token
      });
      this.length++;
    }
    insertElementAfterBookmark(element2, token) {
      let bookmarkIdx = this.length - 1;
      for (; bookmarkIdx >= 0; bookmarkIdx--) {
        if (this.entries[bookmarkIdx] === this.bookmark) {
          break;
        }
      }
      this.entries.splice(bookmarkIdx + 1, 0, {
        type: FormattingElementList2.ELEMENT_ENTRY,
        element: element2,
        token
      });
      this.length++;
    }
    removeEntry(entry) {
      for (let i2 = this.length - 1; i2 >= 0; i2--) {
        if (this.entries[i2] === entry) {
          this.entries.splice(i2, 1);
          this.length--;
          break;
        }
      }
    }
    clearToLastMarker() {
      while (this.length) {
        const entry = this.entries.pop();
        this.length--;
        if (entry.type === FormattingElementList2.MARKER_ENTRY) {
          break;
        }
      }
    }
    //Search
    getElementEntryInScopeWithTagName(tagName) {
      for (let i2 = this.length - 1; i2 >= 0; i2--) {
        const entry = this.entries[i2];
        if (entry.type === FormattingElementList2.MARKER_ENTRY) {
          return null;
        }
        if (this.treeAdapter.getTagName(entry.element) === tagName) {
          return entry;
        }
      }
      return null;
    }
    getElementEntry(element2) {
      for (let i2 = this.length - 1; i2 >= 0; i2--) {
        const entry = this.entries[i2];
        if (entry.type === FormattingElementList2.ELEMENT_ENTRY && entry.element === element2) {
          return entry;
        }
      }
      return null;
    }
  };
  FormattingElementList$1.MARKER_ENTRY = "MARKER_ENTRY";
  FormattingElementList$1.ELEMENT_ENTRY = "ELEMENT_ENTRY";
  var formattingElementList = FormattingElementList$1;
  let Mixin$9 = class Mixin {
    constructor(host) {
      const originalMethods = {};
      const overriddenMethods = this._getOverriddenMethods(this, originalMethods);
      for (const key2 of Object.keys(overriddenMethods)) {
        if (typeof overriddenMethods[key2] === "function") {
          originalMethods[key2] = host[key2];
          host[key2] = overriddenMethods[key2];
        }
      }
    }
    _getOverriddenMethods() {
      throw new Error("Not implemented");
    }
  };
  Mixin$9.install = function(host, Ctor, opts) {
    if (!host.__mixins) {
      host.__mixins = [];
    }
    for (let i2 = 0; i2 < host.__mixins.length; i2++) {
      if (host.__mixins[i2].constructor === Ctor) {
        return host.__mixins[i2];
      }
    }
    const mixin2 = new Ctor(host, opts);
    host.__mixins.push(mixin2);
    return mixin2;
  };
  var mixin = Mixin$9;
  const Mixin$8 = mixin;
  let PositionTrackingPreprocessorMixin$2 = class PositionTrackingPreprocessorMixin extends Mixin$8 {
    constructor(preprocessor2) {
      super(preprocessor2);
      this.preprocessor = preprocessor2;
      this.isEol = false;
      this.lineStartPos = 0;
      this.droppedBufferSize = 0;
      this.offset = 0;
      this.col = 0;
      this.line = 1;
    }
    _getOverriddenMethods(mxn, orig) {
      return {
        advance() {
          const pos = this.pos + 1;
          const ch = this.html[pos];
          if (mxn.isEol) {
            mxn.isEol = false;
            mxn.line++;
            mxn.lineStartPos = pos;
          }
          if (ch === "\n" || ch === "\r" && this.html[pos + 1] !== "\n") {
            mxn.isEol = true;
          }
          mxn.col = pos - mxn.lineStartPos + 1;
          mxn.offset = mxn.droppedBufferSize + pos;
          return orig.advance.call(this);
        },
        retreat() {
          orig.retreat.call(this);
          mxn.isEol = false;
          mxn.col = this.pos - mxn.lineStartPos + 1;
        },
        dropParsedChunk() {
          const prevPos = this.pos;
          orig.dropParsedChunk.call(this);
          const reduction = prevPos - this.pos;
          mxn.lineStartPos -= reduction;
          mxn.droppedBufferSize += reduction;
          mxn.offset = mxn.droppedBufferSize + this.pos;
        }
      };
    }
  };
  var preprocessorMixin$1 = PositionTrackingPreprocessorMixin$2;
  const Mixin$7 = mixin;
  const Tokenizer$3 = tokenizer;
  const PositionTrackingPreprocessorMixin$1 = preprocessorMixin$1;
  let LocationInfoTokenizerMixin$2 = class LocationInfoTokenizerMixin extends Mixin$7 {
    constructor(tokenizer2) {
      super(tokenizer2);
      this.tokenizer = tokenizer2;
      this.posTracker = Mixin$7.install(tokenizer2.preprocessor, PositionTrackingPreprocessorMixin$1);
      this.currentAttrLocation = null;
      this.ctLoc = null;
    }
    _getCurrentLocation() {
      return {
        startLine: this.posTracker.line,
        startCol: this.posTracker.col,
        startOffset: this.posTracker.offset,
        endLine: -1,
        endCol: -1,
        endOffset: -1
      };
    }
    _attachCurrentAttrLocationInfo() {
      this.currentAttrLocation.endLine = this.posTracker.line;
      this.currentAttrLocation.endCol = this.posTracker.col;
      this.currentAttrLocation.endOffset = this.posTracker.offset;
      const currentToken = this.tokenizer.currentToken;
      const currentAttr = this.tokenizer.currentAttr;
      if (!currentToken.location.attrs) {
        currentToken.location.attrs = /* @__PURE__ */ Object.create(null);
      }
      currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;
    }
    _getOverriddenMethods(mxn, orig) {
      const methods = {
        _createStartTagToken() {
          orig._createStartTagToken.call(this);
          this.currentToken.location = mxn.ctLoc;
        },
        _createEndTagToken() {
          orig._createEndTagToken.call(this);
          this.currentToken.location = mxn.ctLoc;
        },
        _createCommentToken() {
          orig._createCommentToken.call(this);
          this.currentToken.location = mxn.ctLoc;
        },
        _createDoctypeToken(initialName) {
          orig._createDoctypeToken.call(this, initialName);
          this.currentToken.location = mxn.ctLoc;
        },
        _createCharacterToken(type, ch) {
          orig._createCharacterToken.call(this, type, ch);
          this.currentCharacterToken.location = mxn.ctLoc;
        },
        _createEOFToken() {
          orig._createEOFToken.call(this);
          this.currentToken.location = mxn._getCurrentLocation();
        },
        _createAttr(attrNameFirstCh) {
          orig._createAttr.call(this, attrNameFirstCh);
          mxn.currentAttrLocation = mxn._getCurrentLocation();
        },
        _leaveAttrName(toState) {
          orig._leaveAttrName.call(this, toState);
          mxn._attachCurrentAttrLocationInfo();
        },
        _leaveAttrValue(toState) {
          orig._leaveAttrValue.call(this, toState);
          mxn._attachCurrentAttrLocationInfo();
        },
        _emitCurrentToken() {
          const ctLoc = this.currentToken.location;
          if (this.currentCharacterToken) {
            this.currentCharacterToken.location.endLine = ctLoc.startLine;
            this.currentCharacterToken.location.endCol = ctLoc.startCol;
            this.currentCharacterToken.location.endOffset = ctLoc.startOffset;
          }
          if (this.currentToken.type === Tokenizer$3.EOF_TOKEN) {
            ctLoc.endLine = ctLoc.startLine;
            ctLoc.endCol = ctLoc.startCol;
            ctLoc.endOffset = ctLoc.startOffset;
          } else {
            ctLoc.endLine = mxn.posTracker.line;
            ctLoc.endCol = mxn.posTracker.col + 1;
            ctLoc.endOffset = mxn.posTracker.offset + 1;
          }
          orig._emitCurrentToken.call(this);
        },
        _emitCurrentCharacterToken() {
          const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;
          if (ctLoc && ctLoc.endOffset === -1) {
            ctLoc.endLine = mxn.posTracker.line;
            ctLoc.endCol = mxn.posTracker.col;
            ctLoc.endOffset = mxn.posTracker.offset;
          }
          orig._emitCurrentCharacterToken.call(this);
        }
      };
      Object.keys(Tokenizer$3.MODE).forEach((modeName) => {
        const state = Tokenizer$3.MODE[modeName];
        methods[state] = function(cp) {
          mxn.ctLoc = mxn._getCurrentLocation();
          orig[state].call(this, cp);
        };
      });
      return methods;
    }
  };
  var tokenizerMixin$1 = LocationInfoTokenizerMixin$2;
  const Mixin$6 = mixin;
  let LocationInfoOpenElementStackMixin$1 = class LocationInfoOpenElementStackMixin extends Mixin$6 {
    constructor(stack, opts) {
      super(stack);
      this.onItemPop = opts.onItemPop;
    }
    _getOverriddenMethods(mxn, orig) {
      return {
        pop() {
          mxn.onItemPop(this.current);
          orig.pop.call(this);
        },
        popAllUpToHtmlElement() {
          for (let i2 = this.stackTop; i2 > 0; i2--) {
            mxn.onItemPop(this.items[i2]);
          }
          orig.popAllUpToHtmlElement.call(this);
        },
        remove(element2) {
          mxn.onItemPop(this.current);
          orig.remove.call(this, element2);
        }
      };
    }
  };
  var openElementStackMixin = LocationInfoOpenElementStackMixin$1;
  const Mixin$5 = mixin;
  const Tokenizer$2 = tokenizer;
  const LocationInfoTokenizerMixin$1 = tokenizerMixin$1;
  const LocationInfoOpenElementStackMixin = openElementStackMixin;
  const HTML$2 = html$6;
  const $$2 = HTML$2.TAG_NAMES;
  let LocationInfoParserMixin$1 = class LocationInfoParserMixin extends Mixin$5 {
    constructor(parser2) {
      super(parser2);
      this.parser = parser2;
      this.treeAdapter = this.parser.treeAdapter;
      this.posTracker = null;
      this.lastStartTagToken = null;
      this.lastFosterParentingLocation = null;
      this.currentToken = null;
    }
    _setStartLocation(element2) {
      let loc = null;
      if (this.lastStartTagToken) {
        loc = Object.assign({}, this.lastStartTagToken.location);
        loc.startTag = this.lastStartTagToken.location;
      }
      this.treeAdapter.setNodeSourceCodeLocation(element2, loc);
    }
    _setEndLocation(element2, closingToken) {
      const loc = this.treeAdapter.getNodeSourceCodeLocation(element2);
      if (loc) {
        if (closingToken.location) {
          const ctLoc = closingToken.location;
          const tn = this.treeAdapter.getTagName(element2);
          const isClosingEndTag = closingToken.type === Tokenizer$2.END_TAG_TOKEN && tn === closingToken.tagName;
          const endLoc = {};
          if (isClosingEndTag) {
            endLoc.endTag = Object.assign({}, ctLoc);
            endLoc.endLine = ctLoc.endLine;
            endLoc.endCol = ctLoc.endCol;
            endLoc.endOffset = ctLoc.endOffset;
          } else {
            endLoc.endLine = ctLoc.startLine;
            endLoc.endCol = ctLoc.startCol;
            endLoc.endOffset = ctLoc.startOffset;
          }
          this.treeAdapter.updateNodeSourceCodeLocation(element2, endLoc);
        }
      }
    }
    _getOverriddenMethods(mxn, orig) {
      return {
        _bootstrap(document2, fragmentContext) {
          orig._bootstrap.call(this, document2, fragmentContext);
          mxn.lastStartTagToken = null;
          mxn.lastFosterParentingLocation = null;
          mxn.currentToken = null;
          const tokenizerMixin2 = Mixin$5.install(this.tokenizer, LocationInfoTokenizerMixin$1);
          mxn.posTracker = tokenizerMixin2.posTracker;
          Mixin$5.install(this.openElements, LocationInfoOpenElementStackMixin, {
            onItemPop: function(element2) {
              mxn._setEndLocation(element2, mxn.currentToken);
            }
          });
        },
        _runParsingLoop(scriptHandler) {
          orig._runParsingLoop.call(this, scriptHandler);
          for (let i2 = this.openElements.stackTop; i2 >= 0; i2--) {
            mxn._setEndLocation(this.openElements.items[i2], mxn.currentToken);
          }
        },
        //Token processing
        _processTokenInForeignContent(token) {
          mxn.currentToken = token;
          orig._processTokenInForeignContent.call(this, token);
        },
        _processToken(token) {
          mxn.currentToken = token;
          orig._processToken.call(this, token);
          const requireExplicitUpdate = token.type === Tokenizer$2.END_TAG_TOKEN && (token.tagName === $$2.HTML || token.tagName === $$2.BODY && this.openElements.hasInScope($$2.BODY));
          if (requireExplicitUpdate) {
            for (let i2 = this.openElements.stackTop; i2 >= 0; i2--) {
              const element2 = this.openElements.items[i2];
              if (this.treeAdapter.getTagName(element2) === token.tagName) {
                mxn._setEndLocation(element2, token);
                break;
              }
            }
          }
        },
        //Doctype
        _setDocumentType(token) {
          orig._setDocumentType.call(this, token);
          const documentChildren = this.treeAdapter.getChildNodes(this.document);
          const cnLength = documentChildren.length;
          for (let i2 = 0; i2 < cnLength; i2++) {
            const node2 = documentChildren[i2];
            if (this.treeAdapter.isDocumentTypeNode(node2)) {
              this.treeAdapter.setNodeSourceCodeLocation(node2, token.location);
              break;
            }
          }
        },
        //Elements
        _attachElementToTree(element2) {
          mxn._setStartLocation(element2);
          mxn.lastStartTagToken = null;
          orig._attachElementToTree.call(this, element2);
        },
        _appendElement(token, namespaceURI) {
          mxn.lastStartTagToken = token;
          orig._appendElement.call(this, token, namespaceURI);
        },
        _insertElement(token, namespaceURI) {
          mxn.lastStartTagToken = token;
          orig._insertElement.call(this, token, namespaceURI);
        },
        _insertTemplate(token) {
          mxn.lastStartTagToken = token;
          orig._insertTemplate.call(this, token);
          const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);
          this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);
        },
        _insertFakeRootElement() {
          orig._insertFakeRootElement.call(this);
          this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
        },
        //Comments
        _appendCommentNode(token, parent) {
          orig._appendCommentNode.call(this, token, parent);
          const children = this.treeAdapter.getChildNodes(parent);
          const commentNode = children[children.length - 1];
          this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
        },
        //Text
        _findFosterParentingLocation() {
          mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);
          return mxn.lastFosterParentingLocation;
        },
        _insertCharacters(token) {
          orig._insertCharacters.call(this, token);
          const hasFosterParent = this._shouldFosterParentOnInsertion();
          const parent = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current;
          const siblings2 = this.treeAdapter.getChildNodes(parent);
          const textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings2.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings2.length - 1;
          const textNode = siblings2[textNodeIdx];
          const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
          if (tnLoc) {
            const { endLine, endCol, endOffset } = token.location;
            this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
          } else {
            this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
          }
        }
      };
    }
  };
  var parserMixin$1 = LocationInfoParserMixin$1;
  const Mixin$4 = mixin;
  let ErrorReportingMixinBase$3 = class ErrorReportingMixinBase extends Mixin$4 {
    constructor(host, opts) {
      super(host);
      this.posTracker = null;
      this.onParseError = opts.onParseError;
    }
    _setErrorLocation(err) {
      err.startLine = err.endLine = this.posTracker.line;
      err.startCol = err.endCol = this.posTracker.col;
      err.startOffset = err.endOffset = this.posTracker.offset;
    }
    _reportError(code2) {
      const err = {
        code: code2,
        startLine: -1,
        startCol: -1,
        startOffset: -1,
        endLine: -1,
        endCol: -1,
        endOffset: -1
      };
      this._setErrorLocation(err);
      this.onParseError(err);
    }
    _getOverriddenMethods(mxn) {
      return {
        _err(code2) {
          mxn._reportError(code2);
        }
      };
    }
  };
  var mixinBase = ErrorReportingMixinBase$3;
  const ErrorReportingMixinBase$2 = mixinBase;
  const PositionTrackingPreprocessorMixin = preprocessorMixin$1;
  const Mixin$3 = mixin;
  let ErrorReportingPreprocessorMixin$1 = class ErrorReportingPreprocessorMixin extends ErrorReportingMixinBase$2 {
    constructor(preprocessor2, opts) {
      super(preprocessor2, opts);
      this.posTracker = Mixin$3.install(preprocessor2, PositionTrackingPreprocessorMixin);
      this.lastErrOffset = -1;
    }
    _reportError(code2) {
      if (this.lastErrOffset !== this.posTracker.offset) {
        this.lastErrOffset = this.posTracker.offset;
        super._reportError(code2);
      }
    }
  };
  var preprocessorMixin = ErrorReportingPreprocessorMixin$1;
  const ErrorReportingMixinBase$1 = mixinBase;
  const ErrorReportingPreprocessorMixin = preprocessorMixin;
  const Mixin$2 = mixin;
  let ErrorReportingTokenizerMixin$1 = class ErrorReportingTokenizerMixin extends ErrorReportingMixinBase$1 {
    constructor(tokenizer2, opts) {
      super(tokenizer2, opts);
      const preprocessorMixin2 = Mixin$2.install(tokenizer2.preprocessor, ErrorReportingPreprocessorMixin, opts);
      this.posTracker = preprocessorMixin2.posTracker;
    }
  };
  var tokenizerMixin = ErrorReportingTokenizerMixin$1;
  const ErrorReportingMixinBase = mixinBase;
  const ErrorReportingTokenizerMixin = tokenizerMixin;
  const LocationInfoTokenizerMixin = tokenizerMixin$1;
  const Mixin$1 = mixin;
  let ErrorReportingParserMixin$1 = class ErrorReportingParserMixin extends ErrorReportingMixinBase {
    constructor(parser2, opts) {
      super(parser2, opts);
      this.opts = opts;
      this.ctLoc = null;
      this.locBeforeToken = false;
    }
    _setErrorLocation(err) {
      if (this.ctLoc) {
        err.startLine = this.ctLoc.startLine;
        err.startCol = this.ctLoc.startCol;
        err.startOffset = this.ctLoc.startOffset;
        err.endLine = this.locBeforeToken ? this.ctLoc.startLine : this.ctLoc.endLine;
        err.endCol = this.locBeforeToken ? this.ctLoc.startCol : this.ctLoc.endCol;
        err.endOffset = this.locBeforeToken ? this.ctLoc.startOffset : this.ctLoc.endOffset;
      }
    }
    _getOverriddenMethods(mxn, orig) {
      return {
        _bootstrap(document2, fragmentContext) {
          orig._bootstrap.call(this, document2, fragmentContext);
          Mixin$1.install(this.tokenizer, ErrorReportingTokenizerMixin, mxn.opts);
          Mixin$1.install(this.tokenizer, LocationInfoTokenizerMixin);
        },
        _processInputToken(token) {
          mxn.ctLoc = token.location;
          orig._processInputToken.call(this, token);
        },
        _err(code2, options) {
          mxn.locBeforeToken = options && options.beforeToken;
          mxn._reportError(code2);
        }
      };
    }
  };
  var parserMixin = ErrorReportingParserMixin$1;
  var _default = {};
  const { DOCUMENT_MODE: DOCUMENT_MODE$1 } = html$6;
  _default.createDocument = function() {
    return {
      nodeName: "#document",
      mode: DOCUMENT_MODE$1.NO_QUIRKS,
      childNodes: []
    };
  };
  _default.createDocumentFragment = function() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  };
  _default.createElement = function(tagName, namespaceURI, attrs) {
    return {
      nodeName: tagName,
      tagName,
      attrs,
      namespaceURI,
      childNodes: [],
      parentNode: null
    };
  };
  _default.createCommentNode = function(data) {
    return {
      nodeName: "#comment",
      data,
      parentNode: null
    };
  };
  const createTextNode = function(value) {
    return {
      nodeName: "#text",
      value,
      parentNode: null
    };
  };
  const appendChild = _default.appendChild = function(parentNode2, newNode) {
    parentNode2.childNodes.push(newNode);
    newNode.parentNode = parentNode2;
  };
  const insertBefore = _default.insertBefore = function(parentNode2, newNode, referenceNode) {
    const insertionIdx = parentNode2.childNodes.indexOf(referenceNode);
    parentNode2.childNodes.splice(insertionIdx, 0, newNode);
    newNode.parentNode = parentNode2;
  };
  _default.setTemplateContent = function(templateElement, contentElement) {
    templateElement.content = contentElement;
  };
  _default.getTemplateContent = function(templateElement) {
    return templateElement.content;
  };
  _default.setDocumentType = function(document2, name, publicId, systemId) {
    let doctypeNode = null;
    for (let i2 = 0; i2 < document2.childNodes.length; i2++) {
      if (document2.childNodes[i2].nodeName === "#documentType") {
        doctypeNode = document2.childNodes[i2];
        break;
      }
    }
    if (doctypeNode) {
      doctypeNode.name = name;
      doctypeNode.publicId = publicId;
      doctypeNode.systemId = systemId;
    } else {
      appendChild(document2, {
        nodeName: "#documentType",
        name,
        publicId,
        systemId
      });
    }
  };
  _default.setDocumentMode = function(document2, mode) {
    document2.mode = mode;
  };
  _default.getDocumentMode = function(document2) {
    return document2.mode;
  };
  _default.detachNode = function(node2) {
    if (node2.parentNode) {
      const idx = node2.parentNode.childNodes.indexOf(node2);
      node2.parentNode.childNodes.splice(idx, 1);
      node2.parentNode = null;
    }
  };
  _default.insertText = function(parentNode2, text2) {
    if (parentNode2.childNodes.length) {
      const prevNode = parentNode2.childNodes[parentNode2.childNodes.length - 1];
      if (prevNode.nodeName === "#text") {
        prevNode.value += text2;
        return;
      }
    }
    appendChild(parentNode2, createTextNode(text2));
  };
  _default.insertTextBefore = function(parentNode2, text2, referenceNode) {
    const prevNode = parentNode2.childNodes[parentNode2.childNodes.indexOf(referenceNode) - 1];
    if (prevNode && prevNode.nodeName === "#text") {
      prevNode.value += text2;
    } else {
      insertBefore(parentNode2, createTextNode(text2), referenceNode);
    }
  };
  _default.adoptAttributes = function(recipient, attrs) {
    const recipientAttrsMap = [];
    for (let i2 = 0; i2 < recipient.attrs.length; i2++) {
      recipientAttrsMap.push(recipient.attrs[i2].name);
    }
    for (let j = 0; j < attrs.length; j++) {
      if (recipientAttrsMap.indexOf(attrs[j].name) === -1) {
        recipient.attrs.push(attrs[j]);
      }
    }
  };
  _default.getFirstChild = function(node2) {
    return node2.childNodes[0];
  };
  _default.getChildNodes = function(node2) {
    return node2.childNodes;
  };
  _default.getParentNode = function(node2) {
    return node2.parentNode;
  };
  _default.getAttrList = function(element2) {
    return element2.attrs;
  };
  _default.getTagName = function(element2) {
    return element2.tagName;
  };
  _default.getNamespaceURI = function(element2) {
    return element2.namespaceURI;
  };
  _default.getTextNodeContent = function(textNode) {
    return textNode.value;
  };
  _default.getCommentNodeContent = function(commentNode) {
    return commentNode.data;
  };
  _default.getDocumentTypeNodeName = function(doctypeNode) {
    return doctypeNode.name;
  };
  _default.getDocumentTypeNodePublicId = function(doctypeNode) {
    return doctypeNode.publicId;
  };
  _default.getDocumentTypeNodeSystemId = function(doctypeNode) {
    return doctypeNode.systemId;
  };
  _default.isTextNode = function(node2) {
    return node2.nodeName === "#text";
  };
  _default.isCommentNode = function(node2) {
    return node2.nodeName === "#comment";
  };
  _default.isDocumentTypeNode = function(node2) {
    return node2.nodeName === "#documentType";
  };
  _default.isElementNode = function(node2) {
    return !!node2.tagName;
  };
  _default.setNodeSourceCodeLocation = function(node2, location2) {
    node2.sourceCodeLocation = location2;
  };
  _default.getNodeSourceCodeLocation = function(node2) {
    return node2.sourceCodeLocation;
  };
  _default.updateNodeSourceCodeLocation = function(node2, endLocation) {
    node2.sourceCodeLocation = Object.assign(node2.sourceCodeLocation, endLocation);
  };
  var mergeOptions$1 = function mergeOptions2(defaults2, options) {
    options = options || /* @__PURE__ */ Object.create(null);
    return [defaults2, options].reduce((merged, optObj) => {
      Object.keys(optObj).forEach((key2) => {
        merged[key2] = optObj[key2];
      });
      return merged;
    }, /* @__PURE__ */ Object.create(null));
  };
  var doctype$3 = {};
  const { DOCUMENT_MODE } = html$6;
  const VALID_DOCTYPE_NAME = "html";
  const VALID_SYSTEM_ID = "about:legacy-compat";
  const QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
  const QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
    "+//silmaril//dtd html pro v0r11 19970101//",
    "-//as//dtd html 3.0 aswedit + extensions//",
    "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
    "-//ietf//dtd html 2.0 level 1//",
    "-//ietf//dtd html 2.0 level 2//",
    "-//ietf//dtd html 2.0 strict level 1//",
    "-//ietf//dtd html 2.0 strict level 2//",
    "-//ietf//dtd html 2.0 strict//",
    "-//ietf//dtd html 2.0//",
    "-//ietf//dtd html 2.1e//",
    "-//ietf//dtd html 3.0//",
    "-//ietf//dtd html 3.2 final//",
    "-//ietf//dtd html 3.2//",
    "-//ietf//dtd html 3//",
    "-//ietf//dtd html level 0//",
    "-//ietf//dtd html level 1//",
    "-//ietf//dtd html level 2//",
    "-//ietf//dtd html level 3//",
    "-//ietf//dtd html strict level 0//",
    "-//ietf//dtd html strict level 1//",
    "-//ietf//dtd html strict level 2//",
    "-//ietf//dtd html strict level 3//",
    "-//ietf//dtd html strict//",
    "-//ietf//dtd html//",
    "-//metrius//dtd metrius presentational//",
    "-//microsoft//dtd internet explorer 2.0 html strict//",
    "-//microsoft//dtd internet explorer 2.0 html//",
    "-//microsoft//dtd internet explorer 2.0 tables//",
    "-//microsoft//dtd internet explorer 3.0 html strict//",
    "-//microsoft//dtd internet explorer 3.0 html//",
    "-//microsoft//dtd internet explorer 3.0 tables//",
    "-//netscape comm. corp.//dtd html//",
    "-//netscape comm. corp.//dtd strict html//",
    "-//o'reilly and associates//dtd html 2.0//",
    "-//o'reilly and associates//dtd html extended 1.0//",
    "-//o'reilly and associates//dtd html extended relaxed 1.0//",
    "-//sq//dtd html 2.0 hotmetal + extensions//",
    "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
    "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
    "-//spyglass//dtd html 2.0 extended//",
    "-//sun microsystems corp.//dtd hotjava html//",
    "-//sun microsystems corp.//dtd hotjava strict html//",
    "-//w3c//dtd html 3 1995-03-24//",
    "-//w3c//dtd html 3.2 draft//",
    "-//w3c//dtd html 3.2 final//",
    "-//w3c//dtd html 3.2//",
    "-//w3c//dtd html 3.2s draft//",
    "-//w3c//dtd html 4.0 frameset//",
    "-//w3c//dtd html 4.0 transitional//",
    "-//w3c//dtd html experimental 19960712//",
    "-//w3c//dtd html experimental 970421//",
    "-//w3c//dtd w3 html//",
    "-//w3o//dtd w3 html 3.0//",
    "-//webtechs//dtd mozilla html 2.0//",
    "-//webtechs//dtd mozilla html//"
  ];
  const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = QUIRKS_MODE_PUBLIC_ID_PREFIXES.concat([
    "-//w3c//dtd html 4.01 frameset//",
    "-//w3c//dtd html 4.01 transitional//"
  ]);
  const QUIRKS_MODE_PUBLIC_IDS = ["-//w3o//dtd w3 html strict 3.0//en//", "-/w3c/dtd html 4.0 transitional/en", "html"];
  const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
  const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = LIMITED_QUIRKS_PUBLIC_ID_PREFIXES.concat([
    "-//w3c//dtd html 4.01 frameset//",
    "-//w3c//dtd html 4.01 transitional//"
  ]);
  function enquoteDoctypeId(id) {
    const quote = id.indexOf('"') !== -1 ? "'" : '"';
    return quote + id + quote;
  }
  function hasPrefix(publicId, prefixes) {
    for (let i2 = 0; i2 < prefixes.length; i2++) {
      if (publicId.indexOf(prefixes[i2]) === 0) {
        return true;
      }
    }
    return false;
  }
  doctype$3.isConforming = function(token) {
    return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
  };
  doctype$3.getDocumentMode = function(token) {
    if (token.name !== VALID_DOCTYPE_NAME) {
      return DOCUMENT_MODE.QUIRKS;
    }
    const systemId = token.systemId;
    if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
      return DOCUMENT_MODE.QUIRKS;
    }
    let publicId = token.publicId;
    if (publicId !== null) {
      publicId = publicId.toLowerCase();
      if (QUIRKS_MODE_PUBLIC_IDS.indexOf(publicId) > -1) {
        return DOCUMENT_MODE.QUIRKS;
      }
      let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
      if (hasPrefix(publicId, prefixes)) {
        return DOCUMENT_MODE.QUIRKS;
      }
      prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
      if (hasPrefix(publicId, prefixes)) {
        return DOCUMENT_MODE.LIMITED_QUIRKS;
      }
    }
    return DOCUMENT_MODE.NO_QUIRKS;
  };
  doctype$3.serializeContent = function(name, publicId, systemId) {
    let str = "!DOCTYPE ";
    if (name) {
      str += name;
    }
    if (publicId) {
      str += " PUBLIC " + enquoteDoctypeId(publicId);
    } else if (systemId) {
      str += " SYSTEM";
    }
    if (systemId !== null) {
      str += " " + enquoteDoctypeId(systemId);
    }
    return str;
  };
  var foreignContent$1 = {};
  const Tokenizer$1 = tokenizer;
  const HTML$1 = html$6;
  const $$1 = HTML$1.TAG_NAMES;
  const NS$1 = HTML$1.NAMESPACES;
  const ATTRS$1 = HTML$1.ATTRS;
  const MIME_TYPES = {
    TEXT_HTML: "text/html",
    APPLICATION_XML: "application/xhtml+xml"
  };
  const DEFINITION_URL_ATTR = "definitionurl";
  const ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
  const SVG_ATTRS_ADJUSTMENT_MAP = {
    attributename: "attributeName",
    attributetype: "attributeType",
    basefrequency: "baseFrequency",
    baseprofile: "baseProfile",
    calcmode: "calcMode",
    clippathunits: "clipPathUnits",
    diffuseconstant: "diffuseConstant",
    edgemode: "edgeMode",
    filterunits: "filterUnits",
    glyphref: "glyphRef",
    gradienttransform: "gradientTransform",
    gradientunits: "gradientUnits",
    kernelmatrix: "kernelMatrix",
    kernelunitlength: "kernelUnitLength",
    keypoints: "keyPoints",
    keysplines: "keySplines",
    keytimes: "keyTimes",
    lengthadjust: "lengthAdjust",
    limitingconeangle: "limitingConeAngle",
    markerheight: "markerHeight",
    markerunits: "markerUnits",
    markerwidth: "markerWidth",
    maskcontentunits: "maskContentUnits",
    maskunits: "maskUnits",
    numoctaves: "numOctaves",
    pathlength: "pathLength",
    patterncontentunits: "patternContentUnits",
    patterntransform: "patternTransform",
    patternunits: "patternUnits",
    pointsatx: "pointsAtX",
    pointsaty: "pointsAtY",
    pointsatz: "pointsAtZ",
    preservealpha: "preserveAlpha",
    preserveaspectratio: "preserveAspectRatio",
    primitiveunits: "primitiveUnits",
    refx: "refX",
    refy: "refY",
    repeatcount: "repeatCount",
    repeatdur: "repeatDur",
    requiredextensions: "requiredExtensions",
    requiredfeatures: "requiredFeatures",
    specularconstant: "specularConstant",
    specularexponent: "specularExponent",
    spreadmethod: "spreadMethod",
    startoffset: "startOffset",
    stddeviation: "stdDeviation",
    stitchtiles: "stitchTiles",
    surfacescale: "surfaceScale",
    systemlanguage: "systemLanguage",
    tablevalues: "tableValues",
    targetx: "targetX",
    targety: "targetY",
    textlength: "textLength",
    viewbox: "viewBox",
    viewtarget: "viewTarget",
    xchannelselector: "xChannelSelector",
    ychannelselector: "yChannelSelector",
    zoomandpan: "zoomAndPan"
  };
  const XML_ATTRS_ADJUSTMENT_MAP = {
    "xlink:actuate": { prefix: "xlink", name: "actuate", namespace: NS$1.XLINK },
    "xlink:arcrole": { prefix: "xlink", name: "arcrole", namespace: NS$1.XLINK },
    "xlink:href": { prefix: "xlink", name: "href", namespace: NS$1.XLINK },
    "xlink:role": { prefix: "xlink", name: "role", namespace: NS$1.XLINK },
    "xlink:show": { prefix: "xlink", name: "show", namespace: NS$1.XLINK },
    "xlink:title": { prefix: "xlink", name: "title", namespace: NS$1.XLINK },
    "xlink:type": { prefix: "xlink", name: "type", namespace: NS$1.XLINK },
    "xml:base": { prefix: "xml", name: "base", namespace: NS$1.XML },
    "xml:lang": { prefix: "xml", name: "lang", namespace: NS$1.XML },
    "xml:space": { prefix: "xml", name: "space", namespace: NS$1.XML },
    xmlns: { prefix: "", name: "xmlns", namespace: NS$1.XMLNS },
    "xmlns:xlink": { prefix: "xmlns", name: "xlink", namespace: NS$1.XMLNS }
  };
  const SVG_TAG_NAMES_ADJUSTMENT_MAP = foreignContent$1.SVG_TAG_NAMES_ADJUSTMENT_MAP = {
    altglyph: "altGlyph",
    altglyphdef: "altGlyphDef",
    altglyphitem: "altGlyphItem",
    animatecolor: "animateColor",
    animatemotion: "animateMotion",
    animatetransform: "animateTransform",
    clippath: "clipPath",
    feblend: "feBlend",
    fecolormatrix: "feColorMatrix",
    fecomponenttransfer: "feComponentTransfer",
    fecomposite: "feComposite",
    feconvolvematrix: "feConvolveMatrix",
    fediffuselighting: "feDiffuseLighting",
    fedisplacementmap: "feDisplacementMap",
    fedistantlight: "feDistantLight",
    feflood: "feFlood",
    fefunca: "feFuncA",
    fefuncb: "feFuncB",
    fefuncg: "feFuncG",
    fefuncr: "feFuncR",
    fegaussianblur: "feGaussianBlur",
    feimage: "feImage",
    femerge: "feMerge",
    femergenode: "feMergeNode",
    femorphology: "feMorphology",
    feoffset: "feOffset",
    fepointlight: "fePointLight",
    fespecularlighting: "feSpecularLighting",
    fespotlight: "feSpotLight",
    fetile: "feTile",
    feturbulence: "feTurbulence",
    foreignobject: "foreignObject",
    glyphref: "glyphRef",
    lineargradient: "linearGradient",
    radialgradient: "radialGradient",
    textpath: "textPath"
  };
  const EXITS_FOREIGN_CONTENT = {
    [$$1.B]: true,
    [$$1.BIG]: true,
    [$$1.BLOCKQUOTE]: true,
    [$$1.BODY]: true,
    [$$1.BR]: true,
    [$$1.CENTER]: true,
    [$$1.CODE]: true,
    [$$1.DD]: true,
    [$$1.DIV]: true,
    [$$1.DL]: true,
    [$$1.DT]: true,
    [$$1.EM]: true,
    [$$1.EMBED]: true,
    [$$1.H1]: true,
    [$$1.H2]: true,
    [$$1.H3]: true,
    [$$1.H4]: true,
    [$$1.H5]: true,
    [$$1.H6]: true,
    [$$1.HEAD]: true,
    [$$1.HR]: true,
    [$$1.I]: true,
    [$$1.IMG]: true,
    [$$1.LI]: true,
    [$$1.LISTING]: true,
    [$$1.MENU]: true,
    [$$1.META]: true,
    [$$1.NOBR]: true,
    [$$1.OL]: true,
    [$$1.P]: true,
    [$$1.PRE]: true,
    [$$1.RUBY]: true,
    [$$1.S]: true,
    [$$1.SMALL]: true,
    [$$1.SPAN]: true,
    [$$1.STRONG]: true,
    [$$1.STRIKE]: true,
    [$$1.SUB]: true,
    [$$1.SUP]: true,
    [$$1.TABLE]: true,
    [$$1.TT]: true,
    [$$1.U]: true,
    [$$1.UL]: true,
    [$$1.VAR]: true
  };
  foreignContent$1.causesExit = function(startTagToken) {
    const tn = startTagToken.tagName;
    const isFontWithAttrs = tn === $$1.FONT && (Tokenizer$1.getTokenAttr(startTagToken, ATTRS$1.COLOR) !== null || Tokenizer$1.getTokenAttr(startTagToken, ATTRS$1.SIZE) !== null || Tokenizer$1.getTokenAttr(startTagToken, ATTRS$1.FACE) !== null);
    return isFontWithAttrs ? true : EXITS_FOREIGN_CONTENT[tn];
  };
  foreignContent$1.adjustTokenMathMLAttrs = function(token) {
    for (let i2 = 0; i2 < token.attrs.length; i2++) {
      if (token.attrs[i2].name === DEFINITION_URL_ATTR) {
        token.attrs[i2].name = ADJUSTED_DEFINITION_URL_ATTR;
        break;
      }
    }
  };
  foreignContent$1.adjustTokenSVGAttrs = function(token) {
    for (let i2 = 0; i2 < token.attrs.length; i2++) {
      const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP[token.attrs[i2].name];
      if (adjustedAttrName) {
        token.attrs[i2].name = adjustedAttrName;
      }
    }
  };
  foreignContent$1.adjustTokenXMLAttrs = function(token) {
    for (let i2 = 0; i2 < token.attrs.length; i2++) {
      const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP[token.attrs[i2].name];
      if (adjustedAttrEntry) {
        token.attrs[i2].prefix = adjustedAttrEntry.prefix;
        token.attrs[i2].name = adjustedAttrEntry.name;
        token.attrs[i2].namespace = adjustedAttrEntry.namespace;
      }
    }
  };
  foreignContent$1.adjustTokenSVGTagName = function(token) {
    const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP[token.tagName];
    if (adjustedTagName) {
      token.tagName = adjustedTagName;
    }
  };
  function isMathMLTextIntegrationPoint(tn, ns) {
    return ns === NS$1.MATHML && (tn === $$1.MI || tn === $$1.MO || tn === $$1.MN || tn === $$1.MS || tn === $$1.MTEXT);
  }
  function isHtmlIntegrationPoint(tn, ns, attrs) {
    if (ns === NS$1.MATHML && tn === $$1.ANNOTATION_XML) {
      for (let i2 = 0; i2 < attrs.length; i2++) {
        if (attrs[i2].name === ATTRS$1.ENCODING) {
          const value = attrs[i2].value.toLowerCase();
          return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
        }
      }
    }
    return ns === NS$1.SVG && (tn === $$1.FOREIGN_OBJECT || tn === $$1.DESC || tn === $$1.TITLE);
  }
  foreignContent$1.isIntegrationPoint = function(tn, ns, attrs, foreignNS) {
    if ((!foreignNS || foreignNS === NS$1.HTML) && isHtmlIntegrationPoint(tn, ns, attrs)) {
      return true;
    }
    if ((!foreignNS || foreignNS === NS$1.MATHML) && isMathMLTextIntegrationPoint(tn, ns)) {
      return true;
    }
    return false;
  };
  const Tokenizer = tokenizer;
  const OpenElementStack = openElementStack;
  const FormattingElementList = formattingElementList;
  const LocationInfoParserMixin = parserMixin$1;
  const ErrorReportingParserMixin = parserMixin;
  const Mixin = mixin;
  const defaultTreeAdapter = _default;
  const mergeOptions = mergeOptions$1;
  const doctype$2 = doctype$3;
  const foreignContent = foreignContent$1;
  const ERR = errorCodes;
  const unicode = unicode$3;
  const HTML = html$6;
  const $ = HTML.TAG_NAMES;
  const NS = HTML.NAMESPACES;
  const ATTRS = HTML.ATTRS;
  const DEFAULT_OPTIONS = {
    scriptingEnabled: true,
    sourceCodeLocationInfo: false,
    onParseError: null,
    treeAdapter: defaultTreeAdapter
  };
  const HIDDEN_INPUT_TYPE = "hidden";
  const AA_OUTER_LOOP_ITER = 8;
  const AA_INNER_LOOP_ITER = 3;
  const INITIAL_MODE = "INITIAL_MODE";
  const BEFORE_HTML_MODE = "BEFORE_HTML_MODE";
  const BEFORE_HEAD_MODE = "BEFORE_HEAD_MODE";
  const IN_HEAD_MODE = "IN_HEAD_MODE";
  const IN_HEAD_NO_SCRIPT_MODE = "IN_HEAD_NO_SCRIPT_MODE";
  const AFTER_HEAD_MODE = "AFTER_HEAD_MODE";
  const IN_BODY_MODE = "IN_BODY_MODE";
  const TEXT_MODE = "TEXT_MODE";
  const IN_TABLE_MODE = "IN_TABLE_MODE";
  const IN_TABLE_TEXT_MODE = "IN_TABLE_TEXT_MODE";
  const IN_CAPTION_MODE = "IN_CAPTION_MODE";
  const IN_COLUMN_GROUP_MODE = "IN_COLUMN_GROUP_MODE";
  const IN_TABLE_BODY_MODE = "IN_TABLE_BODY_MODE";
  const IN_ROW_MODE = "IN_ROW_MODE";
  const IN_CELL_MODE = "IN_CELL_MODE";
  const IN_SELECT_MODE = "IN_SELECT_MODE";
  const IN_SELECT_IN_TABLE_MODE = "IN_SELECT_IN_TABLE_MODE";
  const IN_TEMPLATE_MODE = "IN_TEMPLATE_MODE";
  const AFTER_BODY_MODE = "AFTER_BODY_MODE";
  const IN_FRAMESET_MODE = "IN_FRAMESET_MODE";
  const AFTER_FRAMESET_MODE = "AFTER_FRAMESET_MODE";
  const AFTER_AFTER_BODY_MODE = "AFTER_AFTER_BODY_MODE";
  const AFTER_AFTER_FRAMESET_MODE = "AFTER_AFTER_FRAMESET_MODE";
  const INSERTION_MODE_RESET_MAP = {
    [$.TR]: IN_ROW_MODE,
    [$.TBODY]: IN_TABLE_BODY_MODE,
    [$.THEAD]: IN_TABLE_BODY_MODE,
    [$.TFOOT]: IN_TABLE_BODY_MODE,
    [$.CAPTION]: IN_CAPTION_MODE,
    [$.COLGROUP]: IN_COLUMN_GROUP_MODE,
    [$.TABLE]: IN_TABLE_MODE,
    [$.BODY]: IN_BODY_MODE,
    [$.FRAMESET]: IN_FRAMESET_MODE
  };
  const TEMPLATE_INSERTION_MODE_SWITCH_MAP = {
    [$.CAPTION]: IN_TABLE_MODE,
    [$.COLGROUP]: IN_TABLE_MODE,
    [$.TBODY]: IN_TABLE_MODE,
    [$.TFOOT]: IN_TABLE_MODE,
    [$.THEAD]: IN_TABLE_MODE,
    [$.COL]: IN_COLUMN_GROUP_MODE,
    [$.TR]: IN_TABLE_BODY_MODE,
    [$.TD]: IN_ROW_MODE,
    [$.TH]: IN_ROW_MODE
  };
  const TOKEN_HANDLERS = {
    [INITIAL_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenInInitialMode,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInInitialMode,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: doctypeInInitialMode,
      [Tokenizer.START_TAG_TOKEN]: tokenInInitialMode,
      [Tokenizer.END_TAG_TOKEN]: tokenInInitialMode,
      [Tokenizer.EOF_TOKEN]: tokenInInitialMode
    },
    [BEFORE_HTML_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHtml,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHtml,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagBeforeHtml,
      [Tokenizer.END_TAG_TOKEN]: endTagBeforeHtml,
      [Tokenizer.EOF_TOKEN]: tokenBeforeHtml
    },
    [BEFORE_HEAD_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHead,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHead,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
      [Tokenizer.START_TAG_TOKEN]: startTagBeforeHead,
      [Tokenizer.END_TAG_TOKEN]: endTagBeforeHead,
      [Tokenizer.EOF_TOKEN]: tokenBeforeHead
    },
    [IN_HEAD_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenInHead,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHead,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
      [Tokenizer.START_TAG_TOKEN]: startTagInHead,
      [Tokenizer.END_TAG_TOKEN]: endTagInHead,
      [Tokenizer.EOF_TOKEN]: tokenInHead
    },
    [IN_HEAD_NO_SCRIPT_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenInHeadNoScript,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHeadNoScript,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
      [Tokenizer.START_TAG_TOKEN]: startTagInHeadNoScript,
      [Tokenizer.END_TAG_TOKEN]: endTagInHeadNoScript,
      [Tokenizer.EOF_TOKEN]: tokenInHeadNoScript
    },
    [AFTER_HEAD_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenAfterHead,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterHead,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
      [Tokenizer.START_TAG_TOKEN]: startTagAfterHead,
      [Tokenizer.END_TAG_TOKEN]: endTagAfterHead,
      [Tokenizer.EOF_TOKEN]: tokenAfterHead
    },
    [IN_BODY_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: characterInBody,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInBody,
      [Tokenizer.END_TAG_TOKEN]: endTagInBody,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [TEXT_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.NULL_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: ignoreToken,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: ignoreToken,
      [Tokenizer.END_TAG_TOKEN]: endTagInText,
      [Tokenizer.EOF_TOKEN]: eofInText
    },
    [IN_TABLE_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInTable,
      [Tokenizer.END_TAG_TOKEN]: endTagInTable,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_TABLE_TEXT_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: characterInTableText,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInTableText,
      [Tokenizer.COMMENT_TOKEN]: tokenInTableText,
      [Tokenizer.DOCTYPE_TOKEN]: tokenInTableText,
      [Tokenizer.START_TAG_TOKEN]: tokenInTableText,
      [Tokenizer.END_TAG_TOKEN]: tokenInTableText,
      [Tokenizer.EOF_TOKEN]: tokenInTableText
    },
    [IN_CAPTION_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: characterInBody,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInCaption,
      [Tokenizer.END_TAG_TOKEN]: endTagInCaption,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_COLUMN_GROUP_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenInColumnGroup,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInColumnGroup,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInColumnGroup,
      [Tokenizer.END_TAG_TOKEN]: endTagInColumnGroup,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_TABLE_BODY_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInTableBody,
      [Tokenizer.END_TAG_TOKEN]: endTagInTableBody,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_ROW_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInRow,
      [Tokenizer.END_TAG_TOKEN]: endTagInRow,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_CELL_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: characterInBody,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInCell,
      [Tokenizer.END_TAG_TOKEN]: endTagInCell,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_SELECT_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInSelect,
      [Tokenizer.END_TAG_TOKEN]: endTagInSelect,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_SELECT_IN_TABLE_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInSelectInTable,
      [Tokenizer.END_TAG_TOKEN]: endTagInSelectInTable,
      [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_TEMPLATE_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: characterInBody,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInTemplate,
      [Tokenizer.END_TAG_TOKEN]: endTagInTemplate,
      [Tokenizer.EOF_TOKEN]: eofInTemplate
    },
    [AFTER_BODY_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenAfterBody,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterBody,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
      [Tokenizer.COMMENT_TOKEN]: appendCommentToRootHtmlElement,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagAfterBody,
      [Tokenizer.END_TAG_TOKEN]: endTagAfterBody,
      [Tokenizer.EOF_TOKEN]: stopParsing
    },
    [IN_FRAMESET_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagInFrameset,
      [Tokenizer.END_TAG_TOKEN]: endTagInFrameset,
      [Tokenizer.EOF_TOKEN]: stopParsing
    },
    [AFTER_FRAMESET_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
      [Tokenizer.COMMENT_TOKEN]: appendComment,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagAfterFrameset,
      [Tokenizer.END_TAG_TOKEN]: endTagAfterFrameset,
      [Tokenizer.EOF_TOKEN]: stopParsing
    },
    [AFTER_AFTER_BODY_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: tokenAfterAfterBody,
      [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterAfterBody,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
      [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterBody,
      [Tokenizer.END_TAG_TOKEN]: tokenAfterAfterBody,
      [Tokenizer.EOF_TOKEN]: stopParsing
    },
    [AFTER_AFTER_FRAMESET_MODE]: {
      [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
      [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
      [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
      [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
      [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterFrameset,
      [Tokenizer.END_TAG_TOKEN]: ignoreToken,
      [Tokenizer.EOF_TOKEN]: stopParsing
    }
  };
  class Parser {
    constructor(options) {
      this.options = mergeOptions(DEFAULT_OPTIONS, options);
      this.treeAdapter = this.options.treeAdapter;
      this.pendingScript = null;
      if (this.options.sourceCodeLocationInfo) {
        Mixin.install(this, LocationInfoParserMixin);
      }
      if (this.options.onParseError) {
        Mixin.install(this, ErrorReportingParserMixin, { onParseError: this.options.onParseError });
      }
    }
    // API
    parse(html2) {
      const document2 = this.treeAdapter.createDocument();
      this._bootstrap(document2, null);
      this.tokenizer.write(html2, true);
      this._runParsingLoop(null);
      return document2;
    }
    parseFragment(html2, fragmentContext) {
      if (!fragmentContext) {
        fragmentContext = this.treeAdapter.createElement($.TEMPLATE, NS.HTML, []);
      }
      const documentMock = this.treeAdapter.createElement("documentmock", NS.HTML, []);
      this._bootstrap(documentMock, fragmentContext);
      if (this.treeAdapter.getTagName(fragmentContext) === $.TEMPLATE) {
        this._pushTmplInsertionMode(IN_TEMPLATE_MODE);
      }
      this._initTokenizerForFragmentParsing();
      this._insertFakeRootElement();
      this._resetInsertionMode();
      this._findFormInFragmentContext();
      this.tokenizer.write(html2, true);
      this._runParsingLoop(null);
      const rootElement = this.treeAdapter.getFirstChild(documentMock);
      const fragment = this.treeAdapter.createDocumentFragment();
      this._adoptNodes(rootElement, fragment);
      return fragment;
    }
    //Bootstrap parser
    _bootstrap(document2, fragmentContext) {
      this.tokenizer = new Tokenizer(this.options);
      this.stopped = false;
      this.insertionMode = INITIAL_MODE;
      this.originalInsertionMode = "";
      this.document = document2;
      this.fragmentContext = fragmentContext;
      this.headElement = null;
      this.formElement = null;
      this.openElements = new OpenElementStack(this.document, this.treeAdapter);
      this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
      this.tmplInsertionModeStack = [];
      this.tmplInsertionModeStackTop = -1;
      this.currentTmplInsertionMode = null;
      this.pendingCharacterTokens = [];
      this.hasNonWhitespacePendingCharacterToken = false;
      this.framesetOk = true;
      this.skipNextNewLine = false;
      this.fosterParentingEnabled = false;
    }
    //Errors
    _err() {
    }
    //Parsing loop
    _runParsingLoop(scriptHandler) {
      while (!this.stopped) {
        this._setupTokenizerCDATAMode();
        const token = this.tokenizer.getNextToken();
        if (token.type === Tokenizer.HIBERNATION_TOKEN) {
          break;
        }
        if (this.skipNextNewLine) {
          this.skipNextNewLine = false;
          if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === "\n") {
            if (token.chars.length === 1) {
              continue;
            }
            token.chars = token.chars.substr(1);
          }
        }
        this._processInputToken(token);
        if (scriptHandler && this.pendingScript) {
          break;
        }
      }
    }
    runParsingLoopForCurrentChunk(writeCallback, scriptHandler) {
      this._runParsingLoop(scriptHandler);
      if (scriptHandler && this.pendingScript) {
        const script = this.pendingScript;
        this.pendingScript = null;
        scriptHandler(script);
        return;
      }
      if (writeCallback) {
        writeCallback();
      }
    }
    //Text parsing
    _setupTokenizerCDATAMode() {
      const current = this._getAdjustedCurrentElement();
      this.tokenizer.allowCDATA = current && current !== this.document && this.treeAdapter.getNamespaceURI(current) !== NS.HTML && !this._isIntegrationPoint(current);
    }
    _switchToTextParsing(currentToken, nextTokenizerState) {
      this._insertElement(currentToken, NS.HTML);
      this.tokenizer.state = nextTokenizerState;
      this.originalInsertionMode = this.insertionMode;
      this.insertionMode = TEXT_MODE;
    }
    switchToPlaintextParsing() {
      this.insertionMode = TEXT_MODE;
      this.originalInsertionMode = IN_BODY_MODE;
      this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
    }
    //Fragment parsing
    _getAdjustedCurrentElement() {
      return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
    }
    _findFormInFragmentContext() {
      let node2 = this.fragmentContext;
      do {
        if (this.treeAdapter.getTagName(node2) === $.FORM) {
          this.formElement = node2;
          break;
        }
        node2 = this.treeAdapter.getParentNode(node2);
      } while (node2);
    }
    _initTokenizerForFragmentParsing() {
      if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === NS.HTML) {
        const tn = this.treeAdapter.getTagName(this.fragmentContext);
        if (tn === $.TITLE || tn === $.TEXTAREA) {
          this.tokenizer.state = Tokenizer.MODE.RCDATA;
        } else if (tn === $.STYLE || tn === $.XMP || tn === $.IFRAME || tn === $.NOEMBED || tn === $.NOFRAMES || tn === $.NOSCRIPT) {
          this.tokenizer.state = Tokenizer.MODE.RAWTEXT;
        } else if (tn === $.SCRIPT) {
          this.tokenizer.state = Tokenizer.MODE.SCRIPT_DATA;
        } else if (tn === $.PLAINTEXT) {
          this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
        }
      }
    }
    //Tree mutation
    _setDocumentType(token) {
      const name = token.name || "";
      const publicId = token.publicId || "";
      const systemId = token.systemId || "";
      this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
    }
    _attachElementToTree(element2) {
      if (this._shouldFosterParentOnInsertion()) {
        this._fosterParentElement(element2);
      } else {
        const parent = this.openElements.currentTmplContent || this.openElements.current;
        this.treeAdapter.appendChild(parent, element2);
      }
    }
    _appendElement(token, namespaceURI) {
      const element2 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
      this._attachElementToTree(element2);
    }
    _insertElement(token, namespaceURI) {
      const element2 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
      this._attachElementToTree(element2);
      this.openElements.push(element2);
    }
    _insertFakeElement(tagName) {
      const element2 = this.treeAdapter.createElement(tagName, NS.HTML, []);
      this._attachElementToTree(element2);
      this.openElements.push(element2);
    }
    _insertTemplate(token) {
      const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
      const content2 = this.treeAdapter.createDocumentFragment();
      this.treeAdapter.setTemplateContent(tmpl, content2);
      this._attachElementToTree(tmpl);
      this.openElements.push(tmpl);
    }
    _insertFakeRootElement() {
      const element2 = this.treeAdapter.createElement($.HTML, NS.HTML, []);
      this.treeAdapter.appendChild(this.openElements.current, element2);
      this.openElements.push(element2);
    }
    _appendCommentNode(token, parent) {
      const commentNode = this.treeAdapter.createCommentNode(token.data);
      this.treeAdapter.appendChild(parent, commentNode);
    }
    _insertCharacters(token) {
      if (this._shouldFosterParentOnInsertion()) {
        this._fosterParentText(token.chars);
      } else {
        const parent = this.openElements.currentTmplContent || this.openElements.current;
        this.treeAdapter.insertText(parent, token.chars);
      }
    }
    _adoptNodes(donor, recipient) {
      for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
        this.treeAdapter.detachNode(child);
        this.treeAdapter.appendChild(recipient, child);
      }
    }
    //Token processing
    _shouldProcessTokenInForeignContent(token) {
      const current = this._getAdjustedCurrentElement();
      if (!current || current === this.document) {
        return false;
      }
      const ns = this.treeAdapter.getNamespaceURI(current);
      if (ns === NS.HTML) {
        return false;
      }
      if (this.treeAdapter.getTagName(current) === $.ANNOTATION_XML && ns === NS.MATHML && token.type === Tokenizer.START_TAG_TOKEN && token.tagName === $.SVG) {
        return false;
      }
      const isCharacterToken = token.type === Tokenizer.CHARACTER_TOKEN || token.type === Tokenizer.NULL_CHARACTER_TOKEN || token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN;
      const isMathMLTextStartTag = token.type === Tokenizer.START_TAG_TOKEN && token.tagName !== $.MGLYPH && token.tagName !== $.MALIGNMARK;
      if ((isMathMLTextStartTag || isCharacterToken) && this._isIntegrationPoint(current, NS.MATHML)) {
        return false;
      }
      if ((token.type === Tokenizer.START_TAG_TOKEN || isCharacterToken) && this._isIntegrationPoint(current, NS.HTML)) {
        return false;
      }
      return token.type !== Tokenizer.EOF_TOKEN;
    }
    _processToken(token) {
      TOKEN_HANDLERS[this.insertionMode][token.type](this, token);
    }
    _processTokenInBodyMode(token) {
      TOKEN_HANDLERS[IN_BODY_MODE][token.type](this, token);
    }
    _processTokenInForeignContent(token) {
      if (token.type === Tokenizer.CHARACTER_TOKEN) {
        characterInForeignContent(this, token);
      } else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN) {
        nullCharacterInForeignContent(this, token);
      } else if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN) {
        insertCharacters(this, token);
      } else if (token.type === Tokenizer.COMMENT_TOKEN) {
        appendComment(this, token);
      } else if (token.type === Tokenizer.START_TAG_TOKEN) {
        startTagInForeignContent(this, token);
      } else if (token.type === Tokenizer.END_TAG_TOKEN) {
        endTagInForeignContent(this, token);
      }
    }
    _processInputToken(token) {
      if (this._shouldProcessTokenInForeignContent(token)) {
        this._processTokenInForeignContent(token);
      } else {
        this._processToken(token);
      }
      if (token.type === Tokenizer.START_TAG_TOKEN && token.selfClosing && !token.ackSelfClosing) {
        this._err(ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
      }
    }
    //Integration points
    _isIntegrationPoint(element2, foreignNS) {
      const tn = this.treeAdapter.getTagName(element2);
      const ns = this.treeAdapter.getNamespaceURI(element2);
      const attrs = this.treeAdapter.getAttrList(element2);
      return foreignContent.isIntegrationPoint(tn, ns, attrs, foreignNS);
    }
    //Active formatting elements reconstruction
    _reconstructActiveFormattingElements() {
      const listLength = this.activeFormattingElements.length;
      if (listLength) {
        let unopenIdx = listLength;
        let entry = null;
        do {
          unopenIdx--;
          entry = this.activeFormattingElements.entries[unopenIdx];
          if (entry.type === FormattingElementList.MARKER_ENTRY || this.openElements.contains(entry.element)) {
            unopenIdx++;
            break;
          }
        } while (unopenIdx > 0);
        for (let i2 = unopenIdx; i2 < listLength; i2++) {
          entry = this.activeFormattingElements.entries[i2];
          this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
          entry.element = this.openElements.current;
        }
      }
    }
    //Close elements
    _closeTableCell() {
      this.openElements.generateImpliedEndTags();
      this.openElements.popUntilTableCellPopped();
      this.activeFormattingElements.clearToLastMarker();
      this.insertionMode = IN_ROW_MODE;
    }
    _closePElement() {
      this.openElements.generateImpliedEndTagsWithExclusion($.P);
      this.openElements.popUntilTagNamePopped($.P);
    }
    //Insertion modes
    _resetInsertionMode() {
      for (let i2 = this.openElements.stackTop, last2 = false; i2 >= 0; i2--) {
        let element2 = this.openElements.items[i2];
        if (i2 === 0) {
          last2 = true;
          if (this.fragmentContext) {
            element2 = this.fragmentContext;
          }
        }
        const tn = this.treeAdapter.getTagName(element2);
        const newInsertionMode = INSERTION_MODE_RESET_MAP[tn];
        if (newInsertionMode) {
          this.insertionMode = newInsertionMode;
          break;
        } else if (!last2 && (tn === $.TD || tn === $.TH)) {
          this.insertionMode = IN_CELL_MODE;
          break;
        } else if (!last2 && tn === $.HEAD) {
          this.insertionMode = IN_HEAD_MODE;
          break;
        } else if (tn === $.SELECT) {
          this._resetInsertionModeForSelect(i2);
          break;
        } else if (tn === $.TEMPLATE) {
          this.insertionMode = this.currentTmplInsertionMode;
          break;
        } else if (tn === $.HTML) {
          this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;
          break;
        } else if (last2) {
          this.insertionMode = IN_BODY_MODE;
          break;
        }
      }
    }
    _resetInsertionModeForSelect(selectIdx) {
      if (selectIdx > 0) {
        for (let i2 = selectIdx - 1; i2 > 0; i2--) {
          const ancestor = this.openElements.items[i2];
          const tn = this.treeAdapter.getTagName(ancestor);
          if (tn === $.TEMPLATE) {
            break;
          } else if (tn === $.TABLE) {
            this.insertionMode = IN_SELECT_IN_TABLE_MODE;
            return;
          }
        }
      }
      this.insertionMode = IN_SELECT_MODE;
    }
    _pushTmplInsertionMode(mode) {
      this.tmplInsertionModeStack.push(mode);
      this.tmplInsertionModeStackTop++;
      this.currentTmplInsertionMode = mode;
    }
    _popTmplInsertionMode() {
      this.tmplInsertionModeStack.pop();
      this.tmplInsertionModeStackTop--;
      this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];
    }
    //Foster parenting
    _isElementCausesFosterParenting(element2) {
      const tn = this.treeAdapter.getTagName(element2);
      return tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR;
    }
    _shouldFosterParentOnInsertion() {
      return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);
    }
    _findFosterParentingLocation() {
      const location2 = {
        parent: null,
        beforeElement: null
      };
      for (let i2 = this.openElements.stackTop; i2 >= 0; i2--) {
        const openElement = this.openElements.items[i2];
        const tn = this.treeAdapter.getTagName(openElement);
        const ns = this.treeAdapter.getNamespaceURI(openElement);
        if (tn === $.TEMPLATE && ns === NS.HTML) {
          location2.parent = this.treeAdapter.getTemplateContent(openElement);
          break;
        } else if (tn === $.TABLE) {
          location2.parent = this.treeAdapter.getParentNode(openElement);
          if (location2.parent) {
            location2.beforeElement = openElement;
          } else {
            location2.parent = this.openElements.items[i2 - 1];
          }
          break;
        }
      }
      if (!location2.parent) {
        location2.parent = this.openElements.items[0];
      }
      return location2;
    }
    _fosterParentElement(element2) {
      const location2 = this._findFosterParentingLocation();
      if (location2.beforeElement) {
        this.treeAdapter.insertBefore(location2.parent, element2, location2.beforeElement);
      } else {
        this.treeAdapter.appendChild(location2.parent, element2);
      }
    }
    _fosterParentText(chars) {
      const location2 = this._findFosterParentingLocation();
      if (location2.beforeElement) {
        this.treeAdapter.insertTextBefore(location2.parent, chars, location2.beforeElement);
      } else {
        this.treeAdapter.insertText(location2.parent, chars);
      }
    }
    //Special elements
    _isSpecialElement(element2) {
      const tn = this.treeAdapter.getTagName(element2);
      const ns = this.treeAdapter.getNamespaceURI(element2);
      return HTML.SPECIAL_ELEMENTS[ns][tn];
    }
  }
  var parser = Parser;
  function aaObtainFormattingElementEntry(p2, token) {
    let formattingElementEntry = p2.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
    if (formattingElementEntry) {
      if (!p2.openElements.contains(formattingElementEntry.element)) {
        p2.activeFormattingElements.removeEntry(formattingElementEntry);
        formattingElementEntry = null;
      } else if (!p2.openElements.hasInScope(token.tagName)) {
        formattingElementEntry = null;
      }
    } else {
      genericEndTagInBody(p2, token);
    }
    return formattingElementEntry;
  }
  function aaObtainFurthestBlock(p2, formattingElementEntry) {
    let furthestBlock = null;
    for (let i2 = p2.openElements.stackTop; i2 >= 0; i2--) {
      const element2 = p2.openElements.items[i2];
      if (element2 === formattingElementEntry.element) {
        break;
      }
      if (p2._isSpecialElement(element2)) {
        furthestBlock = element2;
      }
    }
    if (!furthestBlock) {
      p2.openElements.popUntilElementPopped(formattingElementEntry.element);
      p2.activeFormattingElements.removeEntry(formattingElementEntry);
    }
    return furthestBlock;
  }
  function aaInnerLoop(p2, furthestBlock, formattingElement) {
    let lastElement = furthestBlock;
    let nextElement = p2.openElements.getCommonAncestor(furthestBlock);
    for (let i2 = 0, element2 = nextElement; element2 !== formattingElement; i2++, element2 = nextElement) {
      nextElement = p2.openElements.getCommonAncestor(element2);
      const elementEntry = p2.activeFormattingElements.getElementEntry(element2);
      const counterOverflow = elementEntry && i2 >= AA_INNER_LOOP_ITER;
      const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
      if (shouldRemoveFromOpenElements) {
        if (counterOverflow) {
          p2.activeFormattingElements.removeEntry(elementEntry);
        }
        p2.openElements.remove(element2);
      } else {
        element2 = aaRecreateElementFromEntry(p2, elementEntry);
        if (lastElement === furthestBlock) {
          p2.activeFormattingElements.bookmark = elementEntry;
        }
        p2.treeAdapter.detachNode(lastElement);
        p2.treeAdapter.appendChild(element2, lastElement);
        lastElement = element2;
      }
    }
    return lastElement;
  }
  function aaRecreateElementFromEntry(p2, elementEntry) {
    const ns = p2.treeAdapter.getNamespaceURI(elementEntry.element);
    const newElement = p2.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
    p2.openElements.replace(elementEntry.element, newElement);
    elementEntry.element = newElement;
    return newElement;
  }
  function aaInsertLastNodeInCommonAncestor(p2, commonAncestor, lastElement) {
    if (p2._isElementCausesFosterParenting(commonAncestor)) {
      p2._fosterParentElement(lastElement);
    } else {
      const tn = p2.treeAdapter.getTagName(commonAncestor);
      const ns = p2.treeAdapter.getNamespaceURI(commonAncestor);
      if (tn === $.TEMPLATE && ns === NS.HTML) {
        commonAncestor = p2.treeAdapter.getTemplateContent(commonAncestor);
      }
      p2.treeAdapter.appendChild(commonAncestor, lastElement);
    }
  }
  function aaReplaceFormattingElement(p2, furthestBlock, formattingElementEntry) {
    const ns = p2.treeAdapter.getNamespaceURI(formattingElementEntry.element);
    const token = formattingElementEntry.token;
    const newElement = p2.treeAdapter.createElement(token.tagName, ns, token.attrs);
    p2._adoptNodes(furthestBlock, newElement);
    p2.treeAdapter.appendChild(furthestBlock, newElement);
    p2.activeFormattingElements.insertElementAfterBookmark(newElement, formattingElementEntry.token);
    p2.activeFormattingElements.removeEntry(formattingElementEntry);
    p2.openElements.remove(formattingElementEntry.element);
    p2.openElements.insertAfter(furthestBlock, newElement);
  }
  function callAdoptionAgency(p2, token) {
    let formattingElementEntry;
    for (let i2 = 0; i2 < AA_OUTER_LOOP_ITER; i2++) {
      formattingElementEntry = aaObtainFormattingElementEntry(p2, token);
      if (!formattingElementEntry) {
        break;
      }
      const furthestBlock = aaObtainFurthestBlock(p2, formattingElementEntry);
      if (!furthestBlock) {
        break;
      }
      p2.activeFormattingElements.bookmark = formattingElementEntry;
      const lastElement = aaInnerLoop(p2, furthestBlock, formattingElementEntry.element);
      const commonAncestor = p2.openElements.getCommonAncestor(formattingElementEntry.element);
      p2.treeAdapter.detachNode(lastElement);
      aaInsertLastNodeInCommonAncestor(p2, commonAncestor, lastElement);
      aaReplaceFormattingElement(p2, furthestBlock, formattingElementEntry);
    }
  }
  function ignoreToken() {
  }
  function misplacedDoctype(p2) {
    p2._err(ERR.misplacedDoctype);
  }
  function appendComment(p2, token) {
    p2._appendCommentNode(token, p2.openElements.currentTmplContent || p2.openElements.current);
  }
  function appendCommentToRootHtmlElement(p2, token) {
    p2._appendCommentNode(token, p2.openElements.items[0]);
  }
  function appendCommentToDocument(p2, token) {
    p2._appendCommentNode(token, p2.document);
  }
  function insertCharacters(p2, token) {
    p2._insertCharacters(token);
  }
  function stopParsing(p2) {
    p2.stopped = true;
  }
  function doctypeInInitialMode(p2, token) {
    p2._setDocumentType(token);
    const mode = token.forceQuirks ? HTML.DOCUMENT_MODE.QUIRKS : doctype$2.getDocumentMode(token);
    if (!doctype$2.isConforming(token)) {
      p2._err(ERR.nonConformingDoctype);
    }
    p2.treeAdapter.setDocumentMode(p2.document, mode);
    p2.insertionMode = BEFORE_HTML_MODE;
  }
  function tokenInInitialMode(p2, token) {
    p2._err(ERR.missingDoctype, { beforeToken: true });
    p2.treeAdapter.setDocumentMode(p2.document, HTML.DOCUMENT_MODE.QUIRKS);
    p2.insertionMode = BEFORE_HTML_MODE;
    p2._processToken(token);
  }
  function startTagBeforeHtml(p2, token) {
    if (token.tagName === $.HTML) {
      p2._insertElement(token, NS.HTML);
      p2.insertionMode = BEFORE_HEAD_MODE;
    } else {
      tokenBeforeHtml(p2, token);
    }
  }
  function endTagBeforeHtml(p2, token) {
    const tn = token.tagName;
    if (tn === $.HTML || tn === $.HEAD || tn === $.BODY || tn === $.BR) {
      tokenBeforeHtml(p2, token);
    }
  }
  function tokenBeforeHtml(p2, token) {
    p2._insertFakeRootElement();
    p2.insertionMode = BEFORE_HEAD_MODE;
    p2._processToken(token);
  }
  function startTagBeforeHead(p2, token) {
    const tn = token.tagName;
    if (tn === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn === $.HEAD) {
      p2._insertElement(token, NS.HTML);
      p2.headElement = p2.openElements.current;
      p2.insertionMode = IN_HEAD_MODE;
    } else {
      tokenBeforeHead(p2, token);
    }
  }
  function endTagBeforeHead(p2, token) {
    const tn = token.tagName;
    if (tn === $.HEAD || tn === $.BODY || tn === $.HTML || tn === $.BR) {
      tokenBeforeHead(p2, token);
    } else {
      p2._err(ERR.endTagWithoutMatchingOpenElement);
    }
  }
  function tokenBeforeHead(p2, token) {
    p2._insertFakeElement($.HEAD);
    p2.headElement = p2.openElements.current;
    p2.insertionMode = IN_HEAD_MODE;
    p2._processToken(token);
  }
  function startTagInHead(p2, token) {
    const tn = token.tagName;
    if (tn === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META) {
      p2._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
    } else if (tn === $.TITLE) {
      p2._switchToTextParsing(token, Tokenizer.MODE.RCDATA);
    } else if (tn === $.NOSCRIPT) {
      if (p2.options.scriptingEnabled) {
        p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
      } else {
        p2._insertElement(token, NS.HTML);
        p2.insertionMode = IN_HEAD_NO_SCRIPT_MODE;
      }
    } else if (tn === $.NOFRAMES || tn === $.STYLE) {
      p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
    } else if (tn === $.SCRIPT) {
      p2._switchToTextParsing(token, Tokenizer.MODE.SCRIPT_DATA);
    } else if (tn === $.TEMPLATE) {
      p2._insertTemplate(token, NS.HTML);
      p2.activeFormattingElements.insertMarker();
      p2.framesetOk = false;
      p2.insertionMode = IN_TEMPLATE_MODE;
      p2._pushTmplInsertionMode(IN_TEMPLATE_MODE);
    } else if (tn === $.HEAD) {
      p2._err(ERR.misplacedStartTagForHeadElement);
    } else {
      tokenInHead(p2, token);
    }
  }
  function endTagInHead(p2, token) {
    const tn = token.tagName;
    if (tn === $.HEAD) {
      p2.openElements.pop();
      p2.insertionMode = AFTER_HEAD_MODE;
    } else if (tn === $.BODY || tn === $.BR || tn === $.HTML) {
      tokenInHead(p2, token);
    } else if (tn === $.TEMPLATE) {
      if (p2.openElements.tmplCount > 0) {
        p2.openElements.generateImpliedEndTagsThoroughly();
        if (p2.openElements.currentTagName !== $.TEMPLATE) {
          p2._err(ERR.closingOfElementWithOpenChildElements);
        }
        p2.openElements.popUntilTagNamePopped($.TEMPLATE);
        p2.activeFormattingElements.clearToLastMarker();
        p2._popTmplInsertionMode();
        p2._resetInsertionMode();
      } else {
        p2._err(ERR.endTagWithoutMatchingOpenElement);
      }
    } else {
      p2._err(ERR.endTagWithoutMatchingOpenElement);
    }
  }
  function tokenInHead(p2, token) {
    p2.openElements.pop();
    p2.insertionMode = AFTER_HEAD_MODE;
    p2._processToken(token);
  }
  function startTagInHeadNoScript(p2, token) {
    const tn = token.tagName;
    if (tn === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn === $.BASEFONT || tn === $.BGSOUND || tn === $.HEAD || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.STYLE) {
      startTagInHead(p2, token);
    } else if (tn === $.NOSCRIPT) {
      p2._err(ERR.nestedNoscriptInHead);
    } else {
      tokenInHeadNoScript(p2, token);
    }
  }
  function endTagInHeadNoScript(p2, token) {
    const tn = token.tagName;
    if (tn === $.NOSCRIPT) {
      p2.openElements.pop();
      p2.insertionMode = IN_HEAD_MODE;
    } else if (tn === $.BR) {
      tokenInHeadNoScript(p2, token);
    } else {
      p2._err(ERR.endTagWithoutMatchingOpenElement);
    }
  }
  function tokenInHeadNoScript(p2, token) {
    const errCode = token.type === Tokenizer.EOF_TOKEN ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
    p2._err(errCode);
    p2.openElements.pop();
    p2.insertionMode = IN_HEAD_MODE;
    p2._processToken(token);
  }
  function startTagAfterHead(p2, token) {
    const tn = token.tagName;
    if (tn === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn === $.BODY) {
      p2._insertElement(token, NS.HTML);
      p2.framesetOk = false;
      p2.insertionMode = IN_BODY_MODE;
    } else if (tn === $.FRAMESET) {
      p2._insertElement(token, NS.HTML);
      p2.insertionMode = IN_FRAMESET_MODE;
    } else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.SCRIPT || tn === $.STYLE || tn === $.TEMPLATE || tn === $.TITLE) {
      p2._err(ERR.abandonedHeadElementChild);
      p2.openElements.push(p2.headElement);
      startTagInHead(p2, token);
      p2.openElements.remove(p2.headElement);
    } else if (tn === $.HEAD) {
      p2._err(ERR.misplacedStartTagForHeadElement);
    } else {
      tokenAfterHead(p2, token);
    }
  }
  function endTagAfterHead(p2, token) {
    const tn = token.tagName;
    if (tn === $.BODY || tn === $.HTML || tn === $.BR) {
      tokenAfterHead(p2, token);
    } else if (tn === $.TEMPLATE) {
      endTagInHead(p2, token);
    } else {
      p2._err(ERR.endTagWithoutMatchingOpenElement);
    }
  }
  function tokenAfterHead(p2, token) {
    p2._insertFakeElement($.BODY);
    p2.insertionMode = IN_BODY_MODE;
    p2._processToken(token);
  }
  function whitespaceCharacterInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    p2._insertCharacters(token);
  }
  function characterInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    p2._insertCharacters(token);
    p2.framesetOk = false;
  }
  function htmlStartTagInBody(p2, token) {
    if (p2.openElements.tmplCount === 0) {
      p2.treeAdapter.adoptAttributes(p2.openElements.items[0], token.attrs);
    }
  }
  function bodyStartTagInBody(p2, token) {
    const bodyElement = p2.openElements.tryPeekProperlyNestedBodyElement();
    if (bodyElement && p2.openElements.tmplCount === 0) {
      p2.framesetOk = false;
      p2.treeAdapter.adoptAttributes(bodyElement, token.attrs);
    }
  }
  function framesetStartTagInBody(p2, token) {
    const bodyElement = p2.openElements.tryPeekProperlyNestedBodyElement();
    if (p2.framesetOk && bodyElement) {
      p2.treeAdapter.detachNode(bodyElement);
      p2.openElements.popAllUpToHtmlElement();
      p2._insertElement(token, NS.HTML);
      p2.insertionMode = IN_FRAMESET_MODE;
    }
  }
  function addressStartTagInBody(p2, token) {
    if (p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    p2._insertElement(token, NS.HTML);
  }
  function numberedHeaderStartTagInBody(p2, token) {
    if (p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    const tn = p2.openElements.currentTagName;
    if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
      p2.openElements.pop();
    }
    p2._insertElement(token, NS.HTML);
  }
  function preStartTagInBody(p2, token) {
    if (p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    p2._insertElement(token, NS.HTML);
    p2.skipNextNewLine = true;
    p2.framesetOk = false;
  }
  function formStartTagInBody(p2, token) {
    const inTemplate = p2.openElements.tmplCount > 0;
    if (!p2.formElement || inTemplate) {
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._insertElement(token, NS.HTML);
      if (!inTemplate) {
        p2.formElement = p2.openElements.current;
      }
    }
  }
  function listItemStartTagInBody(p2, token) {
    p2.framesetOk = false;
    const tn = token.tagName;
    for (let i2 = p2.openElements.stackTop; i2 >= 0; i2--) {
      const element2 = p2.openElements.items[i2];
      const elementTn = p2.treeAdapter.getTagName(element2);
      let closeTn = null;
      if (tn === $.LI && elementTn === $.LI) {
        closeTn = $.LI;
      } else if ((tn === $.DD || tn === $.DT) && (elementTn === $.DD || elementTn === $.DT)) {
        closeTn = elementTn;
      }
      if (closeTn) {
        p2.openElements.generateImpliedEndTagsWithExclusion(closeTn);
        p2.openElements.popUntilTagNamePopped(closeTn);
        break;
      }
      if (elementTn !== $.ADDRESS && elementTn !== $.DIV && elementTn !== $.P && p2._isSpecialElement(element2)) {
        break;
      }
    }
    if (p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    p2._insertElement(token, NS.HTML);
  }
  function plaintextStartTagInBody(p2, token) {
    if (p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    p2._insertElement(token, NS.HTML);
    p2.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
  }
  function buttonStartTagInBody(p2, token) {
    if (p2.openElements.hasInScope($.BUTTON)) {
      p2.openElements.generateImpliedEndTags();
      p2.openElements.popUntilTagNamePopped($.BUTTON);
    }
    p2._reconstructActiveFormattingElements();
    p2._insertElement(token, NS.HTML);
    p2.framesetOk = false;
  }
  function aStartTagInBody(p2, token) {
    const activeElementEntry = p2.activeFormattingElements.getElementEntryInScopeWithTagName($.A);
    if (activeElementEntry) {
      callAdoptionAgency(p2, token);
      p2.openElements.remove(activeElementEntry.element);
      p2.activeFormattingElements.removeEntry(activeElementEntry);
    }
    p2._reconstructActiveFormattingElements();
    p2._insertElement(token, NS.HTML);
    p2.activeFormattingElements.pushElement(p2.openElements.current, token);
  }
  function bStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    p2._insertElement(token, NS.HTML);
    p2.activeFormattingElements.pushElement(p2.openElements.current, token);
  }
  function nobrStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    if (p2.openElements.hasInScope($.NOBR)) {
      callAdoptionAgency(p2, token);
      p2._reconstructActiveFormattingElements();
    }
    p2._insertElement(token, NS.HTML);
    p2.activeFormattingElements.pushElement(p2.openElements.current, token);
  }
  function appletStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    p2._insertElement(token, NS.HTML);
    p2.activeFormattingElements.insertMarker();
    p2.framesetOk = false;
  }
  function tableStartTagInBody(p2, token) {
    if (p2.treeAdapter.getDocumentMode(p2.document) !== HTML.DOCUMENT_MODE.QUIRKS && p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    p2._insertElement(token, NS.HTML);
    p2.framesetOk = false;
    p2.insertionMode = IN_TABLE_MODE;
  }
  function areaStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    p2._appendElement(token, NS.HTML);
    p2.framesetOk = false;
    token.ackSelfClosing = true;
  }
  function inputStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    p2._appendElement(token, NS.HTML);
    const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);
    if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE) {
      p2.framesetOk = false;
    }
    token.ackSelfClosing = true;
  }
  function paramStartTagInBody(p2, token) {
    p2._appendElement(token, NS.HTML);
    token.ackSelfClosing = true;
  }
  function hrStartTagInBody(p2, token) {
    if (p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    p2._appendElement(token, NS.HTML);
    p2.framesetOk = false;
    token.ackSelfClosing = true;
  }
  function imageStartTagInBody(p2, token) {
    token.tagName = $.IMG;
    areaStartTagInBody(p2, token);
  }
  function textareaStartTagInBody(p2, token) {
    p2._insertElement(token, NS.HTML);
    p2.skipNextNewLine = true;
    p2.tokenizer.state = Tokenizer.MODE.RCDATA;
    p2.originalInsertionMode = p2.insertionMode;
    p2.framesetOk = false;
    p2.insertionMode = TEXT_MODE;
  }
  function xmpStartTagInBody(p2, token) {
    if (p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    p2._reconstructActiveFormattingElements();
    p2.framesetOk = false;
    p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
  }
  function iframeStartTagInBody(p2, token) {
    p2.framesetOk = false;
    p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
  }
  function noembedStartTagInBody(p2, token) {
    p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
  }
  function selectStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    p2._insertElement(token, NS.HTML);
    p2.framesetOk = false;
    if (p2.insertionMode === IN_TABLE_MODE || p2.insertionMode === IN_CAPTION_MODE || p2.insertionMode === IN_TABLE_BODY_MODE || p2.insertionMode === IN_ROW_MODE || p2.insertionMode === IN_CELL_MODE) {
      p2.insertionMode = IN_SELECT_IN_TABLE_MODE;
    } else {
      p2.insertionMode = IN_SELECT_MODE;
    }
  }
  function optgroupStartTagInBody(p2, token) {
    if (p2.openElements.currentTagName === $.OPTION) {
      p2.openElements.pop();
    }
    p2._reconstructActiveFormattingElements();
    p2._insertElement(token, NS.HTML);
  }
  function rbStartTagInBody(p2, token) {
    if (p2.openElements.hasInScope($.RUBY)) {
      p2.openElements.generateImpliedEndTags();
    }
    p2._insertElement(token, NS.HTML);
  }
  function rtStartTagInBody(p2, token) {
    if (p2.openElements.hasInScope($.RUBY)) {
      p2.openElements.generateImpliedEndTagsWithExclusion($.RTC);
    }
    p2._insertElement(token, NS.HTML);
  }
  function menuStartTagInBody(p2, token) {
    if (p2.openElements.hasInButtonScope($.P)) {
      p2._closePElement();
    }
    p2._insertElement(token, NS.HTML);
  }
  function mathStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    foreignContent.adjustTokenMathMLAttrs(token);
    foreignContent.adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p2._appendElement(token, NS.MATHML);
    } else {
      p2._insertElement(token, NS.MATHML);
    }
    token.ackSelfClosing = true;
  }
  function svgStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    foreignContent.adjustTokenSVGAttrs(token);
    foreignContent.adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p2._appendElement(token, NS.SVG);
    } else {
      p2._insertElement(token, NS.SVG);
    }
    token.ackSelfClosing = true;
  }
  function genericStartTagInBody(p2, token) {
    p2._reconstructActiveFormattingElements();
    p2._insertElement(token, NS.HTML);
  }
  function startTagInBody(p2, token) {
    const tn = token.tagName;
    switch (tn.length) {
      case 1:
        if (tn === $.I || tn === $.S || tn === $.B || tn === $.U) {
          bStartTagInBody(p2, token);
        } else if (tn === $.P) {
          addressStartTagInBody(p2, token);
        } else if (tn === $.A) {
          aStartTagInBody(p2, token);
        } else {
          genericStartTagInBody(p2, token);
        }
        break;
      case 2:
        if (tn === $.DL || tn === $.OL || tn === $.UL) {
          addressStartTagInBody(p2, token);
        } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
          numberedHeaderStartTagInBody(p2, token);
        } else if (tn === $.LI || tn === $.DD || tn === $.DT) {
          listItemStartTagInBody(p2, token);
        } else if (tn === $.EM || tn === $.TT) {
          bStartTagInBody(p2, token);
        } else if (tn === $.BR) {
          areaStartTagInBody(p2, token);
        } else if (tn === $.HR) {
          hrStartTagInBody(p2, token);
        } else if (tn === $.RB) {
          rbStartTagInBody(p2, token);
        } else if (tn === $.RT || tn === $.RP) {
          rtStartTagInBody(p2, token);
        } else if (tn !== $.TH && tn !== $.TD && tn !== $.TR) {
          genericStartTagInBody(p2, token);
        }
        break;
      case 3:
        if (tn === $.DIV || tn === $.DIR || tn === $.NAV) {
          addressStartTagInBody(p2, token);
        } else if (tn === $.PRE) {
          preStartTagInBody(p2, token);
        } else if (tn === $.BIG) {
          bStartTagInBody(p2, token);
        } else if (tn === $.IMG || tn === $.WBR) {
          areaStartTagInBody(p2, token);
        } else if (tn === $.XMP) {
          xmpStartTagInBody(p2, token);
        } else if (tn === $.SVG) {
          svgStartTagInBody(p2, token);
        } else if (tn === $.RTC) {
          rbStartTagInBody(p2, token);
        } else if (tn !== $.COL) {
          genericStartTagInBody(p2, token);
        }
        break;
      case 4:
        if (tn === $.HTML) {
          htmlStartTagInBody(p2, token);
        } else if (tn === $.BASE || tn === $.LINK || tn === $.META) {
          startTagInHead(p2, token);
        } else if (tn === $.BODY) {
          bodyStartTagInBody(p2, token);
        } else if (tn === $.MAIN || tn === $.MENU) {
          addressStartTagInBody(p2, token);
        } else if (tn === $.FORM) {
          formStartTagInBody(p2, token);
        } else if (tn === $.CODE || tn === $.FONT) {
          bStartTagInBody(p2, token);
        } else if (tn === $.NOBR) {
          nobrStartTagInBody(p2, token);
        } else if (tn === $.AREA) {
          areaStartTagInBody(p2, token);
        } else if (tn === $.MATH) {
          mathStartTagInBody(p2, token);
        } else if (tn === $.MENU) {
          menuStartTagInBody(p2, token);
        } else if (tn !== $.HEAD) {
          genericStartTagInBody(p2, token);
        }
        break;
      case 5:
        if (tn === $.STYLE || tn === $.TITLE) {
          startTagInHead(p2, token);
        } else if (tn === $.ASIDE) {
          addressStartTagInBody(p2, token);
        } else if (tn === $.SMALL) {
          bStartTagInBody(p2, token);
        } else if (tn === $.TABLE) {
          tableStartTagInBody(p2, token);
        } else if (tn === $.EMBED) {
          areaStartTagInBody(p2, token);
        } else if (tn === $.INPUT) {
          inputStartTagInBody(p2, token);
        } else if (tn === $.PARAM || tn === $.TRACK) {
          paramStartTagInBody(p2, token);
        } else if (tn === $.IMAGE) {
          imageStartTagInBody(p2, token);
        } else if (tn !== $.FRAME && tn !== $.TBODY && tn !== $.TFOOT && tn !== $.THEAD) {
          genericStartTagInBody(p2, token);
        }
        break;
      case 6:
        if (tn === $.SCRIPT) {
          startTagInHead(p2, token);
        } else if (tn === $.CENTER || tn === $.FIGURE || tn === $.FOOTER || tn === $.HEADER || tn === $.HGROUP || tn === $.DIALOG) {
          addressStartTagInBody(p2, token);
        } else if (tn === $.BUTTON) {
          buttonStartTagInBody(p2, token);
        } else if (tn === $.STRIKE || tn === $.STRONG) {
          bStartTagInBody(p2, token);
        } else if (tn === $.APPLET || tn === $.OBJECT) {
          appletStartTagInBody(p2, token);
        } else if (tn === $.KEYGEN) {
          areaStartTagInBody(p2, token);
        } else if (tn === $.SOURCE) {
          paramStartTagInBody(p2, token);
        } else if (tn === $.IFRAME) {
          iframeStartTagInBody(p2, token);
        } else if (tn === $.SELECT) {
          selectStartTagInBody(p2, token);
        } else if (tn === $.OPTION) {
          optgroupStartTagInBody(p2, token);
        } else {
          genericStartTagInBody(p2, token);
        }
        break;
      case 7:
        if (tn === $.BGSOUND) {
          startTagInHead(p2, token);
        } else if (tn === $.DETAILS || tn === $.ADDRESS || tn === $.ARTICLE || tn === $.SECTION || tn === $.SUMMARY) {
          addressStartTagInBody(p2, token);
        } else if (tn === $.LISTING) {
          preStartTagInBody(p2, token);
        } else if (tn === $.MARQUEE) {
          appletStartTagInBody(p2, token);
        } else if (tn === $.NOEMBED) {
          noembedStartTagInBody(p2, token);
        } else if (tn !== $.CAPTION) {
          genericStartTagInBody(p2, token);
        }
        break;
      case 8:
        if (tn === $.BASEFONT) {
          startTagInHead(p2, token);
        } else if (tn === $.FRAMESET) {
          framesetStartTagInBody(p2, token);
        } else if (tn === $.FIELDSET) {
          addressStartTagInBody(p2, token);
        } else if (tn === $.TEXTAREA) {
          textareaStartTagInBody(p2, token);
        } else if (tn === $.TEMPLATE) {
          startTagInHead(p2, token);
        } else if (tn === $.NOSCRIPT) {
          if (p2.options.scriptingEnabled) {
            noembedStartTagInBody(p2, token);
          } else {
            genericStartTagInBody(p2, token);
          }
        } else if (tn === $.OPTGROUP) {
          optgroupStartTagInBody(p2, token);
        } else if (tn !== $.COLGROUP) {
          genericStartTagInBody(p2, token);
        }
        break;
      case 9:
        if (tn === $.PLAINTEXT) {
          plaintextStartTagInBody(p2, token);
        } else {
          genericStartTagInBody(p2, token);
        }
        break;
      case 10:
        if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {
          addressStartTagInBody(p2, token);
        } else {
          genericStartTagInBody(p2, token);
        }
        break;
      default:
        genericStartTagInBody(p2, token);
    }
  }
  function bodyEndTagInBody(p2) {
    if (p2.openElements.hasInScope($.BODY)) {
      p2.insertionMode = AFTER_BODY_MODE;
    }
  }
  function htmlEndTagInBody(p2, token) {
    if (p2.openElements.hasInScope($.BODY)) {
      p2.insertionMode = AFTER_BODY_MODE;
      p2._processToken(token);
    }
  }
  function addressEndTagInBody(p2, token) {
    const tn = token.tagName;
    if (p2.openElements.hasInScope(tn)) {
      p2.openElements.generateImpliedEndTags();
      p2.openElements.popUntilTagNamePopped(tn);
    }
  }
  function formEndTagInBody(p2) {
    const inTemplate = p2.openElements.tmplCount > 0;
    const formElement = p2.formElement;
    if (!inTemplate) {
      p2.formElement = null;
    }
    if ((formElement || inTemplate) && p2.openElements.hasInScope($.FORM)) {
      p2.openElements.generateImpliedEndTags();
      if (inTemplate) {
        p2.openElements.popUntilTagNamePopped($.FORM);
      } else {
        p2.openElements.remove(formElement);
      }
    }
  }
  function pEndTagInBody(p2) {
    if (!p2.openElements.hasInButtonScope($.P)) {
      p2._insertFakeElement($.P);
    }
    p2._closePElement();
  }
  function liEndTagInBody(p2) {
    if (p2.openElements.hasInListItemScope($.LI)) {
      p2.openElements.generateImpliedEndTagsWithExclusion($.LI);
      p2.openElements.popUntilTagNamePopped($.LI);
    }
  }
  function ddEndTagInBody(p2, token) {
    const tn = token.tagName;
    if (p2.openElements.hasInScope(tn)) {
      p2.openElements.generateImpliedEndTagsWithExclusion(tn);
      p2.openElements.popUntilTagNamePopped(tn);
    }
  }
  function numberedHeaderEndTagInBody(p2) {
    if (p2.openElements.hasNumberedHeaderInScope()) {
      p2.openElements.generateImpliedEndTags();
      p2.openElements.popUntilNumberedHeaderPopped();
    }
  }
  function appletEndTagInBody(p2, token) {
    const tn = token.tagName;
    if (p2.openElements.hasInScope(tn)) {
      p2.openElements.generateImpliedEndTags();
      p2.openElements.popUntilTagNamePopped(tn);
      p2.activeFormattingElements.clearToLastMarker();
    }
  }
  function brEndTagInBody(p2) {
    p2._reconstructActiveFormattingElements();
    p2._insertFakeElement($.BR);
    p2.openElements.pop();
    p2.framesetOk = false;
  }
  function genericEndTagInBody(p2, token) {
    const tn = token.tagName;
    for (let i2 = p2.openElements.stackTop; i2 > 0; i2--) {
      const element2 = p2.openElements.items[i2];
      if (p2.treeAdapter.getTagName(element2) === tn) {
        p2.openElements.generateImpliedEndTagsWithExclusion(tn);
        p2.openElements.popUntilElementPopped(element2);
        break;
      }
      if (p2._isSpecialElement(element2)) {
        break;
      }
    }
  }
  function endTagInBody(p2, token) {
    const tn = token.tagName;
    switch (tn.length) {
      case 1:
        if (tn === $.A || tn === $.B || tn === $.I || tn === $.S || tn === $.U) {
          callAdoptionAgency(p2, token);
        } else if (tn === $.P) {
          pEndTagInBody(p2);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      case 2:
        if (tn === $.DL || tn === $.UL || tn === $.OL) {
          addressEndTagInBody(p2, token);
        } else if (tn === $.LI) {
          liEndTagInBody(p2);
        } else if (tn === $.DD || tn === $.DT) {
          ddEndTagInBody(p2, token);
        } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
          numberedHeaderEndTagInBody(p2);
        } else if (tn === $.BR) {
          brEndTagInBody(p2);
        } else if (tn === $.EM || tn === $.TT) {
          callAdoptionAgency(p2, token);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      case 3:
        if (tn === $.BIG) {
          callAdoptionAgency(p2, token);
        } else if (tn === $.DIR || tn === $.DIV || tn === $.NAV || tn === $.PRE) {
          addressEndTagInBody(p2, token);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      case 4:
        if (tn === $.BODY) {
          bodyEndTagInBody(p2);
        } else if (tn === $.HTML) {
          htmlEndTagInBody(p2, token);
        } else if (tn === $.FORM) {
          formEndTagInBody(p2);
        } else if (tn === $.CODE || tn === $.FONT || tn === $.NOBR) {
          callAdoptionAgency(p2, token);
        } else if (tn === $.MAIN || tn === $.MENU) {
          addressEndTagInBody(p2, token);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      case 5:
        if (tn === $.ASIDE) {
          addressEndTagInBody(p2, token);
        } else if (tn === $.SMALL) {
          callAdoptionAgency(p2, token);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      case 6:
        if (tn === $.CENTER || tn === $.FIGURE || tn === $.FOOTER || tn === $.HEADER || tn === $.HGROUP || tn === $.DIALOG) {
          addressEndTagInBody(p2, token);
        } else if (tn === $.APPLET || tn === $.OBJECT) {
          appletEndTagInBody(p2, token);
        } else if (tn === $.STRIKE || tn === $.STRONG) {
          callAdoptionAgency(p2, token);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      case 7:
        if (tn === $.ADDRESS || tn === $.ARTICLE || tn === $.DETAILS || tn === $.SECTION || tn === $.SUMMARY || tn === $.LISTING) {
          addressEndTagInBody(p2, token);
        } else if (tn === $.MARQUEE) {
          appletEndTagInBody(p2, token);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      case 8:
        if (tn === $.FIELDSET) {
          addressEndTagInBody(p2, token);
        } else if (tn === $.TEMPLATE) {
          endTagInHead(p2, token);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      case 10:
        if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {
          addressEndTagInBody(p2, token);
        } else {
          genericEndTagInBody(p2, token);
        }
        break;
      default:
        genericEndTagInBody(p2, token);
    }
  }
  function eofInBody(p2, token) {
    if (p2.tmplInsertionModeStackTop > -1) {
      eofInTemplate(p2, token);
    } else {
      p2.stopped = true;
    }
  }
  function endTagInText(p2, token) {
    if (token.tagName === $.SCRIPT) {
      p2.pendingScript = p2.openElements.current;
    }
    p2.openElements.pop();
    p2.insertionMode = p2.originalInsertionMode;
  }
  function eofInText(p2, token) {
    p2._err(ERR.eofInElementThatCanContainOnlyText);
    p2.openElements.pop();
    p2.insertionMode = p2.originalInsertionMode;
    p2._processToken(token);
  }
  function characterInTable(p2, token) {
    const curTn = p2.openElements.currentTagName;
    if (curTn === $.TABLE || curTn === $.TBODY || curTn === $.TFOOT || curTn === $.THEAD || curTn === $.TR) {
      p2.pendingCharacterTokens = [];
      p2.hasNonWhitespacePendingCharacterToken = false;
      p2.originalInsertionMode = p2.insertionMode;
      p2.insertionMode = IN_TABLE_TEXT_MODE;
      p2._processToken(token);
    } else {
      tokenInTable(p2, token);
    }
  }
  function captionStartTagInTable(p2, token) {
    p2.openElements.clearBackToTableContext();
    p2.activeFormattingElements.insertMarker();
    p2._insertElement(token, NS.HTML);
    p2.insertionMode = IN_CAPTION_MODE;
  }
  function colgroupStartTagInTable(p2, token) {
    p2.openElements.clearBackToTableContext();
    p2._insertElement(token, NS.HTML);
    p2.insertionMode = IN_COLUMN_GROUP_MODE;
  }
  function colStartTagInTable(p2, token) {
    p2.openElements.clearBackToTableContext();
    p2._insertFakeElement($.COLGROUP);
    p2.insertionMode = IN_COLUMN_GROUP_MODE;
    p2._processToken(token);
  }
  function tbodyStartTagInTable(p2, token) {
    p2.openElements.clearBackToTableContext();
    p2._insertElement(token, NS.HTML);
    p2.insertionMode = IN_TABLE_BODY_MODE;
  }
  function tdStartTagInTable(p2, token) {
    p2.openElements.clearBackToTableContext();
    p2._insertFakeElement($.TBODY);
    p2.insertionMode = IN_TABLE_BODY_MODE;
    p2._processToken(token);
  }
  function tableStartTagInTable(p2, token) {
    if (p2.openElements.hasInTableScope($.TABLE)) {
      p2.openElements.popUntilTagNamePopped($.TABLE);
      p2._resetInsertionMode();
      p2._processToken(token);
    }
  }
  function inputStartTagInTable(p2, token) {
    const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);
    if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE) {
      p2._appendElement(token, NS.HTML);
    } else {
      tokenInTable(p2, token);
    }
    token.ackSelfClosing = true;
  }
  function formStartTagInTable(p2, token) {
    if (!p2.formElement && p2.openElements.tmplCount === 0) {
      p2._insertElement(token, NS.HTML);
      p2.formElement = p2.openElements.current;
      p2.openElements.pop();
    }
  }
  function startTagInTable(p2, token) {
    const tn = token.tagName;
    switch (tn.length) {
      case 2:
        if (tn === $.TD || tn === $.TH || tn === $.TR) {
          tdStartTagInTable(p2, token);
        } else {
          tokenInTable(p2, token);
        }
        break;
      case 3:
        if (tn === $.COL) {
          colStartTagInTable(p2, token);
        } else {
          tokenInTable(p2, token);
        }
        break;
      case 4:
        if (tn === $.FORM) {
          formStartTagInTable(p2, token);
        } else {
          tokenInTable(p2, token);
        }
        break;
      case 5:
        if (tn === $.TABLE) {
          tableStartTagInTable(p2, token);
        } else if (tn === $.STYLE) {
          startTagInHead(p2, token);
        } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
          tbodyStartTagInTable(p2, token);
        } else if (tn === $.INPUT) {
          inputStartTagInTable(p2, token);
        } else {
          tokenInTable(p2, token);
        }
        break;
      case 6:
        if (tn === $.SCRIPT) {
          startTagInHead(p2, token);
        } else {
          tokenInTable(p2, token);
        }
        break;
      case 7:
        if (tn === $.CAPTION) {
          captionStartTagInTable(p2, token);
        } else {
          tokenInTable(p2, token);
        }
        break;
      case 8:
        if (tn === $.COLGROUP) {
          colgroupStartTagInTable(p2, token);
        } else if (tn === $.TEMPLATE) {
          startTagInHead(p2, token);
        } else {
          tokenInTable(p2, token);
        }
        break;
      default:
        tokenInTable(p2, token);
    }
  }
  function endTagInTable(p2, token) {
    const tn = token.tagName;
    if (tn === $.TABLE) {
      if (p2.openElements.hasInTableScope($.TABLE)) {
        p2.openElements.popUntilTagNamePopped($.TABLE);
        p2._resetInsertionMode();
      }
    } else if (tn === $.TEMPLATE) {
      endTagInHead(p2, token);
    } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML && tn !== $.TBODY && tn !== $.TD && tn !== $.TFOOT && tn !== $.TH && tn !== $.THEAD && tn !== $.TR) {
      tokenInTable(p2, token);
    }
  }
  function tokenInTable(p2, token) {
    const savedFosterParentingState = p2.fosterParentingEnabled;
    p2.fosterParentingEnabled = true;
    p2._processTokenInBodyMode(token);
    p2.fosterParentingEnabled = savedFosterParentingState;
  }
  function whitespaceCharacterInTableText(p2, token) {
    p2.pendingCharacterTokens.push(token);
  }
  function characterInTableText(p2, token) {
    p2.pendingCharacterTokens.push(token);
    p2.hasNonWhitespacePendingCharacterToken = true;
  }
  function tokenInTableText(p2, token) {
    let i2 = 0;
    if (p2.hasNonWhitespacePendingCharacterToken) {
      for (; i2 < p2.pendingCharacterTokens.length; i2++) {
        tokenInTable(p2, p2.pendingCharacterTokens[i2]);
      }
    } else {
      for (; i2 < p2.pendingCharacterTokens.length; i2++) {
        p2._insertCharacters(p2.pendingCharacterTokens[i2]);
      }
    }
    p2.insertionMode = p2.originalInsertionMode;
    p2._processToken(token);
  }
  function startTagInCaption(p2, token) {
    const tn = token.tagName;
    if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TD || tn === $.TFOOT || tn === $.TH || tn === $.THEAD || tn === $.TR) {
      if (p2.openElements.hasInTableScope($.CAPTION)) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilTagNamePopped($.CAPTION);
        p2.activeFormattingElements.clearToLastMarker();
        p2.insertionMode = IN_TABLE_MODE;
        p2._processToken(token);
      }
    } else {
      startTagInBody(p2, token);
    }
  }
  function endTagInCaption(p2, token) {
    const tn = token.tagName;
    if (tn === $.CAPTION || tn === $.TABLE) {
      if (p2.openElements.hasInTableScope($.CAPTION)) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilTagNamePopped($.CAPTION);
        p2.activeFormattingElements.clearToLastMarker();
        p2.insertionMode = IN_TABLE_MODE;
        if (tn === $.TABLE) {
          p2._processToken(token);
        }
      }
    } else if (tn !== $.BODY && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML && tn !== $.TBODY && tn !== $.TD && tn !== $.TFOOT && tn !== $.TH && tn !== $.THEAD && tn !== $.TR) {
      endTagInBody(p2, token);
    }
  }
  function startTagInColumnGroup(p2, token) {
    const tn = token.tagName;
    if (tn === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn === $.COL) {
      p2._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
    } else if (tn === $.TEMPLATE) {
      startTagInHead(p2, token);
    } else {
      tokenInColumnGroup(p2, token);
    }
  }
  function endTagInColumnGroup(p2, token) {
    const tn = token.tagName;
    if (tn === $.COLGROUP) {
      if (p2.openElements.currentTagName === $.COLGROUP) {
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_MODE;
      }
    } else if (tn === $.TEMPLATE) {
      endTagInHead(p2, token);
    } else if (tn !== $.COL) {
      tokenInColumnGroup(p2, token);
    }
  }
  function tokenInColumnGroup(p2, token) {
    if (p2.openElements.currentTagName === $.COLGROUP) {
      p2.openElements.pop();
      p2.insertionMode = IN_TABLE_MODE;
      p2._processToken(token);
    }
  }
  function startTagInTableBody(p2, token) {
    const tn = token.tagName;
    if (tn === $.TR) {
      p2.openElements.clearBackToTableBodyContext();
      p2._insertElement(token, NS.HTML);
      p2.insertionMode = IN_ROW_MODE;
    } else if (tn === $.TH || tn === $.TD) {
      p2.openElements.clearBackToTableBodyContext();
      p2._insertFakeElement($.TR);
      p2.insertionMode = IN_ROW_MODE;
      p2._processToken(token);
    } else if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
      if (p2.openElements.hasTableBodyContextInTableScope()) {
        p2.openElements.clearBackToTableBodyContext();
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_MODE;
        p2._processToken(token);
      }
    } else {
      startTagInTable(p2, token);
    }
  }
  function endTagInTableBody(p2, token) {
    const tn = token.tagName;
    if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
      if (p2.openElements.hasInTableScope(tn)) {
        p2.openElements.clearBackToTableBodyContext();
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_MODE;
      }
    } else if (tn === $.TABLE) {
      if (p2.openElements.hasTableBodyContextInTableScope()) {
        p2.openElements.clearBackToTableBodyContext();
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_MODE;
        p2._processToken(token);
      }
    } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP || tn !== $.HTML && tn !== $.TD && tn !== $.TH && tn !== $.TR) {
      endTagInTable(p2, token);
    }
  }
  function startTagInRow(p2, token) {
    const tn = token.tagName;
    if (tn === $.TH || tn === $.TD) {
      p2.openElements.clearBackToTableRowContext();
      p2._insertElement(token, NS.HTML);
      p2.insertionMode = IN_CELL_MODE;
      p2.activeFormattingElements.insertMarker();
    } else if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {
      if (p2.openElements.hasInTableScope($.TR)) {
        p2.openElements.clearBackToTableRowContext();
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_BODY_MODE;
        p2._processToken(token);
      }
    } else {
      startTagInTable(p2, token);
    }
  }
  function endTagInRow(p2, token) {
    const tn = token.tagName;
    if (tn === $.TR) {
      if (p2.openElements.hasInTableScope($.TR)) {
        p2.openElements.clearBackToTableRowContext();
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_BODY_MODE;
      }
    } else if (tn === $.TABLE) {
      if (p2.openElements.hasInTableScope($.TR)) {
        p2.openElements.clearBackToTableRowContext();
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_BODY_MODE;
        p2._processToken(token);
      }
    } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
      if (p2.openElements.hasInTableScope(tn) || p2.openElements.hasInTableScope($.TR)) {
        p2.openElements.clearBackToTableRowContext();
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_BODY_MODE;
        p2._processToken(token);
      }
    } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP || tn !== $.HTML && tn !== $.TD && tn !== $.TH) {
      endTagInTable(p2, token);
    }
  }
  function startTagInCell(p2, token) {
    const tn = token.tagName;
    if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TD || tn === $.TFOOT || tn === $.TH || tn === $.THEAD || tn === $.TR) {
      if (p2.openElements.hasInTableScope($.TD) || p2.openElements.hasInTableScope($.TH)) {
        p2._closeTableCell();
        p2._processToken(token);
      }
    } else {
      startTagInBody(p2, token);
    }
  }
  function endTagInCell(p2, token) {
    const tn = token.tagName;
    if (tn === $.TD || tn === $.TH) {
      if (p2.openElements.hasInTableScope(tn)) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilTagNamePopped(tn);
        p2.activeFormattingElements.clearToLastMarker();
        p2.insertionMode = IN_ROW_MODE;
      }
    } else if (tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {
      if (p2.openElements.hasInTableScope(tn)) {
        p2._closeTableCell();
        p2._processToken(token);
      }
    } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML) {
      endTagInBody(p2, token);
    }
  }
  function startTagInSelect(p2, token) {
    const tn = token.tagName;
    if (tn === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn === $.OPTION) {
      if (p2.openElements.currentTagName === $.OPTION) {
        p2.openElements.pop();
      }
      p2._insertElement(token, NS.HTML);
    } else if (tn === $.OPTGROUP) {
      if (p2.openElements.currentTagName === $.OPTION) {
        p2.openElements.pop();
      }
      if (p2.openElements.currentTagName === $.OPTGROUP) {
        p2.openElements.pop();
      }
      p2._insertElement(token, NS.HTML);
    } else if (tn === $.INPUT || tn === $.KEYGEN || tn === $.TEXTAREA || tn === $.SELECT) {
      if (p2.openElements.hasInSelectScope($.SELECT)) {
        p2.openElements.popUntilTagNamePopped($.SELECT);
        p2._resetInsertionMode();
        if (tn !== $.SELECT) {
          p2._processToken(token);
        }
      }
    } else if (tn === $.SCRIPT || tn === $.TEMPLATE) {
      startTagInHead(p2, token);
    }
  }
  function endTagInSelect(p2, token) {
    const tn = token.tagName;
    if (tn === $.OPTGROUP) {
      const prevOpenElement = p2.openElements.items[p2.openElements.stackTop - 1];
      const prevOpenElementTn = prevOpenElement && p2.treeAdapter.getTagName(prevOpenElement);
      if (p2.openElements.currentTagName === $.OPTION && prevOpenElementTn === $.OPTGROUP) {
        p2.openElements.pop();
      }
      if (p2.openElements.currentTagName === $.OPTGROUP) {
        p2.openElements.pop();
      }
    } else if (tn === $.OPTION) {
      if (p2.openElements.currentTagName === $.OPTION) {
        p2.openElements.pop();
      }
    } else if (tn === $.SELECT && p2.openElements.hasInSelectScope($.SELECT)) {
      p2.openElements.popUntilTagNamePopped($.SELECT);
      p2._resetInsertionMode();
    } else if (tn === $.TEMPLATE) {
      endTagInHead(p2, token);
    }
  }
  function startTagInSelectInTable(p2, token) {
    const tn = token.tagName;
    if (tn === $.CAPTION || tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR || tn === $.TD || tn === $.TH) {
      p2.openElements.popUntilTagNamePopped($.SELECT);
      p2._resetInsertionMode();
      p2._processToken(token);
    } else {
      startTagInSelect(p2, token);
    }
  }
  function endTagInSelectInTable(p2, token) {
    const tn = token.tagName;
    if (tn === $.CAPTION || tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR || tn === $.TD || tn === $.TH) {
      if (p2.openElements.hasInTableScope(tn)) {
        p2.openElements.popUntilTagNamePopped($.SELECT);
        p2._resetInsertionMode();
        p2._processToken(token);
      }
    } else {
      endTagInSelect(p2, token);
    }
  }
  function startTagInTemplate(p2, token) {
    const tn = token.tagName;
    if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.SCRIPT || tn === $.STYLE || tn === $.TEMPLATE || tn === $.TITLE) {
      startTagInHead(p2, token);
    } else {
      const newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;
      p2._popTmplInsertionMode();
      p2._pushTmplInsertionMode(newInsertionMode);
      p2.insertionMode = newInsertionMode;
      p2._processToken(token);
    }
  }
  function endTagInTemplate(p2, token) {
    if (token.tagName === $.TEMPLATE) {
      endTagInHead(p2, token);
    }
  }
  function eofInTemplate(p2, token) {
    if (p2.openElements.tmplCount > 0) {
      p2.openElements.popUntilTagNamePopped($.TEMPLATE);
      p2.activeFormattingElements.clearToLastMarker();
      p2._popTmplInsertionMode();
      p2._resetInsertionMode();
      p2._processToken(token);
    } else {
      p2.stopped = true;
    }
  }
  function startTagAfterBody(p2, token) {
    if (token.tagName === $.HTML) {
      startTagInBody(p2, token);
    } else {
      tokenAfterBody(p2, token);
    }
  }
  function endTagAfterBody(p2, token) {
    if (token.tagName === $.HTML) {
      if (!p2.fragmentContext) {
        p2.insertionMode = AFTER_AFTER_BODY_MODE;
      }
    } else {
      tokenAfterBody(p2, token);
    }
  }
  function tokenAfterBody(p2, token) {
    p2.insertionMode = IN_BODY_MODE;
    p2._processToken(token);
  }
  function startTagInFrameset(p2, token) {
    const tn = token.tagName;
    if (tn === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn === $.FRAMESET) {
      p2._insertElement(token, NS.HTML);
    } else if (tn === $.FRAME) {
      p2._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
    } else if (tn === $.NOFRAMES) {
      startTagInHead(p2, token);
    }
  }
  function endTagInFrameset(p2, token) {
    if (token.tagName === $.FRAMESET && !p2.openElements.isRootHtmlElementCurrent()) {
      p2.openElements.pop();
      if (!p2.fragmentContext && p2.openElements.currentTagName !== $.FRAMESET) {
        p2.insertionMode = AFTER_FRAMESET_MODE;
      }
    }
  }
  function startTagAfterFrameset(p2, token) {
    const tn = token.tagName;
    if (tn === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn === $.NOFRAMES) {
      startTagInHead(p2, token);
    }
  }
  function endTagAfterFrameset(p2, token) {
    if (token.tagName === $.HTML) {
      p2.insertionMode = AFTER_AFTER_FRAMESET_MODE;
    }
  }
  function startTagAfterAfterBody(p2, token) {
    if (token.tagName === $.HTML) {
      startTagInBody(p2, token);
    } else {
      tokenAfterAfterBody(p2, token);
    }
  }
  function tokenAfterAfterBody(p2, token) {
    p2.insertionMode = IN_BODY_MODE;
    p2._processToken(token);
  }
  function startTagAfterAfterFrameset(p2, token) {
    const tn = token.tagName;
    if (tn === $.HTML) {
      startTagInBody(p2, token);
    } else if (tn === $.NOFRAMES) {
      startTagInHead(p2, token);
    }
  }
  function nullCharacterInForeignContent(p2, token) {
    token.chars = unicode.REPLACEMENT_CHARACTER;
    p2._insertCharacters(token);
  }
  function characterInForeignContent(p2, token) {
    p2._insertCharacters(token);
    p2.framesetOk = false;
  }
  function startTagInForeignContent(p2, token) {
    if (foreignContent.causesExit(token) && !p2.fragmentContext) {
      while (p2.treeAdapter.getNamespaceURI(p2.openElements.current) !== NS.HTML && !p2._isIntegrationPoint(p2.openElements.current)) {
        p2.openElements.pop();
      }
      p2._processToken(token);
    } else {
      const current = p2._getAdjustedCurrentElement();
      const currentNs = p2.treeAdapter.getNamespaceURI(current);
      if (currentNs === NS.MATHML) {
        foreignContent.adjustTokenMathMLAttrs(token);
      } else if (currentNs === NS.SVG) {
        foreignContent.adjustTokenSVGTagName(token);
        foreignContent.adjustTokenSVGAttrs(token);
      }
      foreignContent.adjustTokenXMLAttrs(token);
      if (token.selfClosing) {
        p2._appendElement(token, currentNs);
      } else {
        p2._insertElement(token, currentNs);
      }
      token.ackSelfClosing = true;
    }
  }
  function endTagInForeignContent(p2, token) {
    for (let i2 = p2.openElements.stackTop; i2 > 0; i2--) {
      const element2 = p2.openElements.items[i2];
      if (p2.treeAdapter.getNamespaceURI(element2) === NS.HTML) {
        p2._processToken(token);
        break;
      }
      if (p2.treeAdapter.getTagName(element2).toLowerCase() === token.tagName) {
        p2.openElements.popUntilElementPopped(element2);
        break;
      }
    }
  }
  const Parser5 = /* @__PURE__ */ getDefaultExportFromCjs(parser);
  class Schema {
    /**
     * @constructor
     * @param {Properties} property
     * @param {Normal} normal
     * @param {string} [space]
     */
    constructor(property, normal, space2) {
      this.property = property;
      this.normal = normal;
      if (space2) {
        this.space = space2;
      }
    }
  }
  Schema.prototype.property = {};
  Schema.prototype.normal = {};
  Schema.prototype.space = null;
  function merge(definitions2, space2) {
    const property = {};
    const normal = {};
    let index2 = -1;
    while (++index2 < definitions2.length) {
      Object.assign(property, definitions2[index2].property);
      Object.assign(normal, definitions2[index2].normal);
    }
    return new Schema(property, normal, space2);
  }
  function normalize$2(value) {
    return value.toLowerCase();
  }
  class Info {
    /**
     * @constructor
     * @param {string} property
     * @param {string} attribute
     */
    constructor(property, attribute) {
      this.property = property;
      this.attribute = attribute;
    }
  }
  Info.prototype.space = null;
  Info.prototype.boolean = false;
  Info.prototype.booleanish = false;
  Info.prototype.overloadedBoolean = false;
  Info.prototype.number = false;
  Info.prototype.commaSeparated = false;
  Info.prototype.spaceSeparated = false;
  Info.prototype.commaOrSpaceSeparated = false;
  Info.prototype.mustUseProperty = false;
  Info.prototype.defined = false;
  let powers = 0;
  const boolean = increment();
  const booleanish = increment();
  const overloadedBoolean = increment();
  const number = increment();
  const spaceSeparated = increment();
  const commaSeparated = increment();
  const commaOrSpaceSeparated = increment();
  function increment() {
    return 2 ** ++powers;
  }
  const types = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    boolean,
    booleanish,
    commaOrSpaceSeparated,
    commaSeparated,
    number,
    overloadedBoolean,
    spaceSeparated
  }, Symbol.toStringTag, { value: "Module" }));
  const checks = Object.keys(types);
  class DefinedInfo extends Info {
    /**
     * @constructor
     * @param {string} property
     * @param {string} attribute
     * @param {number|null} [mask]
     * @param {string} [space]
     */
    constructor(property, attribute, mask, space2) {
      let index2 = -1;
      super(property, attribute);
      mark(this, "space", space2);
      if (typeof mask === "number") {
        while (++index2 < checks.length) {
          const check = checks[index2];
          mark(this, checks[index2], (mask & types[check]) === types[check]);
        }
      }
    }
  }
  DefinedInfo.prototype.defined = true;
  function mark(values, key2, value) {
    if (value) {
      values[key2] = value;
    }
  }
  const own$c = {}.hasOwnProperty;
  function create$6(definition2) {
    const property = {};
    const normal = {};
    let prop;
    for (prop in definition2.properties) {
      if (own$c.call(definition2.properties, prop)) {
        const value = definition2.properties[prop];
        const info = new DefinedInfo(
          prop,
          definition2.transform(definition2.attributes || {}, prop),
          value,
          definition2.space
        );
        if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
          info.mustUseProperty = true;
        }
        property[prop] = info;
        normal[normalize$2(prop)] = prop;
        normal[normalize$2(info.attribute)] = prop;
      }
    }
    return new Schema(property, normal, definition2.space);
  }
  const xlink = create$6({
    space: "xlink",
    transform(_, prop) {
      return "xlink:" + prop.slice(5).toLowerCase();
    },
    properties: {
      xLinkActuate: null,
      xLinkArcRole: null,
      xLinkHref: null,
      xLinkRole: null,
      xLinkShow: null,
      xLinkTitle: null,
      xLinkType: null
    }
  });
  const xml = create$6({
    space: "xml",
    transform(_, prop) {
      return "xml:" + prop.slice(3).toLowerCase();
    },
    properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
  });
  function caseSensitiveTransform(attributes, attribute) {
    return attribute in attributes ? attributes[attribute] : attribute;
  }
  function caseInsensitiveTransform(attributes, property) {
    return caseSensitiveTransform(attributes, property.toLowerCase());
  }
  const xmlns = create$6({
    space: "xmlns",
    attributes: { xmlnsxlink: "xmlns:xlink" },
    transform: caseInsensitiveTransform,
    properties: { xmlns: null, xmlnsXLink: null }
  });
  const aria = create$6({
    transform(_, prop) {
      return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
    },
    properties: {
      ariaActiveDescendant: null,
      ariaAtomic: booleanish,
      ariaAutoComplete: null,
      ariaBusy: booleanish,
      ariaChecked: booleanish,
      ariaColCount: number,
      ariaColIndex: number,
      ariaColSpan: number,
      ariaControls: spaceSeparated,
      ariaCurrent: null,
      ariaDescribedBy: spaceSeparated,
      ariaDetails: null,
      ariaDisabled: booleanish,
      ariaDropEffect: spaceSeparated,
      ariaErrorMessage: null,
      ariaExpanded: booleanish,
      ariaFlowTo: spaceSeparated,
      ariaGrabbed: booleanish,
      ariaHasPopup: null,
      ariaHidden: booleanish,
      ariaInvalid: null,
      ariaKeyShortcuts: null,
      ariaLabel: null,
      ariaLabelledBy: spaceSeparated,
      ariaLevel: number,
      ariaLive: null,
      ariaModal: booleanish,
      ariaMultiLine: booleanish,
      ariaMultiSelectable: booleanish,
      ariaOrientation: null,
      ariaOwns: spaceSeparated,
      ariaPlaceholder: null,
      ariaPosInSet: number,
      ariaPressed: booleanish,
      ariaReadOnly: booleanish,
      ariaRelevant: null,
      ariaRequired: booleanish,
      ariaRoleDescription: spaceSeparated,
      ariaRowCount: number,
      ariaRowIndex: number,
      ariaRowSpan: number,
      ariaSelected: booleanish,
      ariaSetSize: number,
      ariaSort: null,
      ariaValueMax: number,
      ariaValueMin: number,
      ariaValueNow: number,
      ariaValueText: null,
      role: null
    }
  });
  const html$5 = create$6({
    space: "html",
    attributes: {
      acceptcharset: "accept-charset",
      classname: "class",
      htmlfor: "for",
      httpequiv: "http-equiv"
    },
    transform: caseInsensitiveTransform,
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
      // Standard Properties.
      abbr: null,
      accept: commaSeparated,
      acceptCharset: spaceSeparated,
      accessKey: spaceSeparated,
      action: null,
      allow: null,
      allowFullScreen: boolean,
      allowPaymentRequest: boolean,
      allowUserMedia: boolean,
      alt: null,
      as: null,
      async: boolean,
      autoCapitalize: null,
      autoComplete: spaceSeparated,
      autoFocus: boolean,
      autoPlay: boolean,
      blocking: spaceSeparated,
      capture: null,
      charSet: null,
      checked: boolean,
      cite: null,
      className: spaceSeparated,
      cols: number,
      colSpan: null,
      content: null,
      contentEditable: booleanish,
      controls: boolean,
      controlsList: spaceSeparated,
      coords: number | commaSeparated,
      crossOrigin: null,
      data: null,
      dateTime: null,
      decoding: null,
      default: boolean,
      defer: boolean,
      dir: null,
      dirName: null,
      disabled: boolean,
      download: overloadedBoolean,
      draggable: booleanish,
      encType: null,
      enterKeyHint: null,
      fetchPriority: null,
      form: null,
      formAction: null,
      formEncType: null,
      formMethod: null,
      formNoValidate: boolean,
      formTarget: null,
      headers: spaceSeparated,
      height: number,
      hidden: boolean,
      high: number,
      href: null,
      hrefLang: null,
      htmlFor: spaceSeparated,
      httpEquiv: spaceSeparated,
      id: null,
      imageSizes: null,
      imageSrcSet: null,
      inert: boolean,
      inputMode: null,
      integrity: null,
      is: null,
      isMap: boolean,
      itemId: null,
      itemProp: spaceSeparated,
      itemRef: spaceSeparated,
      itemScope: boolean,
      itemType: spaceSeparated,
      kind: null,
      label: null,
      lang: null,
      language: null,
      list: null,
      loading: null,
      loop: boolean,
      low: number,
      manifest: null,
      max: null,
      maxLength: number,
      media: null,
      method: null,
      min: null,
      minLength: number,
      multiple: boolean,
      muted: boolean,
      name: null,
      nonce: null,
      noModule: boolean,
      noValidate: boolean,
      onAbort: null,
      onAfterPrint: null,
      onAuxClick: null,
      onBeforeMatch: null,
      onBeforePrint: null,
      onBeforeToggle: null,
      onBeforeUnload: null,
      onBlur: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onContextLost: null,
      onContextMenu: null,
      onContextRestored: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFormData: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLanguageChange: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadEnd: null,
      onLoadStart: null,
      onMessage: null,
      onMessageError: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRejectionHandled: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onScrollEnd: null,
      onSecurityPolicyViolation: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onSlotChange: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnhandledRejection: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onWheel: null,
      open: boolean,
      optimum: number,
      pattern: null,
      ping: spaceSeparated,
      placeholder: null,
      playsInline: boolean,
      popover: null,
      popoverTarget: null,
      popoverTargetAction: null,
      poster: null,
      preload: null,
      readOnly: boolean,
      referrerPolicy: null,
      rel: spaceSeparated,
      required: boolean,
      reversed: boolean,
      rows: number,
      rowSpan: number,
      sandbox: spaceSeparated,
      scope: null,
      scoped: boolean,
      seamless: boolean,
      selected: boolean,
      shadowRootDelegatesFocus: boolean,
      shadowRootMode: null,
      shape: null,
      size: number,
      sizes: null,
      slot: null,
      span: number,
      spellCheck: booleanish,
      src: null,
      srcDoc: null,
      srcLang: null,
      srcSet: null,
      start: number,
      step: null,
      style: null,
      tabIndex: number,
      target: null,
      title: null,
      translate: null,
      type: null,
      typeMustMatch: boolean,
      useMap: null,
      value: booleanish,
      width: number,
      wrap: null,
      // Legacy.
      // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
      align: null,
      // Several. Use CSS `text-align` instead,
      aLink: null,
      // `<body>`. Use CSS `a:active {color}` instead
      archive: spaceSeparated,
      // `<object>`. List of URIs to archives
      axis: null,
      // `<td>` and `<th>`. Use `scope` on `<th>`
      background: null,
      // `<body>`. Use CSS `background-image` instead
      bgColor: null,
      // `<body>` and table elements. Use CSS `background-color` instead
      border: number,
      // `<table>`. Use CSS `border-width` instead,
      borderColor: null,
      // `<table>`. Use CSS `border-color` instead,
      bottomMargin: number,
      // `<body>`
      cellPadding: null,
      // `<table>`
      cellSpacing: null,
      // `<table>`
      char: null,
      // Several table elements. When `align=char`, sets the character to align on
      charOff: null,
      // Several table elements. When `char`, offsets the alignment
      classId: null,
      // `<object>`
      clear: null,
      // `<br>`. Use CSS `clear` instead
      code: null,
      // `<object>`
      codeBase: null,
      // `<object>`
      codeType: null,
      // `<object>`
      color: null,
      // `<font>` and `<hr>`. Use CSS instead
      compact: boolean,
      // Lists. Use CSS to reduce space between items instead
      declare: boolean,
      // `<object>`
      event: null,
      // `<script>`
      face: null,
      // `<font>`. Use CSS instead
      frame: null,
      // `<table>`
      frameBorder: null,
      // `<iframe>`. Use CSS `border` instead
      hSpace: number,
      // `<img>` and `<object>`
      leftMargin: number,
      // `<body>`
      link: null,
      // `<body>`. Use CSS `a:link {color: *}` instead
      longDesc: null,
      // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
      lowSrc: null,
      // `<img>`. Use a `<picture>`
      marginHeight: number,
      // `<body>`
      marginWidth: number,
      // `<body>`
      noResize: boolean,
      // `<frame>`
      noHref: boolean,
      // `<area>`. Use no href instead of an explicit `nohref`
      noShade: boolean,
      // `<hr>`. Use background-color and height instead of borders
      noWrap: boolean,
      // `<td>` and `<th>`
      object: null,
      // `<applet>`
      profile: null,
      // `<head>`
      prompt: null,
      // `<isindex>`
      rev: null,
      // `<link>`
      rightMargin: number,
      // `<body>`
      rules: null,
      // `<table>`
      scheme: null,
      // `<meta>`
      scrolling: booleanish,
      // `<frame>`. Use overflow in the child context
      standby: null,
      // `<object>`
      summary: null,
      // `<table>`
      text: null,
      // `<body>`. Use CSS `color` instead
      topMargin: number,
      // `<body>`
      valueType: null,
      // `<param>`
      version: null,
      // `<html>`. Use a doctype.
      vAlign: null,
      // Several. Use CSS `vertical-align` instead
      vLink: null,
      // `<body>`. Use CSS `a:visited {color}` instead
      vSpace: number,
      // `<img>` and `<object>`
      // Non-standard Properties.
      allowTransparency: null,
      autoCorrect: null,
      autoSave: null,
      disablePictureInPicture: boolean,
      disableRemotePlayback: boolean,
      prefix: null,
      property: null,
      results: number,
      security: null,
      unselectable: null
    }
  });
  const svg$1 = create$6({
    space: "svg",
    attributes: {
      accentHeight: "accent-height",
      alignmentBaseline: "alignment-baseline",
      arabicForm: "arabic-form",
      baselineShift: "baseline-shift",
      capHeight: "cap-height",
      className: "class",
      clipPath: "clip-path",
      clipRule: "clip-rule",
      colorInterpolation: "color-interpolation",
      colorInterpolationFilters: "color-interpolation-filters",
      colorProfile: "color-profile",
      colorRendering: "color-rendering",
      crossOrigin: "crossorigin",
      dataType: "datatype",
      dominantBaseline: "dominant-baseline",
      enableBackground: "enable-background",
      fillOpacity: "fill-opacity",
      fillRule: "fill-rule",
      floodColor: "flood-color",
      floodOpacity: "flood-opacity",
      fontFamily: "font-family",
      fontSize: "font-size",
      fontSizeAdjust: "font-size-adjust",
      fontStretch: "font-stretch",
      fontStyle: "font-style",
      fontVariant: "font-variant",
      fontWeight: "font-weight",
      glyphName: "glyph-name",
      glyphOrientationHorizontal: "glyph-orientation-horizontal",
      glyphOrientationVertical: "glyph-orientation-vertical",
      hrefLang: "hreflang",
      horizAdvX: "horiz-adv-x",
      horizOriginX: "horiz-origin-x",
      horizOriginY: "horiz-origin-y",
      imageRendering: "image-rendering",
      letterSpacing: "letter-spacing",
      lightingColor: "lighting-color",
      markerEnd: "marker-end",
      markerMid: "marker-mid",
      markerStart: "marker-start",
      navDown: "nav-down",
      navDownLeft: "nav-down-left",
      navDownRight: "nav-down-right",
      navLeft: "nav-left",
      navNext: "nav-next",
      navPrev: "nav-prev",
      navRight: "nav-right",
      navUp: "nav-up",
      navUpLeft: "nav-up-left",
      navUpRight: "nav-up-right",
      onAbort: "onabort",
      onActivate: "onactivate",
      onAfterPrint: "onafterprint",
      onBeforePrint: "onbeforeprint",
      onBegin: "onbegin",
      onCancel: "oncancel",
      onCanPlay: "oncanplay",
      onCanPlayThrough: "oncanplaythrough",
      onChange: "onchange",
      onClick: "onclick",
      onClose: "onclose",
      onCopy: "oncopy",
      onCueChange: "oncuechange",
      onCut: "oncut",
      onDblClick: "ondblclick",
      onDrag: "ondrag",
      onDragEnd: "ondragend",
      onDragEnter: "ondragenter",
      onDragExit: "ondragexit",
      onDragLeave: "ondragleave",
      onDragOver: "ondragover",
      onDragStart: "ondragstart",
      onDrop: "ondrop",
      onDurationChange: "ondurationchange",
      onEmptied: "onemptied",
      onEnd: "onend",
      onEnded: "onended",
      onError: "onerror",
      onFocus: "onfocus",
      onFocusIn: "onfocusin",
      onFocusOut: "onfocusout",
      onHashChange: "onhashchange",
      onInput: "oninput",
      onInvalid: "oninvalid",
      onKeyDown: "onkeydown",
      onKeyPress: "onkeypress",
      onKeyUp: "onkeyup",
      onLoad: "onload",
      onLoadedData: "onloadeddata",
      onLoadedMetadata: "onloadedmetadata",
      onLoadStart: "onloadstart",
      onMessage: "onmessage",
      onMouseDown: "onmousedown",
      onMouseEnter: "onmouseenter",
      onMouseLeave: "onmouseleave",
      onMouseMove: "onmousemove",
      onMouseOut: "onmouseout",
      onMouseOver: "onmouseover",
      onMouseUp: "onmouseup",
      onMouseWheel: "onmousewheel",
      onOffline: "onoffline",
      onOnline: "ononline",
      onPageHide: "onpagehide",
      onPageShow: "onpageshow",
      onPaste: "onpaste",
      onPause: "onpause",
      onPlay: "onplay",
      onPlaying: "onplaying",
      onPopState: "onpopstate",
      onProgress: "onprogress",
      onRateChange: "onratechange",
      onRepeat: "onrepeat",
      onReset: "onreset",
      onResize: "onresize",
      onScroll: "onscroll",
      onSeeked: "onseeked",
      onSeeking: "onseeking",
      onSelect: "onselect",
      onShow: "onshow",
      onStalled: "onstalled",
      onStorage: "onstorage",
      onSubmit: "onsubmit",
      onSuspend: "onsuspend",
      onTimeUpdate: "ontimeupdate",
      onToggle: "ontoggle",
      onUnload: "onunload",
      onVolumeChange: "onvolumechange",
      onWaiting: "onwaiting",
      onZoom: "onzoom",
      overlinePosition: "overline-position",
      overlineThickness: "overline-thickness",
      paintOrder: "paint-order",
      panose1: "panose-1",
      pointerEvents: "pointer-events",
      referrerPolicy: "referrerpolicy",
      renderingIntent: "rendering-intent",
      shapeRendering: "shape-rendering",
      stopColor: "stop-color",
      stopOpacity: "stop-opacity",
      strikethroughPosition: "strikethrough-position",
      strikethroughThickness: "strikethrough-thickness",
      strokeDashArray: "stroke-dasharray",
      strokeDashOffset: "stroke-dashoffset",
      strokeLineCap: "stroke-linecap",
      strokeLineJoin: "stroke-linejoin",
      strokeMiterLimit: "stroke-miterlimit",
      strokeOpacity: "stroke-opacity",
      strokeWidth: "stroke-width",
      tabIndex: "tabindex",
      textAnchor: "text-anchor",
      textDecoration: "text-decoration",
      textRendering: "text-rendering",
      transformOrigin: "transform-origin",
      typeOf: "typeof",
      underlinePosition: "underline-position",
      underlineThickness: "underline-thickness",
      unicodeBidi: "unicode-bidi",
      unicodeRange: "unicode-range",
      unitsPerEm: "units-per-em",
      vAlphabetic: "v-alphabetic",
      vHanging: "v-hanging",
      vIdeographic: "v-ideographic",
      vMathematical: "v-mathematical",
      vectorEffect: "vector-effect",
      vertAdvY: "vert-adv-y",
      vertOriginX: "vert-origin-x",
      vertOriginY: "vert-origin-y",
      wordSpacing: "word-spacing",
      writingMode: "writing-mode",
      xHeight: "x-height",
      // These were camelcased in Tiny. Now lowercased in SVG 2
      playbackOrder: "playbackorder",
      timelineBegin: "timelinebegin"
    },
    transform: caseSensitiveTransform,
    properties: {
      about: commaOrSpaceSeparated,
      accentHeight: number,
      accumulate: null,
      additive: null,
      alignmentBaseline: null,
      alphabetic: number,
      amplitude: number,
      arabicForm: null,
      ascent: number,
      attributeName: null,
      attributeType: null,
      azimuth: number,
      bandwidth: null,
      baselineShift: null,
      baseFrequency: null,
      baseProfile: null,
      bbox: null,
      begin: null,
      bias: number,
      by: null,
      calcMode: null,
      capHeight: number,
      className: spaceSeparated,
      clip: null,
      clipPath: null,
      clipPathUnits: null,
      clipRule: null,
      color: null,
      colorInterpolation: null,
      colorInterpolationFilters: null,
      colorProfile: null,
      colorRendering: null,
      content: null,
      contentScriptType: null,
      contentStyleType: null,
      crossOrigin: null,
      cursor: null,
      cx: null,
      cy: null,
      d: null,
      dataType: null,
      defaultAction: null,
      descent: number,
      diffuseConstant: number,
      direction: null,
      display: null,
      dur: null,
      divisor: number,
      dominantBaseline: null,
      download: boolean,
      dx: null,
      dy: null,
      edgeMode: null,
      editable: null,
      elevation: number,
      enableBackground: null,
      end: null,
      event: null,
      exponent: number,
      externalResourcesRequired: null,
      fill: null,
      fillOpacity: number,
      fillRule: null,
      filter: null,
      filterRes: null,
      filterUnits: null,
      floodColor: null,
      floodOpacity: null,
      focusable: null,
      focusHighlight: null,
      fontFamily: null,
      fontSize: null,
      fontSizeAdjust: null,
      fontStretch: null,
      fontStyle: null,
      fontVariant: null,
      fontWeight: null,
      format: null,
      fr: null,
      from: null,
      fx: null,
      fy: null,
      g1: commaSeparated,
      g2: commaSeparated,
      glyphName: commaSeparated,
      glyphOrientationHorizontal: null,
      glyphOrientationVertical: null,
      glyphRef: null,
      gradientTransform: null,
      gradientUnits: null,
      handler: null,
      hanging: number,
      hatchContentUnits: null,
      hatchUnits: null,
      height: null,
      href: null,
      hrefLang: null,
      horizAdvX: number,
      horizOriginX: number,
      horizOriginY: number,
      id: null,
      ideographic: number,
      imageRendering: null,
      initialVisibility: null,
      in: null,
      in2: null,
      intercept: number,
      k: number,
      k1: number,
      k2: number,
      k3: number,
      k4: number,
      kernelMatrix: commaOrSpaceSeparated,
      kernelUnitLength: null,
      keyPoints: null,
      // SEMI_COLON_SEPARATED
      keySplines: null,
      // SEMI_COLON_SEPARATED
      keyTimes: null,
      // SEMI_COLON_SEPARATED
      kerning: null,
      lang: null,
      lengthAdjust: null,
      letterSpacing: null,
      lightingColor: null,
      limitingConeAngle: number,
      local: null,
      markerEnd: null,
      markerMid: null,
      markerStart: null,
      markerHeight: null,
      markerUnits: null,
      markerWidth: null,
      mask: null,
      maskContentUnits: null,
      maskUnits: null,
      mathematical: null,
      max: null,
      media: null,
      mediaCharacterEncoding: null,
      mediaContentEncodings: null,
      mediaSize: number,
      mediaTime: null,
      method: null,
      min: null,
      mode: null,
      name: null,
      navDown: null,
      navDownLeft: null,
      navDownRight: null,
      navLeft: null,
      navNext: null,
      navPrev: null,
      navRight: null,
      navUp: null,
      navUpLeft: null,
      navUpRight: null,
      numOctaves: null,
      observer: null,
      offset: null,
      onAbort: null,
      onActivate: null,
      onAfterPrint: null,
      onBeforePrint: null,
      onBegin: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnd: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFocusIn: null,
      onFocusOut: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadStart: null,
      onMessage: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onMouseWheel: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRepeat: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onShow: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onZoom: null,
      opacity: null,
      operator: null,
      order: null,
      orient: null,
      orientation: null,
      origin: null,
      overflow: null,
      overlay: null,
      overlinePosition: number,
      overlineThickness: number,
      paintOrder: null,
      panose1: null,
      path: null,
      pathLength: number,
      patternContentUnits: null,
      patternTransform: null,
      patternUnits: null,
      phase: null,
      ping: spaceSeparated,
      pitch: null,
      playbackOrder: null,
      pointerEvents: null,
      points: null,
      pointsAtX: number,
      pointsAtY: number,
      pointsAtZ: number,
      preserveAlpha: null,
      preserveAspectRatio: null,
      primitiveUnits: null,
      propagate: null,
      property: commaOrSpaceSeparated,
      r: null,
      radius: null,
      referrerPolicy: null,
      refX: null,
      refY: null,
      rel: commaOrSpaceSeparated,
      rev: commaOrSpaceSeparated,
      renderingIntent: null,
      repeatCount: null,
      repeatDur: null,
      requiredExtensions: commaOrSpaceSeparated,
      requiredFeatures: commaOrSpaceSeparated,
      requiredFonts: commaOrSpaceSeparated,
      requiredFormats: commaOrSpaceSeparated,
      resource: null,
      restart: null,
      result: null,
      rotate: null,
      rx: null,
      ry: null,
      scale: null,
      seed: null,
      shapeRendering: null,
      side: null,
      slope: null,
      snapshotTime: null,
      specularConstant: number,
      specularExponent: number,
      spreadMethod: null,
      spacing: null,
      startOffset: null,
      stdDeviation: null,
      stemh: null,
      stemv: null,
      stitchTiles: null,
      stopColor: null,
      stopOpacity: null,
      strikethroughPosition: number,
      strikethroughThickness: number,
      string: null,
      stroke: null,
      strokeDashArray: commaOrSpaceSeparated,
      strokeDashOffset: null,
      strokeLineCap: null,
      strokeLineJoin: null,
      strokeMiterLimit: number,
      strokeOpacity: number,
      strokeWidth: null,
      style: null,
      surfaceScale: number,
      syncBehavior: null,
      syncBehaviorDefault: null,
      syncMaster: null,
      syncTolerance: null,
      syncToleranceDefault: null,
      systemLanguage: commaOrSpaceSeparated,
      tabIndex: number,
      tableValues: null,
      target: null,
      targetX: number,
      targetY: number,
      textAnchor: null,
      textDecoration: null,
      textRendering: null,
      textLength: null,
      timelineBegin: null,
      title: null,
      transformBehavior: null,
      type: null,
      typeOf: commaOrSpaceSeparated,
      to: null,
      transform: null,
      transformOrigin: null,
      u1: null,
      u2: null,
      underlinePosition: number,
      underlineThickness: number,
      unicode: null,
      unicodeBidi: null,
      unicodeRange: null,
      unitsPerEm: number,
      values: null,
      vAlphabetic: number,
      vMathematical: number,
      vectorEffect: null,
      vHanging: number,
      vIdeographic: number,
      version: null,
      vertAdvY: number,
      vertOriginX: number,
      vertOriginY: number,
      viewBox: null,
      viewTarget: null,
      visibility: null,
      width: null,
      widths: null,
      wordSpacing: null,
      writingMode: null,
      x: null,
      x1: null,
      x2: null,
      xChannelSelector: null,
      xHeight: number,
      y: null,
      y1: null,
      y2: null,
      yChannelSelector: null,
      z: null,
      zoomAndPan: null
    }
  });
  const valid = /^data[-\w.:]+$/i;
  const dash = /-[a-z]/g;
  const cap = /[A-Z]/g;
  function find$2(schema, value) {
    const normal = normalize$2(value);
    let prop = value;
    let Type = Info;
    if (normal in schema.normal) {
      return schema.property[schema.normal[normal]];
    }
    if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
      if (value.charAt(4) === "-") {
        const rest = value.slice(5).replace(dash, camelcase$1);
        prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
      } else {
        const rest = value.slice(4);
        if (!dash.test(rest)) {
          let dashes = rest.replace(cap, kebab);
          if (dashes.charAt(0) !== "-") {
            dashes = "-" + dashes;
          }
          value = "data" + dashes;
        }
      }
      Type = DefinedInfo;
    }
    return new Type(prop, value);
  }
  function kebab($0) {
    return "-" + $0.toLowerCase();
  }
  function camelcase$1($0) {
    return $0.charAt(1).toUpperCase();
  }
  const html$4 = merge([xml, xlink, xmlns, aria, html$5], "html");
  const svg = merge([xml, xlink, xmlns, aria, svg$1], "svg");
  const search$1 = /[#.]/g;
  function parseSelector(selector, defaultTagName) {
    const value = selector || "";
    const props = {};
    let start = 0;
    let previous2;
    let tagName;
    while (start < value.length) {
      search$1.lastIndex = start;
      const match = search$1.exec(value);
      const subvalue = value.slice(start, match ? match.index : value.length);
      if (subvalue) {
        if (!previous2) {
          tagName = subvalue;
        } else if (previous2 === "#") {
          props.id = subvalue;
        } else if (Array.isArray(props.className)) {
          props.className.push(subvalue);
        } else {
          props.className = [subvalue];
        }
        start += subvalue.length;
      }
      if (match) {
        previous2 = match[0];
        start++;
      }
    }
    return {
      type: "element",
      // @ts-expect-error: fine.
      tagName: tagName || defaultTagName || "div",
      properties: props,
      children: []
    };
  }
  function parse$2(value) {
    const input2 = String(value || "").trim();
    return input2 ? input2.split(/[ \t\n\r\f]+/g) : [];
  }
  function stringify$2(values) {
    return values.join(" ").trim();
  }
  function parse$1(value) {
    const tokens = [];
    const input2 = String(value || "");
    let index2 = input2.indexOf(",");
    let start = 0;
    let end = false;
    while (!end) {
      if (index2 === -1) {
        index2 = input2.length;
        end = true;
      }
      const token = input2.slice(start, index2).trim();
      if (token || !end) {
        tokens.push(token);
      }
      start = index2 + 1;
      index2 = input2.indexOf(",", start);
    }
    return tokens;
  }
  function stringify$1(values, options) {
    const settings = options || {};
    const input2 = values[values.length - 1] === "" ? [...values, ""] : values;
    return input2.join(
      (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
    ).trim();
  }
  const buttonTypes = /* @__PURE__ */ new Set(["menu", "submit", "reset", "button"]);
  const own$b = {}.hasOwnProperty;
  function core$1(schema, defaultTagName, caseSensitive) {
    const adjust = caseSensitive && createAdjustMap(caseSensitive);
    const h2 = (
      /**
       * @type {{
       *   (): Root
       *   (selector: null | undefined, ...children: Array<HChild>): Root
       *   (selector: string, properties?: HProperties, ...children: Array<HChild>): Element
       *   (selector: string, ...children: Array<HChild>): Element
       * }}
       */
      /**
       * Hyperscript compatible DSL for creating virtual hast trees.
       *
       * @param {string | null} [selector]
       * @param {HProperties | HChild} [properties]
       * @param {Array<HChild>} children
       * @returns {HResult}
       */
      function(selector, properties, ...children) {
        let index2 = -1;
        let node2;
        if (selector === void 0 || selector === null) {
          node2 = { type: "root", children: [] };
          children.unshift(properties);
        } else {
          node2 = parseSelector(selector, defaultTagName);
          node2.tagName = node2.tagName.toLowerCase();
          if (adjust && own$b.call(adjust, node2.tagName)) {
            node2.tagName = adjust[node2.tagName];
          }
          if (isProperties(properties, node2.tagName)) {
            let key2;
            for (key2 in properties) {
              if (own$b.call(properties, key2)) {
                addProperty(schema, node2.properties, key2, properties[key2]);
              }
            }
          } else {
            children.unshift(properties);
          }
        }
        while (++index2 < children.length) {
          addChild(node2.children, children[index2]);
        }
        if (node2.type === "element" && node2.tagName === "template") {
          node2.content = { type: "root", children: node2.children };
          node2.children = [];
        }
        return node2;
      }
    );
    return h2;
  }
  function isProperties(value, name) {
    if (value === null || value === void 0 || typeof value !== "object" || Array.isArray(value)) {
      return false;
    }
    if (name === "input" || !value.type || typeof value.type !== "string") {
      return true;
    }
    if ("children" in value && Array.isArray(value.children)) {
      return false;
    }
    if (name === "button") {
      return buttonTypes.has(value.type.toLowerCase());
    }
    return !("value" in value);
  }
  function addProperty(schema, properties, key2, value) {
    const info = find$2(schema, key2);
    let index2 = -1;
    let result;
    if (value === void 0 || value === null)
      return;
    if (typeof value === "number") {
      if (Number.isNaN(value))
        return;
      result = value;
    } else if (typeof value === "boolean") {
      result = value;
    } else if (typeof value === "string") {
      if (info.spaceSeparated) {
        result = parse$2(value);
      } else if (info.commaSeparated) {
        result = parse$1(value);
      } else if (info.commaOrSpaceSeparated) {
        result = parse$2(parse$1(value).join(" "));
      } else {
        result = parsePrimitive(info, info.property, value);
      }
    } else if (Array.isArray(value)) {
      result = value.concat();
    } else {
      result = info.property === "style" ? style$1(value) : String(value);
    }
    if (Array.isArray(result)) {
      const finalResult = [];
      while (++index2 < result.length) {
        finalResult[index2] = parsePrimitive(info, info.property, result[index2]);
      }
      result = finalResult;
    }
    if (info.property === "className" && Array.isArray(properties.className)) {
      result = properties.className.concat(result);
    }
    properties[info.property] = result;
  }
  function addChild(nodes, value) {
    let index2 = -1;
    if (value === void 0 || value === null)
      ;
    else if (typeof value === "string" || typeof value === "number") {
      nodes.push({ type: "text", value: String(value) });
    } else if (Array.isArray(value)) {
      while (++index2 < value.length) {
        addChild(nodes, value[index2]);
      }
    } else if (typeof value === "object" && "type" in value) {
      if (value.type === "root") {
        addChild(nodes, value.children);
      } else {
        nodes.push(value);
      }
    } else {
      throw new Error("Expected node, nodes, or string, got `" + value + "`");
    }
  }
  function parsePrimitive(info, name, value) {
    if (typeof value === "string") {
      if (info.number && value && !Number.isNaN(Number(value))) {
        return Number(value);
      }
      if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize$2(value) === normalize$2(name))) {
        return true;
      }
    }
    return value;
  }
  function style$1(value) {
    const result = [];
    let key2;
    for (key2 in value) {
      if (own$b.call(value, key2)) {
        result.push([key2, value[key2]].join(": "));
      }
    }
    return result.join("; ");
  }
  function createAdjustMap(values) {
    const result = {};
    let index2 = -1;
    while (++index2 < values.length) {
      result[values[index2].toLowerCase()] = values[index2];
    }
    return result;
  }
  const h = core$1(html$4, "div");
  const svgCaseSensitiveTagNames = [
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "solidColor",
    "textArea",
    "textPath"
  ];
  const s = core$1(svg, "g", svgCaseSensitiveTagNames);
  function location$1(file) {
    const value = String(file);
    const indices = [];
    const search2 = /\r?\n|\r/g;
    while (search2.test(value)) {
      indices.push(search2.lastIndex);
    }
    indices.push(value.length + 1);
    return { toPoint, toOffset };
    function toPoint(offset) {
      let index2 = -1;
      if (typeof offset === "number" && offset > -1 && offset < indices[indices.length - 1]) {
        while (++index2 < indices.length) {
          if (indices[index2] > offset) {
            return {
              line: index2 + 1,
              column: offset - (index2 > 0 ? indices[index2 - 1] : 0) + 1,
              offset
            };
          }
        }
      }
      return { line: void 0, column: void 0, offset: void 0 };
    }
    function toOffset(point2) {
      const line = point2 && point2.line;
      const column = point2 && point2.column;
      if (typeof line === "number" && typeof column === "number" && !Number.isNaN(line) && !Number.isNaN(column) && line - 1 in indices) {
        const offset = (indices[line - 2] || 0) + column - 1 || 0;
        if (offset > -1 && offset < indices[indices.length - 1]) {
          return offset;
        }
      }
      return -1;
    }
  }
  const webNamespaces = {
    html: "http://www.w3.org/1999/xhtml",
    mathml: "http://www.w3.org/1998/Math/MathML",
    svg: "http://www.w3.org/2000/svg",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  const own$a = {}.hasOwnProperty;
  const proto = Object.prototype;
  function fromParse5(tree, options) {
    const options_ = options || {};
    let settings;
    let file;
    if (isFile(options_)) {
      file = options_;
      settings = {};
    } else {
      file = options_.file || void 0;
      settings = options_;
    }
    return one$5(
      {
        schema: settings.space === "svg" ? svg : html$4,
        file,
        verbose: settings.verbose,
        location: false
      },
      tree
    );
  }
  function one$5(state, node2) {
    let result;
    switch (node2.nodeName) {
      case "#comment": {
        const reference = (
          /** @type {P5Comment} */
          node2
        );
        result = { type: "comment", value: reference.data };
        patch$1(state, reference, result);
        return result;
      }
      case "#document":
      case "#document-fragment": {
        const reference = (
          /** @type {P5Document | P5DocumentFragment} */
          node2
        );
        const quirksMode = "mode" in reference ? reference.mode === "quirks" || reference.mode === "limited-quirks" : false;
        result = {
          type: "root",
          children: all$6(state, node2.childNodes),
          data: { quirksMode }
        };
        if (state.file && state.location) {
          const doc2 = String(state.file);
          const loc = location$1(doc2);
          const start = loc.toPoint(0);
          const end = loc.toPoint(doc2.length);
          result.position = { start, end };
        }
        return result;
      }
      case "#documentType": {
        const reference = (
          /** @type {P5DocumentType} */
          node2
        );
        result = { type: "doctype" };
        patch$1(state, reference, result);
        return result;
      }
      case "#text": {
        const reference = (
          /** @type {P5Text} */
          node2
        );
        result = { type: "text", value: reference.value };
        patch$1(state, reference, result);
        return result;
      }
      default: {
        const reference = (
          /** @type {P5Element} */
          node2
        );
        result = element$5(state, reference);
        return result;
      }
    }
  }
  function all$6(state, nodes) {
    let index2 = -1;
    const result = [];
    while (++index2 < nodes.length) {
      result[index2] = one$5(state, nodes[index2]);
    }
    return result;
  }
  function element$5(state, node2) {
    const schema = state.schema;
    state.schema = node2.namespaceURI === webNamespaces.svg ? svg : html$4;
    let index2 = -1;
    const props = {};
    while (++index2 < node2.attrs.length) {
      const attribute = node2.attrs[index2];
      const name = (attribute.prefix ? attribute.prefix + ":" : "") + attribute.name;
      if (!own$a.call(proto, name)) {
        props[name] = attribute.value;
      }
    }
    const fn = state.schema.space === "svg" ? s : h;
    const result = fn(node2.tagName, props, all$6(state, node2.childNodes));
    patch$1(state, node2, result);
    if (result.tagName === "template") {
      const reference = (
        /** @type {P5Template} */
        node2
      );
      const pos = reference.sourceCodeLocation;
      const startTag = pos && pos.startTag && position$2(pos.startTag);
      const endTag = pos && pos.endTag && position$2(pos.endTag);
      const content2 = one$5(state, reference.content);
      if (startTag && endTag && state.file) {
        content2.position = { start: startTag.end, end: endTag.start };
      }
      result.content = content2;
    }
    state.schema = schema;
    return result;
  }
  function patch$1(state, from2, to) {
    if ("sourceCodeLocation" in from2 && from2.sourceCodeLocation && state.file) {
      const position2 = createLocation(state, to, from2.sourceCodeLocation);
      if (position2) {
        state.location = true;
        to.position = position2;
      }
    }
  }
  function createLocation(state, node2, location2) {
    const result = position$2(location2);
    if (node2.type === "element") {
      const tail = node2.children[node2.children.length - 1];
      if (result && !location2.endTag && tail && tail.position && tail.position.end) {
        result.end = Object.assign({}, tail.position.end);
      }
      if (state.verbose) {
        const props = {};
        let key2;
        if (location2.attrs) {
          for (key2 in location2.attrs) {
            if (own$a.call(location2.attrs, key2)) {
              props[find$2(state.schema, key2).property] = position$2(
                location2.attrs[key2]
              );
            }
          }
        }
        node2.data = {
          position: {
            // @ts-expect-error: assume not `undefined`.
            opening: position$2(location2.startTag),
            closing: location2.endTag ? position$2(location2.endTag) : null,
            properties: props
          }
        };
      }
    }
    return result;
  }
  function position$2(loc) {
    const start = point$3({
      line: loc.startLine,
      column: loc.startCol,
      offset: loc.startOffset
    });
    const end = point$3({
      line: loc.endLine,
      column: loc.endCol,
      offset: loc.endOffset
    });
    return start || end ? { start, end } : void 0;
  }
  function point$3(point2) {
    return point2.line && point2.column ? point2 : void 0;
  }
  function isFile(value) {
    return "messages" in value;
  }
  const errors = {
    abandonedHeadElementChild: {
      reason: "Unexpected metadata element after head",
      description: "Unexpected element after head. Expected the element before `</head>`",
      url: false
    },
    abruptClosingOfEmptyComment: {
      reason: "Unexpected abruptly closed empty comment",
      description: "Unexpected `>` or `->`. Expected `-->` to close comments"
    },
    abruptDoctypePublicIdentifier: {
      reason: "Unexpected abruptly closed public identifier",
      description: "Unexpected `>`. Expected a closing `\"` or `'` after the public identifier"
    },
    abruptDoctypeSystemIdentifier: {
      reason: "Unexpected abruptly closed system identifier",
      description: "Unexpected `>`. Expected a closing `\"` or `'` after the identifier identifier"
    },
    absenceOfDigitsInNumericCharacterReference: {
      reason: "Unexpected non-digit at start of numeric character reference",
      description: "Unexpected `%c`. Expected `[0-9]` for decimal references or `[0-9a-fA-F]` for hexadecimal references"
    },
    cdataInHtmlContent: {
      reason: "Unexpected CDATA section in HTML",
      description: "Unexpected `<![CDATA[` in HTML. Remove it, use a comment, or encode special characters instead"
    },
    characterReferenceOutsideUnicodeRange: {
      reason: "Unexpected too big numeric character reference",
      description: "Unexpectedly high character reference. Expected character references to be at most hexadecimal 10ffff (or decimal 1114111)"
    },
    closingOfElementWithOpenChildElements: {
      reason: "Unexpected closing tag with open child elements",
      description: "Unexpectedly closing tag. Expected other tags to be closed first",
      url: false
    },
    controlCharacterInInputStream: {
      reason: "Unexpected control character",
      description: "Unexpected control character `%x`. Expected a non-control code point, 0x00, or ASCII whitespace"
    },
    controlCharacterReference: {
      reason: "Unexpected control character reference",
      description: "Unexpectedly control character in reference. Expected a non-control code point, 0x00, or ASCII whitespace"
    },
    disallowedContentInNoscriptInHead: {
      reason: "Disallowed content inside `<noscript>` in `<head>`",
      description: "Unexpected text character `%c`. Only use text in `<noscript>`s in `<body>`",
      url: false
    },
    duplicateAttribute: {
      reason: "Unexpected duplicate attribute",
      description: "Unexpectedly double attribute. Expected attributes to occur only once"
    },
    endTagWithAttributes: {
      reason: "Unexpected attribute on closing tag",
      description: "Unexpected attribute. Expected `>` instead"
    },
    endTagWithTrailingSolidus: {
      reason: "Unexpected slash at end of closing tag",
      description: "Unexpected `%c-1`. Expected `>` instead"
    },
    endTagWithoutMatchingOpenElement: {
      reason: "Unexpected unopened end tag",
      description: "Unexpected end tag. Expected no end tag or another end tag",
      url: false
    },
    eofBeforeTagName: {
      reason: "Unexpected end of file",
      description: "Unexpected end of file. Expected tag name instead"
    },
    eofInCdata: {
      reason: "Unexpected end of file in CDATA",
      description: "Unexpected end of file. Expected `]]>` to close the CDATA"
    },
    eofInComment: {
      reason: "Unexpected end of file in comment",
      description: "Unexpected end of file. Expected `-->` to close the comment"
    },
    eofInDoctype: {
      reason: "Unexpected end of file in doctype",
      description: "Unexpected end of file. Expected a valid doctype (such as `<!doctype html>`)"
    },
    eofInElementThatCanContainOnlyText: {
      reason: "Unexpected end of file in element that can only contain text",
      description: "Unexpected end of file. Expected text or a closing tag",
      url: false
    },
    eofInScriptHtmlCommentLikeText: {
      reason: "Unexpected end of file in comment inside script",
      description: "Unexpected end of file. Expected `-->` to close the comment"
    },
    eofInTag: {
      reason: "Unexpected end of file in tag",
      description: "Unexpected end of file. Expected `>` to close the tag"
    },
    incorrectlyClosedComment: {
      reason: "Incorrectly closed comment",
      description: "Unexpected `%c-1`. Expected `-->` to close the comment"
    },
    incorrectlyOpenedComment: {
      reason: "Incorrectly opened comment",
      description: "Unexpected `%c`. Expected `<!--` to open the comment"
    },
    invalidCharacterSequenceAfterDoctypeName: {
      reason: "Invalid sequence after doctype name",
      description: "Unexpected sequence at `%c`. Expected `public` or `system`"
    },
    invalidFirstCharacterOfTagName: {
      reason: "Invalid first character in tag name",
      description: "Unexpected `%c`. Expected an ASCII letter instead"
    },
    misplacedDoctype: {
      reason: "Misplaced doctype",
      description: "Unexpected doctype. Expected doctype before head",
      url: false
    },
    misplacedStartTagForHeadElement: {
      reason: "Misplaced `<head>` start tag",
      description: "Unexpected start tag `<head>`. Expected `<head>` directly after doctype",
      url: false
    },
    missingAttributeValue: {
      reason: "Missing attribute value",
      description: "Unexpected `%c-1`. Expected an attribute value or no `%c-1` instead"
    },
    missingDoctype: {
      reason: "Missing doctype before other content",
      description: "Expected a `<!doctype html>` before anything else",
      url: false
    },
    missingDoctypeName: {
      reason: "Missing doctype name",
      description: "Unexpected doctype end at `%c`. Expected `html` instead"
    },
    missingDoctypePublicIdentifier: {
      reason: "Missing public identifier in doctype",
      description: "Unexpected `%c`. Expected identifier for `public` instead"
    },
    missingDoctypeSystemIdentifier: {
      reason: "Missing system identifier in doctype",
      description: 'Unexpected `%c`. Expected identifier for `system` instead (suggested: `"about:legacy-compat"`)'
    },
    missingEndTagName: {
      reason: "Missing name in end tag",
      description: "Unexpected `%c`. Expected an ASCII letter instead"
    },
    missingQuoteBeforeDoctypePublicIdentifier: {
      reason: "Missing quote before public identifier in doctype",
      description: "Unexpected `%c`. Expected `\"` or `'` instead"
    },
    missingQuoteBeforeDoctypeSystemIdentifier: {
      reason: "Missing quote before system identifier in doctype",
      description: "Unexpected `%c`. Expected `\"` or `'` instead"
    },
    missingSemicolonAfterCharacterReference: {
      reason: "Missing semicolon after character reference",
      description: "Unexpected `%c`. Expected `;` instead"
    },
    missingWhitespaceAfterDoctypePublicKeyword: {
      reason: "Missing whitespace after public identifier in doctype",
      description: "Unexpected `%c`. Expected ASCII whitespace instead"
    },
    missingWhitespaceAfterDoctypeSystemKeyword: {
      reason: "Missing whitespace after system identifier in doctype",
      description: "Unexpected `%c`. Expected ASCII whitespace instead"
    },
    missingWhitespaceBeforeDoctypeName: {
      reason: "Missing whitespace before doctype name",
      description: "Unexpected `%c`. Expected ASCII whitespace instead"
    },
    missingWhitespaceBetweenAttributes: {
      reason: "Missing whitespace between attributes",
      description: "Unexpected `%c`. Expected ASCII whitespace instead"
    },
    missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: {
      reason: "Missing whitespace between public and system identifiers in doctype",
      description: "Unexpected `%c`. Expected ASCII whitespace instead"
    },
    nestedComment: {
      reason: "Unexpected nested comment",
      description: "Unexpected `<!--`. Expected `-->`"
    },
    nestedNoscriptInHead: {
      reason: "Unexpected nested `<noscript>` in `<head>`",
      description: "Unexpected `<noscript>`. Expected a closing tag or a meta element",
      url: false
    },
    nonConformingDoctype: {
      reason: "Unexpected non-conforming doctype declaration",
      description: 'Expected `<!doctype html>` or `<!doctype html system "about:legacy-compat">`',
      url: false
    },
    nonVoidHtmlElementStartTagWithTrailingSolidus: {
      reason: "Unexpected trailing slash on start tag of non-void element",
      description: "Unexpected `/`. Expected `>` instead"
    },
    noncharacterCharacterReference: {
      reason: "Unexpected noncharacter code point referenced by character reference",
      description: "Unexpected code point. Do not use noncharacters in HTML"
    },
    noncharacterInInputStream: {
      reason: "Unexpected noncharacter character",
      description: "Unexpected code point `%x`. Do not use noncharacters in HTML"
    },
    nullCharacterReference: {
      reason: "Unexpected NULL character referenced by character reference",
      description: "Unexpected code point. Do not use NULL characters in HTML"
    },
    openElementsLeftAfterEof: {
      reason: "Unexpected end of file",
      description: "Unexpected end of file. Expected closing tag instead",
      url: false
    },
    surrogateCharacterReference: {
      reason: "Unexpected surrogate character referenced by character reference",
      description: "Unexpected code point. Do not use lone surrogate characters in HTML"
    },
    surrogateInInputStream: {
      reason: "Unexpected surrogate character",
      description: "Unexpected code point `%x`. Do not use lone surrogate characters in HTML"
    },
    unexpectedCharacterAfterDoctypeSystemIdentifier: {
      reason: "Invalid character after system identifier in doctype",
      description: "Unexpected character at `%c`. Expected `>`"
    },
    unexpectedCharacterInAttributeName: {
      reason: "Unexpected character in attribute name",
      description: "Unexpected `%c`. Expected whitespace, `/`, `>`, `=`, or probably an ASCII letter"
    },
    unexpectedCharacterInUnquotedAttributeValue: {
      reason: "Unexpected character in unquoted attribute value",
      description: "Unexpected `%c`. Quote the attribute value to include it"
    },
    unexpectedEqualsSignBeforeAttributeName: {
      reason: "Unexpected equals sign before attribute name",
      description: "Unexpected `%c`. Add an attribute name before it"
    },
    unexpectedNullCharacter: {
      reason: "Unexpected NULL character",
      description: "Unexpected code point `%x`. Do not use NULL characters in HTML"
    },
    unexpectedQuestionMarkInsteadOfTagName: {
      reason: "Unexpected question mark instead of tag name",
      description: "Unexpected `%c`. Expected an ASCII letter instead"
    },
    unexpectedSolidusInTag: {
      reason: "Unexpected slash in tag",
      description: "Unexpected `%c-1`. Expected it followed by `>` or in a quoted attribute value"
    },
    unknownNamedCharacterReference: {
      reason: "Unexpected unknown named character reference",
      description: "Unexpected character reference. Expected known named character references"
    }
  };
  const base$3 = "https://html.spec.whatwg.org/multipage/parsing.html#parse-error-";
  const fatalities = { 2: true, 1: false, 0: null };
  function rehypeParse(options) {
    const processorSettings = (
      /** @type {Options} */
      this.data("settings")
    );
    const settings = Object.assign({}, processorSettings, options);
    Object.assign(this, { Parser: parser2 });
    function parser2(doc2, file) {
      const fn = settings.fragment ? "parseFragment" : "parse";
      const onParseError = settings.emitParseErrors ? onerror : null;
      const parse5 = new Parser5({
        sourceCodeLocationInfo: true,
        onParseError,
        scriptingEnabled: false
      });
      return fromParse5(parse5[fn](doc2), {
        space: settings.space,
        file,
        verbose: settings.verbose
      });
      function onerror(error) {
        const code2 = error.code;
        const name = camelcase(code2);
        const setting = settings[name];
        const config = setting === void 0 || setting === null ? true : setting;
        const level = typeof config === "number" ? config : config ? 1 : 0;
        const start = {
          line: error.startLine,
          column: error.startCol,
          offset: error.startOffset
        };
        const end = {
          line: error.endLine,
          column: error.endCol,
          offset: error.endOffset
        };
        if (level) {
          const info = errors[name] || { reason: "", description: "", url: "" };
          const message = file.message(format(info.reason), { start, end });
          message.source = "parse-error";
          message.ruleId = code2;
          message.fatal = fatalities[level];
          message.note = format(info.description);
          message.url = "url" in info && info.url === false ? null : base$3 + code2;
        }
        function format(value) {
          return value.replace(/%c(?:-(\d+))?/g, (_, $1) => {
            const offset = $1 ? -Number.parseInt($1, 10) : 0;
            const char = doc2.charAt(error.startOffset + offset);
            return char === "`" ? "` ` `" : char;
          }).replace(
            /%x/g,
            () => "0x" + doc2.charCodeAt(error.startOffset).toString(16).toUpperCase()
          );
        }
      }
    }
  }
  function camelcase(value) {
    return value.replace(/-[a-z]/g, ($0) => $0.charAt(1).toUpperCase());
  }
  const htmlVoidElements = [
    "area",
    "base",
    "basefont",
    "bgsound",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "image",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "menuitem",
    "meta",
    "nextid",
    "param",
    "source",
    "track",
    "wbr"
  ];
  const own$9 = {}.hasOwnProperty;
  function zwitch(key2, options) {
    const settings = options || {};
    function one2(value, ...parameters) {
      let fn = one2.invalid;
      const handlers2 = one2.handlers;
      if (value && own$9.call(value, key2)) {
        const id = String(value[key2]);
        fn = own$9.call(handlers2, id) ? handlers2[id] : one2.unknown;
      }
      if (fn) {
        return fn.call(this, value, ...parameters);
      }
    }
    one2.handlers = settings.handlers || {};
    one2.invalid = settings.invalid;
    one2.unknown = settings.unknown;
    return one2;
  }
  function core(value, options) {
    value = value.replace(
      options.subset ? charactersToExpression(options.subset) : /["&'<>`]/g,
      basic2
    );
    if (options.subset || options.escapeOnly) {
      return value;
    }
    return value.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate).replace(
      // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
      /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
      basic2
    );
    function surrogate(pair, index2, all2) {
      return options.format(
        (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
        all2.charCodeAt(index2 + 2),
        options
      );
    }
    function basic2(character, index2, all2) {
      return options.format(
        character.charCodeAt(0),
        all2.charCodeAt(index2 + 1),
        options
      );
    }
  }
  function charactersToExpression(subset) {
    const groups = [];
    let index2 = -1;
    while (++index2 < subset.length) {
      groups.push(subset[index2].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
    }
    return new RegExp("(?:" + groups.join("|") + ")", "g");
  }
  function toHexadecimal(code2, next, omit) {
    const value = "&#x" + code2.toString(16).toUpperCase();
    return omit && next && !/[\dA-Fa-f]/.test(String.fromCharCode(next)) ? value : value + ";";
  }
  function toDecimal(code2, next, omit) {
    const value = "&#" + String(code2);
    return omit && next && !/\d/.test(String.fromCharCode(next)) ? value : value + ";";
  }
  const characterEntitiesLegacy = [
    "AElig",
    "AMP",
    "Aacute",
    "Acirc",
    "Agrave",
    "Aring",
    "Atilde",
    "Auml",
    "COPY",
    "Ccedil",
    "ETH",
    "Eacute",
    "Ecirc",
    "Egrave",
    "Euml",
    "GT",
    "Iacute",
    "Icirc",
    "Igrave",
    "Iuml",
    "LT",
    "Ntilde",
    "Oacute",
    "Ocirc",
    "Ograve",
    "Oslash",
    "Otilde",
    "Ouml",
    "QUOT",
    "REG",
    "THORN",
    "Uacute",
    "Ucirc",
    "Ugrave",
    "Uuml",
    "Yacute",
    "aacute",
    "acirc",
    "acute",
    "aelig",
    "agrave",
    "amp",
    "aring",
    "atilde",
    "auml",
    "brvbar",
    "ccedil",
    "cedil",
    "cent",
    "copy",
    "curren",
    "deg",
    "divide",
    "eacute",
    "ecirc",
    "egrave",
    "eth",
    "euml",
    "frac12",
    "frac14",
    "frac34",
    "gt",
    "iacute",
    "icirc",
    "iexcl",
    "igrave",
    "iquest",
    "iuml",
    "laquo",
    "lt",
    "macr",
    "micro",
    "middot",
    "nbsp",
    "not",
    "ntilde",
    "oacute",
    "ocirc",
    "ograve",
    "ordf",
    "ordm",
    "oslash",
    "otilde",
    "ouml",
    "para",
    "plusmn",
    "pound",
    "quot",
    "raquo",
    "reg",
    "sect",
    "shy",
    "sup1",
    "sup2",
    "sup3",
    "szlig",
    "thorn",
    "times",
    "uacute",
    "ucirc",
    "ugrave",
    "uml",
    "uuml",
    "yacute",
    "yen",
    "yuml"
  ];
  const characterEntitiesHtml4 = {
    nbsp: " ",
    iexcl: "¡",
    cent: "¢",
    pound: "£",
    curren: "¤",
    yen: "¥",
    brvbar: "¦",
    sect: "§",
    uml: "¨",
    copy: "©",
    ordf: "ª",
    laquo: "«",
    not: "¬",
    shy: "­",
    reg: "®",
    macr: "¯",
    deg: "°",
    plusmn: "±",
    sup2: "²",
    sup3: "³",
    acute: "´",
    micro: "µ",
    para: "¶",
    middot: "·",
    cedil: "¸",
    sup1: "¹",
    ordm: "º",
    raquo: "»",
    frac14: "¼",
    frac12: "½",
    frac34: "¾",
    iquest: "¿",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    times: "×",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    divide: "÷",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    fnof: "ƒ",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    bull: "•",
    hellip: "…",
    prime: "′",
    Prime: "″",
    oline: "‾",
    frasl: "⁄",
    weierp: "℘",
    image: "ℑ",
    real: "ℜ",
    trade: "™",
    alefsym: "ℵ",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lArr: "⇐",
    uArr: "⇑",
    rArr: "⇒",
    dArr: "⇓",
    hArr: "⇔",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    int: "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    lang: "〈",
    rang: "〉",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦",
    quot: '"',
    amp: "&",
    lt: "<",
    gt: ">",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    circ: "ˆ",
    tilde: "˜",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    permil: "‰",
    lsaquo: "‹",
    rsaquo: "›",
    euro: "€"
  };
  const dangerous = [
    "cent",
    "copy",
    "divide",
    "gt",
    "lt",
    "not",
    "para",
    "times"
  ];
  const own$8 = {}.hasOwnProperty;
  const characters = {};
  let key;
  for (key in characterEntitiesHtml4) {
    if (own$8.call(characterEntitiesHtml4, key)) {
      characters[characterEntitiesHtml4[key]] = key;
    }
  }
  function toNamed(code2, next, omit, attribute) {
    const character = String.fromCharCode(code2);
    if (own$8.call(characters, character)) {
      const name = characters[character];
      const value = "&" + name;
      if (omit && characterEntitiesLegacy.includes(name) && !dangerous.includes(name) && (!attribute || next && next !== 61 && /[^\da-z]/i.test(String.fromCharCode(next)))) {
        return value;
      }
      return value + ";";
    }
    return "";
  }
  function formatSmart(code2, next, options) {
    let numeric2 = toHexadecimal(code2, next, options.omitOptionalSemicolons);
    let named;
    if (options.useNamedReferences || options.useShortestReferences) {
      named = toNamed(
        code2,
        next,
        options.omitOptionalSemicolons,
        options.attribute
      );
    }
    if ((options.useShortestReferences || !named) && options.useShortestReferences) {
      const decimal = toDecimal(code2, next, options.omitOptionalSemicolons);
      if (decimal.length < numeric2.length) {
        numeric2 = decimal;
      }
    }
    return named && (!options.useShortestReferences || named.length < numeric2.length) ? named : numeric2;
  }
  function stringifyEntities(value, options) {
    return core(value, Object.assign({ format: formatSmart }, options));
  }
  function comment$2(node2, _1, _2, state) {
    return state.settings.bogusComments ? "<?" + stringifyEntities(
      node2.value,
      Object.assign({}, state.settings.characterReferences, { subset: [">"] })
    ) + ">" : "<!--" + node2.value.replace(/^>|^->|<!--|-->|--!>|<!-$/g, encode) + "-->";
    function encode($0) {
      return stringifyEntities(
        $0,
        Object.assign({}, state.settings.characterReferences, {
          subset: ["<", ">"]
        })
      );
    }
  }
  function doctype$1(_1, _2, _3, state) {
    return "<!" + (state.settings.upperDoctype ? "DOCTYPE" : "doctype") + (state.settings.tightDoctype ? "" : " ") + "html>";
  }
  function ccount(value, character) {
    const source2 = String(value);
    if (typeof character !== "string") {
      throw new TypeError("Expected character");
    }
    let count = 0;
    let index2 = source2.indexOf(character);
    while (index2 !== -1) {
      count++;
      index2 = source2.indexOf(character, index2 + character.length);
    }
    return count;
  }
  function whitespace$2(thing) {
    const value = (
      // @ts-expect-error looks like a node.
      thing && typeof thing === "object" && thing.type === "text" ? (
        // @ts-expect-error looks like a text.
        thing.value || ""
      ) : thing
    );
    return typeof value === "string" && value.replace(/[ \t\n\f\r]/g, "") === "";
  }
  const siblingAfter = siblings(1);
  const siblingBefore = siblings(-1);
  function siblings(increment2) {
    return sibling;
    function sibling(parent, index2, includeWhitespace) {
      const siblings2 = parent ? parent.children : [];
      let offset = (index2 || 0) + increment2;
      let next = siblings2 && siblings2[offset];
      if (!includeWhitespace) {
        while (next && whitespace$2(next)) {
          offset += increment2;
          next = siblings2[offset];
        }
      }
      return next;
    }
  }
  const own$7 = {}.hasOwnProperty;
  function omission(handlers2) {
    return omit;
    function omit(node2, index2, parent) {
      return own$7.call(handlers2, node2.tagName) && handlers2[node2.tagName](node2, index2, parent);
    }
  }
  const closing = omission({
    html: html$3,
    head: headOrColgroupOrCaption,
    body: body$1,
    p: p$3,
    li: li$1,
    dt: dt$1,
    dd: dd$1,
    rt: rubyElement,
    rp: rubyElement,
    optgroup,
    option: option$1,
    menuitem,
    colgroup: headOrColgroupOrCaption,
    caption: headOrColgroupOrCaption,
    thead: thead$1,
    tbody: tbody$1,
    tfoot,
    tr: tr$2,
    td: cells,
    th: cells
  });
  function headOrColgroupOrCaption(_, index2, parent) {
    const next = siblingAfter(parent, index2, true);
    return !next || next.type !== "comment" && !(next.type === "text" && whitespace$2(next.value.charAt(0)));
  }
  function html$3(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type !== "comment";
  }
  function body$1(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type !== "comment";
  }
  function p$3(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return next ? next.type === "element" && (next.tagName === "address" || next.tagName === "article" || next.tagName === "aside" || next.tagName === "blockquote" || next.tagName === "details" || next.tagName === "div" || next.tagName === "dl" || next.tagName === "fieldset" || next.tagName === "figcaption" || next.tagName === "figure" || next.tagName === "footer" || next.tagName === "form" || next.tagName === "h1" || next.tagName === "h2" || next.tagName === "h3" || next.tagName === "h4" || next.tagName === "h5" || next.tagName === "h6" || next.tagName === "header" || next.tagName === "hgroup" || next.tagName === "hr" || next.tagName === "main" || next.tagName === "menu" || next.tagName === "nav" || next.tagName === "ol" || next.tagName === "p" || next.tagName === "pre" || next.tagName === "section" || next.tagName === "table" || next.tagName === "ul") : !parent || // Confusing parent.
    !(parent.type === "element" && (parent.tagName === "a" || parent.tagName === "audio" || parent.tagName === "del" || parent.tagName === "ins" || parent.tagName === "map" || parent.tagName === "noscript" || parent.tagName === "video"));
  }
  function li$1(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && next.tagName === "li";
  }
  function dt$1(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return next && next.type === "element" && (next.tagName === "dt" || next.tagName === "dd");
  }
  function dd$1(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "dt" || next.tagName === "dd");
  }
  function rubyElement(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "rp" || next.tagName === "rt");
  }
  function optgroup(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && next.tagName === "optgroup";
  }
  function option$1(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "option" || next.tagName === "optgroup");
  }
  function menuitem(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "menuitem" || next.tagName === "hr" || next.tagName === "menu");
  }
  function thead$1(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return next && next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot");
  }
  function tbody$1(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot");
  }
  function tfoot(_, index2, parent) {
    return !siblingAfter(parent, index2);
  }
  function tr$2(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && next.tagName === "tr";
  }
  function cells(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "td" || next.tagName === "th");
  }
  const opening = omission({
    html: html$2,
    head,
    body,
    colgroup,
    tbody
  });
  function html$2(node2) {
    const head2 = siblingAfter(node2, -1);
    return !head2 || head2.type !== "comment";
  }
  function head(node2) {
    const children = node2.children;
    const seen = [];
    let index2 = -1;
    while (++index2 < children.length) {
      const child = children[index2];
      if (child.type === "element" && (child.tagName === "title" || child.tagName === "base")) {
        if (seen.includes(child.tagName))
          return false;
        seen.push(child.tagName);
      }
    }
    return children.length > 0;
  }
  function body(node2) {
    const head2 = siblingAfter(node2, -1, true);
    return !head2 || head2.type !== "comment" && !(head2.type === "text" && whitespace$2(head2.value.charAt(0))) && !(head2.type === "element" && (head2.tagName === "meta" || head2.tagName === "link" || head2.tagName === "script" || head2.tagName === "style" || head2.tagName === "template"));
  }
  function colgroup(node2, index2, parent) {
    const previous2 = siblingBefore(parent, index2);
    const head2 = siblingAfter(node2, -1, true);
    if (parent && previous2 && previous2.type === "element" && previous2.tagName === "colgroup" && closing(previous2, parent.children.indexOf(previous2), parent)) {
      return false;
    }
    return head2 && head2.type === "element" && head2.tagName === "col";
  }
  function tbody(node2, index2, parent) {
    const previous2 = siblingBefore(parent, index2);
    const head2 = siblingAfter(node2, -1);
    if (parent && previous2 && previous2.type === "element" && (previous2.tagName === "thead" || previous2.tagName === "tbody") && closing(previous2, parent.children.indexOf(previous2), parent)) {
      return false;
    }
    return head2 && head2.type === "element" && head2.tagName === "tr";
  }
  const constants = {
    // See: <https://html.spec.whatwg.org/#attribute-name-state>.
    name: [
      ["	\n\f\r &/=>".split(""), "	\n\f\r \"&'/=>`".split("")],
      [`\0	
\f\r "&'/<=>`.split(""), "\0	\n\f\r \"&'/<=>`".split("")]
    ],
    // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
    unquoted: [
      ["	\n\f\r &>".split(""), "\0	\n\f\r \"&'<=>`".split("")],
      ["\0	\n\f\r \"&'<=>`".split(""), "\0	\n\f\r \"&'<=>`".split("")]
    ],
    // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
    single: [
      ["&'".split(""), "\"&'`".split("")],
      ["\0&'".split(""), "\0\"&'`".split("")]
    ],
    // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
    double: [
      ['"&'.split(""), "\"&'`".split("")],
      ['\0"&'.split(""), "\0\"&'`".split("")]
    ]
  };
  function element$4(node2, index2, parent, state) {
    const schema = state.schema;
    const omit = schema.space === "svg" ? false : state.settings.omitOptionalTags;
    let selfClosing = schema.space === "svg" ? state.settings.closeEmptyElements : state.settings.voids.includes(node2.tagName.toLowerCase());
    const parts = [];
    let last2;
    if (schema.space === "html" && node2.tagName === "svg") {
      state.schema = svg;
    }
    const attrs = serializeAttributes(state, node2.properties);
    const content2 = state.all(
      schema.space === "html" && node2.tagName === "template" ? node2.content : node2
    );
    state.schema = schema;
    if (content2)
      selfClosing = false;
    if (attrs || !omit || !opening(node2, index2, parent)) {
      parts.push("<", node2.tagName, attrs ? " " + attrs : "");
      if (selfClosing && (schema.space === "svg" || state.settings.closeSelfClosing)) {
        last2 = attrs.charAt(attrs.length - 1);
        if (!state.settings.tightSelfClosing || last2 === "/" || last2 && last2 !== '"' && last2 !== "'") {
          parts.push(" ");
        }
        parts.push("/");
      }
      parts.push(">");
    }
    parts.push(content2);
    if (!selfClosing && (!omit || !closing(node2, index2, parent))) {
      parts.push("</" + node2.tagName + ">");
    }
    return parts.join("");
  }
  function serializeAttributes(state, props) {
    const values = [];
    let index2 = -1;
    let key2;
    if (props) {
      for (key2 in props) {
        if (props[key2] !== void 0 && props[key2] !== null) {
          const value = serializeAttribute(state, key2, props[key2]);
          if (value)
            values.push(value);
        }
      }
    }
    while (++index2 < values.length) {
      const last2 = state.settings.tightAttributes ? values[index2].charAt(values[index2].length - 1) : null;
      if (index2 !== values.length - 1 && last2 !== '"' && last2 !== "'") {
        values[index2] += " ";
      }
    }
    return values.join("");
  }
  function serializeAttribute(state, key2, value) {
    const info = find$2(state.schema, key2);
    const x = state.settings.allowParseErrors && state.schema.space === "html" ? 0 : 1;
    const y = state.settings.allowDangerousCharacters ? 0 : 1;
    let quote = state.quote;
    let result;
    if (info.overloadedBoolean && (value === info.attribute || value === "")) {
      value = true;
    } else if (info.boolean || info.overloadedBoolean && typeof value !== "string") {
      value = Boolean(value);
    }
    if (value === void 0 || value === null || value === false || typeof value === "number" && Number.isNaN(value)) {
      return "";
    }
    const name = stringifyEntities(
      info.attribute,
      Object.assign({}, state.settings.characterReferences, {
        // Always encode without parse errors in non-HTML.
        subset: constants.name[x][y]
      })
    );
    if (value === true)
      return name;
    value = Array.isArray(value) ? (info.commaSeparated ? stringify$1 : stringify$2)(value, {
      padLeft: !state.settings.tightCommaSeparatedLists
    }) : String(value);
    if (state.settings.collapseEmptyAttributes && !value)
      return name;
    if (state.settings.preferUnquoted) {
      result = stringifyEntities(
        value,
        Object.assign({}, state.settings.characterReferences, {
          subset: constants.unquoted[x][y],
          attribute: true
        })
      );
    }
    if (result !== value) {
      if (state.settings.quoteSmart && ccount(value, quote) > ccount(value, state.alternative)) {
        quote = state.alternative;
      }
      result = quote + stringifyEntities(
        value,
        Object.assign({}, state.settings.characterReferences, {
          // Always encode without parse errors in non-HTML.
          subset: (quote === "'" ? constants.single : constants.double)[x][y],
          attribute: true
        })
      ) + quote;
    }
    return name + (result ? "=" + result : result);
  }
  function text$7(node2, _, parent, state) {
    return parent && parent.type === "element" && (parent.tagName === "script" || parent.tagName === "style") ? node2.value : stringifyEntities(
      node2.value,
      Object.assign({}, state.settings.characterReferences, {
        subset: ["<", "&"]
      })
    );
  }
  function raw(node2, index2, parent, state) {
    return state.settings.allowDangerousHtml ? node2.value : text$7(node2, index2, parent, state);
  }
  function root$4(node2, _1, _2, state) {
    return state.all(node2);
  }
  const handle$2 = zwitch("type", {
    invalid: invalid$1,
    unknown: unknown$2,
    handlers: { comment: comment$2, doctype: doctype$1, element: element$4, raw, root: root$4, text: text$7 }
  });
  function invalid$1(node2) {
    throw new Error("Expected node, not `" + node2 + "`");
  }
  function unknown$2(node2) {
    throw new Error("Cannot compile unknown node `" + node2.type + "`");
  }
  function toHtml(tree, options) {
    const options_ = options || {};
    const quote = options_.quote || '"';
    const alternative = quote === '"' ? "'" : '"';
    if (quote !== '"' && quote !== "'") {
      throw new Error("Invalid quote `" + quote + "`, expected `'` or `\"`");
    }
    const state = {
      one: one$4,
      all: all$5,
      settings: {
        omitOptionalTags: options_.omitOptionalTags || false,
        allowParseErrors: options_.allowParseErrors || false,
        allowDangerousCharacters: options_.allowDangerousCharacters || false,
        quoteSmart: options_.quoteSmart || false,
        preferUnquoted: options_.preferUnquoted || false,
        tightAttributes: options_.tightAttributes || false,
        upperDoctype: options_.upperDoctype || false,
        tightDoctype: options_.tightDoctype || false,
        bogusComments: options_.bogusComments || false,
        tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,
        tightSelfClosing: options_.tightSelfClosing || false,
        collapseEmptyAttributes: options_.collapseEmptyAttributes || false,
        allowDangerousHtml: options_.allowDangerousHtml || false,
        voids: options_.voids || htmlVoidElements,
        characterReferences: options_.characterReferences || options_.entities || {},
        closeSelfClosing: options_.closeSelfClosing || false,
        closeEmptyElements: options_.closeEmptyElements || false
      },
      schema: options_.space === "svg" ? svg : html$4,
      quote,
      alternative
    };
    return state.one(
      Array.isArray(tree) ? { type: "root", children: tree } : tree,
      void 0,
      void 0
    );
  }
  function one$4(node2, index2, parent) {
    return handle$2(node2, index2, parent, this);
  }
  function all$5(parent) {
    const results = [];
    const children = parent && parent.children || [];
    let index2 = -1;
    while (++index2 < children.length) {
      results[index2] = this.one(children[index2], index2, parent);
    }
    return results.join("");
  }
  function rehypeStringify(config) {
    const processorSettings = (
      /** @type {Options} */
      this.data("settings")
    );
    const settings = Object.assign({}, processorSettings, config);
    Object.assign(this, { Compiler: compiler2 });
    function compiler2(tree) {
      return toHtml(tree, settings);
    }
  }
  function bail(error) {
    if (error) {
      throw error;
    }
  }
  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  var isBuffer = function isBuffer2(obj) {
    return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  };
  const isBuffer$1 = /* @__PURE__ */ getDefaultExportFromCjs(isBuffer);
  var hasOwn = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var defineProperty = Object.defineProperty;
  var gOPD = Object.getOwnPropertyDescriptor;
  var isArray$1 = function isArray2(arr) {
    if (typeof Array.isArray === "function") {
      return Array.isArray(arr);
    }
    return toStr.call(arr) === "[object Array]";
  };
  var isPlainObject$2 = function isPlainObject2(obj) {
    if (!obj || toStr.call(obj) !== "[object Object]") {
      return false;
    }
    var hasOwnConstructor = hasOwn.call(obj, "constructor");
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
      return false;
    }
    var key2;
    for (key2 in obj) {
    }
    return typeof key2 === "undefined" || hasOwn.call(obj, key2);
  };
  var setProperty = function setProperty2(target, options) {
    if (defineProperty && options.name === "__proto__") {
      defineProperty(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true
      });
    } else {
      target[options.name] = options.newValue;
    }
  };
  var getProperty = function getProperty2(obj, name) {
    if (name === "__proto__") {
      if (!hasOwn.call(obj, name)) {
        return void 0;
      } else if (gOPD) {
        return gOPD(obj, name).value;
      }
    }
    return obj[name];
  };
  var extend = function extend2() {
    var options, name, src, copy2, copyIsArray, clone;
    var target = arguments[0];
    var i2 = 1;
    var length2 = arguments.length;
    var deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[1] || {};
      i2 = 2;
    }
    if (target == null || typeof target !== "object" && typeof target !== "function") {
      target = {};
    }
    for (; i2 < length2; ++i2) {
      options = arguments[i2];
      if (options != null) {
        for (name in options) {
          src = getProperty(target, name);
          copy2 = getProperty(options, name);
          if (target !== copy2) {
            if (deep && copy2 && (isPlainObject$2(copy2) || (copyIsArray = isArray$1(copy2)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray$1(src) ? src : [];
              } else {
                clone = src && isPlainObject$2(src) ? src : {};
              }
              setProperty(target, { name, newValue: extend2(deep, clone, copy2) });
            } else if (typeof copy2 !== "undefined") {
              setProperty(target, { name, newValue: copy2 });
            }
          }
        }
      }
    }
    return target;
  };
  const extend$1 = /* @__PURE__ */ getDefaultExportFromCjs(extend);
  function isPlainObject$1(value) {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
  }
  function trough() {
    const fns = [];
    const pipeline = { run: run2, use };
    return pipeline;
    function run2(...values) {
      let middlewareIndex = -1;
      const callback = values.pop();
      if (typeof callback !== "function") {
        throw new TypeError("Expected function as last argument, not " + callback);
      }
      next(null, ...values);
      function next(error, ...output) {
        const fn = fns[++middlewareIndex];
        let index2 = -1;
        if (error) {
          callback(error);
          return;
        }
        while (++index2 < values.length) {
          if (output[index2] === null || output[index2] === void 0) {
            output[index2] = values[index2];
          }
        }
        values = output;
        if (fn) {
          wrap$3(fn, next)(...output);
        } else {
          callback(null, ...output);
        }
      }
    }
    function use(middelware) {
      if (typeof middelware !== "function") {
        throw new TypeError(
          "Expected `middelware` to be a function, not " + middelware
        );
      }
      fns.push(middelware);
      return pipeline;
    }
  }
  function wrap$3(middleware, callback) {
    let called;
    return wrapped;
    function wrapped(...parameters) {
      const fnExpectsCallback = middleware.length > parameters.length;
      let result;
      if (fnExpectsCallback) {
        parameters.push(done);
      }
      try {
        result = middleware.apply(this, parameters);
      } catch (error) {
        const exception = (
          /** @type {Error} */
          error
        );
        if (fnExpectsCallback && called) {
          throw exception;
        }
        return done(exception);
      }
      if (!fnExpectsCallback) {
        if (result && result.then && typeof result.then === "function") {
          result.then(then, done);
        } else if (result instanceof Error) {
          done(result);
        } else {
          then(result);
        }
      }
    }
    function done(error, ...output) {
      if (!called) {
        called = true;
        callback(error, ...output);
      }
    }
    function then(value) {
      done(null, value);
    }
  }
  function stringifyPosition(value) {
    if (!value || typeof value !== "object") {
      return "";
    }
    if ("position" in value || "type" in value) {
      return position$1(value.position);
    }
    if ("start" in value || "end" in value) {
      return position$1(value);
    }
    if ("line" in value || "column" in value) {
      return point$2(value);
    }
    return "";
  }
  function point$2(point2) {
    return index(point2 && point2.line) + ":" + index(point2 && point2.column);
  }
  function position$1(pos) {
    return point$2(pos && pos.start) + "-" + point$2(pos && pos.end);
  }
  function index(value) {
    return value && typeof value === "number" ? value : 1;
  }
  class VFileMessage extends Error {
    /**
     * Create a message for `reason` at `place` from `origin`.
     *
     * When an error is passed in as `reason`, the `stack` is copied.
     *
     * @param {string | Error | VFileMessage} reason
     *   Reason for message, uses the stack and message of the error if given.
     *
     *   > 👉 **Note**: you should use markdown.
     * @param {Node | NodeLike | Position | Point | null | undefined} [place]
     *   Place in file where the message occurred.
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns
     *   Instance of `VFileMessage`.
     */
    // To do: next major: expose `undefined` everywhere instead of `null`.
    constructor(reason, place, origin) {
      const parts = [null, null];
      let position2 = {
        // @ts-expect-error: we always follows the structure of `position`.
        start: { line: null, column: null },
        // @ts-expect-error: "
        end: { line: null, column: null }
      };
      super();
      if (typeof place === "string") {
        origin = place;
        place = void 0;
      }
      if (typeof origin === "string") {
        const index2 = origin.indexOf(":");
        if (index2 === -1) {
          parts[1] = origin;
        } else {
          parts[0] = origin.slice(0, index2);
          parts[1] = origin.slice(index2 + 1);
        }
      }
      if (place) {
        if ("type" in place || "position" in place) {
          if (place.position) {
            position2 = place.position;
          }
        } else if ("start" in place || "end" in place) {
          position2 = place;
        } else if ("line" in place || "column" in place) {
          position2.start = place;
        }
      }
      this.name = stringifyPosition(place) || "1:1";
      this.message = typeof reason === "object" ? reason.message : reason;
      this.stack = "";
      if (typeof reason === "object" && reason.stack) {
        this.stack = reason.stack;
      }
      this.reason = this.message;
      this.fatal;
      this.line = position2.start.line;
      this.column = position2.start.column;
      this.position = position2;
      this.source = parts[0];
      this.ruleId = parts[1];
      this.file;
      this.actual;
      this.expected;
      this.url;
      this.note;
    }
  }
  VFileMessage.prototype.file = "";
  VFileMessage.prototype.name = "";
  VFileMessage.prototype.reason = "";
  VFileMessage.prototype.message = "";
  VFileMessage.prototype.stack = "";
  VFileMessage.prototype.fatal = null;
  VFileMessage.prototype.column = null;
  VFileMessage.prototype.line = null;
  VFileMessage.prototype.source = null;
  VFileMessage.prototype.ruleId = null;
  VFileMessage.prototype.position = null;
  const path$1 = { basename, dirname, extname, join: join$2, sep: "/" };
  function basename(path2, ext) {
    if (ext !== void 0 && typeof ext !== "string") {
      throw new TypeError('"ext" argument must be a string');
    }
    assertPath$1(path2);
    let start = 0;
    let end = -1;
    let index2 = path2.length;
    let seenNonSlash;
    if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
      while (index2--) {
        if (path2.charCodeAt(index2) === 47) {
          if (seenNonSlash) {
            start = index2 + 1;
            break;
          }
        } else if (end < 0) {
          seenNonSlash = true;
          end = index2 + 1;
        }
      }
      return end < 0 ? "" : path2.slice(start, end);
    }
    if (ext === path2) {
      return "";
    }
    let firstNonSlashEnd = -1;
    let extIndex = ext.length - 1;
    while (index2--) {
      if (path2.charCodeAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd < 0) {
          seenNonSlash = true;
          firstNonSlashEnd = index2 + 1;
        }
        if (extIndex > -1) {
          if (path2.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
            if (extIndex < 0) {
              end = index2;
            }
          } else {
            extIndex = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end) {
      end = firstNonSlashEnd;
    } else if (end < 0) {
      end = path2.length;
    }
    return path2.slice(start, end);
  }
  function dirname(path2) {
    assertPath$1(path2);
    if (path2.length === 0) {
      return ".";
    }
    let end = -1;
    let index2 = path2.length;
    let unmatchedSlash;
    while (--index2) {
      if (path2.charCodeAt(index2) === 47) {
        if (unmatchedSlash) {
          end = index2;
          break;
        }
      } else if (!unmatchedSlash) {
        unmatchedSlash = true;
      }
    }
    return end < 0 ? path2.charCodeAt(0) === 47 ? "/" : "." : end === 1 && path2.charCodeAt(0) === 47 ? "//" : path2.slice(0, end);
  }
  function extname(path2) {
    assertPath$1(path2);
    let index2 = path2.length;
    let end = -1;
    let startPart = 0;
    let startDot = -1;
    let preDotState = 0;
    let unmatchedSlash;
    while (index2--) {
      const code2 = path2.charCodeAt(index2);
      if (code2 === 47) {
        if (unmatchedSlash) {
          startPart = index2 + 1;
          break;
        }
        continue;
      }
      if (end < 0) {
        unmatchedSlash = true;
        end = index2 + 1;
      }
      if (code2 === 46) {
        if (startDot < 0) {
          startDot = index2;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot > -1) {
        preDotState = -1;
      }
    }
    if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
    preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end);
  }
  function join$2(...segments) {
    let index2 = -1;
    let joined;
    while (++index2 < segments.length) {
      assertPath$1(segments[index2]);
      if (segments[index2]) {
        joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
      }
    }
    return joined === void 0 ? "." : normalize$1(joined);
  }
  function normalize$1(path2) {
    assertPath$1(path2);
    const absolute = path2.charCodeAt(0) === 47;
    let value = normalizeString(path2, !absolute);
    if (value.length === 0 && !absolute) {
      value = ".";
    }
    if (value.length > 0 && path2.charCodeAt(path2.length - 1) === 47) {
      value += "/";
    }
    return absolute ? "/" + value : value;
  }
  function normalizeString(path2, allowAboveRoot) {
    let result = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let index2 = -1;
    let code2;
    let lastSlashIndex;
    while (++index2 <= path2.length) {
      if (index2 < path2.length) {
        code2 = path2.charCodeAt(index2);
      } else if (code2 === 47) {
        break;
      } else {
        code2 = 47;
      }
      if (code2 === 47) {
        if (lastSlash === index2 - 1 || dots === 1)
          ;
        else if (lastSlash !== index2 - 1 && dots === 2) {
          if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
            if (result.length > 2) {
              lastSlashIndex = result.lastIndexOf("/");
              if (lastSlashIndex !== result.length - 1) {
                if (lastSlashIndex < 0) {
                  result = "";
                  lastSegmentLength = 0;
                } else {
                  result = result.slice(0, lastSlashIndex);
                  lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
                }
                lastSlash = index2;
                dots = 0;
                continue;
              }
            } else if (result.length > 0) {
              result = "";
              lastSegmentLength = 0;
              lastSlash = index2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            result = result.length > 0 ? result + "/.." : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (result.length > 0) {
            result += "/" + path2.slice(lastSlash + 1, index2);
          } else {
            result = path2.slice(lastSlash + 1, index2);
          }
          lastSegmentLength = index2 - lastSlash - 1;
        }
        lastSlash = index2;
        dots = 0;
      } else if (code2 === 46 && dots > -1) {
        dots++;
      } else {
        dots = -1;
      }
    }
    return result;
  }
  function assertPath$1(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError(
        "Path must be a string. Received " + JSON.stringify(path2)
      );
    }
  }
  const proc = { cwd };
  function cwd() {
    return "/";
  }
  function isUrl(fileUrlOrPath) {
    return fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && // @ts-expect-error: indexable.
    fileUrlOrPath.href && // @ts-expect-error: indexable.
    fileUrlOrPath.origin;
  }
  function urlToPath(path2) {
    if (typeof path2 === "string") {
      path2 = new URL(path2);
    } else if (!isUrl(path2)) {
      const error = new TypeError(
        'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
      );
      error.code = "ERR_INVALID_ARG_TYPE";
      throw error;
    }
    if (path2.protocol !== "file:") {
      const error = new TypeError("The URL must be of scheme file");
      error.code = "ERR_INVALID_URL_SCHEME";
      throw error;
    }
    return getPathFromURLPosix(path2);
  }
  function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
      const error = new TypeError(
        'File URL host must be "localhost" or empty on darwin'
      );
      error.code = "ERR_INVALID_FILE_URL_HOST";
      throw error;
    }
    const pathname = url.pathname;
    let index2 = -1;
    while (++index2 < pathname.length) {
      if (pathname.charCodeAt(index2) === 37 && pathname.charCodeAt(index2 + 1) === 50) {
        const third = pathname.charCodeAt(index2 + 2);
        if (third === 70 || third === 102) {
          const error = new TypeError(
            "File URL path must not include encoded / characters"
          );
          error.code = "ERR_INVALID_FILE_URL_PATH";
          throw error;
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  const order = ["history", "path", "basename", "stem", "extname", "dirname"];
  class VFile {
    /**
     * Create a new virtual file.
     *
     * `options` is treated as:
     *
     * *   `string` or `Buffer` — `{value: options}`
     * *   `URL` — `{path: options}`
     * *   `VFile` — shallow copies its data over to the new file
     * *   `object` — all fields are shallow copied over to the new file
     *
     * Path related fields are set in the following order (least specific to
     * most specific): `history`, `path`, `basename`, `stem`, `extname`,
     * `dirname`.
     *
     * You cannot set `dirname` or `extname` without setting either `history`,
     * `path`, `basename`, or `stem` too.
     *
     * @param {Compatible | null | undefined} [value]
     *   File value.
     * @returns
     *   New instance.
     */
    constructor(value) {
      let options;
      if (!value) {
        options = {};
      } else if (typeof value === "string" || buffer(value)) {
        options = { value };
      } else if (isUrl(value)) {
        options = { path: value };
      } else {
        options = value;
      }
      this.data = {};
      this.messages = [];
      this.history = [];
      this.cwd = proc.cwd();
      this.value;
      this.stored;
      this.result;
      this.map;
      let index2 = -1;
      while (++index2 < order.length) {
        const prop2 = order[index2];
        if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
          this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
        }
      }
      let prop;
      for (prop in options) {
        if (!order.includes(prop)) {
          this[prop] = options[prop];
        }
      }
    }
    /**
     * Get the full path (example: `'~/index.min.js'`).
     *
     * @returns {string}
     */
    get path() {
      return this.history[this.history.length - 1];
    }
    /**
     * Set the full path (example: `'~/index.min.js'`).
     *
     * Cannot be nullified.
     * You can set a file URL (a `URL` object with a `file:` protocol) which will
     * be turned into a path with `url.fileURLToPath`.
     *
     * @param {string | URL} path
     */
    set path(path2) {
      if (isUrl(path2)) {
        path2 = urlToPath(path2);
      }
      assertNonEmpty(path2, "path");
      if (this.path !== path2) {
        this.history.push(path2);
      }
    }
    /**
     * Get the parent path (example: `'~'`).
     */
    get dirname() {
      return typeof this.path === "string" ? path$1.dirname(this.path) : void 0;
    }
    /**
     * Set the parent path (example: `'~'`).
     *
     * Cannot be set if there’s no `path` yet.
     */
    set dirname(dirname2) {
      assertPath(this.basename, "dirname");
      this.path = path$1.join(dirname2 || "", this.basename);
    }
    /**
     * Get the basename (including extname) (example: `'index.min.js'`).
     */
    get basename() {
      return typeof this.path === "string" ? path$1.basename(this.path) : void 0;
    }
    /**
     * Set basename (including extname) (`'index.min.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     */
    set basename(basename2) {
      assertNonEmpty(basename2, "basename");
      assertPart(basename2, "basename");
      this.path = path$1.join(this.dirname || "", basename2);
    }
    /**
     * Get the extname (including dot) (example: `'.js'`).
     */
    get extname() {
      return typeof this.path === "string" ? path$1.extname(this.path) : void 0;
    }
    /**
     * Set the extname (including dot) (example: `'.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be set if there’s no `path` yet.
     */
    set extname(extname2) {
      assertPart(extname2, "extname");
      assertPath(this.dirname, "extname");
      if (extname2) {
        if (extname2.charCodeAt(0) !== 46) {
          throw new Error("`extname` must start with `.`");
        }
        if (extname2.includes(".", 1)) {
          throw new Error("`extname` cannot contain multiple dots");
        }
      }
      this.path = path$1.join(this.dirname, this.stem + (extname2 || ""));
    }
    /**
     * Get the stem (basename w/o extname) (example: `'index.min'`).
     */
    get stem() {
      return typeof this.path === "string" ? path$1.basename(this.path, this.extname) : void 0;
    }
    /**
     * Set the stem (basename w/o extname) (example: `'index.min'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     */
    set stem(stem) {
      assertNonEmpty(stem, "stem");
      assertPart(stem, "stem");
      this.path = path$1.join(this.dirname || "", stem + (this.extname || ""));
    }
    /**
     * Serialize the file.
     *
     * @param {BufferEncoding | null | undefined} [encoding='utf8']
     *   Character encoding to understand `value` as when it’s a `Buffer`
     *   (default: `'utf8'`).
     * @returns {string}
     *   Serialized file.
     */
    toString(encoding) {
      return (this.value || "").toString(encoding || void 0);
    }
    /**
     * Create a warning message associated with the file.
     *
     * Its `fatal` is set to `false` and `file` is set to the current file path.
     * Its added to `file.messages`.
     *
     * @param {string | Error | VFileMessage} reason
     *   Reason for message, uses the stack and message of the error if given.
     * @param {Node | NodeLike | Position | Point | null | undefined} [place]
     *   Place in file where the message occurred.
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    message(reason, place, origin) {
      const message = new VFileMessage(reason, place, origin);
      if (this.path) {
        message.name = this.path + ":" + message.name;
        message.file = this.path;
      }
      message.fatal = false;
      this.messages.push(message);
      return message;
    }
    /**
     * Create an info message associated with the file.
     *
     * Its `fatal` is set to `null` and `file` is set to the current file path.
     * Its added to `file.messages`.
     *
     * @param {string | Error | VFileMessage} reason
     *   Reason for message, uses the stack and message of the error if given.
     * @param {Node | NodeLike | Position | Point | null | undefined} [place]
     *   Place in file where the message occurred.
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    info(reason, place, origin) {
      const message = this.message(reason, place, origin);
      message.fatal = null;
      return message;
    }
    /**
     * Create a fatal error associated with the file.
     *
     * Its `fatal` is set to `true` and `file` is set to the current file path.
     * Its added to `file.messages`.
     *
     * > 👉 **Note**: a fatal error means that a file is no longer processable.
     *
     * @param {string | Error | VFileMessage} reason
     *   Reason for message, uses the stack and message of the error if given.
     * @param {Node | NodeLike | Position | Point | null | undefined} [place]
     *   Place in file where the message occurred.
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {never}
     *   Message.
     * @throws {VFileMessage}
     *   Message.
     */
    fail(reason, place, origin) {
      const message = this.message(reason, place, origin);
      message.fatal = true;
      throw message;
    }
  }
  function assertPart(part, name) {
    if (part && part.includes(path$1.sep)) {
      throw new Error(
        "`" + name + "` cannot be a path: did not expect `" + path$1.sep + "`"
      );
    }
  }
  function assertNonEmpty(part, name) {
    if (!part) {
      throw new Error("`" + name + "` cannot be empty");
    }
  }
  function assertPath(path2, name) {
    if (!path2) {
      throw new Error("Setting `" + name + "` requires `path` to be set too");
    }
  }
  function buffer(value) {
    return isBuffer$1(value);
  }
  const unified = base$2().freeze();
  const own$6 = {}.hasOwnProperty;
  function base$2() {
    const transformers = trough();
    const attachers = [];
    let namespace = {};
    let frozen;
    let freezeIndex = -1;
    processor.data = data;
    processor.Parser = void 0;
    processor.Compiler = void 0;
    processor.freeze = freeze;
    processor.attachers = attachers;
    processor.use = use;
    processor.parse = parse2;
    processor.stringify = stringify2;
    processor.run = run2;
    processor.runSync = runSync;
    processor.process = process2;
    processor.processSync = processSync;
    return processor;
    function processor() {
      const destination = base$2();
      let index2 = -1;
      while (++index2 < attachers.length) {
        destination.use(...attachers[index2]);
      }
      destination.data(extend$1(true, {}, namespace));
      return destination;
    }
    function data(key2, value) {
      if (typeof key2 === "string") {
        if (arguments.length === 2) {
          assertUnfrozen("data", frozen);
          namespace[key2] = value;
          return processor;
        }
        return own$6.call(namespace, key2) && namespace[key2] || null;
      }
      if (key2) {
        assertUnfrozen("data", frozen);
        namespace = key2;
        return processor;
      }
      return namespace;
    }
    function freeze() {
      if (frozen) {
        return processor;
      }
      while (++freezeIndex < attachers.length) {
        const [attacher, ...options] = attachers[freezeIndex];
        if (options[0] === false) {
          continue;
        }
        if (options[0] === true) {
          options[0] = void 0;
        }
        const transformer = attacher.call(processor, ...options);
        if (typeof transformer === "function") {
          transformers.use(transformer);
        }
      }
      frozen = true;
      freezeIndex = Number.POSITIVE_INFINITY;
      return processor;
    }
    function use(value, ...options) {
      let settings;
      assertUnfrozen("use", frozen);
      if (value === null || value === void 0)
        ;
      else if (typeof value === "function") {
        addPlugin(value, ...options);
      } else if (typeof value === "object") {
        if (Array.isArray(value)) {
          addList(value);
        } else {
          addPreset(value);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value + "`");
      }
      if (settings) {
        namespace.settings = Object.assign(namespace.settings || {}, settings);
      }
      return processor;
      function add(value2) {
        if (typeof value2 === "function") {
          addPlugin(value2);
        } else if (typeof value2 === "object") {
          if (Array.isArray(value2)) {
            const [plugin, ...options2] = value2;
            addPlugin(plugin, ...options2);
          } else {
            addPreset(value2);
          }
        } else {
          throw new TypeError("Expected usable value, not `" + value2 + "`");
        }
      }
      function addPreset(result) {
        addList(result.plugins);
        if (result.settings) {
          settings = Object.assign(settings || {}, result.settings);
        }
      }
      function addList(plugins) {
        let index2 = -1;
        if (plugins === null || plugins === void 0)
          ;
        else if (Array.isArray(plugins)) {
          while (++index2 < plugins.length) {
            const thing = plugins[index2];
            add(thing);
          }
        } else {
          throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
        }
      }
      function addPlugin(plugin, value2) {
        let index2 = -1;
        let entry;
        while (++index2 < attachers.length) {
          if (attachers[index2][0] === plugin) {
            entry = attachers[index2];
            break;
          }
        }
        if (entry) {
          if (isPlainObject$1(entry[1]) && isPlainObject$1(value2)) {
            value2 = extend$1(true, entry[1], value2);
          }
          entry[1] = value2;
        } else {
          attachers.push([...arguments]);
        }
      }
    }
    function parse2(doc2) {
      processor.freeze();
      const file = vfile(doc2);
      const Parser2 = processor.Parser;
      assertParser("parse", Parser2);
      if (newable(Parser2, "parse")) {
        return new Parser2(String(file), file).parse();
      }
      return Parser2(String(file), file);
    }
    function stringify2(node2, doc2) {
      processor.freeze();
      const file = vfile(doc2);
      const Compiler = processor.Compiler;
      assertCompiler("stringify", Compiler);
      assertNode(node2);
      if (newable(Compiler, "compile")) {
        return new Compiler(node2, file).compile();
      }
      return Compiler(node2, file);
    }
    function run2(node2, doc2, callback) {
      assertNode(node2);
      processor.freeze();
      if (!callback && typeof doc2 === "function") {
        callback = doc2;
        doc2 = void 0;
      }
      if (!callback) {
        return new Promise(executor);
      }
      executor(null, callback);
      function executor(resolve2, reject) {
        transformers.run(node2, vfile(doc2), done);
        function done(error, tree, file) {
          tree = tree || node2;
          if (error) {
            reject(error);
          } else if (resolve2) {
            resolve2(tree);
          } else {
            callback(null, tree, file);
          }
        }
      }
    }
    function runSync(node2, file) {
      let result;
      let complete;
      processor.run(node2, file, done);
      assertDone("runSync", "run", complete);
      return result;
      function done(error, tree) {
        bail(error);
        result = tree;
        complete = true;
      }
    }
    function process2(doc2, callback) {
      processor.freeze();
      assertParser("process", processor.Parser);
      assertCompiler("process", processor.Compiler);
      if (!callback) {
        return new Promise(executor);
      }
      executor(null, callback);
      function executor(resolve2, reject) {
        const file = vfile(doc2);
        processor.run(processor.parse(file), file, (error, tree, file2) => {
          if (error || !tree || !file2) {
            done(error);
          } else {
            const result = processor.stringify(tree, file2);
            if (result === void 0 || result === null)
              ;
            else if (looksLikeAVFileValue(result)) {
              file2.value = result;
            } else {
              file2.result = result;
            }
            done(error, file2);
          }
        });
        function done(error, file2) {
          if (error || !file2) {
            reject(error);
          } else if (resolve2) {
            resolve2(file2);
          } else {
            callback(null, file2);
          }
        }
      }
    }
    function processSync(doc2) {
      let complete;
      processor.freeze();
      assertParser("processSync", processor.Parser);
      assertCompiler("processSync", processor.Compiler);
      const file = vfile(doc2);
      processor.process(file, done);
      assertDone("processSync", "process", complete);
      return file;
      function done(error) {
        complete = true;
        bail(error);
      }
    }
  }
  function newable(value, name) {
    return typeof value === "function" && // Prototypes do exist.
    // type-coverage:ignore-next-line
    value.prototype && // A function with keys in its prototype is probably a constructor.
    // Classes’ prototype methods are not enumerable, so we check if some value
    // exists in the prototype.
    // type-coverage:ignore-next-line
    (keys$2(value.prototype) || name in value.prototype);
  }
  function keys$2(value) {
    let key2;
    for (key2 in value) {
      if (own$6.call(value, key2)) {
        return true;
      }
    }
    return false;
  }
  function assertParser(name, value) {
    if (typeof value !== "function") {
      throw new TypeError("Cannot `" + name + "` without `Parser`");
    }
  }
  function assertCompiler(name, value) {
    if (typeof value !== "function") {
      throw new TypeError("Cannot `" + name + "` without `Compiler`");
    }
  }
  function assertUnfrozen(name, frozen) {
    if (frozen) {
      throw new Error(
        "Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
      );
    }
  }
  function assertNode(node2) {
    if (!isPlainObject$1(node2) || typeof node2.type !== "string") {
      throw new TypeError("Expected node, got `" + node2 + "`");
    }
  }
  function assertDone(name, asyncName, complete) {
    if (!complete) {
      throw new Error(
        "`" + name + "` finished async. Use `" + asyncName + "` instead"
      );
    }
  }
  function vfile(value) {
    return looksLikeAVFile(value) ? value : new VFile(value);
  }
  function looksLikeAVFile(value) {
    return Boolean(
      value && typeof value === "object" && "message" in value && "messages" in value
    );
  }
  function looksLikeAVFileValue(value) {
    return typeof value === "string" || isBuffer$1(value);
  }
  const lower16 = 65535;
  const factor16 = Math.pow(2, 16);
  function makeRecover(index2, offset) {
    return index2 + offset * factor16;
  }
  function recoverIndex(value) {
    return value & lower16;
  }
  function recoverOffset(value) {
    return (value - (value & lower16)) / factor16;
  }
  const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
  class MapResult {
    /**
    @internal
    */
    constructor(pos, delInfo, recover) {
      this.pos = pos;
      this.delInfo = delInfo;
      this.recover = recover;
    }
    /**
    Tells you whether the position was deleted, that is, whether the
    step removed the token on the side queried (via the `assoc`)
    argument from the document.
    */
    get deleted() {
      return (this.delInfo & DEL_SIDE) > 0;
    }
    /**
    Tells you whether the token before the mapped position was deleted.
    */
    get deletedBefore() {
      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
    }
    /**
    True when the token after the mapped position was deleted.
    */
    get deletedAfter() {
      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
    }
    /**
    Tells whether any of the steps mapped through deletes across the
    position (including both the token before and after the
    position).
    */
    get deletedAcross() {
      return (this.delInfo & DEL_ACROSS) > 0;
    }
  }
  class StepMap {
    /**
    Create a position map. The modifications to the document are
    represented as an array of numbers, in which each group of three
    represents a modified chunk as `[start, oldSize, newSize]`.
    */
    constructor(ranges, inverted = false) {
      this.ranges = ranges;
      this.inverted = inverted;
      if (!ranges.length && StepMap.empty)
        return StepMap.empty;
    }
    /**
    @internal
    */
    recover(value) {
      let diff = 0, index2 = recoverIndex(value);
      if (!this.inverted)
        for (let i2 = 0; i2 < index2; i2++)
          diff += this.ranges[i2 * 3 + 2] - this.ranges[i2 * 3 + 1];
      return this.ranges[index2 * 3] + diff + recoverOffset(value);
    }
    mapResult(pos, assoc = 1) {
      return this._map(pos, assoc, false);
    }
    map(pos, assoc = 1) {
      return this._map(pos, assoc, true);
    }
    /**
    @internal
    */
    _map(pos, assoc, simple) {
      let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i2 = 0; i2 < this.ranges.length; i2 += 3) {
        let start = this.ranges[i2] - (this.inverted ? diff : 0);
        if (start > pos)
          break;
        let oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex], end = start + oldSize;
        if (pos <= end) {
          let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
          let result = start + diff + (side < 0 ? 0 : newSize);
          if (simple)
            return result;
          let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i2 / 3, pos - start);
          let del2 = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
          if (assoc < 0 ? pos != start : pos != end)
            del2 |= DEL_SIDE;
          return new MapResult(result, del2, recover);
        }
        diff += newSize - oldSize;
      }
      return simple ? pos + diff : new MapResult(pos + diff, 0, null);
    }
    /**
    @internal
    */
    touches(pos, recover) {
      let diff = 0, index2 = recoverIndex(recover);
      let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i2 = 0; i2 < this.ranges.length; i2 += 3) {
        let start = this.ranges[i2] - (this.inverted ? diff : 0);
        if (start > pos)
          break;
        let oldSize = this.ranges[i2 + oldIndex], end = start + oldSize;
        if (pos <= end && i2 == index2 * 3)
          return true;
        diff += this.ranges[i2 + newIndex] - oldSize;
      }
      return false;
    }
    /**
    Calls the given function on each of the changed ranges included in
    this map.
    */
    forEach(f) {
      let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i2 = 0, diff = 0; i2 < this.ranges.length; i2 += 3) {
        let start = this.ranges[i2], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
        let oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex];
        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
        diff += newSize - oldSize;
      }
    }
    /**
    Create an inverted version of this map. The result can be used to
    map positions in the post-step document to the pre-step document.
    */
    invert() {
      return new StepMap(this.ranges, !this.inverted);
    }
    /**
    @internal
    */
    toString() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    }
    /**
    Create a map that moves all positions by offset `n` (which may be
    negative). This can be useful when applying steps meant for a
    sub-document to a larger document, or vice-versa.
    */
    static offset(n) {
      return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
    }
  }
  StepMap.empty = new StepMap([]);
  class Mapping {
    /**
    Create a new mapping with the given position maps.
    */
    constructor(maps = [], mirror, from2 = 0, to = maps.length) {
      this.maps = maps;
      this.mirror = mirror;
      this.from = from2;
      this.to = to;
    }
    /**
    Create a mapping that maps only through a part of this one.
    */
    slice(from2 = 0, to = this.maps.length) {
      return new Mapping(this.maps, this.mirror, from2, to);
    }
    /**
    @internal
    */
    copy() {
      return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
    }
    /**
    Add a step map to the end of this mapping. If `mirrors` is
    given, it should be the index of the step map that is the mirror
    image of this one.
    */
    appendMap(map2, mirrors) {
      this.to = this.maps.push(map2);
      if (mirrors != null)
        this.setMirror(this.maps.length - 1, mirrors);
    }
    /**
    Add all the step maps in a given mapping to this one (preserving
    mirroring information).
    */
    appendMapping(mapping) {
      for (let i2 = 0, startSize = this.maps.length; i2 < mapping.maps.length; i2++) {
        let mirr = mapping.getMirror(i2);
        this.appendMap(mapping.maps[i2], mirr != null && mirr < i2 ? startSize + mirr : void 0);
      }
    }
    /**
    Finds the offset of the step map that mirrors the map at the
    given offset, in this mapping (as per the second argument to
    `appendMap`).
    */
    getMirror(n) {
      if (this.mirror) {
        for (let i2 = 0; i2 < this.mirror.length; i2++)
          if (this.mirror[i2] == n)
            return this.mirror[i2 + (i2 % 2 ? -1 : 1)];
      }
    }
    /**
    @internal
    */
    setMirror(n, m) {
      if (!this.mirror)
        this.mirror = [];
      this.mirror.push(n, m);
    }
    /**
    Append the inverse of the given mapping to this one.
    */
    appendMappingInverted(mapping) {
      for (let i2 = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i2 >= 0; i2--) {
        let mirr = mapping.getMirror(i2);
        this.appendMap(mapping.maps[i2].invert(), mirr != null && mirr > i2 ? totalSize - mirr - 1 : void 0);
      }
    }
    /**
    Create an inverted version of this mapping.
    */
    invert() {
      let inverse = new Mapping();
      inverse.appendMappingInverted(this);
      return inverse;
    }
    /**
    Map a position through this mapping.
    */
    map(pos, assoc = 1) {
      if (this.mirror)
        return this._map(pos, assoc, true);
      for (let i2 = this.from; i2 < this.to; i2++)
        pos = this.maps[i2].map(pos, assoc);
      return pos;
    }
    /**
    Map a position through this mapping, returning a mapping
    result.
    */
    mapResult(pos, assoc = 1) {
      return this._map(pos, assoc, false);
    }
    /**
    @internal
    */
    _map(pos, assoc, simple) {
      let delInfo = 0;
      for (let i2 = this.from; i2 < this.to; i2++) {
        let map2 = this.maps[i2], result = map2.mapResult(pos, assoc);
        if (result.recover != null) {
          let corr = this.getMirror(i2);
          if (corr != null && corr > i2 && corr < this.to) {
            i2 = corr;
            pos = this.maps[corr].recover(result.recover);
            continue;
          }
        }
        delInfo |= result.delInfo;
        pos = result.pos;
      }
      return simple ? pos : new MapResult(pos, delInfo, null);
    }
  }
  const stepsByID = /* @__PURE__ */ Object.create(null);
  class Step {
    /**
    Get the step map that represents the changes made by this step,
    and which can be used to transform between positions in the old
    and the new document.
    */
    getMap() {
      return StepMap.empty;
    }
    /**
    Try to merge this step with another one, to be applied directly
    after it. Returns the merged step when possible, null if the
    steps can't be merged.
    */
    merge(other) {
      return null;
    }
    /**
    Deserialize a step from its JSON representation. Will call
    through to the step class' own implementation of this method.
    */
    static fromJSON(schema, json) {
      if (!json || !json.stepType)
        throw new RangeError("Invalid input for Step.fromJSON");
      let type = stepsByID[json.stepType];
      if (!type)
        throw new RangeError(`No step type ${json.stepType} defined`);
      return type.fromJSON(schema, json);
    }
    /**
    To be able to serialize steps to JSON, each step needs a string
    ID to attach to its JSON representation. Use this method to
    register an ID for your step classes. Try to pick something
    that's unlikely to clash with steps from other modules.
    */
    static jsonID(id, stepClass) {
      if (id in stepsByID)
        throw new RangeError("Duplicate use of step JSON ID " + id);
      stepsByID[id] = stepClass;
      stepClass.prototype.jsonID = id;
      return stepClass;
    }
  }
  class StepResult {
    /**
    @internal
    */
    constructor(doc2, failed) {
      this.doc = doc2;
      this.failed = failed;
    }
    /**
    Create a successful step result.
    */
    static ok(doc2) {
      return new StepResult(doc2, null);
    }
    /**
    Create a failed step result.
    */
    static fail(message) {
      return new StepResult(null, message);
    }
    /**
    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
    arguments. Create a successful result if it succeeds, and a
    failed one if it throws a `ReplaceError`.
    */
    static fromReplace(doc2, from2, to, slice) {
      try {
        return StepResult.ok(doc2.replace(from2, to, slice));
      } catch (e) {
        if (e instanceof ReplaceError)
          return StepResult.fail(e.message);
        throw e;
      }
    }
  }
  function mapFragment(fragment, f, parent) {
    let mapped = [];
    for (let i2 = 0; i2 < fragment.childCount; i2++) {
      let child = fragment.child(i2);
      if (child.content.size)
        child = child.copy(mapFragment(child.content, f, child));
      if (child.isInline)
        child = f(child, parent, i2);
      mapped.push(child);
    }
    return Fragment.fromArray(mapped);
  }
  class AddMarkStep extends Step {
    /**
    Create a mark step.
    */
    constructor(from2, to, mark2) {
      super();
      this.from = from2;
      this.to = to;
      this.mark = mark2;
    }
    apply(doc2) {
      let oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
      let parent = $from.node($from.sharedDepth(this.to));
      let slice = new Slice(mapFragment(oldSlice.content, (node2, parent2) => {
        if (!node2.isAtom || !parent2.type.allowsMarkType(this.mark.type))
          return node2;
        return node2.mark(this.mark.addToSet(node2.marks));
      }, parent), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc2, this.from, this.to, slice);
    }
    invert() {
      return new RemoveMarkStep(this.from, this.to, this.mark);
    }
    map(mapping) {
      let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from2.deleted && to.deleted || from2.pos >= to.pos)
        return null;
      return new AddMarkStep(from2.pos, to.pos, this.mark);
    }
    merge(other) {
      if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
        return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
    toJSON() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  }
  Step.jsonID("addMark", AddMarkStep);
  class RemoveMarkStep extends Step {
    /**
    Create a mark-removing step.
    */
    constructor(from2, to, mark2) {
      super();
      this.from = from2;
      this.to = to;
      this.mark = mark2;
    }
    apply(doc2) {
      let oldSlice = doc2.slice(this.from, this.to);
      let slice = new Slice(mapFragment(oldSlice.content, (node2) => {
        return node2.mark(this.mark.removeFromSet(node2.marks));
      }, doc2), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc2, this.from, this.to, slice);
    }
    invert() {
      return new AddMarkStep(this.from, this.to, this.mark);
    }
    map(mapping) {
      let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from2.deleted && to.deleted || from2.pos >= to.pos)
        return null;
      return new RemoveMarkStep(from2.pos, to.pos, this.mark);
    }
    merge(other) {
      if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
        return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
    toJSON() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  }
  Step.jsonID("removeMark", RemoveMarkStep);
  class AddNodeMarkStep extends Step {
    /**
    Create a node mark step.
    */
    constructor(pos, mark2) {
      super();
      this.pos = pos;
      this.mark = mark2;
    }
    apply(doc2) {
      let node2 = doc2.nodeAt(this.pos);
      if (!node2)
        return StepResult.fail("No node at mark step's position");
      let updated = node2.type.create(node2.attrs, null, this.mark.addToSet(node2.marks));
      return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node2.isLeaf ? 0 : 1));
    }
    invert(doc2) {
      let node2 = doc2.nodeAt(this.pos);
      if (node2) {
        let newSet = this.mark.addToSet(node2.marks);
        if (newSet.length == node2.marks.length) {
          for (let i2 = 0; i2 < node2.marks.length; i2++)
            if (!node2.marks[i2].isInSet(newSet))
              return new AddNodeMarkStep(this.pos, node2.marks[i2]);
          return new AddNodeMarkStep(this.pos, this.mark);
        }
      }
      return new RemoveNodeMarkStep(this.pos, this.mark);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);
    }
    toJSON() {
      return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
      return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    }
  }
  Step.jsonID("addNodeMark", AddNodeMarkStep);
  class RemoveNodeMarkStep extends Step {
    /**
    Create a mark-removing step.
    */
    constructor(pos, mark2) {
      super();
      this.pos = pos;
      this.mark = mark2;
    }
    apply(doc2) {
      let node2 = doc2.nodeAt(this.pos);
      if (!node2)
        return StepResult.fail("No node at mark step's position");
      let updated = node2.type.create(node2.attrs, null, this.mark.removeFromSet(node2.marks));
      return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node2.isLeaf ? 0 : 1));
    }
    invert(doc2) {
      let node2 = doc2.nodeAt(this.pos);
      if (!node2 || !this.mark.isInSet(node2.marks))
        return this;
      return new AddNodeMarkStep(this.pos, this.mark);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);
    }
    toJSON() {
      return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
      return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    }
  }
  Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
  class ReplaceStep extends Step {
    /**
    The given `slice` should fit the 'gap' between `from` and
    `to`—the depths must line up, and the surrounding nodes must be
    able to be joined with the open sides of the slice. When
    `structure` is true, the step will fail if the content between
    from and to is not just a sequence of closing and then opening
    tokens (this is to guard against rebased replace steps
    overwriting something they weren't supposed to).
    */
    constructor(from2, to, slice, structure = false) {
      super();
      this.from = from2;
      this.to = to;
      this.slice = slice;
      this.structure = structure;
    }
    apply(doc2) {
      if (this.structure && contentBetween(doc2, this.from, this.to))
        return StepResult.fail("Structure replace would overwrite content");
      return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
    }
    getMap() {
      return new StepMap([this.from, this.to - this.from, this.slice.size]);
    }
    invert(doc2) {
      return new ReplaceStep(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
    }
    map(mapping) {
      let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from2.deletedAcross && to.deletedAcross)
        return null;
      return new ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice);
    }
    merge(other) {
      if (!(other instanceof ReplaceStep) || other.structure || this.structure)
        return null;
      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
        let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
        return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);
      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
        let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
        return new ReplaceStep(other.from, this.to, slice, this.structure);
      } else {
        return null;
      }
    }
    toJSON() {
      let json = { stepType: "replace", from: this.from, to: this.to };
      if (this.slice.size)
        json.slice = this.slice.toJSON();
      if (this.structure)
        json.structure = true;
      return json;
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
    }
  }
  Step.jsonID("replace", ReplaceStep);
  class ReplaceAroundStep extends Step {
    /**
    Create a replace-around step with the given range and gap.
    `insert` should be the point in the slice into which the content
    of the gap should be moved. `structure` has the same meaning as
    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
    */
    constructor(from2, to, gapFrom, gapTo, slice, insert, structure = false) {
      super();
      this.from = from2;
      this.to = to;
      this.gapFrom = gapFrom;
      this.gapTo = gapTo;
      this.slice = slice;
      this.insert = insert;
      this.structure = structure;
    }
    apply(doc2) {
      if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to)))
        return StepResult.fail("Structure gap-replace would overwrite content");
      let gap = doc2.slice(this.gapFrom, this.gapTo);
      if (gap.openStart || gap.openEnd)
        return StepResult.fail("Gap is not a flat range");
      let inserted = this.slice.insertAt(this.insert, gap.content);
      if (!inserted)
        return StepResult.fail("Content does not fit in gap");
      return StepResult.fromReplace(doc2, this.from, this.to, inserted);
    }
    getMap() {
      return new StepMap([
        this.from,
        this.gapFrom - this.from,
        this.insert,
        this.gapTo,
        this.to - this.gapTo,
        this.slice.size - this.insert
      ]);
    }
    invert(doc2) {
      let gap = this.gapTo - this.gapFrom;
      return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    }
    map(mapping) {
      let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
      if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
        return null;
      return new ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
    }
    toJSON() {
      let json = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert
      };
      if (this.slice.size)
        json.slice = this.slice.toJSON();
      if (this.structure)
        json.structure = true;
      return json;
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
        throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
    }
  }
  Step.jsonID("replaceAround", ReplaceAroundStep);
  function contentBetween(doc2, from2, to) {
    let $from = doc2.resolve(from2), dist = to - from2, depth = $from.depth;
    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
      depth--;
      dist--;
    }
    if (dist > 0) {
      let next = $from.node(depth).maybeChild($from.indexAfter(depth));
      while (dist > 0) {
        if (!next || next.isLeaf)
          return true;
        next = next.firstChild;
        dist--;
      }
    }
    return false;
  }
  function addMark(tr2, from2, to, mark2) {
    let removed = [], added = [];
    let removing, adding;
    tr2.doc.nodesBetween(from2, to, (node2, pos, parent) => {
      if (!node2.isInline)
        return;
      let marks = node2.marks;
      if (!mark2.isInSet(marks) && parent.type.allowsMarkType(mark2.type)) {
        let start = Math.max(pos, from2), end = Math.min(pos + node2.nodeSize, to);
        let newSet = mark2.addToSet(marks);
        for (let i2 = 0; i2 < marks.length; i2++) {
          if (!marks[i2].isInSet(newSet)) {
            if (removing && removing.to == start && removing.mark.eq(marks[i2]))
              removing.to = end;
            else
              removed.push(removing = new RemoveMarkStep(start, end, marks[i2]));
          }
        }
        if (adding && adding.to == start)
          adding.to = end;
        else
          added.push(adding = new AddMarkStep(start, end, mark2));
      }
    });
    removed.forEach((s2) => tr2.step(s2));
    added.forEach((s2) => tr2.step(s2));
  }
  function removeMark(tr2, from2, to, mark2) {
    let matched = [], step = 0;
    tr2.doc.nodesBetween(from2, to, (node2, pos) => {
      if (!node2.isInline)
        return;
      step++;
      let toRemove = null;
      if (mark2 instanceof MarkType) {
        let set = node2.marks, found2;
        while (found2 = mark2.isInSet(set)) {
          (toRemove || (toRemove = [])).push(found2);
          set = found2.removeFromSet(set);
        }
      } else if (mark2) {
        if (mark2.isInSet(node2.marks))
          toRemove = [mark2];
      } else {
        toRemove = node2.marks;
      }
      if (toRemove && toRemove.length) {
        let end = Math.min(pos + node2.nodeSize, to);
        for (let i2 = 0; i2 < toRemove.length; i2++) {
          let style2 = toRemove[i2], found2;
          for (let j = 0; j < matched.length; j++) {
            let m = matched[j];
            if (m.step == step - 1 && style2.eq(matched[j].style))
              found2 = m;
          }
          if (found2) {
            found2.to = end;
            found2.step = step;
          } else {
            matched.push({ style: style2, from: Math.max(pos, from2), to: end, step });
          }
        }
      }
    });
    matched.forEach((m) => tr2.step(new RemoveMarkStep(m.from, m.to, m.style)));
  }
  function clearIncompatible(tr2, pos, parentType, match = parentType.contentMatch) {
    let node2 = tr2.doc.nodeAt(pos);
    let replSteps = [], cur = pos + 1;
    for (let i2 = 0; i2 < node2.childCount; i2++) {
      let child = node2.child(i2), end = cur + child.nodeSize;
      let allowed = match.matchType(child.type);
      if (!allowed) {
        replSteps.push(new ReplaceStep(cur, end, Slice.empty));
      } else {
        match = allowed;
        for (let j = 0; j < child.marks.length; j++)
          if (!parentType.allowsMarkType(child.marks[j].type))
            tr2.step(new RemoveMarkStep(cur, end, child.marks[j]));
        if (child.isText && !parentType.spec.code) {
          let m, newline = /\r?\n|\r/g, slice;
          while (m = newline.exec(child.text)) {
            if (!slice)
              slice = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
            replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice));
          }
        }
      }
      cur = end;
    }
    if (!match.validEnd) {
      let fill = match.fillBefore(Fragment.empty, true);
      tr2.replace(cur, cur, new Slice(fill, 0, 0));
    }
    for (let i2 = replSteps.length - 1; i2 >= 0; i2--)
      tr2.step(replSteps[i2]);
  }
  function canCut(node2, start, end) {
    return (start == 0 || node2.canReplace(start, node2.childCount)) && (end == node2.childCount || node2.canReplace(0, end));
  }
  function liftTarget(range) {
    let parent = range.parent;
    let content2 = parent.content.cutByIndex(range.startIndex, range.endIndex);
    for (let depth = range.depth; ; --depth) {
      let node2 = range.$from.node(depth);
      let index2 = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
      if (depth < range.depth && node2.canReplace(index2, endIndex, content2))
        return depth;
      if (depth == 0 || node2.type.spec.isolating || !canCut(node2, index2, endIndex))
        break;
    }
    return null;
  }
  function lift$2(tr2, range, target) {
    let { $from, $to, depth } = range;
    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
    let start = gapStart, end = gapEnd;
    let before = Fragment.empty, openStart = 0;
    for (let d = depth, splitting = false; d > target; d--)
      if (splitting || $from.index(d) > 0) {
        splitting = true;
        before = Fragment.from($from.node(d).copy(before));
        openStart++;
      } else {
        start--;
      }
    let after = Fragment.empty, openEnd = 0;
    for (let d = depth, splitting = false; d > target; d--)
      if (splitting || $to.after(d + 1) < $to.end(d)) {
        splitting = true;
        after = Fragment.from($to.node(d).copy(after));
        openEnd++;
      } else {
        end++;
      }
    tr2.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
  }
  function findWrapping(range, nodeType, attrs = null, innerRange = range) {
    let around = findWrappingOutside(range, nodeType);
    let inner = around && findWrappingInside(innerRange, nodeType);
    if (!inner)
      return null;
    return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
  }
  function withAttrs(type) {
    return { type, attrs: null };
  }
  function findWrappingOutside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let around = parent.contentMatchAt(startIndex).findWrapping(type);
    if (!around)
      return null;
    let outer = around.length ? around[0] : type;
    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
  }
  function findWrappingInside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let inner = parent.child(startIndex);
    let inside = type.contentMatch.findWrapping(inner.type);
    if (!inside)
      return null;
    let lastType = inside.length ? inside[inside.length - 1] : type;
    let innerMatch = lastType.contentMatch;
    for (let i2 = startIndex; innerMatch && i2 < endIndex; i2++)
      innerMatch = innerMatch.matchType(parent.child(i2).type);
    if (!innerMatch || !innerMatch.validEnd)
      return null;
    return inside;
  }
  function wrap$2(tr2, range, wrappers) {
    let content2 = Fragment.empty;
    for (let i2 = wrappers.length - 1; i2 >= 0; i2--) {
      if (content2.size) {
        let match = wrappers[i2].type.contentMatch.matchFragment(content2);
        if (!match || !match.validEnd)
          throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
      }
      content2 = Fragment.from(wrappers[i2].type.create(wrappers[i2].attrs, content2));
    }
    let start = range.start, end = range.end;
    tr2.step(new ReplaceAroundStep(start, end, start, end, new Slice(content2, 0, 0), wrappers.length, true));
  }
  function setBlockType$1(tr2, from2, to, type, attrs) {
    if (!type.isTextblock)
      throw new RangeError("Type given to setBlockType should be a textblock");
    let mapFrom = tr2.steps.length;
    tr2.doc.nodesBetween(from2, to, (node2, pos) => {
      if (node2.isTextblock && !node2.hasMarkup(type, attrs) && canChangeType(tr2.doc, tr2.mapping.slice(mapFrom).map(pos), type)) {
        tr2.clearIncompatible(tr2.mapping.slice(mapFrom).map(pos, 1), type);
        let mapping = tr2.mapping.slice(mapFrom);
        let startM = mapping.map(pos, 1), endM = mapping.map(pos + node2.nodeSize, 1);
        tr2.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node2.marks)), 0, 0), 1, true));
        return false;
      }
    });
  }
  function canChangeType(doc2, pos, type) {
    let $pos = doc2.resolve(pos), index2 = $pos.index();
    return $pos.parent.canReplaceWith(index2, index2 + 1, type);
  }
  function setNodeMarkup(tr2, pos, type, attrs, marks) {
    let node2 = tr2.doc.nodeAt(pos);
    if (!node2)
      throw new RangeError("No node at given position");
    if (!type)
      type = node2.type;
    let newNode = type.create(attrs, null, marks || node2.marks);
    if (node2.isLeaf)
      return tr2.replaceWith(pos, pos + node2.nodeSize, newNode);
    if (!type.validContent(node2.content))
      throw new RangeError("Invalid content for node type " + type.name);
    tr2.step(new ReplaceAroundStep(pos, pos + node2.nodeSize, pos + 1, pos + node2.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
  }
  function canSplit(doc2, pos, depth = 1, typesAfter) {
    let $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
    let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
    if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
      return false;
    for (let d = $pos.depth - 1, i2 = depth - 2; d > base2; d--, i2--) {
      let node2 = $pos.node(d), index3 = $pos.index(d);
      if (node2.type.spec.isolating)
        return false;
      let rest = node2.content.cutByIndex(index3, node2.childCount);
      let overrideChild = typesAfter && typesAfter[i2 + 1];
      if (overrideChild)
        rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
      let after = typesAfter && typesAfter[i2] || node2;
      if (!node2.canReplace(index3 + 1, node2.childCount) || !after.type.validContent(rest))
        return false;
    }
    let index2 = $pos.indexAfter(base2);
    let baseType = typesAfter && typesAfter[0];
    return $pos.node(base2).canReplaceWith(index2, index2, baseType ? baseType.type : $pos.node(base2 + 1).type);
  }
  function split$1(tr2, pos, depth = 1, typesAfter) {
    let $pos = tr2.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
    for (let d = $pos.depth, e = $pos.depth - depth, i2 = depth - 1; d > e; d--, i2--) {
      before = Fragment.from($pos.node(d).copy(before));
      let typeAfter = typesAfter && typesAfter[i2];
      after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
    }
    tr2.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
  }
  function canJoin(doc2, pos) {
    let $pos = doc2.resolve(pos), index2 = $pos.index();
    return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index2, index2 + 1);
  }
  function joinable(a2, b) {
    return !!(a2 && b && !a2.isLeaf && a2.canAppend(b));
  }
  function joinPoint(doc2, pos, dir = -1) {
    let $pos = doc2.resolve(pos);
    for (let d = $pos.depth; ; d--) {
      let before, after, index2 = $pos.index(d);
      if (d == $pos.depth) {
        before = $pos.nodeBefore;
        after = $pos.nodeAfter;
      } else if (dir > 0) {
        before = $pos.node(d + 1);
        index2++;
        after = $pos.node(d).maybeChild(index2);
      } else {
        before = $pos.node(d).maybeChild(index2 - 1);
        after = $pos.node(d + 1);
      }
      if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index2, index2 + 1))
        return pos;
      if (d == 0)
        break;
      pos = dir < 0 ? $pos.before(d) : $pos.after(d);
    }
  }
  function join$1(tr2, pos, depth) {
    let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
    tr2.step(step);
  }
  function insertPoint(doc2, pos, nodeType) {
    let $pos = doc2.resolve(pos);
    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
      return pos;
    if ($pos.parentOffset == 0)
      for (let d = $pos.depth - 1; d >= 0; d--) {
        let index2 = $pos.index(d);
        if ($pos.node(d).canReplaceWith(index2, index2, nodeType))
          return $pos.before(d + 1);
        if (index2 > 0)
          return null;
      }
    if ($pos.parentOffset == $pos.parent.content.size)
      for (let d = $pos.depth - 1; d >= 0; d--) {
        let index2 = $pos.indexAfter(d);
        if ($pos.node(d).canReplaceWith(index2, index2, nodeType))
          return $pos.after(d + 1);
        if (index2 < $pos.node(d).childCount)
          return null;
      }
    return null;
  }
  function dropPoint(doc2, pos, slice) {
    let $pos = doc2.resolve(pos);
    if (!slice.content.size)
      return pos;
    let content2 = slice.content;
    for (let i2 = 0; i2 < slice.openStart; i2++)
      content2 = content2.firstChild.content;
    for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
      for (let d = $pos.depth; d >= 0; d--) {
        let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
        let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
        let parent = $pos.node(d), fits = false;
        if (pass == 1) {
          fits = parent.canReplace(insertPos, insertPos, content2);
        } else {
          let wrapping = parent.contentMatchAt(insertPos).findWrapping(content2.firstChild.type);
          fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
        }
        if (fits)
          return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
      }
    }
    return null;
  }
  function replaceStep(doc2, from2, to = from2, slice = Slice.empty) {
    if (from2 == to && !slice.size)
      return null;
    let $from = doc2.resolve(from2), $to = doc2.resolve(to);
    if (fitsTrivially($from, $to, slice))
      return new ReplaceStep(from2, to, slice);
    return new Fitter($from, $to, slice).fit();
  }
  function fitsTrivially($from, $to, slice) {
    return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);
  }
  class Fitter {
    constructor($from, $to, unplaced) {
      this.$from = $from;
      this.$to = $to;
      this.unplaced = unplaced;
      this.frontier = [];
      this.placed = Fragment.empty;
      for (let i2 = 0; i2 <= $from.depth; i2++) {
        let node2 = $from.node(i2);
        this.frontier.push({
          type: node2.type,
          match: node2.contentMatchAt($from.indexAfter(i2))
        });
      }
      for (let i2 = $from.depth; i2 > 0; i2--)
        this.placed = Fragment.from($from.node(i2).copy(this.placed));
    }
    get depth() {
      return this.frontier.length - 1;
    }
    fit() {
      while (this.unplaced.size) {
        let fit = this.findFittable();
        if (fit)
          this.placeNodes(fit);
        else
          this.openMore() || this.dropNode();
      }
      let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
      let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
      if (!$to)
        return null;
      let content2 = this.placed, openStart = $from.depth, openEnd = $to.depth;
      while (openStart && openEnd && content2.childCount == 1) {
        content2 = content2.firstChild.content;
        openStart--;
        openEnd--;
      }
      let slice = new Slice(content2, openStart, openEnd);
      if (moveInline > -1)
        return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);
      if (slice.size || $from.pos != this.$to.pos)
        return new ReplaceStep($from.pos, $to.pos, slice);
      return null;
    }
    // Find a position on the start spine of `this.unplaced` that has
    // content that can be moved somewhere on the frontier. Returns two
    // depths, one for the slice and one for the frontier.
    findFittable() {
      let startDepth = this.unplaced.openStart;
      for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
        let node2 = cur.firstChild;
        if (cur.childCount > 1)
          openEnd = 0;
        if (node2.type.spec.isolating && openEnd <= d) {
          startDepth = d;
          break;
        }
        cur = node2.content;
      }
      for (let pass = 1; pass <= 2; pass++) {
        for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
          let fragment, parent = null;
          if (sliceDepth) {
            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
            fragment = parent.content;
          } else {
            fragment = this.unplaced.content;
          }
          let first2 = fragment.firstChild;
          for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
            let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
            if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
              return { sliceDepth, frontierDepth, parent, inject };
            else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
              return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
            if (parent && match.matchType(parent.type))
              break;
          }
        }
      }
    }
    openMore() {
      let { content: content2, openStart, openEnd } = this.unplaced;
      let inner = contentAt(content2, openStart);
      if (!inner.childCount || inner.firstChild.isLeaf)
        return false;
      this.unplaced = new Slice(content2, openStart + 1, Math.max(openEnd, inner.size + openStart >= content2.size - openEnd ? openStart + 1 : 0));
      return true;
    }
    dropNode() {
      let { content: content2, openStart, openEnd } = this.unplaced;
      let inner = contentAt(content2, openStart);
      if (inner.childCount <= 1 && openStart > 0) {
        let openAtEnd = content2.size - openStart <= openStart + inner.size;
        this.unplaced = new Slice(dropFromFragment(content2, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
      } else {
        this.unplaced = new Slice(dropFromFragment(content2, openStart, 1), openStart, openEnd);
      }
    }
    // Move content from the unplaced slice at `sliceDepth` to the
    // frontier node at `frontierDepth`. Close that frontier node when
    // applicable.
    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
      while (this.depth > frontierDepth)
        this.closeFrontierNode();
      if (wrap2)
        for (let i2 = 0; i2 < wrap2.length; i2++)
          this.openFrontierNode(wrap2[i2]);
      let slice = this.unplaced, fragment = parent ? parent.content : slice.content;
      let openStart = slice.openStart - sliceDepth;
      let taken = 0, add = [];
      let { match, type } = this.frontier[frontierDepth];
      if (inject) {
        for (let i2 = 0; i2 < inject.childCount; i2++)
          add.push(inject.child(i2));
        match = match.matchFragment(inject);
      }
      let openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);
      while (taken < fragment.childCount) {
        let next = fragment.child(taken), matches2 = match.matchType(next.type);
        if (!matches2)
          break;
        taken++;
        if (taken > 1 || openStart == 0 || next.content.size) {
          match = matches2;
          add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
        }
      }
      let toEnd = taken == fragment.childCount;
      if (!toEnd)
        openEndCount = -1;
      this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
      this.frontier[frontierDepth].match = match;
      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
        this.closeFrontierNode();
      for (let i2 = 0, cur = fragment; i2 < openEndCount; i2++) {
        let node2 = cur.lastChild;
        this.frontier.push({ type: node2.type, match: node2.contentMatchAt(node2.childCount) });
        cur = node2.content;
      }
      this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
    }
    mustMoveInline() {
      if (!this.$to.parent.isTextblock)
        return -1;
      let top = this.frontier[this.depth], level;
      if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
        return -1;
      let { depth } = this.$to, after = this.$to.after(depth);
      while (depth > 1 && after == this.$to.end(--depth))
        ++after;
      return after;
    }
    findCloseLevel($to) {
      scan:
        for (let i2 = Math.min(this.depth, $to.depth); i2 >= 0; i2--) {
          let { match, type } = this.frontier[i2];
          let dropInner = i2 < $to.depth && $to.end(i2 + 1) == $to.pos + ($to.depth - (i2 + 1));
          let fit = contentAfterFits($to, i2, type, match, dropInner);
          if (!fit)
            continue;
          for (let d = i2 - 1; d >= 0; d--) {
            let { match: match2, type: type2 } = this.frontier[d];
            let matches2 = contentAfterFits($to, d, type2, match2, true);
            if (!matches2 || matches2.childCount)
              continue scan;
          }
          return { depth: i2, fit, move: dropInner ? $to.doc.resolve($to.after(i2 + 1)) : $to };
        }
    }
    close($to) {
      let close2 = this.findCloseLevel($to);
      if (!close2)
        return null;
      while (this.depth > close2.depth)
        this.closeFrontierNode();
      if (close2.fit.childCount)
        this.placed = addToFragment(this.placed, close2.depth, close2.fit);
      $to = close2.move;
      for (let d = close2.depth + 1; d <= $to.depth; d++) {
        let node2 = $to.node(d), add = node2.type.contentMatch.fillBefore(node2.content, true, $to.index(d));
        this.openFrontierNode(node2.type, node2.attrs, add);
      }
      return $to;
    }
    openFrontierNode(type, attrs = null, content2) {
      let top = this.frontier[this.depth];
      top.match = top.match.matchType(type);
      this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content2)));
      this.frontier.push({ type, match: type.contentMatch });
    }
    closeFrontierNode() {
      let open = this.frontier.pop();
      let add = open.match.fillBefore(Fragment.empty, true);
      if (add.childCount)
        this.placed = addToFragment(this.placed, this.frontier.length, add);
    }
  }
  function dropFromFragment(fragment, depth, count) {
    if (depth == 0)
      return fragment.cutByIndex(count, fragment.childCount);
    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
  }
  function addToFragment(fragment, depth, content2) {
    if (depth == 0)
      return fragment.append(content2);
    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content2)));
  }
  function contentAt(fragment, depth) {
    for (let i2 = 0; i2 < depth; i2++)
      fragment = fragment.firstChild.content;
    return fragment;
  }
  function closeNodeStart(node2, openStart, openEnd) {
    if (openStart <= 0)
      return node2;
    let frag = node2.content;
    if (openStart > 1)
      frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
    if (openStart > 0) {
      frag = node2.type.contentMatch.fillBefore(frag).append(frag);
      if (openEnd <= 0)
        frag = frag.append(node2.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
    }
    return node2.copy(frag);
  }
  function contentAfterFits($to, depth, type, match, open) {
    let node2 = $to.node(depth), index2 = open ? $to.indexAfter(depth) : $to.index(depth);
    if (index2 == node2.childCount && !type.compatibleContent(node2.type))
      return null;
    let fit = match.fillBefore(node2.content, true, index2);
    return fit && !invalidMarks(type, node2.content, index2) ? fit : null;
  }
  function invalidMarks(type, fragment, start) {
    for (let i2 = start; i2 < fragment.childCount; i2++)
      if (!type.allowsMarks(fragment.child(i2).marks))
        return true;
    return false;
  }
  function definesContent(type) {
    return type.spec.defining || type.spec.definingForContent;
  }
  function replaceRange(tr2, from2, to, slice) {
    if (!slice.size)
      return tr2.deleteRange(from2, to);
    let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
    if (fitsTrivially($from, $to, slice))
      return tr2.step(new ReplaceStep(from2, to, slice));
    let targetDepths = coveredDepths($from, tr2.doc.resolve(to));
    if (targetDepths[targetDepths.length - 1] == 0)
      targetDepths.pop();
    let preferredTarget = -($from.depth + 1);
    targetDepths.unshift(preferredTarget);
    for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
      let spec = $from.node(d).type.spec;
      if (spec.defining || spec.definingAsContext || spec.isolating)
        break;
      if (targetDepths.indexOf(d) > -1)
        preferredTarget = d;
      else if ($from.before(d) == pos)
        targetDepths.splice(1, 0, -d);
    }
    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
    let leftNodes = [], preferredDepth = slice.openStart;
    for (let content2 = slice.content, i2 = 0; ; i2++) {
      let node2 = content2.firstChild;
      leftNodes.push(node2);
      if (i2 == slice.openStart)
        break;
      content2 = node2.content;
    }
    for (let d = preferredDepth - 1; d >= 0; d--) {
      let leftNode = leftNodes[d], def = definesContent(leftNode.type);
      if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
        preferredDepth = d;
      else if (def || !leftNode.type.isTextblock)
        break;
    }
    for (let j = slice.openStart; j >= 0; j--) {
      let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
      let insert = leftNodes[openDepth];
      if (!insert)
        continue;
      for (let i2 = 0; i2 < targetDepths.length; i2++) {
        let targetDepth = targetDepths[(i2 + preferredTargetIndex) % targetDepths.length], expand = true;
        if (targetDepth < 0) {
          expand = false;
          targetDepth = -targetDepth;
        }
        let parent = $from.node(targetDepth - 1), index2 = $from.index(targetDepth - 1);
        if (parent.canReplaceWith(index2, index2, insert.type, insert.marks))
          return tr2.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));
      }
    }
    let startSteps = tr2.steps.length;
    for (let i2 = targetDepths.length - 1; i2 >= 0; i2--) {
      tr2.replace(from2, to, slice);
      if (tr2.steps.length > startSteps)
        break;
      let depth = targetDepths[i2];
      if (depth < 0)
        continue;
      from2 = $from.before(depth);
      to = $to.after(depth);
    }
  }
  function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
    if (depth < oldOpen) {
      let first2 = fragment.firstChild;
      fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
    }
    if (depth > newOpen) {
      let match = parent.contentMatchAt(0);
      let start = match.fillBefore(fragment).append(fragment);
      fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
    }
    return fragment;
  }
  function replaceRangeWith(tr2, from2, to, node2) {
    if (!node2.isInline && from2 == to && tr2.doc.resolve(from2).parent.content.size) {
      let point2 = insertPoint(tr2.doc, from2, node2.type);
      if (point2 != null)
        from2 = to = point2;
    }
    tr2.replaceRange(from2, to, new Slice(Fragment.from(node2), 0, 0));
  }
  function deleteRange$1(tr2, from2, to) {
    let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
    let covered = coveredDepths($from, $to);
    for (let i2 = 0; i2 < covered.length; i2++) {
      let depth = covered[i2], last2 = i2 == covered.length - 1;
      if (last2 && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
        return tr2.delete($from.start(depth), $to.end(depth));
      if (depth > 0 && (last2 || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
        return tr2.delete($from.before(depth), $to.after(depth));
    }
    for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
      if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)
        return tr2.delete($from.before(d), to);
    }
    tr2.delete(from2, to);
  }
  function coveredDepths($from, $to) {
    let result = [], minDepth = Math.min($from.depth, $to.depth);
    for (let d = minDepth; d >= 0; d--) {
      let start = $from.start(d);
      if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
        break;
      if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)
        result.push(d);
    }
    return result;
  }
  class AttrStep extends Step {
    /**
    Construct an attribute step.
    */
    constructor(pos, attr, value) {
      super();
      this.pos = pos;
      this.attr = attr;
      this.value = value;
    }
    apply(doc2) {
      let node2 = doc2.nodeAt(this.pos);
      if (!node2)
        return StepResult.fail("No node at attribute step's position");
      let attrs = /* @__PURE__ */ Object.create(null);
      for (let name in node2.attrs)
        attrs[name] = node2.attrs[name];
      attrs[this.attr] = this.value;
      let updated = node2.type.create(attrs, null, node2.marks);
      return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node2.isLeaf ? 0 : 1));
    }
    getMap() {
      return StepMap.empty;
    }
    invert(doc2) {
      return new AttrStep(this.pos, this.attr, doc2.nodeAt(this.pos).attrs[this.attr]);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);
    }
    toJSON() {
      return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
    }
    static fromJSON(schema, json) {
      if (typeof json.pos != "number" || typeof json.attr != "string")
        throw new RangeError("Invalid input for AttrStep.fromJSON");
      return new AttrStep(json.pos, json.attr, json.value);
    }
  }
  Step.jsonID("attr", AttrStep);
  class DocAttrStep extends Step {
    /**
    Construct an attribute step.
    */
    constructor(attr, value) {
      super();
      this.attr = attr;
      this.value = value;
    }
    apply(doc2) {
      let attrs = /* @__PURE__ */ Object.create(null);
      for (let name in doc2.attrs)
        attrs[name] = doc2.attrs[name];
      attrs[this.attr] = this.value;
      let updated = doc2.type.create(attrs, doc2.content, doc2.marks);
      return StepResult.ok(updated);
    }
    getMap() {
      return StepMap.empty;
    }
    invert(doc2) {
      return new DocAttrStep(this.attr, doc2.attrs[this.attr]);
    }
    map(mapping) {
      return this;
    }
    toJSON() {
      return { stepType: "docAttr", attr: this.attr, value: this.value };
    }
    static fromJSON(schema, json) {
      if (typeof json.attr != "string")
        throw new RangeError("Invalid input for DocAttrStep.fromJSON");
      return new DocAttrStep(json.attr, json.value);
    }
  }
  Step.jsonID("docAttr", DocAttrStep);
  let TransformError = class extends Error {
  };
  TransformError = function TransformError2(message) {
    let err = Error.call(this, message);
    err.__proto__ = TransformError2.prototype;
    return err;
  };
  TransformError.prototype = Object.create(Error.prototype);
  TransformError.prototype.constructor = TransformError;
  TransformError.prototype.name = "TransformError";
  class Transform {
    /**
    Create a transform that starts with the given document.
    */
    constructor(doc2) {
      this.doc = doc2;
      this.steps = [];
      this.docs = [];
      this.mapping = new Mapping();
    }
    /**
    The starting document.
    */
    get before() {
      return this.docs.length ? this.docs[0] : this.doc;
    }
    /**
    Apply a new step in this transform, saving the result. Throws an
    error when the step fails.
    */
    step(step) {
      let result = this.maybeStep(step);
      if (result.failed)
        throw new TransformError(result.failed);
      return this;
    }
    /**
    Try to apply a step in this transformation, ignoring it if it
    fails. Returns the step result.
    */
    maybeStep(step) {
      let result = step.apply(this.doc);
      if (!result.failed)
        this.addStep(step, result.doc);
      return result;
    }
    /**
    True when the document has been changed (when there are any
    steps).
    */
    get docChanged() {
      return this.steps.length > 0;
    }
    /**
    @internal
    */
    addStep(step, doc2) {
      this.docs.push(this.doc);
      this.steps.push(step);
      this.mapping.appendMap(step.getMap());
      this.doc = doc2;
    }
    /**
    Replace the part of the document between `from` and `to` with the
    given `slice`.
    */
    replace(from2, to = from2, slice = Slice.empty) {
      let step = replaceStep(this.doc, from2, to, slice);
      if (step)
        this.step(step);
      return this;
    }
    /**
    Replace the given range with the given content, which may be a
    fragment, node, or array of nodes.
    */
    replaceWith(from2, to, content2) {
      return this.replace(from2, to, new Slice(Fragment.from(content2), 0, 0));
    }
    /**
    Delete the content between the given positions.
    */
    delete(from2, to) {
      return this.replace(from2, to, Slice.empty);
    }
    /**
    Insert the given content at the given position.
    */
    insert(pos, content2) {
      return this.replaceWith(pos, pos, content2);
    }
    /**
    Replace a range of the document with a given slice, using
    `from`, `to`, and the slice's
    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
    than fixed start and end points. This method may grow the
    replaced area or close open nodes in the slice in order to get a
    fit that is more in line with WYSIWYG expectations, by dropping
    fully covered parent nodes of the replaced region when they are
    marked [non-defining as
    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
    open parent node from the slice that _is_ marked as [defining
    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
    
    This is the method, for example, to handle paste. The similar
    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
    primitive tool which will _not_ move the start and end of its given
    range, and is useful in situations where you need more precise
    control over what happens.
    */
    replaceRange(from2, to, slice) {
      replaceRange(this, from2, to, slice);
      return this;
    }
    /**
    Replace the given range with a node, but use `from` and `to` as
    hints, rather than precise positions. When from and to are the same
    and are at the start or end of a parent node in which the given
    node doesn't fit, this method may _move_ them out towards a parent
    that does allow the given node to be placed. When the given range
    completely covers a parent node, this method may completely replace
    that parent node.
    */
    replaceRangeWith(from2, to, node2) {
      replaceRangeWith(this, from2, to, node2);
      return this;
    }
    /**
    Delete the given range, expanding it to cover fully covered
    parent nodes until a valid replace is found.
    */
    deleteRange(from2, to) {
      deleteRange$1(this, from2, to);
      return this;
    }
    /**
    Split the content in the given range off from its parent, if there
    is sibling content before or after it, and move it up the tree to
    the depth specified by `target`. You'll probably want to use
    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
    sure the lift is valid.
    */
    lift(range, target) {
      lift$2(this, range, target);
      return this;
    }
    /**
    Join the blocks around the given position. If depth is 2, their
    last and first siblings are also joined, and so on.
    */
    join(pos, depth = 1) {
      join$1(this, pos, depth);
      return this;
    }
    /**
    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
    The wrappers are assumed to be valid in this position, and should
    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
    */
    wrap(range, wrappers) {
      wrap$2(this, range, wrappers);
      return this;
    }
    /**
    Set the type of all textblocks (partly) between `from` and `to` to
    the given node type with the given attributes.
    */
    setBlockType(from2, to = from2, type, attrs = null) {
      setBlockType$1(this, from2, to, type, attrs);
      return this;
    }
    /**
    Change the type, attributes, and/or marks of the node at `pos`.
    When `type` isn't given, the existing node type is preserved,
    */
    setNodeMarkup(pos, type, attrs = null, marks) {
      setNodeMarkup(this, pos, type, attrs, marks);
      return this;
    }
    /**
    Set a single attribute on a given node to a new value.
    The `pos` addresses the document content. Use `setDocAttribute`
    to set attributes on the document itself.
    */
    setNodeAttribute(pos, attr, value) {
      this.step(new AttrStep(pos, attr, value));
      return this;
    }
    /**
    Set a single attribute on the document to a new value.
    */
    setDocAttribute(attr, value) {
      this.step(new DocAttrStep(attr, value));
      return this;
    }
    /**
    Add a mark to the node at position `pos`.
    */
    addNodeMark(pos, mark2) {
      this.step(new AddNodeMarkStep(pos, mark2));
      return this;
    }
    /**
    Remove a mark (or a mark of the given type) from the node at
    position `pos`.
    */
    removeNodeMark(pos, mark2) {
      if (!(mark2 instanceof Mark$1)) {
        let node2 = this.doc.nodeAt(pos);
        if (!node2)
          throw new RangeError("No node at position " + pos);
        mark2 = mark2.isInSet(node2.marks);
        if (!mark2)
          return this;
      }
      this.step(new RemoveNodeMarkStep(pos, mark2));
      return this;
    }
    /**
    Split the node at the given position, and optionally, if `depth` is
    greater than one, any number of nodes above that. By default, the
    parts split off will inherit the node type of the original node.
    This can be changed by passing an array of types and attributes to
    use after the split.
    */
    split(pos, depth = 1, typesAfter) {
      split$1(this, pos, depth, typesAfter);
      return this;
    }
    /**
    Add the given mark to the inline content between `from` and `to`.
    */
    addMark(from2, to, mark2) {
      addMark(this, from2, to, mark2);
      return this;
    }
    /**
    Remove marks from inline nodes between `from` and `to`. When
    `mark` is a single mark, remove precisely that mark. When it is
    a mark type, remove all marks of that type. When it is null,
    remove all marks of any type.
    */
    removeMark(from2, to, mark2) {
      removeMark(this, from2, to, mark2);
      return this;
    }
    /**
    Removes all marks and nodes from the content of the node at
    `pos` that don't match the given new parent node type. Accepts
    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
    third argument.
    */
    clearIncompatible(pos, parentType, match) {
      clearIncompatible(this, pos, parentType, match);
      return this;
    }
  }
  const classesById = /* @__PURE__ */ Object.create(null);
  class Selection {
    /**
    Initialize a selection with the head and anchor and ranges. If no
    ranges are given, constructs a single range across `$anchor` and
    `$head`.
    */
    constructor($anchor, $head, ranges) {
      this.$anchor = $anchor;
      this.$head = $head;
      this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
    }
    /**
    The selection's anchor, as an unresolved position.
    */
    get anchor() {
      return this.$anchor.pos;
    }
    /**
    The selection's head.
    */
    get head() {
      return this.$head.pos;
    }
    /**
    The lower bound of the selection's main range.
    */
    get from() {
      return this.$from.pos;
    }
    /**
    The upper bound of the selection's main range.
    */
    get to() {
      return this.$to.pos;
    }
    /**
    The resolved lower  bound of the selection's main range.
    */
    get $from() {
      return this.ranges[0].$from;
    }
    /**
    The resolved upper bound of the selection's main range.
    */
    get $to() {
      return this.ranges[0].$to;
    }
    /**
    Indicates whether the selection contains any content.
    */
    get empty() {
      let ranges = this.ranges;
      for (let i2 = 0; i2 < ranges.length; i2++)
        if (ranges[i2].$from.pos != ranges[i2].$to.pos)
          return false;
      return true;
    }
    /**
    Get the content of this selection as a slice.
    */
    content() {
      return this.$from.doc.slice(this.from, this.to, true);
    }
    /**
    Replace the selection with a slice or, if no slice is given,
    delete the selection. Will append to the given transaction.
    */
    replace(tr2, content2 = Slice.empty) {
      let lastNode = content2.content.lastChild, lastParent = null;
      for (let i2 = 0; i2 < content2.openEnd; i2++) {
        lastParent = lastNode;
        lastNode = lastNode.lastChild;
      }
      let mapFrom = tr2.steps.length, ranges = this.ranges;
      for (let i2 = 0; i2 < ranges.length; i2++) {
        let { $from, $to } = ranges[i2], mapping = tr2.mapping.slice(mapFrom);
        tr2.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i2 ? Slice.empty : content2);
        if (i2 == 0)
          selectionToInsertionEnd$1(tr2, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
      }
    }
    /**
    Replace the selection with the given node, appending the changes
    to the given transaction.
    */
    replaceWith(tr2, node2) {
      let mapFrom = tr2.steps.length, ranges = this.ranges;
      for (let i2 = 0; i2 < ranges.length; i2++) {
        let { $from, $to } = ranges[i2], mapping = tr2.mapping.slice(mapFrom);
        let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
        if (i2) {
          tr2.deleteRange(from2, to);
        } else {
          tr2.replaceRangeWith(from2, to, node2);
          selectionToInsertionEnd$1(tr2, mapFrom, node2.isInline ? -1 : 1);
        }
      }
    }
    /**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */
    static findFrom($pos, dir, textOnly = false) {
      let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
      if (inner)
        return inner;
      for (let depth = $pos.depth - 1; depth >= 0; depth--) {
        let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
        if (found2)
          return found2;
      }
      return null;
    }
    /**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */
    static near($pos, bias = 1) {
      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
    }
    /**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */
    static atStart(doc2) {
      return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
    }
    /**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */
    static atEnd(doc2) {
      return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
    }
    /**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */
    static fromJSON(doc2, json) {
      if (!json || !json.type)
        throw new RangeError("Invalid input for Selection.fromJSON");
      let cls = classesById[json.type];
      if (!cls)
        throw new RangeError(`No selection type ${json.type} defined`);
      return cls.fromJSON(doc2, json);
    }
    /**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */
    static jsonID(id, selectionClass) {
      if (id in classesById)
        throw new RangeError("Duplicate use of selection JSON ID " + id);
      classesById[id] = selectionClass;
      selectionClass.prototype.jsonID = id;
      return selectionClass;
    }
    /**
    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
    which is a value that can be mapped without having access to a
    current document, and later resolved to a real selection for a
    given document again. (This is used mostly by the history to
    track and restore old selections.) The default implementation of
    this method just converts the selection to a text selection and
    returns the bookmark for that.
    */
    getBookmark() {
      return TextSelection.between(this.$anchor, this.$head).getBookmark();
    }
  }
  Selection.prototype.visible = true;
  class SelectionRange {
    /**
    Create a range.
    */
    constructor($from, $to) {
      this.$from = $from;
      this.$to = $to;
    }
  }
  let warnedAboutTextSelection = false;
  function checkTextSelection($pos) {
    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
      warnedAboutTextSelection = true;
      console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
    }
  }
  class TextSelection extends Selection {
    /**
    Construct a text selection between the given points.
    */
    constructor($anchor, $head = $anchor) {
      checkTextSelection($anchor);
      checkTextSelection($head);
      super($anchor, $head);
    }
    /**
    Returns a resolved position if this is a cursor selection (an
    empty text selection), and null otherwise.
    */
    get $cursor() {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    }
    map(doc2, mapping) {
      let $head = doc2.resolve(mapping.map(this.head));
      if (!$head.parent.inlineContent)
        return Selection.near($head);
      let $anchor = doc2.resolve(mapping.map(this.anchor));
      return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
    }
    replace(tr2, content2 = Slice.empty) {
      super.replace(tr2, content2);
      if (content2 == Slice.empty) {
        let marks = this.$from.marksAcross(this.$to);
        if (marks)
          tr2.ensureMarks(marks);
      }
    }
    eq(other) {
      return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
    }
    getBookmark() {
      return new TextBookmark(this.anchor, this.head);
    }
    toJSON() {
      return { type: "text", anchor: this.anchor, head: this.head };
    }
    /**
    @internal
    */
    static fromJSON(doc2, json) {
      if (typeof json.anchor != "number" || typeof json.head != "number")
        throw new RangeError("Invalid input for TextSelection.fromJSON");
      return new TextSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
    }
    /**
    Create a text selection from non-resolved positions.
    */
    static create(doc2, anchor, head2 = anchor) {
      let $anchor = doc2.resolve(anchor);
      return new this($anchor, head2 == anchor ? $anchor : doc2.resolve(head2));
    }
    /**
    Return a text selection that spans the given positions or, if
    they aren't text positions, find a text selection near them.
    `bias` determines whether the method searches forward (default)
    or backwards (negative number) first. Will fall back to calling
    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
    doesn't contain a valid text position.
    */
    static between($anchor, $head, bias) {
      let dPos = $anchor.pos - $head.pos;
      if (!bias || dPos)
        bias = dPos >= 0 ? 1 : -1;
      if (!$head.parent.inlineContent) {
        let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
        if (found2)
          $head = found2.$head;
        else
          return Selection.near($head, bias);
      }
      if (!$anchor.parent.inlineContent) {
        if (dPos == 0) {
          $anchor = $head;
        } else {
          $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
          if ($anchor.pos < $head.pos != dPos < 0)
            $anchor = $head;
        }
      }
      return new TextSelection($anchor, $head);
    }
  }
  Selection.jsonID("text", TextSelection);
  class TextBookmark {
    constructor(anchor, head2) {
      this.anchor = anchor;
      this.head = head2;
    }
    map(mapping) {
      return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
    }
    resolve(doc2) {
      return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
    }
  }
  class NodeSelection extends Selection {
    /**
    Create a node selection. Does not verify the validity of its
    argument.
    */
    constructor($pos) {
      let node2 = $pos.nodeAfter;
      let $end = $pos.node(0).resolve($pos.pos + node2.nodeSize);
      super($pos, $end);
      this.node = node2;
    }
    map(doc2, mapping) {
      let { deleted, pos } = mapping.mapResult(this.anchor);
      let $pos = doc2.resolve(pos);
      if (deleted)
        return Selection.near($pos);
      return new NodeSelection($pos);
    }
    content() {
      return new Slice(Fragment.from(this.node), 0, 0);
    }
    eq(other) {
      return other instanceof NodeSelection && other.anchor == this.anchor;
    }
    toJSON() {
      return { type: "node", anchor: this.anchor };
    }
    getBookmark() {
      return new NodeBookmark(this.anchor);
    }
    /**
    @internal
    */
    static fromJSON(doc2, json) {
      if (typeof json.anchor != "number")
        throw new RangeError("Invalid input for NodeSelection.fromJSON");
      return new NodeSelection(doc2.resolve(json.anchor));
    }
    /**
    Create a node selection from non-resolved positions.
    */
    static create(doc2, from2) {
      return new NodeSelection(doc2.resolve(from2));
    }
    /**
    Determines whether the given node may be selected as a node
    selection.
    */
    static isSelectable(node2) {
      return !node2.isText && node2.type.spec.selectable !== false;
    }
  }
  NodeSelection.prototype.visible = false;
  Selection.jsonID("node", NodeSelection);
  class NodeBookmark {
    constructor(anchor) {
      this.anchor = anchor;
    }
    map(mapping) {
      let { deleted, pos } = mapping.mapResult(this.anchor);
      return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
    }
    resolve(doc2) {
      let $pos = doc2.resolve(this.anchor), node2 = $pos.nodeAfter;
      if (node2 && NodeSelection.isSelectable(node2))
        return new NodeSelection($pos);
      return Selection.near($pos);
    }
  }
  class AllSelection extends Selection {
    /**
    Create an all-selection over the given document.
    */
    constructor(doc2) {
      super(doc2.resolve(0), doc2.resolve(doc2.content.size));
    }
    replace(tr2, content2 = Slice.empty) {
      if (content2 == Slice.empty) {
        tr2.delete(0, tr2.doc.content.size);
        let sel = Selection.atStart(tr2.doc);
        if (!sel.eq(tr2.selection))
          tr2.setSelection(sel);
      } else {
        super.replace(tr2, content2);
      }
    }
    toJSON() {
      return { type: "all" };
    }
    /**
    @internal
    */
    static fromJSON(doc2) {
      return new AllSelection(doc2);
    }
    map(doc2) {
      return new AllSelection(doc2);
    }
    eq(other) {
      return other instanceof AllSelection;
    }
    getBookmark() {
      return AllBookmark;
    }
  }
  Selection.jsonID("all", AllSelection);
  const AllBookmark = {
    map() {
      return this;
    },
    resolve(doc2) {
      return new AllSelection(doc2);
    }
  };
  function findSelectionIn(doc2, node2, pos, index2, dir, text2 = false) {
    if (node2.inlineContent)
      return TextSelection.create(doc2, pos);
    for (let i2 = index2 - (dir > 0 ? 0 : 1); dir > 0 ? i2 < node2.childCount : i2 >= 0; i2 += dir) {
      let child = node2.child(i2);
      if (!child.isAtom) {
        let inner = findSelectionIn(doc2, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text2);
        if (inner)
          return inner;
      } else if (!text2 && NodeSelection.isSelectable(child)) {
        return NodeSelection.create(doc2, pos - (dir < 0 ? child.nodeSize : 0));
      }
      pos += child.nodeSize * dir;
    }
    return null;
  }
  function selectionToInsertionEnd$1(tr2, startLen, bias) {
    let last2 = tr2.steps.length - 1;
    if (last2 < startLen)
      return;
    let step = tr2.steps[last2];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
      return;
    let map2 = tr2.mapping.maps[last2], end;
    map2.forEach((_from, _to, _newFrom, newTo) => {
      if (end == null)
        end = newTo;
    });
    tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
  }
  const UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
  let Transaction$1 = class Transaction extends Transform {
    /**
    @internal
    */
    constructor(state) {
      super(state.doc);
      this.curSelectionFor = 0;
      this.updated = 0;
      this.meta = /* @__PURE__ */ Object.create(null);
      this.time = Date.now();
      this.curSelection = state.selection;
      this.storedMarks = state.storedMarks;
    }
    /**
    The transaction's current selection. This defaults to the editor
    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
    transaction, but can be overwritten with
    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
    */
    get selection() {
      if (this.curSelectionFor < this.steps.length) {
        this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
        this.curSelectionFor = this.steps.length;
      }
      return this.curSelection;
    }
    /**
    Update the transaction's current selection. Will determine the
    selection that the editor gets when the transaction is applied.
    */
    setSelection(selection) {
      if (selection.$from.doc != this.doc)
        throw new RangeError("Selection passed to setSelection must point at the current document");
      this.curSelection = selection;
      this.curSelectionFor = this.steps.length;
      this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
      this.storedMarks = null;
      return this;
    }
    /**
    Whether the selection was explicitly updated by this transaction.
    */
    get selectionSet() {
      return (this.updated & UPDATED_SEL) > 0;
    }
    /**
    Set the current stored marks.
    */
    setStoredMarks(marks) {
      this.storedMarks = marks;
      this.updated |= UPDATED_MARKS;
      return this;
    }
    /**
    Make sure the current stored marks or, if that is null, the marks
    at the selection, match the given set of marks. Does nothing if
    this is already the case.
    */
    ensureMarks(marks) {
      if (!Mark$1.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
        this.setStoredMarks(marks);
      return this;
    }
    /**
    Add a mark to the set of stored marks.
    */
    addStoredMark(mark2) {
      return this.ensureMarks(mark2.addToSet(this.storedMarks || this.selection.$head.marks()));
    }
    /**
    Remove a mark or mark type from the set of stored marks.
    */
    removeStoredMark(mark2) {
      return this.ensureMarks(mark2.removeFromSet(this.storedMarks || this.selection.$head.marks()));
    }
    /**
    Whether the stored marks were explicitly set for this transaction.
    */
    get storedMarksSet() {
      return (this.updated & UPDATED_MARKS) > 0;
    }
    /**
    @internal
    */
    addStep(step, doc2) {
      super.addStep(step, doc2);
      this.updated = this.updated & ~UPDATED_MARKS;
      this.storedMarks = null;
    }
    /**
    Update the timestamp for the transaction.
    */
    setTime(time) {
      this.time = time;
      return this;
    }
    /**
    Replace the current selection with the given slice.
    */
    replaceSelection(slice) {
      this.selection.replace(this, slice);
      return this;
    }
    /**
    Replace the selection with the given node. When `inheritMarks` is
    true and the content is inline, it inherits the marks from the
    place where it is inserted.
    */
    replaceSelectionWith(node2, inheritMarks = true) {
      let selection = this.selection;
      if (inheritMarks)
        node2 = node2.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark$1.none));
      selection.replaceWith(this, node2);
      return this;
    }
    /**
    Delete the selection.
    */
    deleteSelection() {
      this.selection.replace(this);
      return this;
    }
    /**
    Replace the given range, or the selection if no range is given,
    with a text node containing the given string.
    */
    insertText(text2, from2, to) {
      let schema = this.doc.type.schema;
      if (from2 == null) {
        if (!text2)
          return this.deleteSelection();
        return this.replaceSelectionWith(schema.text(text2), true);
      } else {
        if (to == null)
          to = from2;
        to = to == null ? from2 : to;
        if (!text2)
          return this.deleteRange(from2, to);
        let marks = this.storedMarks;
        if (!marks) {
          let $from = this.doc.resolve(from2);
          marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
        }
        this.replaceRangeWith(from2, to, schema.text(text2, marks));
        if (!this.selection.empty)
          this.setSelection(Selection.near(this.selection.$to));
        return this;
      }
    }
    /**
    Store a metadata property in this transaction, keyed either by
    name or by plugin.
    */
    setMeta(key2, value) {
      this.meta[typeof key2 == "string" ? key2 : key2.key] = value;
      return this;
    }
    /**
    Retrieve a metadata property for a given name or plugin.
    */
    getMeta(key2) {
      return this.meta[typeof key2 == "string" ? key2 : key2.key];
    }
    /**
    Returns true if this transaction doesn't contain any metadata,
    and can thus safely be extended.
    */
    get isGeneric() {
      for (let _ in this.meta)
        return false;
      return true;
    }
    /**
    Indicate that the editor should scroll the selection into view
    when updated to the state produced by this transaction.
    */
    scrollIntoView() {
      this.updated |= UPDATED_SCROLL;
      return this;
    }
    /**
    True when this transaction has had `scrollIntoView` called on it.
    */
    get scrolledIntoView() {
      return (this.updated & UPDATED_SCROLL) > 0;
    }
  };
  function bind(f, self2) {
    return !self2 || !f ? f : f.bind(self2);
  }
  class FieldDesc {
    constructor(name, desc, self2) {
      this.name = name;
      this.init = bind(desc.init, self2);
      this.apply = bind(desc.apply, self2);
    }
  }
  const baseFields = [
    new FieldDesc("doc", {
      init(config) {
        return config.doc || config.schema.topNodeType.createAndFill();
      },
      apply(tr2) {
        return tr2.doc;
      }
    }),
    new FieldDesc("selection", {
      init(config, instance) {
        return config.selection || Selection.atStart(instance.doc);
      },
      apply(tr2) {
        return tr2.selection;
      }
    }),
    new FieldDesc("storedMarks", {
      init(config) {
        return config.storedMarks || null;
      },
      apply(tr2, _marks, _old, state) {
        return state.selection.$cursor ? tr2.storedMarks : null;
      }
    }),
    new FieldDesc("scrollToSelection", {
      init() {
        return 0;
      },
      apply(tr2, prev) {
        return tr2.scrolledIntoView ? prev + 1 : prev;
      }
    })
  ];
  class Configuration {
    constructor(schema, plugins) {
      this.schema = schema;
      this.plugins = [];
      this.pluginsByKey = /* @__PURE__ */ Object.create(null);
      this.fields = baseFields.slice();
      if (plugins)
        plugins.forEach((plugin) => {
          if (this.pluginsByKey[plugin.key])
            throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
          this.plugins.push(plugin);
          this.pluginsByKey[plugin.key] = plugin;
          if (plugin.spec.state)
            this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
        });
    }
  }
  class EditorState {
    /**
    @internal
    */
    constructor(config) {
      this.config = config;
    }
    /**
    The schema of the state's document.
    */
    get schema() {
      return this.config.schema;
    }
    /**
    The plugins that are active in this state.
    */
    get plugins() {
      return this.config.plugins;
    }
    /**
    Apply the given transaction to produce a new state.
    */
    apply(tr2) {
      return this.applyTransaction(tr2).state;
    }
    /**
    @internal
    */
    filterTransaction(tr2, ignore2 = -1) {
      for (let i2 = 0; i2 < this.config.plugins.length; i2++)
        if (i2 != ignore2) {
          let plugin = this.config.plugins[i2];
          if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr2, this))
            return false;
        }
      return true;
    }
    /**
    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
    returns the precise transactions that were applied (which might
    be influenced by the [transaction
    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
    plugins) along with the new state.
    */
    applyTransaction(rootTr) {
      if (!this.filterTransaction(rootTr))
        return { state: this, transactions: [] };
      let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
      for (; ; ) {
        let haveNew = false;
        for (let i2 = 0; i2 < this.config.plugins.length; i2++) {
          let plugin = this.config.plugins[i2];
          if (plugin.spec.appendTransaction) {
            let n = seen ? seen[i2].n : 0, oldState = seen ? seen[i2].state : this;
            let tr2 = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
            if (tr2 && newState.filterTransaction(tr2, i2)) {
              tr2.setMeta("appendedTransaction", rootTr);
              if (!seen) {
                seen = [];
                for (let j = 0; j < this.config.plugins.length; j++)
                  seen.push(j < i2 ? { state: newState, n: trs.length } : { state: this, n: 0 });
              }
              trs.push(tr2);
              newState = newState.applyInner(tr2);
              haveNew = true;
            }
            if (seen)
              seen[i2] = { state: newState, n: trs.length };
          }
        }
        if (!haveNew)
          return { state: newState, transactions: trs };
      }
    }
    /**
    @internal
    */
    applyInner(tr2) {
      if (!tr2.before.eq(this.doc))
        throw new RangeError("Applying a mismatched transaction");
      let newInstance = new EditorState(this.config), fields = this.config.fields;
      for (let i2 = 0; i2 < fields.length; i2++) {
        let field = fields[i2];
        newInstance[field.name] = field.apply(tr2, this[field.name], this, newInstance);
      }
      return newInstance;
    }
    /**
    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
    */
    get tr() {
      return new Transaction$1(this);
    }
    /**
    Create a new state.
    */
    static create(config) {
      let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
      let instance = new EditorState($config);
      for (let i2 = 0; i2 < $config.fields.length; i2++)
        instance[$config.fields[i2].name] = $config.fields[i2].init(config, instance);
      return instance;
    }
    /**
    Create a new state based on this one, but with an adjusted set
    of active plugins. State fields that exist in both sets of
    plugins are kept unchanged. Those that no longer exist are
    dropped, and those that are new are initialized using their
    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
    configuration object..
    */
    reconfigure(config) {
      let $config = new Configuration(this.schema, config.plugins);
      let fields = $config.fields, instance = new EditorState($config);
      for (let i2 = 0; i2 < fields.length; i2++) {
        let name = fields[i2].name;
        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i2].init(config, instance);
      }
      return instance;
    }
    /**
    Serialize this state to JSON. If you want to serialize the state
    of plugins, pass an object mapping property names to use in the
    resulting JSON object to plugin objects. The argument may also be
    a string or number, in which case it is ignored, to support the
    way `JSON.stringify` calls `toString` methods.
    */
    toJSON(pluginFields) {
      let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
      if (this.storedMarks)
        result.storedMarks = this.storedMarks.map((m) => m.toJSON());
      if (pluginFields && typeof pluginFields == "object")
        for (let prop in pluginFields) {
          if (prop == "doc" || prop == "selection")
            throw new RangeError("The JSON fields `doc` and `selection` are reserved");
          let plugin = pluginFields[prop], state = plugin.spec.state;
          if (state && state.toJSON)
            result[prop] = state.toJSON.call(plugin, this[plugin.key]);
        }
      return result;
    }
    /**
    Deserialize a JSON representation of a state. `config` should
    have at least a `schema` field, and should contain array of
    plugins to initialize the state with. `pluginFields` can be used
    to deserialize the state of plugins, by associating plugin
    instances with the property names they use in the JSON object.
    */
    static fromJSON(config, json, pluginFields) {
      if (!json)
        throw new RangeError("Invalid input for EditorState.fromJSON");
      if (!config.schema)
        throw new RangeError("Required config field 'schema' missing");
      let $config = new Configuration(config.schema, config.plugins);
      let instance = new EditorState($config);
      $config.fields.forEach((field) => {
        if (field.name == "doc") {
          instance.doc = Node$1.fromJSON(config.schema, json.doc);
        } else if (field.name == "selection") {
          instance.selection = Selection.fromJSON(instance.doc, json.selection);
        } else if (field.name == "storedMarks") {
          if (json.storedMarks)
            instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
        } else {
          if (pluginFields)
            for (let prop in pluginFields) {
              let plugin = pluginFields[prop], state = plugin.spec.state;
              if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
                instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
                return;
              }
            }
          instance[field.name] = field.init(config, instance);
        }
      });
      return instance;
    }
  }
  function bindProps(obj, self2, target) {
    for (let prop in obj) {
      let val = obj[prop];
      if (val instanceof Function)
        val = val.bind(self2);
      else if (prop == "handleDOMEvents")
        val = bindProps(val, self2, {});
      target[prop] = val;
    }
    return target;
  }
  class Plugin {
    /**
    Create a plugin.
    */
    constructor(spec) {
      this.spec = spec;
      this.props = {};
      if (spec.props)
        bindProps(spec.props, this, this.props);
      this.key = spec.key ? spec.key.key : createKey("plugin");
    }
    /**
    Extract the plugin's state field from an editor state.
    */
    getState(state) {
      return state[this.key];
    }
  }
  const keys$1 = /* @__PURE__ */ Object.create(null);
  function createKey(name) {
    if (name in keys$1)
      return name + "$" + ++keys$1[name];
    keys$1[name] = 0;
    return name + "$";
  }
  class PluginKey {
    /**
    Create a plugin key.
    */
    constructor(name = "key") {
      this.key = createKey(name);
    }
    /**
    Get the active plugin with this key, if any, from an editor
    state.
    */
    get(state) {
      return state.config.pluginsByKey[this.key];
    }
    /**
    Get the plugin's state from an editor state.
    */
    getState(state) {
      return state[this.key];
    }
  }
  const domIndex = function(node2) {
    for (var index2 = 0; ; index2++) {
      node2 = node2.previousSibling;
      if (!node2)
        return index2;
    }
  };
  const parentNode = function(node2) {
    let parent = node2.assignedSlot || node2.parentNode;
    return parent && parent.nodeType == 11 ? parent.host : parent;
  };
  let reusedRange = null;
  const textRange = function(node2, from2, to) {
    let range = reusedRange || (reusedRange = document.createRange());
    range.setEnd(node2, to == null ? node2.nodeValue.length : to);
    range.setStart(node2, from2 || 0);
    return range;
  };
  const clearReusedRange = function() {
    reusedRange = null;
  };
  const isEquivalentPosition = function(node2, off, targetNode, targetOff) {
    return targetNode && (scanFor(node2, off, targetNode, targetOff, -1) || scanFor(node2, off, targetNode, targetOff, 1));
  };
  const atomElements = /^(img|br|input|textarea|hr)$/i;
  function scanFor(node2, off, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node2 == targetNode && off == targetOff)
        return true;
      if (off == (dir < 0 ? 0 : nodeSize(node2))) {
        let parent = node2.parentNode;
        if (!parent || parent.nodeType != 1 || hasBlockDesc(node2) || atomElements.test(node2.nodeName) || node2.contentEditable == "false")
          return false;
        off = domIndex(node2) + (dir < 0 ? 0 : 1);
        node2 = parent;
      } else if (node2.nodeType == 1) {
        node2 = node2.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node2.contentEditable == "false")
          return false;
        off = dir < 0 ? nodeSize(node2) : 0;
      } else {
        return false;
      }
    }
  }
  function nodeSize(node2) {
    return node2.nodeType == 3 ? node2.nodeValue.length : node2.childNodes.length;
  }
  function textNodeBefore$1(node2, offset) {
    for (; ; ) {
      if (node2.nodeType == 3 && offset)
        return node2;
      if (node2.nodeType == 1 && offset > 0) {
        if (node2.contentEditable == "false")
          return null;
        node2 = node2.childNodes[offset - 1];
        offset = nodeSize(node2);
      } else if (node2.parentNode && !hasBlockDesc(node2)) {
        offset = domIndex(node2);
        node2 = node2.parentNode;
      } else {
        return null;
      }
    }
  }
  function textNodeAfter$1(node2, offset) {
    for (; ; ) {
      if (node2.nodeType == 3 && offset < node2.nodeValue.length)
        return node2;
      if (node2.nodeType == 1 && offset < node2.childNodes.length) {
        if (node2.contentEditable == "false")
          return null;
        node2 = node2.childNodes[offset];
        offset = 0;
      } else if (node2.parentNode && !hasBlockDesc(node2)) {
        offset = domIndex(node2) + 1;
        node2 = node2.parentNode;
      } else {
        return null;
      }
    }
  }
  function isOnEdge(node2, offset, parent) {
    for (let atStart = offset == 0, atEnd = offset == nodeSize(node2); atStart || atEnd; ) {
      if (node2 == parent)
        return true;
      let index2 = domIndex(node2);
      node2 = node2.parentNode;
      if (!node2)
        return false;
      atStart = atStart && index2 == 0;
      atEnd = atEnd && index2 == nodeSize(node2);
    }
  }
  function hasBlockDesc(dom) {
    let desc;
    for (let cur = dom; cur; cur = cur.parentNode)
      if (desc = cur.pmViewDesc)
        break;
    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
  }
  const selectionCollapsed = function(domSel) {
    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
  };
  function keyEvent(keyCode, key2) {
    let event = document.createEvent("Event");
    event.initEvent("keydown", true, true);
    event.keyCode = keyCode;
    event.key = event.code = key2;
    return event;
  }
  function deepActiveElement(doc2) {
    let elt = doc2.activeElement;
    while (elt && elt.shadowRoot)
      elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function caretFromPoint(doc2, x, y) {
    if (doc2.caretPositionFromPoint) {
      try {
        let pos = doc2.caretPositionFromPoint(x, y);
        if (pos)
          return { node: pos.offsetNode, offset: pos.offset };
      } catch (_) {
      }
    }
    if (doc2.caretRangeFromPoint) {
      let range = doc2.caretRangeFromPoint(x, y);
      if (range)
        return { node: range.startContainer, offset: range.startOffset };
    }
  }
  const nav = typeof navigator != "undefined" ? navigator : null;
  const doc$2 = typeof document != "undefined" ? document : null;
  const agent = nav && nav.userAgent || "";
  const ie_edge = /Edge\/(\d+)/.exec(agent);
  const ie_upto10 = /MSIE \d/.exec(agent);
  const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
  const ie$1 = !!(ie_upto10 || ie_11up || ie_edge);
  const ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
  const gecko = !ie$1 && /gecko\/(\d+)/i.test(agent);
  gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
  const _chrome = !ie$1 && /Chrome\/(\d+)/.exec(agent);
  const chrome = !!_chrome;
  const chrome_version = _chrome ? +_chrome[1] : 0;
  const safari = !ie$1 && !!nav && /Apple Computer/.test(nav.vendor);
  const ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
  const mac$2 = ios || (nav ? /Mac/.test(nav.platform) : false);
  const windows = nav ? /Win/.test(nav.platform) : false;
  const android = /Android \d/.test(agent);
  const webkit = !!doc$2 && "webkitFontSmoothing" in doc$2.documentElement.style;
  const webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
  function windowRect(doc2) {
    let vp = doc2.defaultView && doc2.defaultView.visualViewport;
    if (vp)
      return {
        left: 0,
        right: vp.width,
        top: 0,
        bottom: vp.height
      };
    return {
      left: 0,
      right: doc2.documentElement.clientWidth,
      top: 0,
      bottom: doc2.documentElement.clientHeight
    };
  }
  function getSide(value, side) {
    return typeof value == "number" ? value : value[side];
  }
  function clientRect(node2) {
    let rect = node2.getBoundingClientRect();
    let scaleX = rect.width / node2.offsetWidth || 1;
    let scaleY = rect.height / node2.offsetHeight || 1;
    return {
      left: rect.left,
      right: rect.left + node2.clientWidth * scaleX,
      top: rect.top,
      bottom: rect.top + node2.clientHeight * scaleY
    };
  }
  function scrollRectIntoView(view, rect, startDOM) {
    let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
    let doc2 = view.dom.ownerDocument;
    for (let parent = startDOM || view.dom; ; parent = parentNode(parent)) {
      if (!parent)
        break;
      if (parent.nodeType != 1)
        continue;
      let elt = parent;
      let atTop = elt == doc2.body;
      let bounding = atTop ? windowRect(doc2) : clientRect(elt);
      let moveX = 0, moveY = 0;
      if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
        moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
      else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
        moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
      if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
        moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
      else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
        moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
      if (moveX || moveY) {
        if (atTop) {
          doc2.defaultView.scrollBy(moveX, moveY);
        } else {
          let startX = elt.scrollLeft, startY = elt.scrollTop;
          if (moveY)
            elt.scrollTop += moveY;
          if (moveX)
            elt.scrollLeft += moveX;
          let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
          rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
        }
      }
      if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position))
        break;
    }
  }
  function storeScrollPos(view) {
    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
    let refDOM, refTop;
    for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
      let dom = view.root.elementFromPoint(x, y);
      if (!dom || dom == view.dom || !view.dom.contains(dom))
        continue;
      let localRect = dom.getBoundingClientRect();
      if (localRect.top >= startY - 20) {
        refDOM = dom;
        refTop = localRect.top;
        break;
      }
    }
    return { refDOM, refTop, stack: scrollStack(view.dom) };
  }
  function scrollStack(dom) {
    let stack = [], doc2 = dom.ownerDocument;
    for (let cur = dom; cur; cur = parentNode(cur)) {
      stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
      if (dom == doc2)
        break;
    }
    return stack;
  }
  function resetScrollPos({ refDOM, refTop, stack }) {
    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
  }
  function restoreScrollStack(stack, dTop) {
    for (let i2 = 0; i2 < stack.length; i2++) {
      let { dom, top, left } = stack[i2];
      if (dom.scrollTop != top + dTop)
        dom.scrollTop = top + dTop;
      if (dom.scrollLeft != left)
        dom.scrollLeft = left;
    }
  }
  let preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive)
      return dom.setActive();
    if (preventScrollSupported)
      return dom.focus(preventScrollSupported);
    let stored = scrollStack(dom);
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      restoreScrollStack(stored, 0);
    }
  }
  function findOffsetInNode(node2, coords) {
    let closest, dxClosest = 2e8, coordsClosest, offset = 0;
    let rowBot = coords.top, rowTop = coords.top;
    let firstBelow, coordsBelow;
    for (let child = node2.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
      let rects;
      if (child.nodeType == 1)
        rects = child.getClientRects();
      else if (child.nodeType == 3)
        rects = textRange(child).getClientRects();
      else
        continue;
      for (let i2 = 0; i2 < rects.length; i2++) {
        let rect = rects[i2];
        if (rect.top <= rowBot && rect.bottom >= rowTop) {
          rowBot = Math.max(rect.bottom, rowBot);
          rowTop = Math.min(rect.top, rowTop);
          let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
          if (dx < dxClosest) {
            closest = child;
            dxClosest = dx;
            coordsClosest = dx && closest.nodeType == 3 ? {
              left: rect.right < coords.left ? rect.right : rect.left,
              top: coords.top
            } : coords;
            if (child.nodeType == 1 && dx)
              offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
            continue;
          }
        } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
          firstBelow = child;
          coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
        }
        if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
          offset = childIndex + 1;
      }
    }
    if (!closest && firstBelow) {
      closest = firstBelow;
      coordsClosest = coordsBelow;
      dxClosest = 0;
    }
    if (closest && closest.nodeType == 3)
      return findOffsetInText(closest, coordsClosest);
    if (!closest || dxClosest && closest.nodeType == 1)
      return { node: node2, offset };
    return findOffsetInNode(closest, coordsClosest);
  }
  function findOffsetInText(node2, coords) {
    let len = node2.nodeValue.length;
    let range = document.createRange();
    for (let i2 = 0; i2 < len; i2++) {
      range.setEnd(node2, i2 + 1);
      range.setStart(node2, i2);
      let rect = singleRect(range, 1);
      if (rect.top == rect.bottom)
        continue;
      if (inRect(coords, rect))
        return { node: node2, offset: i2 + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
    }
    return { node: node2, offset: 0 };
  }
  function inRect(coords, rect) {
    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
  }
  function targetKludge(dom, coords) {
    let parent = dom.parentNode;
    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
      return parent;
    return dom;
  }
  function posFromElement(view, elt, coords) {
    let { node: node2, offset } = findOffsetInNode(elt, coords), bias = -1;
    if (node2.nodeType == 1 && !node2.firstChild) {
      let rect = node2.getBoundingClientRect();
      bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
    }
    return view.docView.posFromDOM(node2, offset, bias);
  }
  function posFromCaret(view, node2, offset, coords) {
    let outsideBlock = -1;
    for (let cur = node2, sawBlock = false; ; ) {
      if (cur == view.dom)
        break;
      let desc = view.docView.nearestDesc(cur, true);
      if (!desc)
        return null;
      if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent && !sawBlock || !desc.contentDOM)) {
        let rect = desc.dom.getBoundingClientRect();
        if (desc.node.isBlock && desc.parent && !sawBlock) {
          sawBlock = true;
          if (rect.left > coords.left || rect.top > coords.top)
            outsideBlock = desc.posBefore;
          else if (rect.right < coords.left || rect.bottom < coords.top)
            outsideBlock = desc.posAfter;
        }
        if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
          let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
          return before ? desc.posBefore : desc.posAfter;
        }
      }
      cur = desc.dom.parentNode;
    }
    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node2, offset, -1);
  }
  function elementFromPoint(element2, coords, box) {
    let len = element2.childNodes.length;
    if (len && box.top < box.bottom) {
      for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i2 = startI; ; ) {
        let child = element2.childNodes[i2];
        if (child.nodeType == 1) {
          let rects = child.getClientRects();
          for (let j = 0; j < rects.length; j++) {
            let rect = rects[j];
            if (inRect(coords, rect))
              return elementFromPoint(child, coords, rect);
          }
        }
        if ((i2 = (i2 + 1) % len) == startI)
          break;
      }
    }
    return element2;
  }
  function posAtCoords(view, coords) {
    let doc2 = view.dom.ownerDocument, node2, offset = 0;
    let caret = caretFromPoint(doc2, coords.left, coords.top);
    if (caret)
      ({ node: node2, offset } = caret);
    let elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top);
    let pos;
    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
      let box = view.dom.getBoundingClientRect();
      if (!inRect(coords, box))
        return null;
      elt = elementFromPoint(view.dom, coords, box);
      if (!elt)
        return null;
    }
    if (safari) {
      for (let p2 = elt; node2 && p2; p2 = parentNode(p2))
        if (p2.draggable)
          node2 = void 0;
    }
    elt = targetKludge(elt, coords);
    if (node2) {
      if (gecko && node2.nodeType == 1) {
        offset = Math.min(offset, node2.childNodes.length);
        if (offset < node2.childNodes.length) {
          let next = node2.childNodes[offset], box;
          if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
            offset++;
        }
      }
      let prev;
      if (webkit && offset && node2.nodeType == 1 && (prev = node2.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
        offset--;
      if (node2 == view.dom && offset == node2.childNodes.length - 1 && node2.lastChild.nodeType == 1 && coords.top > node2.lastChild.getBoundingClientRect().bottom)
        pos = view.state.doc.content.size;
      else if (offset == 0 || node2.nodeType != 1 || node2.childNodes[offset - 1].nodeName != "BR")
        pos = posFromCaret(view, node2, offset, coords);
    }
    if (pos == null)
      pos = posFromElement(view, elt, coords);
    let desc = view.docView.nearestDesc(elt, true);
    return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
  }
  function nonZero(rect) {
    return rect.top < rect.bottom || rect.left < rect.right;
  }
  function singleRect(target, bias) {
    let rects = target.getClientRects();
    if (rects.length) {
      let first2 = rects[bias < 0 ? 0 : rects.length - 1];
      if (nonZero(first2))
        return first2;
    }
    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
  }
  const BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  function coordsAtPos(view, pos, side) {
    let { node: node2, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
    let supportEmptyRange = webkit || gecko;
    if (node2.nodeType == 3) {
      if (supportEmptyRange && (BIDI.test(node2.nodeValue) || (side < 0 ? !offset : offset == node2.nodeValue.length))) {
        let rect = singleRect(textRange(node2, offset, offset), side);
        if (gecko && offset && /\s/.test(node2.nodeValue[offset - 1]) && offset < node2.nodeValue.length) {
          let rectBefore = singleRect(textRange(node2, offset - 1, offset - 1), -1);
          if (rectBefore.top == rect.top) {
            let rectAfter = singleRect(textRange(node2, offset, offset + 1), -1);
            if (rectAfter.top != rect.top)
              return flattenV(rectAfter, rectAfter.left < rectBefore.left);
          }
        }
        return rect;
      } else {
        let from2 = offset, to = offset, takeSide = side < 0 ? 1 : -1;
        if (side < 0 && !offset) {
          to++;
          takeSide = -1;
        } else if (side >= 0 && offset == node2.nodeValue.length) {
          from2--;
          takeSide = 1;
        } else if (side < 0) {
          from2--;
        } else {
          to++;
        }
        return flattenV(singleRect(textRange(node2, from2, to), takeSide), takeSide < 0);
      }
    }
    let $dom = view.state.doc.resolve(pos - (atom || 0));
    if (!$dom.parent.inlineContent) {
      if (atom == null && offset && (side < 0 || offset == nodeSize(node2))) {
        let before = node2.childNodes[offset - 1];
        if (before.nodeType == 1)
          return flattenH(before.getBoundingClientRect(), false);
      }
      if (atom == null && offset < nodeSize(node2)) {
        let after = node2.childNodes[offset];
        if (after.nodeType == 1)
          return flattenH(after.getBoundingClientRect(), true);
      }
      return flattenH(node2.getBoundingClientRect(), side >= 0);
    }
    if (atom == null && offset && (side < 0 || offset == nodeSize(node2))) {
      let before = node2.childNodes[offset - 1];
      let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
      if (target)
        return flattenV(singleRect(target, 1), false);
    }
    if (atom == null && offset < nodeSize(node2)) {
      let after = node2.childNodes[offset];
      while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
        after = after.nextSibling;
      let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
      if (target)
        return flattenV(singleRect(target, -1), true);
    }
    return flattenV(singleRect(node2.nodeType == 3 ? textRange(node2) : node2, -side), side >= 0);
  }
  function flattenV(rect, left) {
    if (rect.width == 0)
      return rect;
    let x = left ? rect.left : rect.right;
    return { top: rect.top, bottom: rect.bottom, left: x, right: x };
  }
  function flattenH(rect, top) {
    if (rect.height == 0)
      return rect;
    let y = top ? rect.top : rect.bottom;
    return { top: y, bottom: y, left: rect.left, right: rect.right };
  }
  function withFlushedState(view, state, f) {
    let viewState = view.state, active = view.root.activeElement;
    if (viewState != state)
      view.updateState(state);
    if (active != view.dom)
      view.focus();
    try {
      return f();
    } finally {
      if (viewState != state)
        view.updateState(viewState);
      if (active != view.dom && active)
        active.focus();
    }
  }
  function endOfTextblockVertical(view, state, dir) {
    let sel = state.selection;
    let $pos = dir == "up" ? sel.$from : sel.$to;
    return withFlushedState(view, state, () => {
      let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
      for (; ; ) {
        let nearest = view.docView.nearestDesc(dom, true);
        if (!nearest)
          break;
        if (nearest.node.isBlock) {
          dom = nearest.contentDOM || nearest.dom;
          break;
        }
        dom = nearest.dom.parentNode;
      }
      let coords = coordsAtPos(view, $pos.pos, 1);
      for (let child = dom.firstChild; child; child = child.nextSibling) {
        let boxes;
        if (child.nodeType == 1)
          boxes = child.getClientRects();
        else if (child.nodeType == 3)
          boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
        else
          continue;
        for (let i2 = 0; i2 < boxes.length; i2++) {
          let box = boxes[i2];
          if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
            return false;
        }
      }
      return true;
    });
  }
  const maybeRTL = /[\u0590-\u08ac]/;
  function endOfTextblockHorizontal(view, state, dir) {
    let { $head } = state.selection;
    if (!$head.parent.isTextblock)
      return false;
    let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
    let sel = view.domSelection();
    if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
      return dir == "left" || dir == "backward" ? atStart : atEnd;
    return withFlushedState(view, state, () => {
      let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
      let oldBidiLevel = sel.caretBidiLevel;
      sel.modify("move", dir, "character");
      let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
      let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
      let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
      try {
        sel.collapse(anchorNode, anchorOffset);
        if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
          sel.extend(oldNode, oldOff);
      } catch (_) {
      }
      if (oldBidiLevel != null)
        sel.caretBidiLevel = oldBidiLevel;
      return result;
    });
  }
  let cachedState = null;
  let cachedDir = null;
  let cachedResult = false;
  function endOfTextblock(view, state, dir) {
    if (cachedState == state && cachedDir == dir)
      return cachedResult;
    cachedState = state;
    cachedDir = dir;
    return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
  }
  const NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
  class ViewDesc {
    constructor(parent, children, dom, contentDOM) {
      this.parent = parent;
      this.children = children;
      this.dom = dom;
      this.contentDOM = contentDOM;
      this.dirty = NOT_DIRTY;
      dom.pmViewDesc = this;
    }
    // Used to check whether a given description corresponds to a
    // widget/mark/node.
    matchesWidget(widget) {
      return false;
    }
    matchesMark(mark2) {
      return false;
    }
    matchesNode(node2, outerDeco, innerDeco) {
      return false;
    }
    matchesHack(nodeName) {
      return false;
    }
    // When parsing in-editor content (in domchange.js), we allow
    // descriptions to determine the parse rules that should be used to
    // parse them.
    parseRule() {
      return null;
    }
    // Used by the editor's event handler to ignore events that come
    // from certain descs.
    stopEvent(event) {
      return false;
    }
    // The size of the content represented by this desc.
    get size() {
      let size = 0;
      for (let i2 = 0; i2 < this.children.length; i2++)
        size += this.children[i2].size;
      return size;
    }
    // For block nodes, this represents the space taken up by their
    // start/end tokens.
    get border() {
      return 0;
    }
    destroy() {
      this.parent = void 0;
      if (this.dom.pmViewDesc == this)
        this.dom.pmViewDesc = void 0;
      for (let i2 = 0; i2 < this.children.length; i2++)
        this.children[i2].destroy();
    }
    posBeforeChild(child) {
      for (let i2 = 0, pos = this.posAtStart; ; i2++) {
        let cur = this.children[i2];
        if (cur == child)
          return pos;
        pos += cur.size;
      }
    }
    get posBefore() {
      return this.parent.posBeforeChild(this);
    }
    get posAtStart() {
      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
    }
    get posAfter() {
      return this.posBefore + this.size;
    }
    get posAtEnd() {
      return this.posAtStart + this.size - 2 * this.border;
    }
    localPosFromDOM(dom, offset, bias) {
      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
        if (bias < 0) {
          let domBefore, desc;
          if (dom == this.contentDOM) {
            domBefore = dom.childNodes[offset - 1];
          } else {
            while (dom.parentNode != this.contentDOM)
              dom = dom.parentNode;
            domBefore = dom.previousSibling;
          }
          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
            domBefore = domBefore.previousSibling;
          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
        } else {
          let domAfter, desc;
          if (dom == this.contentDOM) {
            domAfter = dom.childNodes[offset];
          } else {
            while (dom.parentNode != this.contentDOM)
              dom = dom.parentNode;
            domAfter = dom.nextSibling;
          }
          while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
            domAfter = domAfter.nextSibling;
          return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
        }
      }
      let atEnd;
      if (dom == this.dom && this.contentDOM) {
        atEnd = offset > domIndex(this.contentDOM);
      } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
        atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
      } else if (this.dom.firstChild) {
        if (offset == 0)
          for (let search2 = dom; ; search2 = search2.parentNode) {
            if (search2 == this.dom) {
              atEnd = false;
              break;
            }
            if (search2.previousSibling)
              break;
          }
        if (atEnd == null && offset == dom.childNodes.length)
          for (let search2 = dom; ; search2 = search2.parentNode) {
            if (search2 == this.dom) {
              atEnd = true;
              break;
            }
            if (search2.nextSibling)
              break;
          }
      }
      return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
    }
    nearestDesc(dom, onlyNodes = false) {
      for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
        let desc = this.getDesc(cur), nodeDOM;
        if (desc && (!onlyNodes || desc.node)) {
          if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
            first2 = false;
          else
            return desc;
        }
      }
    }
    getDesc(dom) {
      let desc = dom.pmViewDesc;
      for (let cur = desc; cur; cur = cur.parent)
        if (cur == this)
          return desc;
    }
    posFromDOM(dom, offset, bias) {
      for (let scan = dom; scan; scan = scan.parentNode) {
        let desc = this.getDesc(scan);
        if (desc)
          return desc.localPosFromDOM(dom, offset, bias);
      }
      return -1;
    }
    // Find the desc for the node after the given pos, if any. (When a
    // parent node overrode rendering, there might not be one.)
    descAt(pos) {
      for (let i2 = 0, offset = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = offset + child.size;
        if (offset == pos && end != offset) {
          while (!child.border && child.children.length)
            child = child.children[0];
          return child;
        }
        if (pos < end)
          return child.descAt(pos - offset - child.border);
        offset = end;
      }
    }
    domFromPos(pos, side) {
      if (!this.contentDOM)
        return { node: this.dom, offset: 0, atom: pos + 1 };
      let i2 = 0, offset = 0;
      for (let curPos = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = curPos + child.size;
        if (end > pos || child instanceof TrailingHackViewDesc) {
          offset = pos - curPos;
          break;
        }
        curPos = end;
      }
      if (offset)
        return this.children[i2].domFromPos(offset - this.children[i2].border, side);
      for (let prev; i2 && !(prev = this.children[i2 - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i2--) {
      }
      if (side <= 0) {
        let prev, enter2 = true;
        for (; ; i2--, enter2 = false) {
          prev = i2 ? this.children[i2 - 1] : null;
          if (!prev || prev.dom.parentNode == this.contentDOM)
            break;
        }
        if (prev && side && enter2 && !prev.border && !prev.domAtom)
          return prev.domFromPos(prev.size, side);
        return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
      } else {
        let next, enter2 = true;
        for (; ; i2++, enter2 = false) {
          next = i2 < this.children.length ? this.children[i2] : null;
          if (!next || next.dom.parentNode == this.contentDOM)
            break;
        }
        if (next && enter2 && !next.border && !next.domAtom)
          return next.domFromPos(0, side);
        return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
      }
    }
    // Used to find a DOM range in a single parent for a given changed
    // range.
    parseRange(from2, to, base2 = 0) {
      if (this.children.length == 0)
        return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
      let fromOffset = -1, toOffset = -1;
      for (let offset = base2, i2 = 0; ; i2++) {
        let child = this.children[i2], end = offset + child.size;
        if (fromOffset == -1 && from2 <= end) {
          let childBase = offset + child.border;
          if (from2 >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
            return child.parseRange(from2, to, childBase);
          from2 = offset;
          for (let j = i2; j > 0; j--) {
            let prev = this.children[j - 1];
            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
              fromOffset = domIndex(prev.dom) + 1;
              break;
            }
            from2 -= prev.size;
          }
          if (fromOffset == -1)
            fromOffset = 0;
        }
        if (fromOffset > -1 && (end > to || i2 == this.children.length - 1)) {
          to = end;
          for (let j = i2 + 1; j < this.children.length; j++) {
            let next = this.children[j];
            if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
              toOffset = domIndex(next.dom);
              break;
            }
            to += next.size;
          }
          if (toOffset == -1)
            toOffset = this.contentDOM.childNodes.length;
          break;
        }
        offset = end;
      }
      return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
    }
    emptyChildAt(side) {
      if (this.border || !this.contentDOM || !this.children.length)
        return false;
      let child = this.children[side < 0 ? 0 : this.children.length - 1];
      return child.size == 0 || child.emptyChildAt(side);
    }
    domAfterPos(pos) {
      let { node: node2, offset } = this.domFromPos(pos, 0);
      if (node2.nodeType != 1 || offset == node2.childNodes.length)
        throw new RangeError("No node after pos " + pos);
      return node2.childNodes[offset];
    }
    // View descs are responsible for setting any selection that falls
    // entirely inside of them, so that custom implementations can do
    // custom things with the selection. Note that this falls apart when
    // a selection starts in such a node and ends in another, in which
    // case we just use whatever domFromPos produces as a best effort.
    setSelection(anchor, head2, root2, force = false) {
      let from2 = Math.min(anchor, head2), to = Math.max(anchor, head2);
      for (let i2 = 0, offset = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = offset + child.size;
        if (from2 > offset && to < end)
          return child.setSelection(anchor - offset - child.border, head2 - offset - child.border, root2, force);
        offset = end;
      }
      let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
      let headDOM = head2 == anchor ? anchorDOM : this.domFromPos(head2, head2 ? -1 : 1);
      let domSel = root2.getSelection();
      let brKludge = false;
      if ((gecko || safari) && anchor == head2) {
        let { node: node2, offset } = anchorDOM;
        if (node2.nodeType == 3) {
          brKludge = !!(offset && node2.nodeValue[offset - 1] == "\n");
          if (brKludge && offset == node2.nodeValue.length) {
            for (let scan = node2, after; scan; scan = scan.parentNode) {
              if (after = scan.nextSibling) {
                if (after.nodeName == "BR")
                  anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
                break;
              }
              let desc = scan.pmViewDesc;
              if (desc && desc.node && desc.node.isBlock)
                break;
            }
          }
        } else {
          let prev = node2.childNodes[offset - 1];
          brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
        }
      }
      if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
        let after = domSel.focusNode.childNodes[domSel.focusOffset];
        if (after && after.contentEditable == "false")
          force = true;
      }
      if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
        return;
      let domSelExtended = false;
      if ((domSel.extend || anchor == head2) && !brKludge) {
        domSel.collapse(anchorDOM.node, anchorDOM.offset);
        try {
          if (anchor != head2)
            domSel.extend(headDOM.node, headDOM.offset);
          domSelExtended = true;
        } catch (_) {
        }
      }
      if (!domSelExtended) {
        if (anchor > head2) {
          let tmp = anchorDOM;
          anchorDOM = headDOM;
          headDOM = tmp;
        }
        let range = document.createRange();
        range.setEnd(headDOM.node, headDOM.offset);
        range.setStart(anchorDOM.node, anchorDOM.offset);
        domSel.removeAllRanges();
        domSel.addRange(range);
      }
    }
    ignoreMutation(mutation) {
      return !this.contentDOM && mutation.type != "selection";
    }
    get contentLost() {
      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
    }
    // Remove a subtree of the element tree that has been touched
    // by a DOM change, so that the next update will redraw it.
    markDirty(from2, to) {
      for (let offset = 0, i2 = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = offset + child.size;
        if (offset == end ? from2 <= end && to >= offset : from2 < end && to > offset) {
          let startInside = offset + child.border, endInside = end - child.border;
          if (from2 >= startInside && to <= endInside) {
            this.dirty = from2 == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
            if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
              child.dirty = NODE_DIRTY;
            else
              child.markDirty(from2 - startInside, to - startInside);
            return;
          } else {
            child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
          }
        }
        offset = end;
      }
      this.dirty = CONTENT_DIRTY;
    }
    markParentsDirty() {
      let level = 1;
      for (let node2 = this.parent; node2; node2 = node2.parent, level++) {
        let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (node2.dirty < dirty)
          node2.dirty = dirty;
      }
    }
    get domAtom() {
      return false;
    }
    get ignoreForCoords() {
      return false;
    }
    isText(text2) {
      return false;
    }
  }
  class WidgetViewDesc extends ViewDesc {
    constructor(parent, widget, view, pos) {
      let self2, dom = widget.type.toDOM;
      if (typeof dom == "function")
        dom = dom(view, () => {
          if (!self2)
            return pos;
          if (self2.parent)
            return self2.parent.posBeforeChild(self2);
        });
      if (!widget.type.spec.raw) {
        if (dom.nodeType != 1) {
          let wrap2 = document.createElement("span");
          wrap2.appendChild(dom);
          dom = wrap2;
        }
        dom.contentEditable = "false";
        dom.classList.add("ProseMirror-widget");
      }
      super(parent, [], dom, null);
      this.widget = widget;
      this.widget = widget;
      self2 = this;
    }
    matchesWidget(widget) {
      return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
    }
    parseRule() {
      return { ignore: true };
    }
    stopEvent(event) {
      let stop = this.widget.spec.stopEvent;
      return stop ? stop(event) : false;
    }
    ignoreMutation(mutation) {
      return mutation.type != "selection" || this.widget.spec.ignoreSelection;
    }
    destroy() {
      this.widget.type.destroy(this.dom);
      super.destroy();
    }
    get domAtom() {
      return true;
    }
    get side() {
      return this.widget.type.side;
    }
  }
  class CompositionViewDesc extends ViewDesc {
    constructor(parent, dom, textDOM, text2) {
      super(parent, [], dom, null);
      this.textDOM = textDOM;
      this.text = text2;
    }
    get size() {
      return this.text.length;
    }
    localPosFromDOM(dom, offset) {
      if (dom != this.textDOM)
        return this.posAtStart + (offset ? this.size : 0);
      return this.posAtStart + offset;
    }
    domFromPos(pos) {
      return { node: this.textDOM, offset: pos };
    }
    ignoreMutation(mut) {
      return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
    }
  }
  class MarkViewDesc extends ViewDesc {
    constructor(parent, mark2, dom, contentDOM) {
      super(parent, [], dom, contentDOM);
      this.mark = mark2;
    }
    static create(parent, mark2, inline, view) {
      let custom = view.nodeViews[mark2.type.name];
      let spec = custom && custom(mark2, view, inline);
      if (!spec || !spec.dom)
        spec = DOMSerializer.renderSpec(document, mark2.type.spec.toDOM(mark2, inline));
      return new MarkViewDesc(parent, mark2, spec.dom, spec.contentDOM || spec.dom);
    }
    parseRule() {
      if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
        return null;
      return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
    }
    matchesMark(mark2) {
      return this.dirty != NODE_DIRTY && this.mark.eq(mark2);
    }
    markDirty(from2, to) {
      super.markDirty(from2, to);
      if (this.dirty != NOT_DIRTY) {
        let parent = this.parent;
        while (!parent.node)
          parent = parent.parent;
        if (parent.dirty < this.dirty)
          parent.dirty = this.dirty;
        this.dirty = NOT_DIRTY;
      }
    }
    slice(from2, to, view) {
      let copy2 = MarkViewDesc.create(this.parent, this.mark, true, view);
      let nodes = this.children, size = this.size;
      if (to < size)
        nodes = replaceNodes(nodes, to, size, view);
      if (from2 > 0)
        nodes = replaceNodes(nodes, 0, from2, view);
      for (let i2 = 0; i2 < nodes.length; i2++)
        nodes[i2].parent = copy2;
      copy2.children = nodes;
      return copy2;
    }
  }
  class NodeViewDesc extends ViewDesc {
    constructor(parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
      super(parent, [], dom, contentDOM);
      this.node = node2;
      this.outerDeco = outerDeco;
      this.innerDeco = innerDeco;
      this.nodeDOM = nodeDOM;
    }
    // By default, a node is rendered using the `toDOM` method from the
    // node type spec. But client code can use the `nodeViews` spec to
    // supply a custom node view, which can influence various aspects of
    // the way the node works.
    //
    // (Using subclassing for this was intentionally decided against,
    // since it'd require exposing a whole slew of finicky
    // implementation details to the user code that they probably will
    // never need.)
    static create(parent, node2, outerDeco, innerDeco, view, pos) {
      let custom = view.nodeViews[node2.type.name], descObj;
      let spec = custom && custom(node2, view, () => {
        if (!descObj)
          return pos;
        if (descObj.parent)
          return descObj.parent.posBeforeChild(descObj);
      }, outerDeco, innerDeco);
      let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
      if (node2.isText) {
        if (!dom)
          dom = document.createTextNode(node2.text);
        else if (dom.nodeType != 3)
          throw new RangeError("Text must be rendered as a DOM text node");
      } else if (!dom) {
        ({ dom, contentDOM } = DOMSerializer.renderSpec(document, node2.type.spec.toDOM(node2)));
      }
      if (!contentDOM && !node2.isText && dom.nodeName != "BR") {
        if (!dom.hasAttribute("contenteditable"))
          dom.contentEditable = "false";
        if (node2.type.spec.draggable)
          dom.draggable = true;
      }
      let nodeDOM = dom;
      dom = applyOuterDeco(dom, outerDeco, node2);
      if (spec)
        return descObj = new CustomNodeViewDesc(parent, node2, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
      else if (node2.isText)
        return new TextViewDesc(parent, node2, outerDeco, innerDeco, dom, nodeDOM, view);
      else
        return new NodeViewDesc(parent, node2, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
    }
    parseRule() {
      if (this.node.type.spec.reparseInView)
        return null;
      let rule = { node: this.node.type.name, attrs: this.node.attrs };
      if (this.node.type.whitespace == "pre")
        rule.preserveWhitespace = "full";
      if (!this.contentDOM) {
        rule.getContent = () => this.node.content;
      } else if (!this.contentLost) {
        rule.contentElement = this.contentDOM;
      } else {
        for (let i2 = this.children.length - 1; i2 >= 0; i2--) {
          let child = this.children[i2];
          if (this.dom.contains(child.dom.parentNode)) {
            rule.contentElement = child.dom.parentNode;
            break;
          }
        }
        if (!rule.contentElement)
          rule.getContent = () => Fragment.empty;
      }
      return rule;
    }
    matchesNode(node2, outerDeco, innerDeco) {
      return this.dirty == NOT_DIRTY && node2.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
    }
    get size() {
      return this.node.nodeSize;
    }
    get border() {
      return this.node.isLeaf ? 0 : 1;
    }
    // Syncs `this.children` to match `this.node.content` and the local
    // decorations, possibly introducing nesting for marks. Then, in a
    // separate step, syncs the DOM inside `this.contentDOM` to
    // `this.children`.
    updateChildren(view, pos) {
      let inline = this.node.inlineContent, off = pos;
      let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
      let localComposition = composition && composition.pos > -1 ? composition : null;
      let compositionInChild = composition && composition.pos < 0;
      let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
      iterDeco(this.node, this.innerDeco, (widget, i2, insideNode) => {
        if (widget.spec.marks)
          updater.syncToMarks(widget.spec.marks, inline, view);
        else if (widget.type.side >= 0 && !insideNode)
          updater.syncToMarks(i2 == this.node.childCount ? Mark$1.none : this.node.child(i2).marks, inline, view);
        updater.placeWidget(widget, view, off);
      }, (child, outerDeco, innerDeco, i2) => {
        updater.syncToMarks(child.marks, inline, view);
        let compIndex;
        if (updater.findNodeMatch(child, outerDeco, innerDeco, i2))
          ;
        else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))
          ;
        else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i2, off))
          ;
        else {
          updater.addNode(child, outerDeco, innerDeco, view, off);
        }
        off += child.nodeSize;
      });
      updater.syncToMarks([], inline, view);
      if (this.node.isTextblock)
        updater.addTextblockHacks();
      updater.destroyRest();
      if (updater.changed || this.dirty == CONTENT_DIRTY) {
        if (localComposition)
          this.protectLocalComposition(view, localComposition);
        renderDescs(this.contentDOM, this.children, view);
        if (ios)
          iosHacks(this.dom);
      }
    }
    localCompositionInfo(view, pos) {
      let { from: from2, to } = view.state.selection;
      if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
        return null;
      let textNode = view.input.compositionNode;
      if (!textNode || !this.dom.contains(textNode.parentNode))
        return null;
      if (this.node.inlineContent) {
        let text2 = textNode.nodeValue;
        let textPos = findTextInFragment(this.node.content, text2, from2 - pos, to - pos);
        return textPos < 0 ? null : { node: textNode, pos: textPos, text: text2 };
      } else {
        return { node: textNode, pos: -1, text: "" };
      }
    }
    protectLocalComposition(view, { node: node2, pos, text: text2 }) {
      if (this.getDesc(node2))
        return;
      let topNode = node2;
      for (; ; topNode = topNode.parentNode) {
        if (topNode.parentNode == this.contentDOM)
          break;
        while (topNode.previousSibling)
          topNode.parentNode.removeChild(topNode.previousSibling);
        while (topNode.nextSibling)
          topNode.parentNode.removeChild(topNode.nextSibling);
        if (topNode.pmViewDesc)
          topNode.pmViewDesc = void 0;
      }
      let desc = new CompositionViewDesc(this, topNode, node2, text2);
      view.input.compositionNodes.push(desc);
      this.children = replaceNodes(this.children, pos, pos + text2.length, view, desc);
    }
    // If this desc must be updated to match the given node decoration,
    // do so and return true.
    update(node2, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || !node2.sameMarkup(this.node))
        return false;
      this.updateInner(node2, outerDeco, innerDeco, view);
      return true;
    }
    updateInner(node2, outerDeco, innerDeco, view) {
      this.updateOuterDeco(outerDeco);
      this.node = node2;
      this.innerDeco = innerDeco;
      if (this.contentDOM)
        this.updateChildren(view, this.posAtStart);
      this.dirty = NOT_DIRTY;
    }
    updateOuterDeco(outerDeco) {
      if (sameOuterDeco(outerDeco, this.outerDeco))
        return;
      let needsWrap = this.nodeDOM.nodeType != 1;
      let oldDOM = this.dom;
      this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
      if (this.dom != oldDOM) {
        oldDOM.pmViewDesc = void 0;
        this.dom.pmViewDesc = this;
      }
      this.outerDeco = outerDeco;
    }
    // Mark this node as being the selected node.
    selectNode() {
      if (this.nodeDOM.nodeType == 1)
        this.nodeDOM.classList.add("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.draggable = true;
    }
    // Remove selected node marking from this node.
    deselectNode() {
      if (this.nodeDOM.nodeType == 1)
        this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.removeAttribute("draggable");
    }
    get domAtom() {
      return this.node.isAtom;
    }
  }
  function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
    applyOuterDeco(dom, outerDeco, doc2);
    let docView = new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
    if (docView.contentDOM)
      docView.updateChildren(view, 0);
    return docView;
  }
  class TextViewDesc extends NodeViewDesc {
    constructor(parent, node2, outerDeco, innerDeco, dom, nodeDOM, view) {
      super(parent, node2, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
    }
    parseRule() {
      let skip = this.nodeDOM.parentNode;
      while (skip && skip != this.dom && !skip.pmIsDeco)
        skip = skip.parentNode;
      return { skip: skip || true };
    }
    update(node2, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node2.sameMarkup(this.node))
        return false;
      this.updateOuterDeco(outerDeco);
      if ((this.dirty != NOT_DIRTY || node2.text != this.node.text) && node2.text != this.nodeDOM.nodeValue) {
        this.nodeDOM.nodeValue = node2.text;
        if (view.trackWrites == this.nodeDOM)
          view.trackWrites = null;
      }
      this.node = node2;
      this.dirty = NOT_DIRTY;
      return true;
    }
    inParent() {
      let parentDOM = this.parent.contentDOM;
      for (let n = this.nodeDOM; n; n = n.parentNode)
        if (n == parentDOM)
          return true;
      return false;
    }
    domFromPos(pos) {
      return { node: this.nodeDOM, offset: pos };
    }
    localPosFromDOM(dom, offset, bias) {
      if (dom == this.nodeDOM)
        return this.posAtStart + Math.min(offset, this.node.text.length);
      return super.localPosFromDOM(dom, offset, bias);
    }
    ignoreMutation(mutation) {
      return mutation.type != "characterData" && mutation.type != "selection";
    }
    slice(from2, to, view) {
      let node2 = this.node.cut(from2, to), dom = document.createTextNode(node2.text);
      return new TextViewDesc(this.parent, node2, this.outerDeco, this.innerDeco, dom, dom, view);
    }
    markDirty(from2, to) {
      super.markDirty(from2, to);
      if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
        this.dirty = NODE_DIRTY;
    }
    get domAtom() {
      return false;
    }
    isText(text2) {
      return this.node.text == text2;
    }
  }
  class TrailingHackViewDesc extends ViewDesc {
    parseRule() {
      return { ignore: true };
    }
    matchesHack(nodeName) {
      return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
    }
    get domAtom() {
      return true;
    }
    get ignoreForCoords() {
      return this.dom.nodeName == "IMG";
    }
  }
  class CustomNodeViewDesc extends NodeViewDesc {
    constructor(parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
      super(parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
      this.spec = spec;
    }
    // A custom `update` method gets to decide whether the update goes
    // through. If it does, and there's a `contentDOM` node, our logic
    // updates the children.
    update(node2, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY)
        return false;
      if (this.spec.update) {
        let result = this.spec.update(node2, outerDeco, innerDeco);
        if (result)
          this.updateInner(node2, outerDeco, innerDeco, view);
        return result;
      } else if (!this.contentDOM && !node2.isLeaf) {
        return false;
      } else {
        return super.update(node2, outerDeco, innerDeco, view);
      }
    }
    selectNode() {
      this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
    }
    deselectNode() {
      this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
    }
    setSelection(anchor, head2, root2, force) {
      this.spec.setSelection ? this.spec.setSelection(anchor, head2, root2) : super.setSelection(anchor, head2, root2, force);
    }
    destroy() {
      if (this.spec.destroy)
        this.spec.destroy();
      super.destroy();
    }
    stopEvent(event) {
      return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
    }
    ignoreMutation(mutation) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
    }
  }
  function renderDescs(parentDOM, descs, view) {
    let dom = parentDOM.firstChild, written = false;
    for (let i2 = 0; i2 < descs.length; i2++) {
      let desc = descs[i2], childDOM = desc.dom;
      if (childDOM.parentNode == parentDOM) {
        while (childDOM != dom) {
          dom = rm(dom);
          written = true;
        }
        dom = dom.nextSibling;
      } else {
        written = true;
        parentDOM.insertBefore(childDOM, dom);
      }
      if (desc instanceof MarkViewDesc) {
        let pos = dom ? dom.previousSibling : parentDOM.lastChild;
        renderDescs(desc.contentDOM, desc.children, view);
        dom = pos ? pos.nextSibling : parentDOM.firstChild;
      }
    }
    while (dom) {
      dom = rm(dom);
      written = true;
    }
    if (written && view.trackWrites == parentDOM)
      view.trackWrites = null;
  }
  const OuterDecoLevel = function(nodeName) {
    if (nodeName)
      this.nodeName = nodeName;
  };
  OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
  const noDeco = [new OuterDecoLevel()];
  function computeOuterDeco(outerDeco, node2, needsWrap) {
    if (outerDeco.length == 0)
      return noDeco;
    let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];
    for (let i2 = 0; i2 < outerDeco.length; i2++) {
      let attrs = outerDeco[i2].type.attrs;
      if (!attrs)
        continue;
      if (attrs.nodeName)
        result.push(top = new OuterDecoLevel(attrs.nodeName));
      for (let name in attrs) {
        let val = attrs[name];
        if (val == null)
          continue;
        if (needsWrap && result.length == 1)
          result.push(top = new OuterDecoLevel(node2.isInline ? "span" : "div"));
        if (name == "class")
          top.class = (top.class ? top.class + " " : "") + val;
        else if (name == "style")
          top.style = (top.style ? top.style + ";" : "") + val;
        else if (name != "nodeName")
          top[name] = val;
      }
    }
    return result;
  }
  function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
    if (prevComputed == noDeco && curComputed == noDeco)
      return nodeDOM;
    let curDOM = nodeDOM;
    for (let i2 = 0; i2 < curComputed.length; i2++) {
      let deco = curComputed[i2], prev = prevComputed[i2];
      if (i2) {
        let parent;
        if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
          curDOM = parent;
        } else {
          parent = document.createElement(deco.nodeName);
          parent.pmIsDeco = true;
          parent.appendChild(curDOM);
          prev = noDeco[0];
          curDOM = parent;
        }
      }
      patchAttributes(curDOM, prev || noDeco[0], deco);
    }
    return curDOM;
  }
  function patchAttributes(dom, prev, cur) {
    for (let name in prev)
      if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
        dom.removeAttribute(name);
    for (let name in cur)
      if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
        dom.setAttribute(name, cur[name]);
    if (prev.class != cur.class) {
      let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
      let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
      for (let i2 = 0; i2 < prevList.length; i2++)
        if (curList.indexOf(prevList[i2]) == -1)
          dom.classList.remove(prevList[i2]);
      for (let i2 = 0; i2 < curList.length; i2++)
        if (prevList.indexOf(curList[i2]) == -1)
          dom.classList.add(curList[i2]);
      if (dom.classList.length == 0)
        dom.removeAttribute("class");
    }
    if (prev.style != cur.style) {
      if (prev.style) {
        let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
        while (m = prop.exec(prev.style))
          dom.style.removeProperty(m[1]);
      }
      if (cur.style)
        dom.style.cssText += cur.style;
    }
  }
  function applyOuterDeco(dom, deco, node2) {
    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node2, dom.nodeType != 1));
  }
  function sameOuterDeco(a2, b) {
    if (a2.length != b.length)
      return false;
    for (let i2 = 0; i2 < a2.length; i2++)
      if (!a2[i2].type.eq(b[i2].type))
        return false;
    return true;
  }
  function rm(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  class ViewTreeUpdater {
    constructor(top, lock, view) {
      this.lock = lock;
      this.view = view;
      this.index = 0;
      this.stack = [];
      this.changed = false;
      this.top = top;
      this.preMatch = preMatch(top.node.content, top);
    }
    // Destroy and remove the children between the given indices in
    // `this.top`.
    destroyBetween(start, end) {
      if (start == end)
        return;
      for (let i2 = start; i2 < end; i2++)
        this.top.children[i2].destroy();
      this.top.children.splice(start, end - start);
      this.changed = true;
    }
    // Destroy all remaining children in `this.top`.
    destroyRest() {
      this.destroyBetween(this.index, this.top.children.length);
    }
    // Sync the current stack of mark descs with the given array of
    // marks, reusing existing mark descs when possible.
    syncToMarks(marks, inline, view) {
      let keep = 0, depth = this.stack.length >> 1;
      let maxKeep = Math.min(depth, marks.length);
      while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
        keep++;
      while (keep < depth) {
        this.destroyRest();
        this.top.dirty = NOT_DIRTY;
        this.index = this.stack.pop();
        this.top = this.stack.pop();
        depth--;
      }
      while (depth < marks.length) {
        this.stack.push(this.top, this.index + 1);
        let found2 = -1;
        for (let i2 = this.index; i2 < Math.min(this.index + 3, this.top.children.length); i2++) {
          let next = this.top.children[i2];
          if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
            found2 = i2;
            break;
          }
        }
        if (found2 > -1) {
          if (found2 > this.index) {
            this.changed = true;
            this.destroyBetween(this.index, found2);
          }
          this.top = this.top.children[this.index];
        } else {
          let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
          this.top.children.splice(this.index, 0, markDesc);
          this.top = markDesc;
          this.changed = true;
        }
        this.index = 0;
        depth++;
      }
    }
    // Try to find a node desc matching the given data. Skip over it and
    // return true when successful.
    findNodeMatch(node2, outerDeco, innerDeco, index2) {
      let found2 = -1, targetDesc;
      if (index2 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index2 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node2, outerDeco, innerDeco)) {
        found2 = this.top.children.indexOf(targetDesc, this.index);
      } else {
        for (let i2 = this.index, e = Math.min(this.top.children.length, i2 + 5); i2 < e; i2++) {
          let child = this.top.children[i2];
          if (child.matchesNode(node2, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
            found2 = i2;
            break;
          }
        }
      }
      if (found2 < 0)
        return false;
      this.destroyBetween(this.index, found2);
      this.index++;
      return true;
    }
    updateNodeAt(node2, outerDeco, innerDeco, index2, view) {
      let child = this.top.children[index2];
      if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
        child.dirty = CONTENT_DIRTY;
      if (!child.update(node2, outerDeco, innerDeco, view))
        return false;
      this.destroyBetween(this.index, index2);
      this.index++;
      return true;
    }
    findIndexWithChild(domNode) {
      for (; ; ) {
        let parent = domNode.parentNode;
        if (!parent)
          return -1;
        if (parent == this.top.contentDOM) {
          let desc = domNode.pmViewDesc;
          if (desc)
            for (let i2 = this.index; i2 < this.top.children.length; i2++) {
              if (this.top.children[i2] == desc)
                return i2;
            }
          return -1;
        }
        domNode = parent;
      }
    }
    // Try to update the next node, if any, to the given data. Checks
    // pre-matches to avoid overwriting nodes that could still be used.
    updateNextNode(node2, outerDeco, innerDeco, view, index2, pos) {
      for (let i2 = this.index; i2 < this.top.children.length; i2++) {
        let next = this.top.children[i2];
        if (next instanceof NodeViewDesc) {
          let preMatch2 = this.preMatch.matched.get(next);
          if (preMatch2 != null && preMatch2 != index2)
            return false;
          let nextDOM = next.dom, updated;
          let locked = this.isLocked(nextDOM) && !(node2.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node2.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
          if (!locked && next.update(node2, outerDeco, innerDeco, view)) {
            this.destroyBetween(this.index, i2);
            if (next.dom != nextDOM)
              this.changed = true;
            this.index++;
            return true;
          } else if (!locked && (updated = this.recreateWrapper(next, node2, outerDeco, innerDeco, view, pos))) {
            this.top.children[this.index] = updated;
            if (updated.contentDOM) {
              updated.dirty = CONTENT_DIRTY;
              updated.updateChildren(view, pos + 1);
              updated.dirty = NOT_DIRTY;
            }
            this.changed = true;
            this.index++;
            return true;
          }
          break;
        }
      }
      return false;
    }
    // When a node with content is replaced by a different node with
    // identical content, move over its children.
    recreateWrapper(next, node2, outerDeco, innerDeco, view, pos) {
      if (next.dirty || node2.isAtom || !next.children.length || !next.node.content.eq(node2.content))
        return null;
      let wrapper = NodeViewDesc.create(this.top, node2, outerDeco, innerDeco, view, pos);
      if (wrapper.contentDOM) {
        wrapper.children = next.children;
        next.children = [];
        for (let ch of wrapper.children)
          ch.parent = wrapper;
      }
      next.destroy();
      return wrapper;
    }
    // Insert the node as a newly created node desc.
    addNode(node2, outerDeco, innerDeco, view, pos) {
      let desc = NodeViewDesc.create(this.top, node2, outerDeco, innerDeco, view, pos);
      if (desc.contentDOM)
        desc.updateChildren(view, pos + 1);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
    placeWidget(widget, view, pos) {
      let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
      if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
        this.index++;
      } else {
        let desc = new WidgetViewDesc(this.top, widget, view, pos);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
    }
    // Make sure a textblock looks and behaves correctly in
    // contentEditable.
    addTextblockHacks() {
      let lastChild = this.top.children[this.index - 1], parent = this.top;
      while (lastChild instanceof MarkViewDesc) {
        parent = lastChild;
        lastChild = parent.children[parent.children.length - 1];
      }
      if (!lastChild || // Empty textblock
      !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
        if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
          this.addHackNode("IMG", parent);
        this.addHackNode("BR", this.top);
      }
    }
    addHackNode(nodeName, parent) {
      if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
        this.index++;
      } else {
        let dom = document.createElement(nodeName);
        if (nodeName == "IMG") {
          dom.className = "ProseMirror-separator";
          dom.alt = "";
        }
        if (nodeName == "BR")
          dom.className = "ProseMirror-trailingBreak";
        let hack = new TrailingHackViewDesc(this.top, [], dom, null);
        if (parent != this.top)
          parent.children.push(hack);
        else
          parent.children.splice(this.index++, 0, hack);
        this.changed = true;
      }
    }
    isLocked(node2) {
      return this.lock && (node2 == this.lock || node2.nodeType == 1 && node2.contains(this.lock.parentNode));
    }
  }
  function preMatch(frag, parentDesc) {
    let curDesc = parentDesc, descI = curDesc.children.length;
    let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
    outer:
      while (fI > 0) {
        let desc;
        for (; ; ) {
          if (descI) {
            let next = curDesc.children[descI - 1];
            if (next instanceof MarkViewDesc) {
              curDesc = next;
              descI = next.children.length;
            } else {
              desc = next;
              descI--;
              break;
            }
          } else if (curDesc == parentDesc) {
            break outer;
          } else {
            descI = curDesc.parent.children.indexOf(curDesc);
            curDesc = curDesc.parent;
          }
        }
        let node2 = desc.node;
        if (!node2)
          continue;
        if (node2 != frag.child(fI - 1))
          break;
        --fI;
        matched.set(desc, fI);
        matches2.push(desc);
      }
    return { index: fI, matched, matches: matches2.reverse() };
  }
  function compareSide(a2, b) {
    return a2.type.side - b.type.side;
  }
  function iterDeco(parent, deco, onWidget, onNode) {
    let locals = deco.locals(parent), offset = 0;
    if (locals.length == 0) {
      for (let i2 = 0; i2 < parent.childCount; i2++) {
        let child = parent.child(i2);
        onNode(child, locals, deco.forChild(offset, child), i2);
        offset += child.nodeSize;
      }
      return;
    }
    let decoIndex = 0, active = [], restNode = null;
    for (let parentIndex = 0; ; ) {
      let widget, widgets;
      while (decoIndex < locals.length && locals[decoIndex].to == offset) {
        let next = locals[decoIndex++];
        if (next.widget) {
          if (!widget)
            widget = next;
          else
            (widgets || (widgets = [widget])).push(next);
        }
      }
      if (widget) {
        if (widgets) {
          widgets.sort(compareSide);
          for (let i2 = 0; i2 < widgets.length; i2++)
            onWidget(widgets[i2], parentIndex, !!restNode);
        } else {
          onWidget(widget, parentIndex, !!restNode);
        }
      }
      let child, index2;
      if (restNode) {
        index2 = -1;
        child = restNode;
        restNode = null;
      } else if (parentIndex < parent.childCount) {
        index2 = parentIndex;
        child = parent.child(parentIndex++);
      } else {
        break;
      }
      for (let i2 = 0; i2 < active.length; i2++)
        if (active[i2].to <= offset)
          active.splice(i2--, 1);
      while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)
        active.push(locals[decoIndex++]);
      let end = offset + child.nodeSize;
      if (child.isText) {
        let cutAt = end;
        if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
          cutAt = locals[decoIndex].from;
        for (let i2 = 0; i2 < active.length; i2++)
          if (active[i2].to < cutAt)
            cutAt = active[i2].to;
        if (cutAt < end) {
          restNode = child.cut(cutAt - offset);
          child = child.cut(0, cutAt - offset);
          end = cutAt;
          index2 = -1;
        }
      } else {
        while (decoIndex < locals.length && locals[decoIndex].to < end)
          decoIndex++;
      }
      let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
      onNode(child, outerDeco, deco.forChild(offset, child), index2);
      offset = end;
    }
  }
  function iosHacks(dom) {
    if (dom.nodeName == "UL" || dom.nodeName == "OL") {
      let oldCSS = dom.style.cssText;
      dom.style.cssText = oldCSS + "; list-style: square !important";
      window.getComputedStyle(dom).listStyle;
      dom.style.cssText = oldCSS;
    }
  }
  function findTextInFragment(frag, text2, from2, to) {
    for (let i2 = 0, pos = 0; i2 < frag.childCount && pos <= to; ) {
      let child = frag.child(i2++), childStart = pos;
      pos += child.nodeSize;
      if (!child.isText)
        continue;
      let str = child.text;
      while (i2 < frag.childCount) {
        let next = frag.child(i2++);
        pos += next.nodeSize;
        if (!next.isText)
          break;
        str += next.text;
      }
      if (pos >= from2) {
        if (pos >= to && str.slice(to - text2.length - childStart, to - childStart) == text2)
          return to - text2.length;
        let found2 = childStart < to ? str.lastIndexOf(text2, to - childStart - 1) : -1;
        if (found2 >= 0 && found2 + text2.length + childStart >= from2)
          return childStart + found2;
        if (from2 == to && str.length >= to + text2.length - childStart && str.slice(to - childStart, to - childStart + text2.length) == text2)
          return to;
      }
    }
    return -1;
  }
  function replaceNodes(nodes, from2, to, view, replacement) {
    let result = [];
    for (let i2 = 0, off = 0; i2 < nodes.length; i2++) {
      let child = nodes[i2], start = off, end = off += child.size;
      if (start >= to || end <= from2) {
        result.push(child);
      } else {
        if (start < from2)
          result.push(child.slice(0, from2 - start, view));
        if (replacement) {
          result.push(replacement);
          replacement = void 0;
        }
        if (end > to)
          result.push(child.slice(to - start, child.size, view));
      }
    }
    return result;
  }
  function selectionFromDOM(view, origin = null) {
    let domSel = view.domSelectionRange(), doc2 = view.state.doc;
    if (!domSel.focusNode)
      return null;
    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
    let head2 = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
    if (head2 < 0)
      return null;
    let $head = doc2.resolve(head2), $anchor, selection;
    if (selectionCollapsed(domSel)) {
      $anchor = $head;
      while (nearestDesc && !nearestDesc.node)
        nearestDesc = nearestDesc.parent;
      let nearestDescNode = nearestDesc.node;
      if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
        let pos = nearestDesc.posBefore;
        selection = new NodeSelection(head2 == pos ? $head : doc2.resolve(pos));
      }
    } else {
      let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
      if (anchor < 0)
        return null;
      $anchor = doc2.resolve(anchor);
    }
    if (!selection) {
      let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
      selection = selectionBetween(view, $anchor, $head, bias);
    }
    return selection;
  }
  function editorOwnsSelection(view) {
    return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
  }
  function selectionToDOM(view, force = false) {
    let sel = view.state.selection;
    syncNodeSelection(view, sel);
    if (!editorOwnsSelection(view))
      return;
    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
      let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
      if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
        view.input.mouseDown.delayedSelectionSync = true;
        view.domObserver.setCurSelection();
        return;
      }
    }
    view.domObserver.disconnectSelection();
    if (view.cursorWrapper) {
      selectCursorWrapper(view);
    } else {
      let { anchor, head: head2 } = sel, resetEditableFrom, resetEditableTo;
      if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
        if (!sel.$from.parent.inlineContent)
          resetEditableFrom = temporarilyEditableNear(view, sel.from);
        if (!sel.empty && !sel.$from.parent.inlineContent)
          resetEditableTo = temporarilyEditableNear(view, sel.to);
      }
      view.docView.setSelection(anchor, head2, view.root, force);
      if (brokenSelectBetweenUneditable) {
        if (resetEditableFrom)
          resetEditable(resetEditableFrom);
        if (resetEditableTo)
          resetEditable(resetEditableTo);
      }
      if (sel.visible) {
        view.dom.classList.remove("ProseMirror-hideselection");
      } else {
        view.dom.classList.add("ProseMirror-hideselection");
        if ("onselectionchange" in document)
          removeClassOnSelectionChange(view);
      }
    }
    view.domObserver.setCurSelection();
    view.domObserver.connectSelection();
  }
  const brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
  function temporarilyEditableNear(view, pos) {
    let { node: node2, offset } = view.docView.domFromPos(pos, 0);
    let after = offset < node2.childNodes.length ? node2.childNodes[offset] : null;
    let before = offset ? node2.childNodes[offset - 1] : null;
    if (safari && after && after.contentEditable == "false")
      return setEditable(after);
    if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
      if (after)
        return setEditable(after);
      else if (before)
        return setEditable(before);
    }
  }
  function setEditable(element2) {
    element2.contentEditable = "true";
    if (safari && element2.draggable) {
      element2.draggable = false;
      element2.wasDraggable = true;
    }
    return element2;
  }
  function resetEditable(element2) {
    element2.contentEditable = "false";
    if (element2.wasDraggable) {
      element2.draggable = true;
      element2.wasDraggable = null;
    }
  }
  function removeClassOnSelectionChange(view) {
    let doc2 = view.dom.ownerDocument;
    doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
    let domSel = view.domSelectionRange();
    let node2 = domSel.anchorNode, offset = domSel.anchorOffset;
    doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
      if (domSel.anchorNode != node2 || domSel.anchorOffset != offset) {
        doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
        setTimeout(() => {
          if (!editorOwnsSelection(view) || view.state.selection.visible)
            view.dom.classList.remove("ProseMirror-hideselection");
        }, 20);
      }
    });
  }
  function selectCursorWrapper(view) {
    let domSel = view.domSelection(), range = document.createRange();
    let node2 = view.cursorWrapper.dom, img2 = node2.nodeName == "IMG";
    if (img2)
      range.setEnd(node2.parentNode, domIndex(node2) + 1);
    else
      range.setEnd(node2, 0);
    range.collapse(false);
    domSel.removeAllRanges();
    domSel.addRange(range);
    if (!img2 && !view.state.selection.visible && ie$1 && ie_version <= 11) {
      node2.disabled = true;
      node2.disabled = false;
    }
  }
  function syncNodeSelection(view, sel) {
    if (sel instanceof NodeSelection) {
      let desc = view.docView.descAt(sel.from);
      if (desc != view.lastSelectedViewDesc) {
        clearNodeSelection(view);
        if (desc)
          desc.selectNode();
        view.lastSelectedViewDesc = desc;
      }
    } else {
      clearNodeSelection(view);
    }
  }
  function clearNodeSelection(view) {
    if (view.lastSelectedViewDesc) {
      if (view.lastSelectedViewDesc.parent)
        view.lastSelectedViewDesc.deselectNode();
      view.lastSelectedViewDesc = void 0;
    }
  }
  function selectionBetween(view, $anchor, $head, bias) {
    return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
  }
  function hasFocusAndSelection(view) {
    if (view.editable && !view.hasFocus())
      return false;
    return hasSelection(view);
  }
  function hasSelection(view) {
    let sel = view.domSelectionRange();
    if (!sel.anchorNode)
      return false;
    try {
      return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
    } catch (_) {
      return false;
    }
  }
  function anchorInRightPlace(view) {
    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
    let domSel = view.domSelectionRange();
    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
  }
  function moveSelectionBlock(state, dir) {
    let { $anchor, $head } = state.selection;
    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
    return $start && Selection.findFrom($start, dir);
  }
  function apply(view, sel) {
    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
    return true;
  }
  function selectHorizontally(view, dir, mods) {
    let sel = view.state.selection;
    if (sel instanceof TextSelection) {
      if (mods.indexOf("s") > -1) {
        let { $head } = sel, node2 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
        if (!node2 || node2.isText || !node2.isLeaf)
          return false;
        let $newHead = view.state.doc.resolve($head.pos + node2.nodeSize * (dir < 0 ? -1 : 1));
        return apply(view, new TextSelection(sel.$anchor, $newHead));
      } else if (!sel.empty) {
        return false;
      } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
        let next = moveSelectionBlock(view.state, dir);
        if (next && next instanceof NodeSelection)
          return apply(view, next);
        return false;
      } else if (!(mac$2 && mods.indexOf("m") > -1)) {
        let $head = sel.$head, node2 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
        if (!node2 || node2.isText)
          return false;
        let nodePos = dir < 0 ? $head.pos - node2.nodeSize : $head.pos;
        if (!(node2.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
          return false;
        if (NodeSelection.isSelectable(node2)) {
          return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node2.nodeSize) : $head));
        } else if (webkit) {
          return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node2.nodeSize)));
        } else {
          return false;
        }
      }
    } else if (sel instanceof NodeSelection && sel.node.isInline) {
      return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
    } else {
      let next = moveSelectionBlock(view.state, dir);
      if (next)
        return apply(view, next);
      return false;
    }
  }
  function nodeLen(node2) {
    return node2.nodeType == 3 ? node2.nodeValue.length : node2.childNodes.length;
  }
  function isIgnorable(dom, dir) {
    let desc = dom.pmViewDesc;
    return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
  }
  function skipIgnoredNodes(view, dir) {
    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
  }
  function skipIgnoredNodesBefore(view) {
    let sel = view.domSelectionRange();
    let node2 = sel.focusNode, offset = sel.focusOffset;
    if (!node2)
      return;
    let moveNode, moveOffset, force = false;
    if (gecko && node2.nodeType == 1 && offset < nodeLen(node2) && isIgnorable(node2.childNodes[offset], -1))
      force = true;
    for (; ; ) {
      if (offset > 0) {
        if (node2.nodeType != 1) {
          break;
        } else {
          let before = node2.childNodes[offset - 1];
          if (isIgnorable(before, -1)) {
            moveNode = node2;
            moveOffset = --offset;
          } else if (before.nodeType == 3) {
            node2 = before;
            offset = node2.nodeValue.length;
          } else
            break;
        }
      } else if (isBlockNode(node2)) {
        break;
      } else {
        let prev = node2.previousSibling;
        while (prev && isIgnorable(prev, -1)) {
          moveNode = node2.parentNode;
          moveOffset = domIndex(prev);
          prev = prev.previousSibling;
        }
        if (!prev) {
          node2 = node2.parentNode;
          if (node2 == view.dom)
            break;
          offset = 0;
        } else {
          node2 = prev;
          offset = nodeLen(node2);
        }
      }
    }
    if (force)
      setSelFocus(view, node2, offset);
    else if (moveNode)
      setSelFocus(view, moveNode, moveOffset);
  }
  function skipIgnoredNodesAfter(view) {
    let sel = view.domSelectionRange();
    let node2 = sel.focusNode, offset = sel.focusOffset;
    if (!node2)
      return;
    let len = nodeLen(node2);
    let moveNode, moveOffset;
    for (; ; ) {
      if (offset < len) {
        if (node2.nodeType != 1)
          break;
        let after = node2.childNodes[offset];
        if (isIgnorable(after, 1)) {
          moveNode = node2;
          moveOffset = ++offset;
        } else
          break;
      } else if (isBlockNode(node2)) {
        break;
      } else {
        let next = node2.nextSibling;
        while (next && isIgnorable(next, 1)) {
          moveNode = next.parentNode;
          moveOffset = domIndex(next) + 1;
          next = next.nextSibling;
        }
        if (!next) {
          node2 = node2.parentNode;
          if (node2 == view.dom)
            break;
          offset = len = 0;
        } else {
          node2 = next;
          offset = 0;
          len = nodeLen(node2);
        }
      }
    }
    if (moveNode)
      setSelFocus(view, moveNode, moveOffset);
  }
  function isBlockNode(dom) {
    let desc = dom.pmViewDesc;
    return desc && desc.node && desc.node.isBlock;
  }
  function textNodeAfter(node2, offset) {
    while (node2 && offset == node2.childNodes.length && !hasBlockDesc(node2)) {
      offset = domIndex(node2) + 1;
      node2 = node2.parentNode;
    }
    while (node2 && offset < node2.childNodes.length) {
      let next = node2.childNodes[offset];
      if (next.nodeType == 3)
        return next;
      if (next.nodeType == 1 && next.contentEditable == "false")
        break;
      node2 = next;
      offset = 0;
    }
  }
  function textNodeBefore(node2, offset) {
    while (node2 && !offset && !hasBlockDesc(node2)) {
      offset = domIndex(node2);
      node2 = node2.parentNode;
    }
    while (node2 && offset) {
      let next = node2.childNodes[offset - 1];
      if (next.nodeType == 3)
        return next;
      if (next.nodeType == 1 && next.contentEditable == "false")
        break;
      node2 = next;
      offset = node2.childNodes.length;
    }
  }
  function setSelFocus(view, node2, offset) {
    if (node2.nodeType != 3) {
      let before, after;
      if (after = textNodeAfter(node2, offset)) {
        node2 = after;
        offset = 0;
      } else if (before = textNodeBefore(node2, offset)) {
        node2 = before;
        offset = before.nodeValue.length;
      }
    }
    let sel = view.domSelection();
    if (selectionCollapsed(sel)) {
      let range = document.createRange();
      range.setEnd(node2, offset);
      range.setStart(node2, offset);
      sel.removeAllRanges();
      sel.addRange(range);
    } else if (sel.extend) {
      sel.extend(node2, offset);
    }
    view.domObserver.setCurSelection();
    let { state } = view;
    setTimeout(() => {
      if (view.state == state)
        selectionToDOM(view);
    }, 50);
  }
  function findDirection(view, pos) {
    let $pos = view.state.doc.resolve(pos);
    if (!(chrome || windows) && $pos.parent.inlineContent) {
      let coords = view.coordsAtPos(pos);
      if (pos > $pos.start()) {
        let before = view.coordsAtPos(pos - 1);
        let mid = (before.top + before.bottom) / 2;
        if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
          return before.left < coords.left ? "ltr" : "rtl";
      }
      if (pos < $pos.end()) {
        let after = view.coordsAtPos(pos + 1);
        let mid = (after.top + after.bottom) / 2;
        if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
          return after.left > coords.left ? "ltr" : "rtl";
      }
    }
    let computed = getComputedStyle(view.dom).direction;
    return computed == "rtl" ? "rtl" : "ltr";
  }
  function selectVertically(view, dir, mods) {
    let sel = view.state.selection;
    if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
      return false;
    if (mac$2 && mods.indexOf("m") > -1)
      return false;
    let { $from, $to } = sel;
    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
    }
    if (!$from.parent.inlineContent) {
      let side = dir < 0 ? $from : $to;
      let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
      return beyond ? apply(view, beyond) : false;
    }
    return false;
  }
  function stopNativeHorizontalDelete(view, dir) {
    if (!(view.state.selection instanceof TextSelection))
      return true;
    let { $head, $anchor, empty: empty2 } = view.state.selection;
    if (!$head.sameParent($anchor))
      return true;
    if (!empty2)
      return false;
    if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
      return true;
    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
    if (nextNode && !nextNode.isText) {
      let tr2 = view.state.tr;
      if (dir < 0)
        tr2.delete($head.pos - nextNode.nodeSize, $head.pos);
      else
        tr2.delete($head.pos, $head.pos + nextNode.nodeSize);
      view.dispatch(tr2);
      return true;
    }
    return false;
  }
  function switchEditable(view, node2, state) {
    view.domObserver.stop();
    node2.contentEditable = state;
    view.domObserver.start();
  }
  function safariDownArrowBug(view) {
    if (!safari || view.state.selection.$head.parentOffset > 0)
      return false;
    let { focusNode, focusOffset } = view.domSelectionRange();
    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
      let child = focusNode.firstChild;
      switchEditable(view, child, "true");
      setTimeout(() => switchEditable(view, child, "false"), 20);
    }
    return false;
  }
  function getMods(event) {
    let result = "";
    if (event.ctrlKey)
      result += "c";
    if (event.metaKey)
      result += "m";
    if (event.altKey)
      result += "a";
    if (event.shiftKey)
      result += "s";
    return result;
  }
  function captureKeyDown(view, event) {
    let code2 = event.keyCode, mods = getMods(event);
    if (code2 == 8 || mac$2 && code2 == 72 && mods == "c") {
      return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
    } else if (code2 == 46 && !event.shiftKey || mac$2 && code2 == 68 && mods == "c") {
      return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
    } else if (code2 == 13 || code2 == 27) {
      return true;
    } else if (code2 == 37 || mac$2 && code2 == 66 && mods == "c") {
      let dir = code2 == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
    } else if (code2 == 39 || mac$2 && code2 == 70 && mods == "c") {
      let dir = code2 == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
    } else if (code2 == 38 || mac$2 && code2 == 80 && mods == "c") {
      return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
    } else if (code2 == 40 || mac$2 && code2 == 78 && mods == "c") {
      return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
    } else if (mods == (mac$2 ? "m" : "c") && (code2 == 66 || code2 == 73 || code2 == 89 || code2 == 90)) {
      return true;
    }
    return false;
  }
  function serializeForClipboard(view, slice) {
    view.someProp("transformCopied", (f) => {
      slice = f(slice, view);
    });
    let context = [], { content: content2, openStart, openEnd } = slice;
    while (openStart > 1 && openEnd > 1 && content2.childCount == 1 && content2.firstChild.childCount == 1) {
      openStart--;
      openEnd--;
      let node2 = content2.firstChild;
      context.push(node2.type.name, node2.attrs != node2.type.defaultAttrs ? node2.attrs : null);
      content2 = node2.content;
    }
    let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
    let doc2 = detachedDoc(), wrap2 = doc2.createElement("div");
    wrap2.appendChild(serializer.serializeFragment(content2, { document: doc2 }));
    let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
    while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
      for (let i2 = needsWrap.length - 1; i2 >= 0; i2--) {
        let wrapper = doc2.createElement(needsWrap[i2]);
        while (wrap2.firstChild)
          wrapper.appendChild(wrap2.firstChild);
        wrap2.appendChild(wrapper);
        wrappers++;
      }
      firstChild = wrap2.firstChild;
    }
    if (firstChild && firstChild.nodeType == 1)
      firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
    let text2 = view.someProp("clipboardTextSerializer", (f) => f(slice, view)) || slice.content.textBetween(0, slice.content.size, "\n\n");
    return { dom: wrap2, text: text2 };
  }
  function parseFromClipboard(view, text2, html2, plainText, $context) {
    let inCode = $context.parent.type.spec.code;
    let dom, slice;
    if (!html2 && !text2)
      return null;
    let asText = text2 && (plainText || inCode || !html2);
    if (asText) {
      view.someProp("transformPastedText", (f) => {
        text2 = f(text2, inCode || plainText, view);
      });
      if (inCode)
        return text2 ? new Slice(Fragment.from(view.state.schema.text(text2.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
      let parsed = view.someProp("clipboardTextParser", (f) => f(text2, $context, plainText, view));
      if (parsed) {
        slice = parsed;
      } else {
        let marks = $context.marks();
        let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
        dom = document.createElement("div");
        text2.split(/(?:\r\n?|\n)+/).forEach((block2) => {
          let p2 = dom.appendChild(document.createElement("p"));
          if (block2)
            p2.appendChild(serializer.serializeNode(schema.text(block2, marks)));
        });
      }
    } else {
      view.someProp("transformPastedHTML", (f) => {
        html2 = f(html2, view);
      });
      dom = readHTML(html2);
      if (webkit)
        restoreReplacedSpaces(dom);
    }
    let contextNode = dom && dom.querySelector("[data-pm-slice]");
    let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
    if (sliceData && sliceData[3])
      for (let i2 = +sliceData[3]; i2 > 0; i2--) {
        let child = dom.firstChild;
        while (child && child.nodeType != 1)
          child = child.nextSibling;
        if (!child)
          break;
        dom = child;
      }
    if (!slice) {
      let parser2 = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
      slice = parser2.parseSlice(dom, {
        preserveWhitespace: !!(asText || sliceData),
        context: $context,
        ruleFromNode(dom2) {
          if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
            return { ignore: true };
          return null;
        }
      });
    }
    if (sliceData) {
      slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);
    } else {
      slice = Slice.maxOpen(normalizeSiblings(slice.content, $context), true);
      if (slice.openStart || slice.openEnd) {
        let openStart = 0, openEnd = 0;
        for (let node2 = slice.content.firstChild; openStart < slice.openStart && !node2.type.spec.isolating; openStart++, node2 = node2.firstChild) {
        }
        for (let node2 = slice.content.lastChild; openEnd < slice.openEnd && !node2.type.spec.isolating; openEnd++, node2 = node2.lastChild) {
        }
        slice = closeSlice(slice, openStart, openEnd);
      }
    }
    view.someProp("transformPasted", (f) => {
      slice = f(slice, view);
    });
    return slice;
  }
  const inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
  function normalizeSiblings(fragment, $context) {
    if (fragment.childCount < 2)
      return fragment;
    for (let d = $context.depth; d >= 0; d--) {
      let parent = $context.node(d);
      let match = parent.contentMatchAt($context.index(d));
      let lastWrap, result = [];
      fragment.forEach((node2) => {
        if (!result)
          return;
        let wrap2 = match.findWrapping(node2.type), inLast;
        if (!wrap2)
          return result = null;
        if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node2, result[result.length - 1], 0)) {
          result[result.length - 1] = inLast;
        } else {
          if (result.length)
            result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
          let wrapped = withWrappers(node2, wrap2);
          result.push(wrapped);
          match = match.matchType(wrapped.type);
          lastWrap = wrap2;
        }
      });
      if (result)
        return Fragment.from(result);
    }
    return fragment;
  }
  function withWrappers(node2, wrap2, from2 = 0) {
    for (let i2 = wrap2.length - 1; i2 >= from2; i2--)
      node2 = wrap2[i2].create(null, Fragment.from(node2));
    return node2;
  }
  function addToSibling(wrap2, lastWrap, node2, sibling, depth) {
    if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
      let inner = addToSibling(wrap2, lastWrap, node2, sibling.lastChild, depth + 1);
      if (inner)
        return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
      let match = sibling.contentMatchAt(sibling.childCount);
      if (match.matchType(depth == wrap2.length - 1 ? node2.type : wrap2[depth + 1]))
        return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node2, wrap2, depth + 1))));
    }
  }
  function closeRight(node2, depth) {
    if (depth == 0)
      return node2;
    let fragment = node2.content.replaceChild(node2.childCount - 1, closeRight(node2.lastChild, depth - 1));
    let fill = node2.contentMatchAt(node2.childCount).fillBefore(Fragment.empty, true);
    return node2.copy(fragment.append(fill));
  }
  function closeRange(fragment, side, from2, to, depth, openEnd) {
    let node2 = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node2.content;
    if (fragment.childCount > 1)
      openEnd = 0;
    if (depth < to - 1)
      inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
    if (depth >= from2)
      inner = side < 0 ? node2.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node2.contentMatchAt(node2.childCount).fillBefore(Fragment.empty, true));
    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node2.copy(inner));
  }
  function closeSlice(slice, openStart, openEnd) {
    if (openStart < slice.openStart)
      slice = new Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);
    if (openEnd < slice.openEnd)
      slice = new Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);
    return slice;
  }
  const wrapMap = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
  };
  let _detachedDoc = null;
  function detachedDoc() {
    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
  }
  function readHTML(html2) {
    let metas = /^(\s*<meta [^>]*>)*/.exec(html2);
    if (metas)
      html2 = html2.slice(metas[0].length);
    let elt = detachedDoc().createElement("div");
    let firstTag = /<([a-z][^>\s]+)/i.exec(html2), wrap2;
    if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
      html2 = wrap2.map((n) => "<" + n + ">").join("") + html2 + wrap2.map((n) => "</" + n + ">").reverse().join("");
    elt.innerHTML = html2;
    if (wrap2)
      for (let i2 = 0; i2 < wrap2.length; i2++)
        elt = elt.querySelector(wrap2[i2]) || elt;
    return elt;
  }
  function restoreReplacedSpaces(dom) {
    let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
    for (let i2 = 0; i2 < nodes.length; i2++) {
      let node2 = nodes[i2];
      if (node2.childNodes.length == 1 && node2.textContent == " " && node2.parentNode)
        node2.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node2);
    }
  }
  function addContext(slice, context) {
    if (!slice.size)
      return slice;
    let schema = slice.content.firstChild.type.schema, array;
    try {
      array = JSON.parse(context);
    } catch (e) {
      return slice;
    }
    let { content: content2, openStart, openEnd } = slice;
    for (let i2 = array.length - 2; i2 >= 0; i2 -= 2) {
      let type = schema.nodes[array[i2]];
      if (!type || type.hasRequiredAttrs())
        break;
      content2 = Fragment.from(type.create(array[i2 + 1], content2));
      openStart++;
      openEnd++;
    }
    return new Slice(content2, openStart, openEnd);
  }
  const handlers$2 = {};
  const editHandlers = {};
  const passiveHandlers = { touchstart: true, touchmove: true };
  class InputState {
    constructor() {
      this.shiftKey = false;
      this.mouseDown = null;
      this.lastKeyCode = null;
      this.lastKeyCodeTime = 0;
      this.lastClick = { time: 0, x: 0, y: 0, type: "" };
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastIOSEnter = 0;
      this.lastIOSEnterFallbackTimeout = -1;
      this.lastFocus = 0;
      this.lastTouch = 0;
      this.lastAndroidDelete = 0;
      this.composing = false;
      this.compositionNode = null;
      this.composingTimeout = -1;
      this.compositionNodes = [];
      this.compositionEndedAt = -2e8;
      this.compositionID = 1;
      this.compositionPendingChanges = 0;
      this.domChangeCount = 0;
      this.eventHandlers = /* @__PURE__ */ Object.create(null);
      this.hideSelectionGuard = null;
    }
  }
  function initInput(view) {
    for (let event in handlers$2) {
      let handler = handlers$2[event];
      view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
        if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
          handler(view, event2);
      }, passiveHandlers[event] ? { passive: true } : void 0);
    }
    if (safari)
      view.dom.addEventListener("input", () => null);
    ensureListeners(view);
  }
  function setSelectionOrigin(view, origin) {
    view.input.lastSelectionOrigin = origin;
    view.input.lastSelectionTime = Date.now();
  }
  function destroyInput(view) {
    view.domObserver.stop();
    for (let type in view.input.eventHandlers)
      view.dom.removeEventListener(type, view.input.eventHandlers[type]);
    clearTimeout(view.input.composingTimeout);
    clearTimeout(view.input.lastIOSEnterFallbackTimeout);
  }
  function ensureListeners(view) {
    view.someProp("handleDOMEvents", (currentHandlers) => {
      for (let type in currentHandlers)
        if (!view.input.eventHandlers[type])
          view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
    });
  }
  function runCustomHandler(view, event) {
    return view.someProp("handleDOMEvents", (handlers2) => {
      let handler = handlers2[event.type];
      return handler ? handler(view, event) || event.defaultPrevented : false;
    });
  }
  function eventBelongsToView(view, event) {
    if (!event.bubbles)
      return true;
    if (event.defaultPrevented)
      return false;
    for (let node2 = event.target; node2 != view.dom; node2 = node2.parentNode)
      if (!node2 || node2.nodeType == 11 || node2.pmViewDesc && node2.pmViewDesc.stopEvent(event))
        return false;
    return true;
  }
  function dispatchEvent(view, event) {
    if (!runCustomHandler(view, event) && handlers$2[event.type] && (view.editable || !(event.type in editHandlers)))
      handlers$2[event.type](view, event);
  }
  editHandlers.keydown = (view, _event) => {
    let event = _event;
    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
    if (inOrNearComposition(view, event))
      return;
    view.input.lastKeyCode = event.keyCode;
    view.input.lastKeyCodeTime = Date.now();
    if (android && chrome && event.keyCode == 13)
      return;
    if (event.keyCode != 229)
      view.domObserver.forceFlush();
    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
      let now = Date.now();
      view.input.lastIOSEnter = now;
      view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        if (view.input.lastIOSEnter == now) {
          view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
          view.input.lastIOSEnter = 0;
        }
      }, 200);
    } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
      event.preventDefault();
    } else {
      setSelectionOrigin(view, "key");
    }
  };
  editHandlers.keyup = (view, event) => {
    if (event.keyCode == 16)
      view.input.shiftKey = false;
  };
  editHandlers.keypress = (view, _event) => {
    let event = _event;
    if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac$2 && event.metaKey)
      return;
    if (view.someProp("handleKeyPress", (f) => f(view, event))) {
      event.preventDefault();
      return;
    }
    let sel = view.state.selection;
    if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
      let text2 = String.fromCharCode(event.charCode);
      if (!/[\r\n]/.test(text2) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text2)))
        view.dispatch(view.state.tr.insertText(text2).scrollIntoView());
      event.preventDefault();
    }
  };
  function eventCoords(event) {
    return { left: event.clientX, top: event.clientY };
  }
  function isNear(event, click) {
    let dx = click.x - event.clientX, dy = click.y - event.clientY;
    return dx * dx + dy * dy < 100;
  }
  function runHandlerOnContext(view, propName, pos, inside, event) {
    if (inside == -1)
      return false;
    let $pos = view.state.doc.resolve(inside);
    for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
      if (view.someProp(propName, (f) => i2 > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f(view, pos, $pos.node(i2), $pos.before(i2), event, false)))
        return true;
    }
    return false;
  }
  function updateSelection(view, selection, origin) {
    if (!view.focused)
      view.focus();
    let tr2 = view.state.tr.setSelection(selection);
    if (origin == "pointer")
      tr2.setMeta("pointer", true);
    view.dispatch(tr2);
  }
  function selectClickedLeaf(view, inside) {
    if (inside == -1)
      return false;
    let $pos = view.state.doc.resolve(inside), node2 = $pos.nodeAfter;
    if (node2 && node2.isAtom && NodeSelection.isSelectable(node2)) {
      updateSelection(view, new NodeSelection($pos), "pointer");
      return true;
    }
    return false;
  }
  function selectClickedNode(view, inside) {
    if (inside == -1)
      return false;
    let sel = view.state.selection, selectedNode, selectAt;
    if (sel instanceof NodeSelection)
      selectedNode = sel.node;
    let $pos = view.state.doc.resolve(inside);
    for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
      let node2 = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
      if (NodeSelection.isSelectable(node2)) {
        if (selectedNode && sel.$from.depth > 0 && i2 >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
          selectAt = $pos.before(sel.$from.depth);
        else
          selectAt = $pos.before(i2);
        break;
      }
    }
    if (selectAt != null) {
      updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
      return true;
    } else {
      return false;
    }
  }
  function handleSingleClick(view, pos, inside, event, selectNode) {
    return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
  }
  function handleDoubleClick(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
  }
  function handleTripleClick$1(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
  }
  function defaultTripleClick(view, inside, event) {
    if (event.button != 0)
      return false;
    let doc2 = view.state.doc;
    if (inside == -1) {
      if (doc2.inlineContent) {
        updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size), "pointer");
        return true;
      }
      return false;
    }
    let $pos = doc2.resolve(inside);
    for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
      let node2 = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
      let nodePos = $pos.before(i2);
      if (node2.inlineContent)
        updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node2.content.size), "pointer");
      else if (NodeSelection.isSelectable(node2))
        updateSelection(view, NodeSelection.create(doc2, nodePos), "pointer");
      else
        continue;
      return true;
    }
  }
  function forceDOMFlush(view) {
    return endComposition(view);
  }
  const selectNodeModifier = mac$2 ? "metaKey" : "ctrlKey";
  handlers$2.mousedown = (view, _event) => {
    let event = _event;
    view.input.shiftKey = event.shiftKey;
    let flushed = forceDOMFlush(view);
    let now = Date.now(), type = "singleClick";
    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
      if (view.input.lastClick.type == "singleClick")
        type = "doubleClick";
      else if (view.input.lastClick.type == "doubleClick")
        type = "tripleClick";
    }
    view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type };
    let pos = view.posAtCoords(eventCoords(event));
    if (!pos)
      return;
    if (type == "singleClick") {
      if (view.input.mouseDown)
        view.input.mouseDown.done();
      view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
    } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick$1)(view, pos.pos, pos.inside, event)) {
      event.preventDefault();
    } else {
      setSelectionOrigin(view, "pointer");
    }
  };
  class MouseDown {
    constructor(view, pos, event, flushed) {
      this.view = view;
      this.pos = pos;
      this.event = event;
      this.flushed = flushed;
      this.delayedSelectionSync = false;
      this.mightDrag = null;
      this.startDoc = view.state.doc;
      this.selectNode = !!event[selectNodeModifier];
      this.allowDefault = event.shiftKey;
      let targetNode, targetPos;
      if (pos.inside > -1) {
        targetNode = view.state.doc.nodeAt(pos.inside);
        targetPos = pos.inside;
      } else {
        let $pos = view.state.doc.resolve(pos.pos);
        targetNode = $pos.parent;
        targetPos = $pos.depth ? $pos.before() : 0;
      }
      const target = flushed ? null : event.target;
      const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
      this.target = targetDesc ? targetDesc.dom : null;
      let { selection } = view.state;
      if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
        this.mightDrag = {
          node: targetNode,
          pos: targetPos,
          addAttr: !!(this.target && !this.target.draggable),
          setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
        };
      if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr)
          this.target.draggable = true;
        if (this.mightDrag.setUneditable)
          setTimeout(() => {
            if (this.view.input.mouseDown == this)
              this.target.setAttribute("contentEditable", "false");
          }, 20);
        this.view.domObserver.start();
      }
      view.root.addEventListener("mouseup", this.up = this.up.bind(this));
      view.root.addEventListener("mousemove", this.move = this.move.bind(this));
      setSelectionOrigin(view, "pointer");
    }
    done() {
      this.view.root.removeEventListener("mouseup", this.up);
      this.view.root.removeEventListener("mousemove", this.move);
      if (this.mightDrag && this.target) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr)
          this.target.removeAttribute("draggable");
        if (this.mightDrag.setUneditable)
          this.target.removeAttribute("contentEditable");
        this.view.domObserver.start();
      }
      if (this.delayedSelectionSync)
        setTimeout(() => selectionToDOM(this.view));
      this.view.input.mouseDown = null;
    }
    up(event) {
      this.done();
      if (!this.view.dom.contains(event.target))
        return;
      let pos = this.pos;
      if (this.view.state.doc != this.startDoc)
        pos = this.view.posAtCoords(eventCoords(event));
      this.updateAllowDefault(event);
      if (this.allowDefault || !pos) {
        setSelectionOrigin(this.view, "pointer");
      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
        event.preventDefault();
      } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
      safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
      // cursor, but still report that the node is selected
      // when asked through getSelection. You'll then get a
      // situation where clicking at the point where that
      // (hidden) cursor is doesn't change the selection, and
      // thus doesn't get a reaction from ProseMirror. This
      // works around that.
      chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
        updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
        event.preventDefault();
      } else {
        setSelectionOrigin(this.view, "pointer");
      }
    }
    move(event) {
      this.updateAllowDefault(event);
      setSelectionOrigin(this.view, "pointer");
      if (event.buttons == 0)
        this.done();
    }
    updateAllowDefault(event) {
      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
        this.allowDefault = true;
    }
  }
  handlers$2.touchstart = (view) => {
    view.input.lastTouch = Date.now();
    forceDOMFlush(view);
    setSelectionOrigin(view, "pointer");
  };
  handlers$2.touchmove = (view) => {
    view.input.lastTouch = Date.now();
    setSelectionOrigin(view, "pointer");
  };
  handlers$2.contextmenu = (view) => forceDOMFlush(view);
  function inOrNearComposition(view, event) {
    if (view.composing)
      return true;
    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
      view.input.compositionEndedAt = -2e8;
      return true;
    }
    return false;
  }
  const timeoutComposition = android ? 5e3 : -1;
  editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
    if (!view.composing) {
      view.domObserver.flush();
      let { state } = view, $pos = state.selection.$from;
      if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
        view.markCursor = view.state.storedMarks || $pos.marks();
        endComposition(view, true);
        view.markCursor = null;
      } else {
        endComposition(view);
        if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
          let sel = view.domSelectionRange();
          for (let node2 = sel.focusNode, offset = sel.focusOffset; node2 && node2.nodeType == 1 && offset != 0; ) {
            let before = offset < 0 ? node2.lastChild : node2.childNodes[offset - 1];
            if (!before)
              break;
            if (before.nodeType == 3) {
              view.domSelection().collapse(before, before.nodeValue.length);
              break;
            } else {
              node2 = before;
              offset = -1;
            }
          }
        }
      }
      view.input.composing = true;
    }
    scheduleComposeEnd(view, timeoutComposition);
  };
  editHandlers.compositionend = (view, event) => {
    if (view.composing) {
      view.input.composing = false;
      view.input.compositionEndedAt = event.timeStamp;
      view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
      view.input.compositionNode = null;
      if (view.input.compositionPendingChanges)
        Promise.resolve().then(() => view.domObserver.flush());
      view.input.compositionID++;
      scheduleComposeEnd(view, 20);
    }
  };
  function scheduleComposeEnd(view, delay) {
    clearTimeout(view.input.composingTimeout);
    if (delay > -1)
      view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
  }
  function clearComposition(view) {
    if (view.composing) {
      view.input.composing = false;
      view.input.compositionEndedAt = timestampFromCustomEvent();
    }
    while (view.input.compositionNodes.length > 0)
      view.input.compositionNodes.pop().markParentsDirty();
  }
  function findCompositionNode(view) {
    let sel = view.domSelectionRange();
    if (!sel.focusNode)
      return null;
    let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
    let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
    if (textBefore && textAfter && textBefore != textAfter) {
      let descAfter = textAfter.pmViewDesc;
      if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
        return textAfter;
      } else if (view.input.compositionNode == textAfter) {
        let descBefore = textBefore.pmViewDesc;
        if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
          return textAfter;
      }
    }
    return textBefore;
  }
  function timestampFromCustomEvent() {
    let event = document.createEvent("Event");
    event.initEvent("event", true, true);
    return event.timeStamp;
  }
  function endComposition(view, forceUpdate = false) {
    if (android && view.domObserver.flushingSoon >= 0)
      return;
    view.domObserver.forceFlush();
    clearComposition(view);
    if (forceUpdate || view.docView && view.docView.dirty) {
      let sel = selectionFromDOM(view);
      if (sel && !sel.eq(view.state.selection))
        view.dispatch(view.state.tr.setSelection(sel));
      else
        view.updateState(view.state);
      return true;
    }
    return false;
  }
  function captureCopy(view, dom) {
    if (!view.dom.parentNode)
      return;
    let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
    wrap2.appendChild(dom);
    wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
    let sel = getSelection(), range = document.createRange();
    range.selectNodeContents(dom);
    view.dom.blur();
    sel.removeAllRanges();
    sel.addRange(range);
    setTimeout(() => {
      if (wrap2.parentNode)
        wrap2.parentNode.removeChild(wrap2);
      view.focus();
    }, 50);
  }
  const brokenClipboardAPI = ie$1 && ie_version < 15 || ios && webkit_version < 604;
  handlers$2.copy = editHandlers.cut = (view, _event) => {
    let event = _event;
    let sel = view.state.selection, cut2 = event.type == "cut";
    if (sel.empty)
      return;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    let slice = sel.content(), { dom, text: text2 } = serializeForClipboard(view, slice);
    if (data) {
      event.preventDefault();
      data.clearData();
      data.setData("text/html", dom.innerHTML);
      data.setData("text/plain", text2);
    } else {
      captureCopy(view, dom);
    }
    if (cut2)
      view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
  };
  function sliceSingleNode(slice) {
    return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;
  }
  function capturePaste(view, event) {
    if (!view.dom.parentNode)
      return;
    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
    if (!plainText)
      target.contentEditable = "true";
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
    setTimeout(() => {
      view.focus();
      if (target.parentNode)
        target.parentNode.removeChild(target);
      if (plainText)
        doPaste(view, target.value, null, plain, event);
      else
        doPaste(view, target.textContent, target.innerHTML, plain, event);
    }, 50);
  }
  function doPaste(view, text2, html2, preferPlain, event) {
    let slice = parseFromClipboard(view, text2, html2, preferPlain, view.state.selection.$from);
    if (view.someProp("handlePaste", (f) => f(view, event, slice || Slice.empty)))
      return true;
    if (!slice)
      return false;
    let singleNode = sliceSingleNode(slice);
    let tr2 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice);
    view.dispatch(tr2.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
    return true;
  }
  function getText$1(clipboardData) {
    let text2 = clipboardData.getData("text/plain") || clipboardData.getData("Text");
    if (text2)
      return text2;
    let uris = clipboardData.getData("text/uri-list");
    return uris ? uris.replace(/\r?\n/g, " ") : "";
  }
  editHandlers.paste = (view, _event) => {
    let event = _event;
    if (view.composing && !android)
      return;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
    if (data && doPaste(view, getText$1(data), data.getData("text/html"), plain, event))
      event.preventDefault();
    else
      capturePaste(view, event);
  };
  class Dragging {
    constructor(slice, move, node2) {
      this.slice = slice;
      this.move = move;
      this.node = node2;
    }
  }
  const dragCopyModifier = mac$2 ? "altKey" : "ctrlKey";
  handlers$2.dragstart = (view, _event) => {
    let event = _event;
    let mouseDown = view.input.mouseDown;
    if (mouseDown)
      mouseDown.done();
    if (!event.dataTransfer)
      return;
    let sel = view.state.selection;
    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
    let node2;
    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
      ;
    else if (mouseDown && mouseDown.mightDrag) {
      node2 = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
    } else if (event.target && event.target.nodeType == 1) {
      let desc = view.docView.nearestDesc(event.target, true);
      if (desc && desc.node.type.spec.draggable && desc != view.docView)
        node2 = NodeSelection.create(view.state.doc, desc.posBefore);
    }
    let slice = (node2 || view.state.selection).content(), { dom, text: text2 } = serializeForClipboard(view, slice);
    event.dataTransfer.clearData();
    event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
    event.dataTransfer.effectAllowed = "copyMove";
    if (!brokenClipboardAPI)
      event.dataTransfer.setData("text/plain", text2);
    view.dragging = new Dragging(slice, !event[dragCopyModifier], node2);
  };
  handlers$2.dragend = (view) => {
    let dragging = view.dragging;
    window.setTimeout(() => {
      if (view.dragging == dragging)
        view.dragging = null;
    }, 50);
  };
  editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
  editHandlers.drop = (view, _event) => {
    let event = _event;
    let dragging = view.dragging;
    view.dragging = null;
    if (!event.dataTransfer)
      return;
    let eventPos = view.posAtCoords(eventCoords(event));
    if (!eventPos)
      return;
    let $mouse = view.state.doc.resolve(eventPos.pos);
    let slice = dragging && dragging.slice;
    if (slice) {
      view.someProp("transformPasted", (f) => {
        slice = f(slice, view);
      });
    } else {
      slice = parseFromClipboard(view, getText$1(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
    }
    let move = !!(dragging && !event[dragCopyModifier]);
    if (view.someProp("handleDrop", (f) => f(view, event, slice || Slice.empty, move))) {
      event.preventDefault();
      return;
    }
    if (!slice)
      return;
    event.preventDefault();
    let insertPos = slice ? dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;
    if (insertPos == null)
      insertPos = $mouse.pos;
    let tr2 = view.state.tr;
    if (move) {
      let { node: node2 } = dragging;
      if (node2)
        node2.replace(tr2);
      else
        tr2.deleteSelection();
    }
    let pos = tr2.mapping.map(insertPos);
    let isNode2 = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
    let beforeInsert = tr2.doc;
    if (isNode2)
      tr2.replaceRangeWith(pos, pos, slice.content.firstChild);
    else
      tr2.replaceRange(pos, pos, slice);
    if (tr2.doc.eq(beforeInsert))
      return;
    let $pos = tr2.doc.resolve(pos);
    if (isNode2 && NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
      tr2.setSelection(new NodeSelection($pos));
    } else {
      let end = tr2.mapping.map(insertPos);
      tr2.mapping.maps[tr2.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
      tr2.setSelection(selectionBetween(view, $pos, tr2.doc.resolve(end)));
    }
    view.focus();
    view.dispatch(tr2.setMeta("uiEvent", "drop"));
  };
  handlers$2.focus = (view) => {
    view.input.lastFocus = Date.now();
    if (!view.focused) {
      view.domObserver.stop();
      view.dom.classList.add("ProseMirror-focused");
      view.domObserver.start();
      view.focused = true;
      setTimeout(() => {
        if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
          selectionToDOM(view);
      }, 20);
    }
  };
  handlers$2.blur = (view, _event) => {
    let event = _event;
    if (view.focused) {
      view.domObserver.stop();
      view.dom.classList.remove("ProseMirror-focused");
      view.domObserver.start();
      if (event.relatedTarget && view.dom.contains(event.relatedTarget))
        view.domObserver.currentSelection.clear();
      view.focused = false;
    }
  };
  handlers$2.beforeinput = (view, _event) => {
    let event = _event;
    if (chrome && android && event.inputType == "deleteContentBackward") {
      view.domObserver.flushSoon();
      let { domChangeCount } = view.input;
      setTimeout(() => {
        if (view.input.domChangeCount != domChangeCount)
          return;
        view.dom.blur();
        view.focus();
        if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
          return;
        let { $cursor } = view.state.selection;
        if ($cursor && $cursor.pos > 0)
          view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
      }, 50);
    }
  };
  for (let prop in editHandlers)
    handlers$2[prop] = editHandlers[prop];
  function compareObjs(a2, b) {
    if (a2 == b)
      return true;
    for (let p2 in a2)
      if (a2[p2] !== b[p2])
        return false;
    for (let p2 in b)
      if (!(p2 in a2))
        return false;
    return true;
  }
  class WidgetType {
    constructor(toDOM, spec) {
      this.toDOM = toDOM;
      this.spec = spec || noSpec;
      this.side = this.spec.side || 0;
    }
    map(mapping, span, offset, oldOffset) {
      let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
      return deleted ? null : new Decoration(pos - offset, pos - offset, this);
    }
    valid() {
      return true;
    }
    eq(other) {
      return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
    }
    destroy(node2) {
      if (this.spec.destroy)
        this.spec.destroy(node2);
    }
  }
  class InlineType {
    constructor(attrs, spec) {
      this.attrs = attrs;
      this.spec = spec || noSpec;
    }
    map(mapping, span, offset, oldOffset) {
      let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
      let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
      return from2 >= to ? null : new Decoration(from2, to, this);
    }
    valid(_, span) {
      return span.from < span.to;
    }
    eq(other) {
      return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
    static is(span) {
      return span.type instanceof InlineType;
    }
    destroy() {
    }
  }
  class NodeType {
    constructor(attrs, spec) {
      this.attrs = attrs;
      this.spec = spec || noSpec;
    }
    map(mapping, span, offset, oldOffset) {
      let from2 = mapping.mapResult(span.from + oldOffset, 1);
      if (from2.deleted)
        return null;
      let to = mapping.mapResult(span.to + oldOffset, -1);
      if (to.deleted || to.pos <= from2.pos)
        return null;
      return new Decoration(from2.pos - offset, to.pos - offset, this);
    }
    valid(node2, span) {
      let { index: index2, offset } = node2.content.findIndex(span.from), child;
      return offset == span.from && !(child = node2.child(index2)).isText && offset + child.nodeSize == span.to;
    }
    eq(other) {
      return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
    destroy() {
    }
  }
  class Decoration {
    /**
    @internal
    */
    constructor(from2, to, type) {
      this.from = from2;
      this.to = to;
      this.type = type;
    }
    /**
    @internal
    */
    copy(from2, to) {
      return new Decoration(from2, to, this.type);
    }
    /**
    @internal
    */
    eq(other, offset = 0) {
      return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
    }
    /**
    @internal
    */
    map(mapping, offset, oldOffset) {
      return this.type.map(mapping, this, offset, oldOffset);
    }
    /**
    Creates a widget decoration, which is a DOM node that's shown in
    the document at the given position. It is recommended that you
    delay rendering the widget by passing a function that will be
    called when the widget is actually drawn in a view, but you can
    also directly pass a DOM node. `getPos` can be used to find the
    widget's current document position.
    */
    static widget(pos, toDOM, spec) {
      return new Decoration(pos, pos, new WidgetType(toDOM, spec));
    }
    /**
    Creates an inline decoration, which adds the given attributes to
    each inline node between `from` and `to`.
    */
    static inline(from2, to, attrs, spec) {
      return new Decoration(from2, to, new InlineType(attrs, spec));
    }
    /**
    Creates a node decoration. `from` and `to` should point precisely
    before and after a node in the document. That node, and only that
    node, will receive the given attributes.
    */
    static node(from2, to, attrs, spec) {
      return new Decoration(from2, to, new NodeType(attrs, spec));
    }
    /**
    The spec provided when creating this decoration. Can be useful
    if you've stored extra information in that object.
    */
    get spec() {
      return this.type.spec;
    }
    /**
    @internal
    */
    get inline() {
      return this.type instanceof InlineType;
    }
    /**
    @internal
    */
    get widget() {
      return this.type instanceof WidgetType;
    }
  }
  const none = [], noSpec = {};
  class DecorationSet {
    /**
    @internal
    */
    constructor(local, children) {
      this.local = local.length ? local : none;
      this.children = children.length ? children : none;
    }
    /**
    Create a set of decorations, using the structure of the given
    document. This will consume (modify) the `decorations` array, so
    you must make a copy if you want need to preserve that.
    */
    static create(doc2, decorations) {
      return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
    }
    /**
    Find all decorations in this set which touch the given range
    (including decorations that start or end directly at the
    boundaries) and match the given predicate on their spec. When
    `start` and `end` are omitted, all decorations in the set are
    considered. When `predicate` isn't given, all decorations are
    assumed to match.
    */
    find(start, end, predicate) {
      let result = [];
      this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
      return result;
    }
    findInner(start, end, result, offset, predicate) {
      for (let i2 = 0; i2 < this.local.length; i2++) {
        let span = this.local[i2];
        if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
          result.push(span.copy(span.from + offset, span.to + offset));
      }
      for (let i2 = 0; i2 < this.children.length; i2 += 3) {
        if (this.children[i2] < end && this.children[i2 + 1] > start) {
          let childOff = this.children[i2] + 1;
          this.children[i2 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
        }
      }
    }
    /**
    Map the set of decorations in response to a change in the
    document.
    */
    map(mapping, doc2, options) {
      if (this == empty || mapping.maps.length == 0)
        return this;
      return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
    }
    /**
    @internal
    */
    mapInner(mapping, node2, offset, oldOffset, options) {
      let newLocal;
      for (let i2 = 0; i2 < this.local.length; i2++) {
        let mapped = this.local[i2].map(mapping, offset, oldOffset);
        if (mapped && mapped.type.valid(node2, mapped))
          (newLocal || (newLocal = [])).push(mapped);
        else if (options.onRemove)
          options.onRemove(this.local[i2].spec);
      }
      if (this.children.length)
        return mapChildren(this.children, newLocal || [], mapping, node2, offset, oldOffset, options);
      else
        return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
    }
    /**
    Add the given array of decorations to the ones in the set,
    producing a new set. Consumes the `decorations` array. Needs
    access to the current document to create the appropriate tree
    structure.
    */
    add(doc2, decorations) {
      if (!decorations.length)
        return this;
      if (this == empty)
        return DecorationSet.create(doc2, decorations);
      return this.addInner(doc2, decorations, 0);
    }
    addInner(doc2, decorations, offset) {
      let children, childIndex = 0;
      doc2.forEach((childNode, childOffset) => {
        let baseOffset = childOffset + offset, found2;
        if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
          return;
        if (!children)
          children = this.children.slice();
        while (childIndex < children.length && children[childIndex] < childOffset)
          childIndex += 3;
        if (children[childIndex] == childOffset)
          children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
        else
          children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
        childIndex += 3;
      });
      let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
      for (let i2 = 0; i2 < local.length; i2++)
        if (!local[i2].type.valid(doc2, local[i2]))
          local.splice(i2--, 1);
      return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
    }
    /**
    Create a new set that contains the decorations in this set, minus
    the ones in the given array.
    */
    remove(decorations) {
      if (decorations.length == 0 || this == empty)
        return this;
      return this.removeInner(decorations, 0);
    }
    removeInner(decorations, offset) {
      let children = this.children, local = this.local;
      for (let i2 = 0; i2 < children.length; i2 += 3) {
        let found2;
        let from2 = children[i2] + offset, to = children[i2 + 1] + offset;
        for (let j = 0, span; j < decorations.length; j++)
          if (span = decorations[j]) {
            if (span.from > from2 && span.to < to) {
              decorations[j] = null;
              (found2 || (found2 = [])).push(span);
            }
          }
        if (!found2)
          continue;
        if (children == this.children)
          children = this.children.slice();
        let removed = children[i2 + 2].removeInner(found2, from2 + 1);
        if (removed != empty) {
          children[i2 + 2] = removed;
        } else {
          children.splice(i2, 3);
          i2 -= 3;
        }
      }
      if (local.length) {
        for (let i2 = 0, span; i2 < decorations.length; i2++)
          if (span = decorations[i2]) {
            for (let j = 0; j < local.length; j++)
              if (local[j].eq(span, offset)) {
                if (local == this.local)
                  local = this.local.slice();
                local.splice(j--, 1);
              }
          }
      }
      if (children == this.children && local == this.local)
        return this;
      return local.length || children.length ? new DecorationSet(local, children) : empty;
    }
    forChild(offset, node2) {
      if (this == empty)
        return this;
      if (node2.isLeaf)
        return DecorationSet.empty;
      let child, local;
      for (let i2 = 0; i2 < this.children.length; i2 += 3)
        if (this.children[i2] >= offset) {
          if (this.children[i2] == offset)
            child = this.children[i2 + 2];
          break;
        }
      let start = offset + 1, end = start + node2.content.size;
      for (let i2 = 0; i2 < this.local.length; i2++) {
        let dec = this.local[i2];
        if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
          let from2 = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
          if (from2 < to)
            (local || (local = [])).push(dec.copy(from2, to));
        }
      }
      if (local) {
        let localSet = new DecorationSet(local.sort(byPos), none);
        return child ? new DecorationGroup([localSet, child]) : localSet;
      }
      return child || empty;
    }
    /**
    @internal
    */
    eq(other) {
      if (this == other)
        return true;
      if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
        return false;
      for (let i2 = 0; i2 < this.local.length; i2++)
        if (!this.local[i2].eq(other.local[i2]))
          return false;
      for (let i2 = 0; i2 < this.children.length; i2 += 3)
        if (this.children[i2] != other.children[i2] || this.children[i2 + 1] != other.children[i2 + 1] || !this.children[i2 + 2].eq(other.children[i2 + 2]))
          return false;
      return true;
    }
    /**
    @internal
    */
    locals(node2) {
      return removeOverlap(this.localsInner(node2));
    }
    /**
    @internal
    */
    localsInner(node2) {
      if (this == empty)
        return none;
      if (node2.inlineContent || !this.local.some(InlineType.is))
        return this.local;
      let result = [];
      for (let i2 = 0; i2 < this.local.length; i2++) {
        if (!(this.local[i2].type instanceof InlineType))
          result.push(this.local[i2]);
      }
      return result;
    }
  }
  DecorationSet.empty = new DecorationSet([], []);
  DecorationSet.removeOverlap = removeOverlap;
  const empty = DecorationSet.empty;
  class DecorationGroup {
    constructor(members) {
      this.members = members;
    }
    map(mapping, doc2) {
      const mappedDecos = this.members.map((member) => member.map(mapping, doc2, noSpec));
      return DecorationGroup.from(mappedDecos);
    }
    forChild(offset, child) {
      if (child.isLeaf)
        return DecorationSet.empty;
      let found2 = [];
      for (let i2 = 0; i2 < this.members.length; i2++) {
        let result = this.members[i2].forChild(offset, child);
        if (result == empty)
          continue;
        if (result instanceof DecorationGroup)
          found2 = found2.concat(result.members);
        else
          found2.push(result);
      }
      return DecorationGroup.from(found2);
    }
    eq(other) {
      if (!(other instanceof DecorationGroup) || other.members.length != this.members.length)
        return false;
      for (let i2 = 0; i2 < this.members.length; i2++)
        if (!this.members[i2].eq(other.members[i2]))
          return false;
      return true;
    }
    locals(node2) {
      let result, sorted = true;
      for (let i2 = 0; i2 < this.members.length; i2++) {
        let locals = this.members[i2].localsInner(node2);
        if (!locals.length)
          continue;
        if (!result) {
          result = locals;
        } else {
          if (sorted) {
            result = result.slice();
            sorted = false;
          }
          for (let j = 0; j < locals.length; j++)
            result.push(locals[j]);
        }
      }
      return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
    }
    // Create a group for the given array of decoration sets, or return
    // a single set when possible.
    static from(members) {
      switch (members.length) {
        case 0:
          return empty;
        case 1:
          return members[0];
        default:
          return new DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));
      }
    }
  }
  function mapChildren(oldChildren, newLocal, mapping, node2, offset, oldOffset, options) {
    let children = oldChildren.slice();
    for (let i2 = 0, baseOffset = oldOffset; i2 < mapping.maps.length; i2++) {
      let moved = 0;
      mapping.maps[i2].forEach((oldStart, oldEnd, newStart, newEnd) => {
        let dSize = newEnd - newStart - (oldEnd - oldStart);
        for (let i3 = 0; i3 < children.length; i3 += 3) {
          let end = children[i3 + 1];
          if (end < 0 || oldStart > end + baseOffset - moved)
            continue;
          let start = children[i3] + baseOffset - moved;
          if (oldEnd >= start) {
            children[i3 + 1] = oldStart <= start ? -2 : -1;
          } else if (oldStart >= baseOffset && dSize) {
            children[i3] += dSize;
            children[i3 + 1] += dSize;
          }
        }
        moved += dSize;
      });
      baseOffset = mapping.maps[i2].map(baseOffset, -1);
    }
    let mustRebuild = false;
    for (let i2 = 0; i2 < children.length; i2 += 3)
      if (children[i2 + 1] < 0) {
        if (children[i2 + 1] == -2) {
          mustRebuild = true;
          children[i2 + 1] = -1;
          continue;
        }
        let from2 = mapping.map(oldChildren[i2] + oldOffset), fromLocal = from2 - offset;
        if (fromLocal < 0 || fromLocal >= node2.content.size) {
          mustRebuild = true;
          continue;
        }
        let to = mapping.map(oldChildren[i2 + 1] + oldOffset, -1), toLocal = to - offset;
        let { index: index2, offset: childOffset } = node2.content.findIndex(fromLocal);
        let childNode = node2.maybeChild(index2);
        if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
          let mapped = children[i2 + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i2] + oldOffset + 1, options);
          if (mapped != empty) {
            children[i2] = fromLocal;
            children[i2 + 1] = toLocal;
            children[i2 + 2] = mapped;
          } else {
            children[i2 + 1] = -2;
            mustRebuild = true;
          }
        } else {
          mustRebuild = true;
        }
      }
    if (mustRebuild) {
      let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);
      let built = buildTree(decorations, node2, 0, options);
      newLocal = built.local;
      for (let i2 = 0; i2 < children.length; i2 += 3)
        if (children[i2 + 1] < 0) {
          children.splice(i2, 3);
          i2 -= 3;
        }
      for (let i2 = 0, j = 0; i2 < built.children.length; i2 += 3) {
        let from2 = built.children[i2];
        while (j < children.length && children[j] < from2)
          j += 3;
        children.splice(j, 0, built.children[i2], built.children[i2 + 1], built.children[i2 + 2]);
      }
    }
    return new DecorationSet(newLocal.sort(byPos), children);
  }
  function moveSpans(spans, offset) {
    if (!offset || !spans.length)
      return spans;
    let result = [];
    for (let i2 = 0; i2 < spans.length; i2++) {
      let span = spans[i2];
      result.push(new Decoration(span.from + offset, span.to + offset, span.type));
    }
    return result;
  }
  function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
    function gather(set, oldOffset2) {
      for (let i2 = 0; i2 < set.local.length; i2++) {
        let mapped = set.local[i2].map(mapping, offset, oldOffset2);
        if (mapped)
          decorations.push(mapped);
        else if (options.onRemove)
          options.onRemove(set.local[i2].spec);
      }
      for (let i2 = 0; i2 < set.children.length; i2 += 3)
        gather(set.children[i2 + 2], set.children[i2] + oldOffset2 + 1);
    }
    for (let i2 = 0; i2 < children.length; i2 += 3)
      if (children[i2 + 1] == -1)
        gather(children[i2 + 2], oldChildren[i2] + oldOffset + 1);
    return decorations;
  }
  function takeSpansForNode(spans, node2, offset) {
    if (node2.isLeaf)
      return null;
    let end = offset + node2.nodeSize, found2 = null;
    for (let i2 = 0, span; i2 < spans.length; i2++) {
      if ((span = spans[i2]) && span.from > offset && span.to < end) {
        (found2 || (found2 = [])).push(span);
        spans[i2] = null;
      }
    }
    return found2;
  }
  function withoutNulls(array) {
    let result = [];
    for (let i2 = 0; i2 < array.length; i2++)
      if (array[i2] != null)
        result.push(array[i2]);
    return result;
  }
  function buildTree(spans, node2, offset, options) {
    let children = [], hasNulls = false;
    node2.forEach((childNode, localStart) => {
      let found2 = takeSpansForNode(spans, childNode, localStart + offset);
      if (found2) {
        hasNulls = true;
        let subtree = buildTree(found2, childNode, offset + localStart + 1, options);
        if (subtree != empty)
          children.push(localStart, localStart + childNode.nodeSize, subtree);
      }
    });
    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
    for (let i2 = 0; i2 < locals.length; i2++)
      if (!locals[i2].type.valid(node2, locals[i2])) {
        if (options.onRemove)
          options.onRemove(locals[i2].spec);
        locals.splice(i2--, 1);
      }
    return locals.length || children.length ? new DecorationSet(locals, children) : empty;
  }
  function byPos(a2, b) {
    return a2.from - b.from || a2.to - b.to;
  }
  function removeOverlap(spans) {
    let working = spans;
    for (let i2 = 0; i2 < working.length - 1; i2++) {
      let span = working[i2];
      if (span.from != span.to)
        for (let j = i2 + 1; j < working.length; j++) {
          let next = working[j];
          if (next.from == span.from) {
            if (next.to != span.to) {
              if (working == spans)
                working = spans.slice();
              working[j] = next.copy(next.from, span.to);
              insertAhead(working, j + 1, next.copy(span.to, next.to));
            }
            continue;
          } else {
            if (next.from < span.to) {
              if (working == spans)
                working = spans.slice();
              working[i2] = span.copy(span.from, next.from);
              insertAhead(working, j, span.copy(next.from, span.to));
            }
            break;
          }
        }
    }
    return working;
  }
  function insertAhead(array, i2, deco) {
    while (i2 < array.length && byPos(deco, array[i2]) > 0)
      i2++;
    array.splice(i2, 0, deco);
  }
  function viewDecorations(view) {
    let found2 = [];
    view.someProp("decorations", (f) => {
      let result = f(view.state);
      if (result && result != empty)
        found2.push(result);
    });
    if (view.cursorWrapper)
      found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
    return DecorationGroup.from(found2);
  }
  const observeOptions = {
    childList: true,
    characterData: true,
    characterDataOldValue: true,
    attributes: true,
    attributeOldValue: true,
    subtree: true
  };
  const useCharData = ie$1 && ie_version <= 11;
  class SelectionState {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    set(sel) {
      this.anchorNode = sel.anchorNode;
      this.anchorOffset = sel.anchorOffset;
      this.focusNode = sel.focusNode;
      this.focusOffset = sel.focusOffset;
    }
    clear() {
      this.anchorNode = this.focusNode = null;
    }
    eq(sel) {
      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
    }
  }
  class DOMObserver {
    constructor(view, handleDOMChange) {
      this.view = view;
      this.handleDOMChange = handleDOMChange;
      this.queue = [];
      this.flushingSoon = -1;
      this.observer = null;
      this.currentSelection = new SelectionState();
      this.onCharData = null;
      this.suppressingSelectionUpdates = false;
      this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
        for (let i2 = 0; i2 < mutations.length; i2++)
          this.queue.push(mutations[i2]);
        if (ie$1 && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (useCharData) {
        this.onCharData = (e) => {
          this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
          this.flushSoon();
        };
      }
      this.onSelectionChange = this.onSelectionChange.bind(this);
    }
    flushSoon() {
      if (this.flushingSoon < 0)
        this.flushingSoon = window.setTimeout(() => {
          this.flushingSoon = -1;
          this.flush();
        }, 20);
    }
    forceFlush() {
      if (this.flushingSoon > -1) {
        window.clearTimeout(this.flushingSoon);
        this.flushingSoon = -1;
        this.flush();
      }
    }
    start() {
      if (this.observer) {
        this.observer.takeRecords();
        this.observer.observe(this.view.dom, observeOptions);
      }
      if (this.onCharData)
        this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.connectSelection();
    }
    stop() {
      if (this.observer) {
        let take = this.observer.takeRecords();
        if (take.length) {
          for (let i2 = 0; i2 < take.length; i2++)
            this.queue.push(take[i2]);
          window.setTimeout(() => this.flush(), 20);
        }
        this.observer.disconnect();
      }
      if (this.onCharData)
        this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
      this.disconnectSelection();
    }
    connectSelection() {
      this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    }
    disconnectSelection() {
      this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    }
    suppressSelectionUpdates() {
      this.suppressingSelectionUpdates = true;
      setTimeout(() => this.suppressingSelectionUpdates = false, 50);
    }
    onSelectionChange() {
      if (!hasFocusAndSelection(this.view))
        return;
      if (this.suppressingSelectionUpdates)
        return selectionToDOM(this.view);
      if (ie$1 && ie_version <= 11 && !this.view.state.selection.empty) {
        let sel = this.view.domSelectionRange();
        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
    setCurSelection() {
      this.currentSelection.set(this.view.domSelectionRange());
    }
    ignoreSelectionChange(sel) {
      if (!sel.focusNode)
        return true;
      let ancestors = /* @__PURE__ */ new Set(), container;
      for (let scan = sel.focusNode; scan; scan = parentNode(scan))
        ancestors.add(scan);
      for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
        if (ancestors.has(scan)) {
          container = scan;
          break;
        }
      let desc = container && this.view.docView.nearestDesc(container);
      if (desc && desc.ignoreMutation({
        type: "selection",
        target: container.nodeType == 3 ? container.parentNode : container
      })) {
        this.setCurSelection();
        return true;
      }
    }
    pendingRecords() {
      if (this.observer)
        for (let mut of this.observer.takeRecords())
          this.queue.push(mut);
      return this.queue;
    }
    flush() {
      let { view } = this;
      if (!view.docView || this.flushingSoon > -1)
        return;
      let mutations = this.pendingRecords();
      if (mutations.length)
        this.queue = [];
      let sel = view.domSelectionRange();
      let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
      let from2 = -1, to = -1, typeOver = false, added = [];
      if (view.editable) {
        for (let i2 = 0; i2 < mutations.length; i2++) {
          let result = this.registerMutation(mutations[i2], added);
          if (result) {
            from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
            to = to < 0 ? result.to : Math.max(result.to, to);
            if (result.typeOver)
              typeOver = true;
          }
        }
      }
      if (gecko && added.length > 1) {
        let brs = added.filter((n) => n.nodeName == "BR");
        if (brs.length == 2) {
          let a2 = brs[0], b = brs[1];
          if (a2.parentNode && a2.parentNode.parentNode == b.parentNode)
            b.remove();
          else
            a2.remove();
        }
      }
      let readSel = null;
      if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
        view.input.lastFocus = 0;
        selectionToDOM(view);
        this.currentSelection.set(sel);
        view.scrollToSelection();
      } else if (from2 > -1 || newSel) {
        if (from2 > -1) {
          view.docView.markDirty(from2, to);
          checkCSS(view);
        }
        this.handleDOMChange(from2, to, typeOver, added);
        if (view.docView && view.docView.dirty)
          view.updateState(view.state);
        else if (!this.currentSelection.eq(sel))
          selectionToDOM(view);
        this.currentSelection.set(sel);
      }
    }
    registerMutation(mut, added) {
      if (added.indexOf(mut.target) > -1)
        return null;
      let desc = this.view.docView.nearestDesc(mut.target);
      if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
      mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
        return null;
      if (!desc || desc.ignoreMutation(mut))
        return null;
      if (mut.type == "childList") {
        for (let i2 = 0; i2 < mut.addedNodes.length; i2++)
          added.push(mut.addedNodes[i2]);
        if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
          return { from: desc.posBefore, to: desc.posAfter };
        let prev = mut.previousSibling, next = mut.nextSibling;
        if (ie$1 && ie_version <= 11 && mut.addedNodes.length) {
          for (let i2 = 0; i2 < mut.addedNodes.length; i2++) {
            let { previousSibling, nextSibling } = mut.addedNodes[i2];
            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
              prev = previousSibling;
            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
              next = nextSibling;
          }
        }
        let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
        let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
        let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
        let to = desc.localPosFromDOM(mut.target, toOffset, 1);
        return { from: from2, to };
      } else if (mut.type == "attributes") {
        return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
      } else {
        return {
          from: desc.posAtStart,
          to: desc.posAtEnd,
          // An event was generated for a text change that didn't change
          // any text. Mark the dom change to fall back to assuming the
          // selection was typed over with an identical value if it can't
          // find another change.
          typeOver: mut.target.nodeValue == mut.oldValue
        };
      }
    }
  }
  let cssChecked = /* @__PURE__ */ new WeakMap();
  let cssCheckWarned = false;
  function checkCSS(view) {
    if (cssChecked.has(view))
      return;
    cssChecked.set(view, null);
    if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
      view.requiresGeckoHackNode = gecko;
      if (cssCheckWarned)
        return;
      console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
      cssCheckWarned = true;
    }
  }
  function safariShadowSelectionRange(view) {
    let found2;
    function read(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found2 = event.getTargetRanges()[0];
    }
    view.dom.addEventListener("beforeinput", read, true);
    document.execCommand("indent");
    view.dom.removeEventListener("beforeinput", read, true);
    let anchorNode = found2.startContainer, anchorOffset = found2.startOffset;
    let focusNode = found2.endContainer, focusOffset = found2.endOffset;
    let currentAnchor = view.domAtPos(view.state.selection.anchor);
    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
  }
  function parseBetween(view, from_, to_) {
    let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
    let domSel = view.domSelectionRange();
    let find2;
    let anchor = domSel.anchorNode;
    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
      find2 = [{ node: anchor, offset: domSel.anchorOffset }];
      if (!selectionCollapsed(domSel))
        find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
    }
    if (chrome && view.input.lastKeyCode === 8) {
      for (let off = toOffset; off > fromOffset; off--) {
        let node2 = parent.childNodes[off - 1], desc = node2.pmViewDesc;
        if (node2.nodeName == "BR" && !desc) {
          toOffset = off;
          break;
        }
        if (!desc || desc.size)
          break;
      }
    }
    let startDoc = view.state.doc;
    let parser2 = view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
    let $from = startDoc.resolve(from2);
    let sel = null, doc2 = parser2.parse(parent, {
      topNode: $from.parent,
      topMatch: $from.parent.contentMatchAt($from.index()),
      topOpen: true,
      from: fromOffset,
      to: toOffset,
      preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
      findPositions: find2,
      ruleFromNode,
      context: $from
    });
    if (find2 && find2[0].pos != null) {
      let anchor2 = find2[0].pos, head2 = find2[1] && find2[1].pos;
      if (head2 == null)
        head2 = anchor2;
      sel = { anchor: anchor2 + from2, head: head2 + from2 };
    }
    return { doc: doc2, sel, from: from2, to };
  }
  function ruleFromNode(dom) {
    let desc = dom.pmViewDesc;
    if (desc) {
      return desc.parseRule();
    } else if (dom.nodeName == "BR" && dom.parentNode) {
      if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
        let skip = document.createElement("div");
        skip.appendChild(document.createElement("li"));
        return { skip };
      } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
        return { ignore: true };
      }
    } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
      return { ignore: true };
    }
    return null;
  }
  const isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
  function readDOMChange(view, from2, to, typeOver, addedNodes) {
    let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
    view.input.compositionPendingChanges = 0;
    if (from2 < 0) {
      let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
      let newSel = selectionFromDOM(view, origin);
      if (newSel && !view.state.selection.eq(newSel)) {
        if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
          return;
        let tr3 = view.state.tr.setSelection(newSel);
        if (origin == "pointer")
          tr3.setMeta("pointer", true);
        else if (origin == "key")
          tr3.scrollIntoView();
        if (compositionID)
          tr3.setMeta("composition", compositionID);
        view.dispatch(tr3);
      }
      return;
    }
    let $before = view.state.doc.resolve(from2);
    let shared = $before.sharedDepth(to);
    from2 = $before.before(shared + 1);
    to = view.state.doc.resolve(to).after(shared + 1);
    let sel = view.state.selection;
    let parse2 = parseBetween(view, from2, to);
    let doc2 = view.state.doc, compare = doc2.slice(parse2.from, parse2.to);
    let preferredPos, preferredSide;
    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
      preferredPos = view.state.selection.to;
      preferredSide = "end";
    } else {
      preferredPos = view.state.selection.from;
      preferredSide = "start";
    }
    view.input.lastKeyCode = null;
    let change = findDiff(compare.content, parse2.doc.content, parse2.from, preferredPos, preferredSide);
    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
      view.input.lastIOSEnter = 0;
      return;
    }
    if (!change) {
      if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse2.sel && parse2.sel.anchor != parse2.sel.head)) {
        change = { start: sel.from, endA: sel.to, endB: sel.to };
      } else {
        if (parse2.sel) {
          let sel2 = resolveSelection(view, view.state.doc, parse2.sel);
          if (sel2 && !sel2.eq(view.state.selection)) {
            let tr3 = view.state.tr.setSelection(sel2);
            if (compositionID)
              tr3.setMeta("composition", compositionID);
            view.dispatch(tr3);
          }
        }
        return;
      }
    }
    view.input.domChangeCount++;
    if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
      if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse2.from) {
        change.start = view.state.selection.from;
      } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse2.to) {
        change.endB += view.state.selection.to - change.endA;
        change.endA = view.state.selection.to;
      }
    }
    if (ie$1 && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse2.from && parse2.doc.textBetween(change.start - parse2.from - 1, change.start - parse2.from + 1) == "  ") {
      change.start--;
      change.endA--;
      change.endB--;
    }
    let $from = parse2.doc.resolveNoCache(change.start - parse2.from);
    let $to = parse2.doc.resolveNoCache(change.endB - parse2.from);
    let $fromA = doc2.resolve(change.start);
    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
    let nextSel;
    if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse2.doc.content.size && !$from.sameParent($to) && (nextSel = Selection.findFrom(parse2.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
      view.input.lastIOSEnter = 0;
      return;
    }
    if (view.state.selection.anchor > change.start && looksLikeBackspace(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
      if (android && chrome)
        view.domObserver.suppressSelectionUpdates();
      return;
    }
    if (chrome && android && change.endB == change.start)
      view.input.lastAndroidDelete = Date.now();
    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse2.sel && parse2.sel.anchor == parse2.sel.head && parse2.sel.head == change.endA) {
      change.endB -= 2;
      $to = parse2.doc.resolveNoCache(change.endB - parse2.from);
      setTimeout(() => {
        view.someProp("handleKeyDown", function(f) {
          return f(view, keyEvent(13, "Enter"));
        });
      }, 20);
    }
    let chFrom = change.start, chTo = change.endA;
    let tr2, storedMarks, markChange;
    if (inlineChange) {
      if ($from.pos == $to.pos) {
        if (ie$1 && ie_version <= 11 && $from.parentOffset == 0) {
          view.domObserver.suppressSelectionUpdates();
          setTimeout(() => selectionToDOM(view), 20);
        }
        tr2 = view.state.tr.delete(chFrom, chTo);
        storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
      } else if (
        // Adding or removing a mark
        change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
      ) {
        tr2 = view.state.tr;
        if (markChange.type == "add")
          tr2.addMark(chFrom, chTo, markChange.mark);
        else
          tr2.removeMark(chFrom, chTo, markChange.mark);
      } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
        let text2 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
        if (view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text2)))
          return;
        tr2 = view.state.tr.insertText(text2, chFrom, chTo);
      }
    }
    if (!tr2)
      tr2 = view.state.tr.replace(chFrom, chTo, parse2.doc.slice(change.start - parse2.from, change.endB - parse2.from));
    if (parse2.sel) {
      let sel2 = resolveSelection(view, tr2.doc, parse2.sel);
      if (sel2 && !(chrome && android && view.composing && sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr2.mapping.map(chTo) - 1) || ie$1 && sel2.empty && sel2.head == chFrom))
        tr2.setSelection(sel2);
    }
    if (storedMarks)
      tr2.ensureMarks(storedMarks);
    if (compositionID)
      tr2.setMeta("composition", compositionID);
    view.dispatch(tr2.scrollIntoView());
  }
  function resolveSelection(view, doc2, parsedSel) {
    if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size)
      return null;
    return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
  }
  function isMarkChange(cur, prev) {
    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
    let added = curMarks, removed = prevMarks, type, mark2, update;
    for (let i2 = 0; i2 < prevMarks.length; i2++)
      added = prevMarks[i2].removeFromSet(added);
    for (let i2 = 0; i2 < curMarks.length; i2++)
      removed = curMarks[i2].removeFromSet(removed);
    if (added.length == 1 && removed.length == 0) {
      mark2 = added[0];
      type = "add";
      update = (node2) => node2.mark(mark2.addToSet(node2.marks));
    } else if (added.length == 0 && removed.length == 1) {
      mark2 = removed[0];
      type = "remove";
      update = (node2) => node2.mark(mark2.removeFromSet(node2.marks));
    } else {
      return null;
    }
    let updated = [];
    for (let i2 = 0; i2 < prev.childCount; i2++)
      updated.push(update(prev.child(i2)));
    if (Fragment.from(updated).eq(cur))
      return { mark: mark2, type };
  }
  function looksLikeBackspace(old, start, end, $newStart, $newEnd) {
    if (
      // The content must have shrunk
      end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
      skipClosingAndOpening($newStart, true, false) < $newEnd.pos
    )
      return false;
    let $start = old.resolve(start);
    if (!$newStart.parent.isTextblock) {
      let after = $start.nodeAfter;
      return after != null && end == start + after.nodeSize;
    }
    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
      return false;
    let $next = old.resolve(skipClosingAndOpening($start, true, true));
    if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)
      return false;
    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
  }
  function skipClosingAndOpening($pos, fromEnd, mayOpen) {
    let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
    while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
      depth--;
      end++;
      fromEnd = false;
    }
    if (mayOpen) {
      let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
      while (next && !next.isLeaf) {
        next = next.firstChild;
        end++;
      }
    }
    return end;
  }
  function findDiff(a2, b, pos, preferredPos, preferredSide) {
    let start = a2.findDiffStart(b, pos);
    if (start == null)
      return null;
    let { a: endA, b: endB } = a2.findDiffEnd(b, pos + a2.size, pos + b.size);
    if (preferredSide == "end") {
      let adjust = Math.max(0, start - Math.min(endA, endB));
      preferredPos -= endA + adjust - start;
    }
    if (endA < start && a2.size < b.size) {
      let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
      start -= move;
      if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1)))
        start += move ? 1 : -1;
      endB = start + (endB - endA);
      endA = start;
    } else if (endB < start) {
      let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
      start -= move;
      if (start && start < a2.size && isSurrogatePair(a2.textBetween(start - 1, start + 1)))
        start += move ? 1 : -1;
      endA = start + (endA - endB);
      endB = start;
    }
    return { start, endA, endB };
  }
  function isSurrogatePair(str) {
    if (str.length != 2)
      return false;
    let a2 = str.charCodeAt(0), b = str.charCodeAt(1);
    return a2 >= 56320 && a2 <= 57343 && b >= 55296 && b <= 56319;
  }
  class EditorView {
    /**
    Create a view. `place` may be a DOM node that the editor should
    be appended to, a function that will place it into the document,
    or an object whose `mount` property holds the node to use as the
    document container. If it is `null`, the editor will not be
    added to the document.
    */
    constructor(place, props) {
      this._root = null;
      this.focused = false;
      this.trackWrites = null;
      this.mounted = false;
      this.markCursor = null;
      this.cursorWrapper = null;
      this.lastSelectedViewDesc = void 0;
      this.input = new InputState();
      this.prevDirectPlugins = [];
      this.pluginViews = [];
      this.requiresGeckoHackNode = false;
      this.dragging = null;
      this._props = props;
      this.state = props.state;
      this.directPlugins = props.plugins || [];
      this.directPlugins.forEach(checkStateComponent);
      this.dispatch = this.dispatch.bind(this);
      this.dom = place && place.mount || document.createElement("div");
      if (place) {
        if (place.appendChild)
          place.appendChild(this.dom);
        else if (typeof place == "function")
          place(this.dom);
        else if (place.mount)
          this.mounted = true;
      }
      this.editable = getEditable(this);
      updateCursorWrapper(this);
      this.nodeViews = buildNodeViews(this);
      this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
      this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
      this.domObserver.start();
      initInput(this);
      this.updatePluginViews();
    }
    /**
    Holds `true` when a
    [composition](https://w3c.github.io/uievents/#events-compositionevents)
    is active.
    */
    get composing() {
      return this.input.composing;
    }
    /**
    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
    */
    get props() {
      if (this._props.state != this.state) {
        let prev = this._props;
        this._props = {};
        for (let name in prev)
          this._props[name] = prev[name];
        this._props.state = this.state;
      }
      return this._props;
    }
    /**
    Update the view's props. Will immediately cause an update to
    the DOM.
    */
    update(props) {
      if (props.handleDOMEvents != this._props.handleDOMEvents)
        ensureListeners(this);
      let prevProps = this._props;
      this._props = props;
      if (props.plugins) {
        props.plugins.forEach(checkStateComponent);
        this.directPlugins = props.plugins;
      }
      this.updateStateInner(props.state, prevProps);
    }
    /**
    Update the view by updating existing props object with the object
    given as argument. Equivalent to `view.update(Object.assign({},
    view.props, props))`.
    */
    setProps(props) {
      let updated = {};
      for (let name in this._props)
        updated[name] = this._props[name];
      updated.state = this.state;
      for (let name in props)
        updated[name] = props[name];
      this.update(updated);
    }
    /**
    Update the editor's `state` prop, without touching any of the
    other props.
    */
    updateState(state) {
      this.updateStateInner(state, this._props);
    }
    updateStateInner(state, prevProps) {
      var _a;
      let prev = this.state, redraw = false, updateSel = false;
      if (state.storedMarks && this.composing) {
        clearComposition(this);
        updateSel = true;
      }
      this.state = state;
      let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
      if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
        let nodeViews = buildNodeViews(this);
        if (changedNodeViews(nodeViews, this.nodeViews)) {
          this.nodeViews = nodeViews;
          redraw = true;
        }
      }
      if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
        ensureListeners(this);
      }
      this.editable = getEditable(this);
      updateCursorWrapper(this);
      let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
      let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
      let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
      if (updateDoc || !state.selection.eq(prev.selection))
        updateSel = true;
      let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
      if (updateSel) {
        this.domObserver.stop();
        let forceSelUpdate = updateDoc && (ie$1 || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
        if (updateDoc) {
          let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
          if (this.composing)
            this.input.compositionNode = findCompositionNode(this);
          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
            this.docView.updateOuterDeco(outerDeco);
            this.docView.destroy();
            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
          }
          if (chromeKludge && !this.trackWrites)
            forceSelUpdate = true;
        }
        if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
          selectionToDOM(this, forceSelUpdate);
        } else {
          syncNodeSelection(this, state.selection);
          this.domObserver.setCurSelection();
        }
        this.domObserver.start();
      }
      this.updatePluginViews(prev);
      if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))
        this.updateDraggedNode(this.dragging, prev);
      if (scroll == "reset") {
        this.dom.scrollTop = 0;
      } else if (scroll == "to selection") {
        this.scrollToSelection();
      } else if (oldScrollPos) {
        resetScrollPos(oldScrollPos);
      }
    }
    /**
    @internal
    */
    scrollToSelection() {
      let startDOM = this.domSelectionRange().focusNode;
      if (this.someProp("handleScrollToSelection", (f) => f(this)))
        ;
      else if (this.state.selection instanceof NodeSelection) {
        let target = this.docView.domAfterPos(this.state.selection.from);
        if (target.nodeType == 1)
          scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
      } else {
        scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
      }
    }
    destroyPluginViews() {
      let view;
      while (view = this.pluginViews.pop())
        if (view.destroy)
          view.destroy();
    }
    updatePluginViews(prevState) {
      if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
        this.prevDirectPlugins = this.directPlugins;
        this.destroyPluginViews();
        for (let i2 = 0; i2 < this.directPlugins.length; i2++) {
          let plugin = this.directPlugins[i2];
          if (plugin.spec.view)
            this.pluginViews.push(plugin.spec.view(this));
        }
        for (let i2 = 0; i2 < this.state.plugins.length; i2++) {
          let plugin = this.state.plugins[i2];
          if (plugin.spec.view)
            this.pluginViews.push(plugin.spec.view(this));
        }
      } else {
        for (let i2 = 0; i2 < this.pluginViews.length; i2++) {
          let pluginView = this.pluginViews[i2];
          if (pluginView.update)
            pluginView.update(this, prevState);
        }
      }
    }
    updateDraggedNode(dragging, prev) {
      let sel = dragging.node, found2 = -1;
      if (this.state.doc.nodeAt(sel.from) == sel.node) {
        found2 = sel.from;
      } else {
        let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
        let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
        if (moved == sel.node)
          found2 = movedPos;
      }
      this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
    }
    someProp(propName, f) {
      let prop = this._props && this._props[propName], value;
      if (prop != null && (value = f ? f(prop) : prop))
        return value;
      for (let i2 = 0; i2 < this.directPlugins.length; i2++) {
        let prop2 = this.directPlugins[i2].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
      let plugins = this.state.plugins;
      if (plugins)
        for (let i2 = 0; i2 < plugins.length; i2++) {
          let prop2 = plugins[i2].props[propName];
          if (prop2 != null && (value = f ? f(prop2) : prop2))
            return value;
        }
    }
    /**
    Query whether the view has focus.
    */
    hasFocus() {
      if (ie$1) {
        let node2 = this.root.activeElement;
        if (node2 == this.dom)
          return true;
        if (!node2 || !this.dom.contains(node2))
          return false;
        while (node2 && this.dom != node2 && this.dom.contains(node2)) {
          if (node2.contentEditable == "false")
            return false;
          node2 = node2.parentElement;
        }
        return true;
      }
      return this.root.activeElement == this.dom;
    }
    /**
    Focus the editor.
    */
    focus() {
      this.domObserver.stop();
      if (this.editable)
        focusPreventScroll(this.dom);
      selectionToDOM(this);
      this.domObserver.start();
    }
    /**
    Get the document root in which the editor exists. This will
    usually be the top-level `document`, but might be a [shadow
    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
    root if the editor is inside one.
    */
    get root() {
      let cached = this._root;
      if (cached == null)
        for (let search2 = this.dom.parentNode; search2; search2 = search2.parentNode) {
          if (search2.nodeType == 9 || search2.nodeType == 11 && search2.host) {
            if (!search2.getSelection)
              Object.getPrototypeOf(search2).getSelection = () => search2.ownerDocument.getSelection();
            return this._root = search2;
          }
        }
      return cached || document;
    }
    /**
    When an existing editor view is moved to a new document or
    shadow tree, call this to make it recompute its root.
    */
    updateRoot() {
      this._root = null;
    }
    /**
    Given a pair of viewport coordinates, return the document
    position that corresponds to them. May return null if the given
    coordinates aren't inside of the editor. When an object is
    returned, its `pos` property is the position nearest to the
    coordinates, and its `inside` property holds the position of the
    inner node that the position falls inside of, or -1 if it is at
    the top level, not in any node.
    */
    posAtCoords(coords) {
      return posAtCoords(this, coords);
    }
    /**
    Returns the viewport rectangle at a given document position.
    `left` and `right` will be the same number, as this returns a
    flat cursor-ish rectangle. If the position is between two things
    that aren't directly adjacent, `side` determines which element
    is used. When < 0, the element before the position is used,
    otherwise the element after.
    */
    coordsAtPos(pos, side = 1) {
      return coordsAtPos(this, pos, side);
    }
    /**
    Find the DOM position that corresponds to the given document
    position. When `side` is negative, find the position as close as
    possible to the content before the position. When positive,
    prefer positions close to the content after the position. When
    zero, prefer as shallow a position as possible.
    
    Note that you should **not** mutate the editor's internal DOM,
    only inspect it (and even that is usually not necessary).
    */
    domAtPos(pos, side = 0) {
      return this.docView.domFromPos(pos, side);
    }
    /**
    Find the DOM node that represents the document node after the
    given position. May return `null` when the position doesn't point
    in front of a node or if the node is inside an opaque node view.
    
    This is intended to be able to call things like
    `getBoundingClientRect` on that DOM node. Do **not** mutate the
    editor DOM directly, or add styling this way, since that will be
    immediately overriden by the editor as it redraws the node.
    */
    nodeDOM(pos) {
      let desc = this.docView.descAt(pos);
      return desc ? desc.nodeDOM : null;
    }
    /**
    Find the document position that corresponds to a given DOM
    position. (Whenever possible, it is preferable to inspect the
    document structure directly, rather than poking around in the
    DOM, but sometimes—for example when interpreting an event
    target—you don't have a choice.)
    
    The `bias` parameter can be used to influence which side of a DOM
    node to use when the position is inside a leaf node.
    */
    posAtDOM(node2, offset, bias = -1) {
      let pos = this.docView.posFromDOM(node2, offset, bias);
      if (pos == null)
        throw new RangeError("DOM position not inside the editor");
      return pos;
    }
    /**
    Find out whether the selection is at the end of a textblock when
    moving in a given direction. When, for example, given `"left"`,
    it will return true if moving left from the current cursor
    position would leave that position's parent textblock. Will apply
    to the view's current state by default, but it is possible to
    pass a different state.
    */
    endOfTextblock(dir, state) {
      return endOfTextblock(this, state || this.state, dir);
    }
    /**
    Run the editor's paste logic with the given HTML string. The
    `event`, if given, will be passed to the
    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
    */
    pasteHTML(html2, event) {
      return doPaste(this, "", html2, false, event || new ClipboardEvent("paste"));
    }
    /**
    Run the editor's paste logic with the given plain-text input.
    */
    pasteText(text2, event) {
      return doPaste(this, text2, null, true, event || new ClipboardEvent("paste"));
    }
    /**
    Removes the editor from the DOM and destroys all [node
    views](https://prosemirror.net/docs/ref/#view.NodeView).
    */
    destroy() {
      if (!this.docView)
        return;
      destroyInput(this);
      this.destroyPluginViews();
      if (this.mounted) {
        this.docView.update(this.state.doc, [], viewDecorations(this), this);
        this.dom.textContent = "";
      } else if (this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }
      this.docView.destroy();
      this.docView = null;
      clearReusedRange();
    }
    /**
    This is true when the view has been
    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
    used anymore).
    */
    get isDestroyed() {
      return this.docView == null;
    }
    /**
    Used for testing.
    */
    dispatchEvent(event) {
      return dispatchEvent(this, event);
    }
    /**
    Dispatch a transaction. Will call
    [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
    when given, and otherwise defaults to applying the transaction to
    the current state and calling
    [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
    This method is bound to the view instance, so that it can be
    easily passed around.
    */
    dispatch(tr2) {
      let dispatchTransaction = this._props.dispatchTransaction;
      if (dispatchTransaction)
        dispatchTransaction.call(this, tr2);
      else
        this.updateState(this.state.apply(tr2));
    }
    /**
    @internal
    */
    domSelectionRange() {
      return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom ? safariShadowSelectionRange(this) : this.domSelection();
    }
    /**
    @internal
    */
    domSelection() {
      return this.root.getSelection();
    }
  }
  function computeDocDeco(view) {
    let attrs = /* @__PURE__ */ Object.create(null);
    attrs.class = "ProseMirror";
    attrs.contenteditable = String(view.editable);
    view.someProp("attributes", (value) => {
      if (typeof value == "function")
        value = value(view.state);
      if (value)
        for (let attr in value) {
          if (attr == "class")
            attrs.class += " " + value[attr];
          else if (attr == "style")
            attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
          else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
            attrs[attr] = String(value[attr]);
        }
    });
    if (!attrs.translate)
      attrs.translate = "no";
    return [Decoration.node(0, view.state.doc.content.size, attrs)];
  }
  function updateCursorWrapper(view) {
    if (view.markCursor) {
      let dom = document.createElement("img");
      dom.className = "ProseMirror-separator";
      dom.setAttribute("mark-placeholder", "true");
      dom.setAttribute("alt", "");
      view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
    } else {
      view.cursorWrapper = null;
    }
  }
  function getEditable(view) {
    return !view.someProp("editable", (value) => value(view.state) === false);
  }
  function selectionContextChanged(sel1, sel2) {
    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
  }
  function buildNodeViews(view) {
    let result = /* @__PURE__ */ Object.create(null);
    function add(obj) {
      for (let prop in obj)
        if (!Object.prototype.hasOwnProperty.call(result, prop))
          result[prop] = obj[prop];
    }
    view.someProp("nodeViews", add);
    view.someProp("markViews", add);
    return result;
  }
  function changedNodeViews(a2, b) {
    let nA = 0, nB = 0;
    for (let prop in a2) {
      if (a2[prop] != b[prop])
        return true;
      nA++;
    }
    for (let _ in b)
      nB++;
    return nA != nB;
  }
  function checkStateComponent(plugin) {
    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
      throw new RangeError("Plugins passed directly to the view must not have a state component");
  }
  var base$1 = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  for (var i$1 = 0; i$1 < 10; i$1++)
    base$1[48 + i$1] = base$1[96 + i$1] = String(i$1);
  for (var i$1 = 1; i$1 <= 24; i$1++)
    base$1[i$1 + 111] = "F" + i$1;
  for (var i$1 = 65; i$1 <= 90; i$1++) {
    base$1[i$1] = String.fromCharCode(i$1 + 32);
    shift[i$1] = String.fromCharCode(i$1);
  }
  for (var code$5 in base$1)
    if (!shift.hasOwnProperty(code$5))
      shift[code$5] = base$1[code$5];
  function keyName(event) {
    var ignoreKey = mac$1 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name = !ignoreKey && event.key || (event.shiftKey ? shift : base$1)[event.keyCode] || event.key || "Unidentified";
    if (name == "Esc")
      name = "Escape";
    if (name == "Del")
      name = "Delete";
    if (name == "Left")
      name = "ArrowLeft";
    if (name == "Up")
      name = "ArrowUp";
    if (name == "Right")
      name = "ArrowRight";
    if (name == "Down")
      name = "ArrowDown";
    return name;
  }
  const mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
  function normalizeKeyName$1(name) {
    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt, ctrl, shift2, meta2;
    for (let i2 = 0; i2 < parts.length - 1; i2++) {
      let mod = parts[i2];
      if (/^(cmd|meta|m)$/i.test(mod))
        meta2 = true;
      else if (/^a(lt)?$/i.test(mod))
        alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod))
        shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (mac)
          meta2 = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta2)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function normalize(map2) {
    let copy2 = /* @__PURE__ */ Object.create(null);
    for (let prop in map2)
      copy2[normalizeKeyName$1(prop)] = map2[prop];
    return copy2;
  }
  function modifiers(name, event, shift2 = true) {
    if (event.altKey)
      name = "Alt-" + name;
    if (event.ctrlKey)
      name = "Ctrl-" + name;
    if (event.metaKey)
      name = "Meta-" + name;
    if (shift2 && event.shiftKey)
      name = "Shift-" + name;
    return name;
  }
  function keymap(bindings) {
    return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
  }
  function keydownHandler(bindings) {
    let map2 = normalize(bindings);
    return function(view, event) {
      let name = keyName(event), baseName, direct = map2[modifiers(name, event)];
      if (direct && direct(view.state, view.dispatch, view))
        return true;
      if (name.length == 1 && name != " ") {
        if (event.shiftKey) {
          let noShift = map2[modifiers(name, event, false)];
          if (noShift && noShift(view.state, view.dispatch, view))
            return true;
        }
        if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base$1[event.keyCode]) && baseName != name) {
          let fromCode = map2[modifiers(baseName, event)];
          if (fromCode && fromCode(view.state, view.dispatch, view))
            return true;
        }
      }
      return false;
    };
  }
  const deleteSelection$1 = (state, dispatch) => {
    if (state.selection.empty)
      return false;
    if (dispatch)
      dispatch(state.tr.deleteSelection().scrollIntoView());
    return true;
  };
  function atBlockStart(state, view) {
    let { $cursor } = state.selection;
    if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
      return null;
    return $cursor;
  }
  const joinBackward$1 = (state, dispatch, view) => {
    let $cursor = atBlockStart(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutBefore($cursor);
    if (!$cut) {
      let range = $cursor.blockRange(), target = range && liftTarget(range);
      if (target == null)
        return false;
      if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    let before = $cut.nodeBefore;
    if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
      return true;
    if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
      let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr2 = state.tr.step(delStep);
          tr2.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr2.doc, $cut.pos - before.nodeSize));
          dispatch(tr2.scrollIntoView());
        }
        return true;
      }
    }
    if (before.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch)
        dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
      return true;
    }
    return false;
  };
  const joinTextblockBackward$1 = (state, dispatch, view) => {
    let $cursor = atBlockStart(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutBefore($cursor);
    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
  };
  const joinTextblockForward$1 = (state, dispatch, view) => {
    let $cursor = atBlockEnd(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutAfter($cursor);
    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
  };
  function joinTextblocksAround(state, $cut, dispatch) {
    let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
    for (; !beforeText.isTextblock; beforePos--) {
      if (beforeText.type.spec.isolating)
        return false;
      let child = beforeText.lastChild;
      if (!child)
        return false;
      beforeText = child;
    }
    let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
    for (; !afterText.isTextblock; afterPos++) {
      if (afterText.type.spec.isolating)
        return false;
      let child = afterText.firstChild;
      if (!child)
        return false;
      afterText = child;
    }
    let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
    if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
      return false;
    if (dispatch) {
      let tr2 = state.tr.step(step);
      tr2.setSelection(TextSelection.create(tr2.doc, beforePos));
      dispatch(tr2.scrollIntoView());
    }
    return true;
  }
  function textblockAt(node2, side, only = false) {
    for (let scan = node2; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
      if (scan.isTextblock)
        return true;
      if (only && scan.childCount != 1)
        return false;
    }
    return false;
  }
  const selectNodeBackward$1 = (state, dispatch, view) => {
    let { $head, empty: empty2 } = state.selection, $cut = $head;
    if (!empty2)
      return false;
    if ($head.parent.isTextblock) {
      if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
        return false;
      $cut = findCutBefore($head);
    }
    let node2 = $cut && $cut.nodeBefore;
    if (!node2 || !NodeSelection.isSelectable(node2))
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node2.nodeSize)).scrollIntoView());
    return true;
  };
  function findCutBefore($pos) {
    if (!$pos.parent.type.spec.isolating)
      for (let i2 = $pos.depth - 1; i2 >= 0; i2--) {
        if ($pos.index(i2) > 0)
          return $pos.doc.resolve($pos.before(i2 + 1));
        if ($pos.node(i2).type.spec.isolating)
          break;
      }
    return null;
  }
  function atBlockEnd(state, view) {
    let { $cursor } = state.selection;
    if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
      return null;
    return $cursor;
  }
  const joinForward$1 = (state, dispatch, view) => {
    let $cursor = atBlockEnd(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutAfter($cursor);
    if (!$cut)
      return false;
    let after = $cut.nodeAfter;
    if (deleteBarrier(state, $cut, dispatch))
      return true;
    if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
      let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr2 = state.tr.step(delStep);
          tr2.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos)), 1) : NodeSelection.create(tr2.doc, tr2.mapping.map($cut.pos)));
          dispatch(tr2.scrollIntoView());
        }
        return true;
      }
    }
    if (after.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch)
        dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
      return true;
    }
    return false;
  };
  const selectNodeForward$1 = (state, dispatch, view) => {
    let { $head, empty: empty2 } = state.selection, $cut = $head;
    if (!empty2)
      return false;
    if ($head.parent.isTextblock) {
      if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
        return false;
      $cut = findCutAfter($head);
    }
    let node2 = $cut && $cut.nodeAfter;
    if (!node2 || !NodeSelection.isSelectable(node2))
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
    return true;
  };
  function findCutAfter($pos) {
    if (!$pos.parent.type.spec.isolating)
      for (let i2 = $pos.depth - 1; i2 >= 0; i2--) {
        let parent = $pos.node(i2);
        if ($pos.index(i2) + 1 < parent.childCount)
          return $pos.doc.resolve($pos.after(i2 + 1));
        if (parent.type.spec.isolating)
          break;
      }
    return null;
  }
  const joinUp$1 = (state, dispatch) => {
    let sel = state.selection, nodeSel = sel instanceof NodeSelection, point2;
    if (nodeSel) {
      if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
        return false;
      point2 = sel.from;
    } else {
      point2 = joinPoint(state.doc, sel.from, -1);
      if (point2 == null)
        return false;
    }
    if (dispatch) {
      let tr2 = state.tr.join(point2);
      if (nodeSel)
        tr2.setSelection(NodeSelection.create(tr2.doc, point2 - state.doc.resolve(point2).nodeBefore.nodeSize));
      dispatch(tr2.scrollIntoView());
    }
    return true;
  };
  const joinDown$1 = (state, dispatch) => {
    let sel = state.selection, point2;
    if (sel instanceof NodeSelection) {
      if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
        return false;
      point2 = sel.to;
    } else {
      point2 = joinPoint(state.doc, sel.to, 1);
      if (point2 == null)
        return false;
    }
    if (dispatch)
      dispatch(state.tr.join(point2).scrollIntoView());
    return true;
  };
  const lift$1 = (state, dispatch) => {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  };
  const newlineInCode$1 = (state, dispatch) => {
    let { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
      return false;
    if (dispatch)
      dispatch(state.tr.insertText("\n").scrollIntoView());
    return true;
  };
  function defaultBlockAt$1(match) {
    for (let i2 = 0; i2 < match.edgeCount; i2++) {
      let { type } = match.edge(i2);
      if (type.isTextblock && !type.hasRequiredAttrs())
        return type;
    }
    return null;
  }
  const exitCode$1 = (state, dispatch) => {
    let { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
      return false;
    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt$1(above.contentMatchAt(after));
    if (!type || !above.canReplaceWith(after, after, type))
      return false;
    if (dispatch) {
      let pos = $head.after(), tr2 = state.tr.replaceWith(pos, pos, type.createAndFill());
      tr2.setSelection(Selection.near(tr2.doc.resolve(pos), 1));
      dispatch(tr2.scrollIntoView());
    }
    return true;
  };
  const createParagraphNear$1 = (state, dispatch) => {
    let sel = state.selection, { $from, $to } = sel;
    if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
      return false;
    let type = defaultBlockAt$1($to.parent.contentMatchAt($to.indexAfter()));
    if (!type || !type.isTextblock)
      return false;
    if (dispatch) {
      let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
      let tr2 = state.tr.insert(side, type.createAndFill());
      tr2.setSelection(TextSelection.create(tr2.doc, side + 1));
      dispatch(tr2.scrollIntoView());
    }
    return true;
  };
  const liftEmptyBlock$1 = (state, dispatch) => {
    let { $cursor } = state.selection;
    if (!$cursor || $cursor.parent.content.size)
      return false;
    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
      let before = $cursor.before();
      if (canSplit(state.doc, before)) {
        if (dispatch)
          dispatch(state.tr.split(before).scrollIntoView());
        return true;
      }
    }
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  };
  const selectParentNode$1 = (state, dispatch) => {
    let { $from, to } = state.selection, pos;
    let same = $from.sharedDepth(to);
    if (same == 0)
      return false;
    pos = $from.before(same);
    if (dispatch)
      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
    return true;
  };
  function joinMaybeClear(state, $pos, dispatch) {
    let before = $pos.nodeBefore, after = $pos.nodeAfter, index2 = $pos.index();
    if (!before || !after || !before.type.compatibleContent(after.type))
      return false;
    if (!before.content.size && $pos.parent.canReplace(index2 - 1, index2)) {
      if (dispatch)
        dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
      return true;
    }
    if (!$pos.parent.canReplace(index2, index2 + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
      return false;
    if (dispatch)
      dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
    return true;
  }
  function deleteBarrier(state, $cut, dispatch) {
    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
    if (before.type.spec.isolating || after.type.spec.isolating)
      return false;
    if (joinMaybeClear(state, $cut, dispatch))
      return true;
    let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
    if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
      if (dispatch) {
        let end = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
        for (let i2 = conn.length - 1; i2 >= 0; i2--)
          wrap2 = Fragment.from(conn[i2].create(null, wrap2));
        wrap2 = Fragment.from(before.copy(wrap2));
        let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));
        let joinAt = end + 2 * conn.length;
        if (canJoin(tr2.doc, joinAt))
          tr2.join(joinAt);
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
    let selAfter = Selection.findFrom($cut, 1);
    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
    if (target != null && target >= $cut.depth) {
      if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
      let at = before, wrap2 = [];
      for (; ; ) {
        wrap2.push(at);
        if (at.isTextblock)
          break;
        at = at.lastChild;
      }
      let afterText = after, afterDepth = 1;
      for (; !afterText.isTextblock; afterText = afterText.firstChild)
        afterDepth++;
      if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
        if (dispatch) {
          let end = Fragment.empty;
          for (let i2 = wrap2.length - 1; i2 >= 0; i2--)
            end = Fragment.from(wrap2[i2].copy(end));
          let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));
          dispatch(tr2.scrollIntoView());
        }
        return true;
      }
    }
    return false;
  }
  function selectTextblockSide(side) {
    return function(state, dispatch) {
      let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
      let depth = $pos.depth;
      while ($pos.node(depth).isInline) {
        if (!depth)
          return false;
        depth--;
      }
      if (!$pos.node(depth).isTextblock)
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
      return true;
    };
  }
  const selectTextblockStart$1 = selectTextblockSide(-1);
  const selectTextblockEnd$1 = selectTextblockSide(1);
  function wrapIn$1(nodeType, attrs = null) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
      if (!wrapping)
        return false;
      if (dispatch)
        dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
      return true;
    };
  }
  function setBlockType(nodeType, attrs = null) {
    return function(state, dispatch) {
      let applicable = false;
      for (let i2 = 0; i2 < state.selection.ranges.length && !applicable; i2++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i2];
        state.doc.nodesBetween(from2, to, (node2, pos) => {
          if (applicable)
            return false;
          if (!node2.isTextblock || node2.hasMarkup(nodeType, attrs))
            return;
          if (node2.type == nodeType) {
            applicable = true;
          } else {
            let $pos = state.doc.resolve(pos), index2 = $pos.index();
            applicable = $pos.parent.canReplaceWith(index2, index2 + 1, nodeType);
          }
        });
      }
      if (!applicable)
        return false;
      if (dispatch) {
        let tr2 = state.tr;
        for (let i2 = 0; i2 < state.selection.ranges.length; i2++) {
          let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i2];
          tr2.setBlockType(from2, to, nodeType, attrs);
        }
        dispatch(tr2.scrollIntoView());
      }
      return true;
    };
  }
  typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
  function wrapInList$1(listType, attrs = null) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to), doJoin = false, outerRange = range;
      if (!range)
        return false;
      if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
        if ($from.index(range.depth - 1) == 0)
          return false;
        let $insert = state.doc.resolve(range.start - 2);
        outerRange = new NodeRange($insert, $insert, range.depth);
        if (range.endIndex < range.parent.childCount)
          range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
        doJoin = true;
      }
      let wrap2 = findWrapping(outerRange, listType, attrs, range);
      if (!wrap2)
        return false;
      if (dispatch)
        dispatch(doWrapInList(state.tr, range, wrap2, doJoin, listType).scrollIntoView());
      return true;
    };
  }
  function doWrapInList(tr2, range, wrappers, joinBefore, listType) {
    let content2 = Fragment.empty;
    for (let i2 = wrappers.length - 1; i2 >= 0; i2--)
      content2 = Fragment.from(wrappers[i2].type.create(wrappers[i2].attrs, content2));
    tr2.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content2, 0, 0), wrappers.length, true));
    let found2 = 0;
    for (let i2 = 0; i2 < wrappers.length; i2++)
      if (wrappers[i2].type == listType)
        found2 = i2 + 1;
    let splitDepth = wrappers.length - found2;
    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
    for (let i2 = range.startIndex, e = range.endIndex, first2 = true; i2 < e; i2++, first2 = false) {
      if (!first2 && canSplit(tr2.doc, splitPos, splitDepth)) {
        tr2.split(splitPos, splitDepth);
        splitPos += 2 * splitDepth;
      }
      splitPos += parent.child(i2).nodeSize;
    }
    return tr2;
  }
  function liftListItem$1(itemType) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to, (node2) => node2.childCount > 0 && node2.firstChild.type == itemType);
      if (!range)
        return false;
      if (!dispatch)
        return true;
      if ($from.node(range.depth - 1).type == itemType)
        return liftToOuterList(state, dispatch, itemType, range);
      else
        return liftOutOfList(state, dispatch, range);
    };
  }
  function liftToOuterList(state, dispatch, itemType, range) {
    let tr2 = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
    if (end < endOfList) {
      tr2.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
      range = new NodeRange(tr2.doc.resolve(range.$from.pos), tr2.doc.resolve(endOfList), range.depth);
    }
    const target = liftTarget(range);
    if (target == null)
      return false;
    tr2.lift(range, target);
    let after = tr2.mapping.map(end, -1) - 1;
    if (canJoin(tr2.doc, after))
      tr2.join(after);
    dispatch(tr2.scrollIntoView());
    return true;
  }
  function liftOutOfList(state, dispatch, range) {
    let tr2 = state.tr, list2 = range.parent;
    for (let pos = range.end, i2 = range.endIndex - 1, e = range.startIndex; i2 > e; i2--) {
      pos -= list2.child(i2).nodeSize;
      tr2.delete(pos - 1, pos + 1);
    }
    let $start = tr2.doc.resolve(range.start), item = $start.nodeAfter;
    if (tr2.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
      return false;
    let atStart = range.startIndex == 0, atEnd = range.endIndex == list2.childCount;
    let parent = $start.node(-1), indexBefore = $start.index(-1);
    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list2))))
      return false;
    let start = $start.pos, end = start + item.nodeSize;
    tr2.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list2.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list2.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
    dispatch(tr2.scrollIntoView());
    return true;
  }
  function sinkListItem$1(itemType) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to, (node2) => node2.childCount > 0 && node2.firstChild.type == itemType);
      if (!range)
        return false;
      let startIndex = range.startIndex;
      if (startIndex == 0)
        return false;
      let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
      if (nodeBefore.type != itemType)
        return false;
      if (dispatch) {
        let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
        let inner = Fragment.from(nestedBefore ? itemType.create() : null);
        let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
        let before = range.start, after = range.end;
        dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());
      }
      return true;
    };
  }
  function createChainableState(config) {
    const { state, transaction } = config;
    let { selection } = transaction;
    let { doc: doc2 } = transaction;
    let { storedMarks } = transaction;
    return {
      ...state,
      apply: state.apply.bind(state),
      applyTransaction: state.applyTransaction.bind(state),
      plugins: state.plugins,
      schema: state.schema,
      reconfigure: state.reconfigure.bind(state),
      toJSON: state.toJSON.bind(state),
      get storedMarks() {
        return storedMarks;
      },
      get selection() {
        return selection;
      },
      get doc() {
        return doc2;
      },
      get tr() {
        selection = transaction.selection;
        doc2 = transaction.doc;
        storedMarks = transaction.storedMarks;
        return transaction;
      }
    };
  }
  class CommandManager {
    constructor(props) {
      this.editor = props.editor;
      this.rawCommands = this.editor.extensionManager.commands;
      this.customState = props.state;
    }
    get hasCustomState() {
      return !!this.customState;
    }
    get state() {
      return this.customState || this.editor.state;
    }
    get commands() {
      const { rawCommands, editor: editor2, state } = this;
      const { view } = editor2;
      const { tr: tr2 } = state;
      const props = this.buildProps(tr2);
      return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const method = (...args) => {
          const callback = command2(...args)(props);
          if (!tr2.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr2);
          }
          return callback;
        };
        return [name, method];
      }));
    }
    get chain() {
      return () => this.createChain();
    }
    get can() {
      return () => this.createCan();
    }
    createChain(startTr, shouldDispatch = true) {
      const { rawCommands, editor: editor2, state } = this;
      const { view } = editor2;
      const callbacks = [];
      const hasStartTransaction = !!startTr;
      const tr2 = startTr || state.tr;
      const run2 = () => {
        if (!hasStartTransaction && shouldDispatch && !tr2.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr2);
        }
        return callbacks.every((callback) => callback === true);
      };
      const chain = {
        ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          const chainedCommand = (...args) => {
            const props = this.buildProps(tr2, shouldDispatch);
            const callback = command2(...args)(props);
            callbacks.push(callback);
            return chain;
          };
          return [name, chainedCommand];
        })),
        run: run2
      };
      return chain;
    }
    createCan(startTr) {
      const { rawCommands, state } = this;
      const dispatch = false;
      const tr2 = startTr || state.tr;
      const props = this.buildProps(tr2, dispatch);
      const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
      }));
      return {
        ...formattedCommands,
        chain: () => this.createChain(tr2, dispatch)
      };
    }
    buildProps(tr2, shouldDispatch = true) {
      const { rawCommands, editor: editor2, state } = this;
      const { view } = editor2;
      const props = {
        tr: tr2,
        editor: editor2,
        view,
        state: createChainableState({
          state,
          transaction: tr2
        }),
        dispatch: shouldDispatch ? () => void 0 : void 0,
        chain: () => this.createChain(tr2, shouldDispatch),
        can: () => this.createCan(tr2),
        get commands() {
          return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args) => command2(...args)(props)];
          }));
        }
      };
      return props;
    }
  }
  let EventEmitter$1 = class EventEmitter {
    constructor() {
      this.callbacks = {};
    }
    on(event, fn) {
      if (!this.callbacks[event]) {
        this.callbacks[event] = [];
      }
      this.callbacks[event].push(fn);
      return this;
    }
    emit(event, ...args) {
      const callbacks = this.callbacks[event];
      if (callbacks) {
        callbacks.forEach((callback) => callback.apply(this, args));
      }
      return this;
    }
    off(event, fn) {
      const callbacks = this.callbacks[event];
      if (callbacks) {
        if (fn) {
          this.callbacks[event] = callbacks.filter((callback) => callback !== fn);
        } else {
          delete this.callbacks[event];
        }
      }
      return this;
    }
    removeAllListeners() {
      this.callbacks = {};
    }
  };
  function getExtensionField(extension2, field, context) {
    if (extension2.config[field] === void 0 && extension2.parent) {
      return getExtensionField(extension2.parent, field, context);
    }
    if (typeof extension2.config[field] === "function") {
      const value = extension2.config[field].bind({
        ...context,
        parent: extension2.parent ? getExtensionField(extension2.parent, field, context) : null
      });
      return value;
    }
    return extension2.config[field];
  }
  function splitExtensions(extensions2) {
    const baseExtensions = extensions2.filter((extension2) => extension2.type === "extension");
    const nodeExtensions = extensions2.filter((extension2) => extension2.type === "node");
    const markExtensions = extensions2.filter((extension2) => extension2.type === "mark");
    return {
      baseExtensions,
      nodeExtensions,
      markExtensions
    };
  }
  function getAttributesFromExtensions(extensions2) {
    const extensionAttributes = [];
    const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
    const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
    const defaultAttribute = {
      default: null,
      rendered: true,
      renderHTML: null,
      parseHTML: null,
      keepOnSplit: true,
      isRequired: false
    };
    extensions2.forEach((extension2) => {
      const context = {
        name: extension2.name,
        options: extension2.options,
        storage: extension2.storage
      };
      const addGlobalAttributes = getExtensionField(extension2, "addGlobalAttributes", context);
      if (!addGlobalAttributes) {
        return;
      }
      const globalAttributes = addGlobalAttributes();
      globalAttributes.forEach((globalAttribute) => {
        globalAttribute.types.forEach((type) => {
          Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
            extensionAttributes.push({
              type,
              name,
              attribute: {
                ...defaultAttribute,
                ...attribute
              }
            });
          });
        });
      });
    });
    nodeAndMarkExtensions.forEach((extension2) => {
      const context = {
        name: extension2.name,
        options: extension2.options,
        storage: extension2.storage
      };
      const addAttributes = getExtensionField(extension2, "addAttributes", context);
      if (!addAttributes) {
        return;
      }
      const attributes = addAttributes();
      Object.entries(attributes).forEach(([name, attribute]) => {
        const mergedAttr = {
          ...defaultAttribute,
          ...attribute
        };
        if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
          mergedAttr.default = mergedAttr.default();
        }
        if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
          delete mergedAttr.default;
        }
        extensionAttributes.push({
          type: extension2.name,
          name,
          attribute: mergedAttr
        });
      });
    });
    return extensionAttributes;
  }
  function getNodeType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.nodes[nameOrType]) {
        throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
      }
      return schema.nodes[nameOrType];
    }
    return nameOrType;
  }
  function mergeAttributes(...objects) {
    return objects.filter((item) => !!item).reduce((items, item) => {
      const mergedAttributes = { ...items };
      Object.entries(item).forEach(([key2, value]) => {
        const exists = mergedAttributes[key2];
        if (!exists) {
          mergedAttributes[key2] = value;
          return;
        }
        if (key2 === "class") {
          const valueClasses = value ? value.split(" ") : [];
          const existingClasses = mergedAttributes[key2] ? mergedAttributes[key2].split(" ") : [];
          const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
          mergedAttributes[key2] = [...existingClasses, ...insertClasses].join(" ");
        } else if (key2 === "style") {
          mergedAttributes[key2] = [mergedAttributes[key2], value].join("; ");
        } else {
          mergedAttributes[key2] = value;
        }
      });
      return mergedAttributes;
    }, {});
  }
  function getRenderedAttributes(nodeOrMark, extensionAttributes) {
    return extensionAttributes.filter((item) => item.attribute.rendered).map((item) => {
      if (!item.attribute.renderHTML) {
        return {
          [item.name]: nodeOrMark.attrs[item.name]
        };
      }
      return item.attribute.renderHTML(nodeOrMark.attrs) || {};
    }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function callOrReturn(value, context = void 0, ...props) {
    if (isFunction(value)) {
      if (context) {
        return value.bind(context)(...props);
      }
      return value(...props);
    }
    return value;
  }
  function isEmptyObject(value = {}) {
    return Object.keys(value).length === 0 && value.constructor === Object;
  }
  function fromString(value) {
    if (typeof value !== "string") {
      return value;
    }
    if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
      return Number(value);
    }
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    return value;
  }
  function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
    if (parseRule.style) {
      return parseRule;
    }
    return {
      ...parseRule,
      getAttrs: (node2) => {
        const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node2) : parseRule.attrs;
        if (oldAttributes === false) {
          return false;
        }
        const newAttributes = extensionAttributes.reduce((items, item) => {
          const value = item.attribute.parseHTML ? item.attribute.parseHTML(node2) : fromString(node2.getAttribute(item.name));
          if (value === null || value === void 0) {
            return items;
          }
          return {
            ...items,
            [item.name]: value
          };
        }, {});
        return { ...oldAttributes, ...newAttributes };
      }
    };
  }
  function cleanUpSchemaItem(data) {
    return Object.fromEntries(
      // @ts-ignore
      Object.entries(data).filter(([key2, value]) => {
        if (key2 === "attrs" && isEmptyObject(value)) {
          return false;
        }
        return value !== null && value !== void 0;
      })
    );
  }
  function getSchemaByResolvedExtensions(extensions2, editor2) {
    var _a;
    const allAttributes = getAttributesFromExtensions(extensions2);
    const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
    const topNode = (_a = nodeExtensions.find((extension2) => getExtensionField(extension2, "topNode"))) === null || _a === void 0 ? void 0 : _a.name;
    const nodes = Object.fromEntries(nodeExtensions.map((extension2) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension2.name);
      const context = {
        name: extension2.name,
        options: extension2.options,
        storage: extension2.storage,
        editor: editor2
      };
      const extraNodeFields = extensions2.reduce((fields, e) => {
        const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
        return {
          ...fields,
          ...extendNodeSchema ? extendNodeSchema(extension2) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraNodeFields,
        content: callOrReturn(getExtensionField(extension2, "content", context)),
        marks: callOrReturn(getExtensionField(extension2, "marks", context)),
        group: callOrReturn(getExtensionField(extension2, "group", context)),
        inline: callOrReturn(getExtensionField(extension2, "inline", context)),
        atom: callOrReturn(getExtensionField(extension2, "atom", context)),
        selectable: callOrReturn(getExtensionField(extension2, "selectable", context)),
        draggable: callOrReturn(getExtensionField(extension2, "draggable", context)),
        code: callOrReturn(getExtensionField(extension2, "code", context)),
        defining: callOrReturn(getExtensionField(extension2, "defining", context)),
        isolating: callOrReturn(getExtensionField(extension2, "isolating", context)),
        attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
          var _a2;
          return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
        }))
      });
      const parseHTML = callOrReturn(getExtensionField(extension2, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
      }
      const renderHTML = getExtensionField(extension2, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (node2) => renderHTML({
          node: node2,
          HTMLAttributes: getRenderedAttributes(node2, extensionAttributes)
        });
      }
      const renderText = getExtensionField(extension2, "renderText", context);
      if (renderText) {
        schema.toText = renderText;
      }
      return [extension2.name, schema];
    }));
    const marks = Object.fromEntries(markExtensions.map((extension2) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension2.name);
      const context = {
        name: extension2.name,
        options: extension2.options,
        storage: extension2.storage,
        editor: editor2
      };
      const extraMarkFields = extensions2.reduce((fields, e) => {
        const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
        return {
          ...fields,
          ...extendMarkSchema ? extendMarkSchema(extension2) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraMarkFields,
        inclusive: callOrReturn(getExtensionField(extension2, "inclusive", context)),
        excludes: callOrReturn(getExtensionField(extension2, "excludes", context)),
        group: callOrReturn(getExtensionField(extension2, "group", context)),
        spanning: callOrReturn(getExtensionField(extension2, "spanning", context)),
        code: callOrReturn(getExtensionField(extension2, "code", context)),
        attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
          var _a2;
          return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
        }))
      });
      const parseHTML = callOrReturn(getExtensionField(extension2, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
      }
      const renderHTML = getExtensionField(extension2, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (mark2) => renderHTML({
          mark: mark2,
          HTMLAttributes: getRenderedAttributes(mark2, extensionAttributes)
        });
      }
      return [extension2.name, schema];
    }));
    return new Schema$1({
      topNode,
      nodes,
      marks
    });
  }
  function getSchemaTypeByName(name, schema) {
    return schema.nodes[name] || schema.marks[name] || null;
  }
  function isExtensionRulesEnabled(extension2, enabled) {
    if (Array.isArray(enabled)) {
      return enabled.some((enabledExtension) => {
        const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
        return name === extension2.name;
      });
    }
    return enabled;
  }
  const getTextContentFromNodes = ($from, maxMatch = 500) => {
    let textBefore = "";
    const sliceEndPos = $from.parentOffset;
    $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node2, pos, parent, index2) => {
      var _a, _b;
      const chunk = ((_b = (_a = node2.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {
        node: node2,
        pos,
        parent,
        index: index2
      })) || node2.textContent || "%leaf%";
      textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));
    });
    return textBefore;
  };
  function isRegExp(value) {
    return Object.prototype.toString.call(value) === "[object RegExp]";
  }
  class InputRule {
    constructor(config) {
      this.find = config.find;
      this.handler = config.handler;
    }
  }
  const inputRuleMatcherHandler = (text2, find2) => {
    if (isRegExp(find2)) {
      return find2.exec(text2);
    }
    const inputRuleMatch = find2(text2);
    if (!inputRuleMatch) {
      return null;
    }
    const result = [inputRuleMatch.text];
    result.index = inputRuleMatch.index;
    result.input = text2;
    result.data = inputRuleMatch.data;
    if (inputRuleMatch.replaceWith) {
      if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
      }
      result.push(inputRuleMatch.replaceWith);
    }
    return result;
  };
  function run$1$1(config) {
    var _a;
    const { editor: editor2, from: from2, to, text: text2, rules, plugin } = config;
    const { view } = editor2;
    if (view.composing) {
      return false;
    }
    const $from = view.state.doc.resolve(from2);
    if (
      // check for code node
      $from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark2) => mark2.type.spec.code))
    ) {
      return false;
    }
    let matched = false;
    const textBefore = getTextContentFromNodes($from) + text2;
    rules.forEach((rule) => {
      if (matched) {
        return;
      }
      const match = inputRuleMatcherHandler(textBefore, rule.find);
      if (!match) {
        return;
      }
      const tr2 = view.state.tr;
      const state = createChainableState({
        state: view.state,
        transaction: tr2
      });
      const range = {
        from: from2 - (match[0].length - text2.length),
        to
      };
      const { commands: commands2, chain, can } = new CommandManager({
        editor: editor2,
        state
      });
      const handler = rule.handler({
        state,
        range,
        match,
        commands: commands2,
        chain,
        can
      });
      if (handler === null || !tr2.steps.length) {
        return;
      }
      tr2.setMeta(plugin, {
        transform: tr2,
        from: from2,
        to,
        text: text2
      });
      view.dispatch(tr2);
      matched = true;
    });
    return matched;
  }
  function inputRulesPlugin(props) {
    const { editor: editor2, rules } = props;
    const plugin = new Plugin({
      state: {
        init() {
          return null;
        },
        apply(tr2, prev) {
          const stored = tr2.getMeta(plugin);
          if (stored) {
            return stored;
          }
          return tr2.selectionSet || tr2.docChanged ? null : prev;
        }
      },
      props: {
        handleTextInput(view, from2, to, text2) {
          return run$1$1({
            editor: editor2,
            from: from2,
            to,
            text: text2,
            rules,
            plugin
          });
        },
        handleDOMEvents: {
          compositionend: (view) => {
            setTimeout(() => {
              const { $cursor } = view.state.selection;
              if ($cursor) {
                run$1$1({
                  editor: editor2,
                  from: $cursor.pos,
                  to: $cursor.pos,
                  text: "",
                  rules,
                  plugin
                });
              }
            });
            return false;
          }
        },
        // add support for input rules to trigger on enter
        // this is useful for example for code blocks
        handleKeyDown(view, event) {
          if (event.key !== "Enter") {
            return false;
          }
          const { $cursor } = view.state.selection;
          if ($cursor) {
            return run$1$1({
              editor: editor2,
              from: $cursor.pos,
              to: $cursor.pos,
              text: "\n",
              rules,
              plugin
            });
          }
          return false;
        }
      },
      // @ts-ignore
      isInputRules: true
    });
    return plugin;
  }
  function isNumber(value) {
    return typeof value === "number";
  }
  class PasteRule {
    constructor(config) {
      this.find = config.find;
      this.handler = config.handler;
    }
  }
  const pasteRuleMatcherHandler = (text2, find2, event) => {
    if (isRegExp(find2)) {
      return [...text2.matchAll(find2)];
    }
    const matches2 = find2(text2, event);
    if (!matches2) {
      return [];
    }
    return matches2.map((pasteRuleMatch) => {
      const result = [pasteRuleMatch.text];
      result.index = pasteRuleMatch.index;
      result.input = text2;
      result.data = pasteRuleMatch.data;
      if (pasteRuleMatch.replaceWith) {
        if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
          console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
        }
        result.push(pasteRuleMatch.replaceWith);
      }
      return result;
    });
  };
  function run$2(config) {
    const { editor: editor2, state, from: from2, to, rule, pasteEvent, dropEvent } = config;
    const { commands: commands2, chain, can } = new CommandManager({
      editor: editor2,
      state
    });
    const handlers2 = [];
    state.doc.nodesBetween(from2, to, (node2, pos) => {
      if (!node2.isTextblock || node2.type.spec.code) {
        return;
      }
      const resolvedFrom = Math.max(from2, pos);
      const resolvedTo = Math.min(to, pos + node2.content.size);
      const textToMatch = node2.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "￼");
      const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
      matches2.forEach((match) => {
        if (match.index === void 0) {
          return;
        }
        const start = resolvedFrom + match.index + 1;
        const end = start + match[0].length;
        const range = {
          from: state.tr.mapping.map(start),
          to: state.tr.mapping.map(end)
        };
        const handler = rule.handler({
          state,
          range,
          match,
          commands: commands2,
          chain,
          can,
          pasteEvent,
          dropEvent
        });
        handlers2.push(handler);
      });
    });
    const success = handlers2.every((handler) => handler !== null);
    return success;
  }
  function pasteRulesPlugin(props) {
    const { editor: editor2, rules } = props;
    let dragSourceElement = null;
    let isPastedFromProseMirror = false;
    let isDroppedFromProseMirror = false;
    let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
    let dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
    const plugins = rules.map((rule) => {
      return new Plugin({
        // we register a global drag handler to track the current drag source element
        view(view) {
          const handleDragstart = (event) => {
            var _a;
            dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
          };
          window.addEventListener("dragstart", handleDragstart);
          return {
            destroy() {
              window.removeEventListener("dragstart", handleDragstart);
            }
          };
        },
        props: {
          handleDOMEvents: {
            drop: (view, event) => {
              isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
              dropEvent = event;
              return false;
            },
            paste: (_view, event) => {
              var _a;
              const html2 = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
              pasteEvent = event;
              isPastedFromProseMirror = !!(html2 === null || html2 === void 0 ? void 0 : html2.includes("data-pm-slice"));
              return false;
            }
          }
        },
        appendTransaction: (transactions, oldState, state) => {
          const transaction = transactions[0];
          const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
          const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
          if (!isPaste && !isDrop) {
            return;
          }
          const from2 = oldState.doc.content.findDiffStart(state.doc.content);
          const to = oldState.doc.content.findDiffEnd(state.doc.content);
          if (!isNumber(from2) || !to || from2 === to.b) {
            return;
          }
          const tr2 = state.tr;
          const chainableState = createChainableState({
            state,
            transaction: tr2
          });
          const handler = run$2({
            editor: editor2,
            state: chainableState,
            from: Math.max(from2 - 1, 0),
            to: to.b - 1,
            rule,
            pasteEvent,
            dropEvent
          });
          if (!handler || !tr2.steps.length) {
            return;
          }
          dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
          pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
          return tr2;
        }
      });
    });
    return plugins;
  }
  function findDuplicates$1(items) {
    const filtered = items.filter((el, index2) => items.indexOf(el) !== index2);
    return [...new Set(filtered)];
  }
  class ExtensionManager {
    constructor(extensions2, editor2) {
      this.splittableMarks = [];
      this.editor = editor2;
      this.extensions = ExtensionManager.resolve(extensions2);
      this.schema = getSchemaByResolvedExtensions(this.extensions, editor2);
      this.extensions.forEach((extension2) => {
        var _a;
        this.editor.extensionStorage[extension2.name] = extension2.storage;
        const context = {
          name: extension2.name,
          options: extension2.options,
          storage: extension2.storage,
          editor: this.editor,
          type: getSchemaTypeByName(extension2.name, this.schema)
        };
        if (extension2.type === "mark") {
          const keepOnSplit = (_a = callOrReturn(getExtensionField(extension2, "keepOnSplit", context))) !== null && _a !== void 0 ? _a : true;
          if (keepOnSplit) {
            this.splittableMarks.push(extension2.name);
          }
        }
        const onBeforeCreate = getExtensionField(extension2, "onBeforeCreate", context);
        if (onBeforeCreate) {
          this.editor.on("beforeCreate", onBeforeCreate);
        }
        const onCreate = getExtensionField(extension2, "onCreate", context);
        if (onCreate) {
          this.editor.on("create", onCreate);
        }
        const onUpdate = getExtensionField(extension2, "onUpdate", context);
        if (onUpdate) {
          this.editor.on("update", onUpdate);
        }
        const onSelectionUpdate = getExtensionField(extension2, "onSelectionUpdate", context);
        if (onSelectionUpdate) {
          this.editor.on("selectionUpdate", onSelectionUpdate);
        }
        const onTransaction = getExtensionField(extension2, "onTransaction", context);
        if (onTransaction) {
          this.editor.on("transaction", onTransaction);
        }
        const onFocus = getExtensionField(extension2, "onFocus", context);
        if (onFocus) {
          this.editor.on("focus", onFocus);
        }
        const onBlur = getExtensionField(extension2, "onBlur", context);
        if (onBlur) {
          this.editor.on("blur", onBlur);
        }
        const onDestroy = getExtensionField(extension2, "onDestroy", context);
        if (onDestroy) {
          this.editor.on("destroy", onDestroy);
        }
      });
    }
    static resolve(extensions2) {
      const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions2));
      const duplicatedNames = findDuplicates$1(resolvedExtensions.map((extension2) => extension2.name));
      if (duplicatedNames.length) {
        console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
      }
      return resolvedExtensions;
    }
    static flatten(extensions2) {
      return extensions2.map((extension2) => {
        const context = {
          name: extension2.name,
          options: extension2.options,
          storage: extension2.storage
        };
        const addExtensions = getExtensionField(extension2, "addExtensions", context);
        if (addExtensions) {
          return [extension2, ...this.flatten(addExtensions())];
        }
        return extension2;
      }).flat(10);
    }
    static sort(extensions2) {
      const defaultPriority = 100;
      return extensions2.sort((a2, b) => {
        const priorityA = getExtensionField(a2, "priority") || defaultPriority;
        const priorityB = getExtensionField(b, "priority") || defaultPriority;
        if (priorityA > priorityB) {
          return -1;
        }
        if (priorityA < priorityB) {
          return 1;
        }
        return 0;
      });
    }
    get commands() {
      return this.extensions.reduce((commands2, extension2) => {
        const context = {
          name: extension2.name,
          options: extension2.options,
          storage: extension2.storage,
          editor: this.editor,
          type: getSchemaTypeByName(extension2.name, this.schema)
        };
        const addCommands = getExtensionField(extension2, "addCommands", context);
        if (!addCommands) {
          return commands2;
        }
        return {
          ...commands2,
          ...addCommands()
        };
      }, {});
    }
    get plugins() {
      const { editor: editor2 } = this;
      const extensions2 = ExtensionManager.sort([...this.extensions].reverse());
      const inputRules = [];
      const pasteRules = [];
      const allPlugins = extensions2.map((extension2) => {
        const context = {
          name: extension2.name,
          options: extension2.options,
          storage: extension2.storage,
          editor: editor2,
          type: getSchemaTypeByName(extension2.name, this.schema)
        };
        const plugins = [];
        const addKeyboardShortcuts = getExtensionField(extension2, "addKeyboardShortcuts", context);
        let defaultBindings = {};
        if (extension2.type === "mark" && extension2.config.exitable) {
          defaultBindings.ArrowRight = () => Mark.handleExit({ editor: editor2, mark: extension2 });
        }
        if (addKeyboardShortcuts) {
          const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
            return [shortcut, () => method({ editor: editor2 })];
          }));
          defaultBindings = { ...defaultBindings, ...bindings };
        }
        const keyMapPlugin = keymap(defaultBindings);
        plugins.push(keyMapPlugin);
        const addInputRules = getExtensionField(extension2, "addInputRules", context);
        if (isExtensionRulesEnabled(extension2, editor2.options.enableInputRules) && addInputRules) {
          inputRules.push(...addInputRules());
        }
        const addPasteRules = getExtensionField(extension2, "addPasteRules", context);
        if (isExtensionRulesEnabled(extension2, editor2.options.enablePasteRules) && addPasteRules) {
          pasteRules.push(...addPasteRules());
        }
        const addProseMirrorPlugins = getExtensionField(extension2, "addProseMirrorPlugins", context);
        if (addProseMirrorPlugins) {
          const proseMirrorPlugins = addProseMirrorPlugins();
          plugins.push(...proseMirrorPlugins);
        }
        return plugins;
      }).flat();
      return [
        inputRulesPlugin({
          editor: editor2,
          rules: inputRules
        }),
        ...pasteRulesPlugin({
          editor: editor2,
          rules: pasteRules
        }),
        ...allPlugins
      ];
    }
    get attributes() {
      return getAttributesFromExtensions(this.extensions);
    }
    get nodeViews() {
      const { editor: editor2 } = this;
      const { nodeExtensions } = splitExtensions(this.extensions);
      return Object.fromEntries(nodeExtensions.filter((extension2) => !!getExtensionField(extension2, "addNodeView")).map((extension2) => {
        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension2.name);
        const context = {
          name: extension2.name,
          options: extension2.options,
          storage: extension2.storage,
          editor: editor2,
          type: getNodeType(extension2.name, this.schema)
        };
        const addNodeView = getExtensionField(extension2, "addNodeView", context);
        if (!addNodeView) {
          return [];
        }
        const nodeview = (node2, view, getPos, decorations) => {
          const HTMLAttributes = getRenderedAttributes(node2, extensionAttributes);
          return addNodeView()({
            editor: editor2,
            node: node2,
            getPos,
            decorations,
            HTMLAttributes,
            extension: extension2
          });
        };
        return [extension2.name, nodeview];
      }));
    }
  }
  function getType(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  }
  function isPlainObject(value) {
    if (getType(value) !== "Object") {
      return false;
    }
    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
  }
  function mergeDeep(target, source2) {
    const output = { ...target };
    if (isPlainObject(target) && isPlainObject(source2)) {
      Object.keys(source2).forEach((key2) => {
        if (isPlainObject(source2[key2])) {
          if (!(key2 in target)) {
            Object.assign(output, { [key2]: source2[key2] });
          } else {
            output[key2] = mergeDeep(target[key2], source2[key2]);
          }
        } else {
          Object.assign(output, { [key2]: source2[key2] });
        }
      });
    }
    return output;
  }
  class Extension {
    constructor(config = {}) {
      this.type = "extension";
      this.name = "extension";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = {
        ...this.config,
        ...config
      };
      this.name = this.config.name;
      if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config = {}) {
      return new Extension(config);
    }
    configure(options = {}) {
      const extension2 = this.extend();
      extension2.options = mergeDeep(this.options, options);
      extension2.storage = callOrReturn(getExtensionField(extension2, "addStorage", {
        name: extension2.name,
        options: extension2.options
      }));
      return extension2;
    }
    extend(extendedConfig = {}) {
      const extension2 = new Extension({ ...this.config, ...extendedConfig });
      extension2.parent = this;
      this.child = extension2;
      extension2.name = extendedConfig.name ? extendedConfig.name : extension2.parent.name;
      if (extendedConfig.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension2.name}".`);
      }
      extension2.options = callOrReturn(getExtensionField(extension2, "addOptions", {
        name: extension2.name
      }));
      extension2.storage = callOrReturn(getExtensionField(extension2, "addStorage", {
        name: extension2.name,
        options: extension2.options
      }));
      return extension2;
    }
  }
  function getTextBetween(startNode, range, options) {
    const { from: from2, to } = range;
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    let text2 = "";
    let separated = true;
    startNode.nodesBetween(from2, to, (node2, pos, parent, index2) => {
      var _a;
      const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node2.type.name];
      if (textSerializer) {
        if (node2.isBlock && !separated) {
          text2 += blockSeparator;
          separated = true;
        }
        if (parent) {
          text2 += textSerializer({
            node: node2,
            pos,
            parent,
            index: index2,
            range
          });
        }
      } else if (node2.isText) {
        text2 += (_a = node2 === null || node2 === void 0 ? void 0 : node2.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from2, pos) - pos, to - pos);
        separated = false;
      } else if (node2.isBlock && !separated) {
        text2 += blockSeparator;
        separated = true;
      }
    });
    return text2;
  }
  function getTextSerializersFromSchema(schema) {
    return Object.fromEntries(Object.entries(schema.nodes).filter(([, node2]) => node2.spec.toText).map(([name, node2]) => [name, node2.spec.toText]));
  }
  const ClipboardTextSerializer = Extension.create({
    name: "clipboardTextSerializer",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("clipboardTextSerializer"),
          props: {
            clipboardTextSerializer: () => {
              const { editor: editor2 } = this;
              const { state, schema } = editor2;
              const { doc: doc2, selection } = state;
              const { ranges } = selection;
              const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
              const to = Math.max(...ranges.map((range2) => range2.$to.pos));
              const textSerializers = getTextSerializersFromSchema(schema);
              const range = { from: from2, to };
              return getTextBetween(doc2, range, {
                textSerializers
              });
            }
          }
        })
      ];
    }
  });
  const blur = () => ({ editor: editor2, view }) => {
    requestAnimationFrame(() => {
      var _a;
      if (!editor2.isDestroyed) {
        view.dom.blur();
        (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
      }
    });
    return true;
  };
  const clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
    return commands2.setContent("", emitUpdate);
  };
  const clearNodes = () => ({ state, tr: tr2, dispatch }) => {
    const { selection } = tr2;
    const { ranges } = selection;
    if (!dispatch) {
      return true;
    }
    ranges.forEach(({ $from, $to }) => {
      state.doc.nodesBetween($from.pos, $to.pos, (node2, pos) => {
        if (node2.type.isText) {
          return;
        }
        const { doc: doc2, mapping } = tr2;
        const $mappedFrom = doc2.resolve(mapping.map(pos));
        const $mappedTo = doc2.resolve(mapping.map(pos + node2.nodeSize));
        const nodeRange = $mappedFrom.blockRange($mappedTo);
        if (!nodeRange) {
          return;
        }
        const targetLiftDepth = liftTarget(nodeRange);
        if (node2.type.isTextblock) {
          const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
          tr2.setNodeMarkup(nodeRange.start, defaultType);
        }
        if (targetLiftDepth || targetLiftDepth === 0) {
          tr2.lift(nodeRange, targetLiftDepth);
        }
      });
    });
    return true;
  };
  const command = (fn) => (props) => {
    return fn(props);
  };
  const createParagraphNear = () => ({ state, dispatch }) => {
    return createParagraphNear$1(state, dispatch);
  };
  const cut = (originRange, targetPos) => ({ editor: editor2, tr: tr2 }) => {
    const { state } = editor2;
    const contentSlice = state.doc.slice(originRange.from, originRange.to);
    tr2.deleteRange(originRange.from, originRange.to);
    const newPos = tr2.mapping.map(targetPos);
    tr2.insert(newPos, contentSlice.content);
    tr2.setSelection(new TextSelection(tr2.doc.resolve(newPos - 1)));
    return true;
  };
  const deleteCurrentNode = () => ({ tr: tr2, dispatch }) => {
    const { selection } = tr2;
    const currentNode = selection.$anchor.node();
    if (currentNode.content.size > 0) {
      return false;
    }
    const $pos = tr2.selection.$anchor;
    for (let depth = $pos.depth; depth > 0; depth -= 1) {
      const node2 = $pos.node(depth);
      if (node2.type === currentNode.type) {
        if (dispatch) {
          const from2 = $pos.before(depth);
          const to = $pos.after(depth);
          tr2.delete(from2, to).scrollIntoView();
        }
        return true;
      }
    }
    return false;
  };
  const deleteNode = (typeOrName) => ({ tr: tr2, state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    const $pos = tr2.selection.$anchor;
    for (let depth = $pos.depth; depth > 0; depth -= 1) {
      const node2 = $pos.node(depth);
      if (node2.type === type) {
        if (dispatch) {
          const from2 = $pos.before(depth);
          const to = $pos.after(depth);
          tr2.delete(from2, to).scrollIntoView();
        }
        return true;
      }
    }
    return false;
  };
  const deleteRange = (range) => ({ tr: tr2, dispatch }) => {
    const { from: from2, to } = range;
    if (dispatch) {
      tr2.delete(from2, to);
    }
    return true;
  };
  const deleteSelection = () => ({ state, dispatch }) => {
    return deleteSelection$1(state, dispatch);
  };
  const enter = () => ({ commands: commands2 }) => {
    return commands2.keyboardShortcut("Enter");
  };
  const exitCode = () => ({ state, dispatch }) => {
    return exitCode$1(state, dispatch);
  };
  function objectIncludes(object1, object2, options = { strict: true }) {
    const keys2 = Object.keys(object2);
    if (!keys2.length) {
      return true;
    }
    return keys2.every((key2) => {
      if (options.strict) {
        return object2[key2] === object1[key2];
      }
      if (isRegExp(object2[key2])) {
        return object2[key2].test(object1[key2]);
      }
      return object2[key2] === object1[key2];
    });
  }
  function findMarkInSet(marks, type, attributes = {}) {
    return marks.find((item) => {
      return item.type === type && objectIncludes(item.attrs, attributes);
    });
  }
  function isMarkInSet(marks, type, attributes = {}) {
    return !!findMarkInSet(marks, type, attributes);
  }
  function getMarkRange($pos, type, attributes = {}) {
    if (!$pos || !type) {
      return;
    }
    let start = $pos.parent.childAfter($pos.parentOffset);
    if ($pos.parentOffset === start.offset && start.offset !== 0) {
      start = $pos.parent.childBefore($pos.parentOffset);
    }
    if (!start.node) {
      return;
    }
    const mark2 = findMarkInSet([...start.node.marks], type, attributes);
    if (!mark2) {
      return;
    }
    let startIndex = start.index;
    let startPos = $pos.start() + start.offset;
    let endIndex = startIndex + 1;
    let endPos = startPos + start.node.nodeSize;
    findMarkInSet([...start.node.marks], type, attributes);
    while (startIndex > 0 && mark2.isInSet($pos.parent.child(startIndex - 1).marks)) {
      startIndex -= 1;
      startPos -= $pos.parent.child(startIndex).nodeSize;
    }
    while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
      endPos += $pos.parent.child(endIndex).nodeSize;
      endIndex += 1;
    }
    return {
      from: startPos,
      to: endPos
    };
  }
  function getMarkType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.marks[nameOrType]) {
        throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
      }
      return schema.marks[nameOrType];
    }
    return nameOrType;
  }
  const extendMarkRange = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
    const type = getMarkType(typeOrName, state.schema);
    const { doc: doc2, selection } = tr2;
    const { $from, from: from2, to } = selection;
    if (dispatch) {
      const range = getMarkRange($from, type, attributes);
      if (range && range.from <= from2 && range.to >= to) {
        const newSelection = TextSelection.create(doc2, range.from, range.to);
        tr2.setSelection(newSelection);
      }
    }
    return true;
  };
  const first = (commands2) => (props) => {
    const items = typeof commands2 === "function" ? commands2(props) : commands2;
    for (let i2 = 0; i2 < items.length; i2 += 1) {
      if (items[i2](props)) {
        return true;
      }
    }
    return false;
  };
  function isTextSelection(value) {
    return value instanceof TextSelection;
  }
  function minMax(value = 0, min2 = 0, max2 = 0) {
    return Math.min(Math.max(value, min2), max2);
  }
  function resolveFocusPosition(doc2, position2 = null) {
    if (!position2) {
      return null;
    }
    const selectionAtStart = Selection.atStart(doc2);
    const selectionAtEnd = Selection.atEnd(doc2);
    if (position2 === "start" || position2 === true) {
      return selectionAtStart;
    }
    if (position2 === "end") {
      return selectionAtEnd;
    }
    const minPos = selectionAtStart.from;
    const maxPos = selectionAtEnd.to;
    if (position2 === "all") {
      return TextSelection.create(doc2, minMax(0, minPos, maxPos), minMax(doc2.content.size, minPos, maxPos));
    }
    return TextSelection.create(doc2, minMax(position2, minPos, maxPos), minMax(position2, minPos, maxPos));
  }
  function isiOS() {
    return [
      "iPad Simulator",
      "iPhone Simulator",
      "iPod Simulator",
      "iPad",
      "iPhone",
      "iPod"
    ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  const focus = (position2 = null, options = {}) => ({ editor: editor2, view, tr: tr2, dispatch }) => {
    options = {
      scrollIntoView: true,
      ...options
    };
    const delayedFocus = () => {
      if (isiOS()) {
        view.dom.focus();
      }
      requestAnimationFrame(() => {
        if (!editor2.isDestroyed) {
          view.focus();
          if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
            editor2.commands.scrollIntoView();
          }
        }
      });
    };
    if (view.hasFocus() && position2 === null || position2 === false) {
      return true;
    }
    if (dispatch && position2 === null && !isTextSelection(editor2.state.selection)) {
      delayedFocus();
      return true;
    }
    const selection = resolveFocusPosition(tr2.doc, position2) || editor2.state.selection;
    const isSameSelection = editor2.state.selection.eq(selection);
    if (dispatch) {
      if (!isSameSelection) {
        tr2.setSelection(selection);
      }
      if (isSameSelection && tr2.storedMarks) {
        tr2.setStoredMarks(tr2.storedMarks);
      }
      delayedFocus();
    }
    return true;
  };
  const forEach$1 = (items, fn) => (props) => {
    return items.every((item, index2) => fn(item, { ...props, index: index2 }));
  };
  const insertContent = (value, options) => ({ tr: tr2, commands: commands2 }) => {
    return commands2.insertContentAt({ from: tr2.selection.from, to: tr2.selection.to }, value, options);
  };
  const removeWhitespaces = (node2) => {
    const children = node2.childNodes;
    for (let i2 = children.length - 1; i2 >= 0; i2 -= 1) {
      const child = children[i2];
      if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
        node2.removeChild(child);
      } else if (child.nodeType === 1) {
        removeWhitespaces(child);
      }
    }
    return node2;
  };
  function elementFromString(value) {
    const wrappedValue = `<body>${value}</body>`;
    const html2 = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
    return removeWhitespaces(html2);
  }
  function createNodeFromContent(content2, schema, options) {
    options = {
      slice: true,
      parseOptions: {},
      ...options
    };
    if (typeof content2 === "object" && content2 !== null) {
      try {
        if (Array.isArray(content2) && content2.length > 0) {
          return Fragment.fromArray(content2.map((item) => schema.nodeFromJSON(item)));
        }
        return schema.nodeFromJSON(content2);
      } catch (error) {
        console.warn("[tiptap warn]: Invalid content.", "Passed value:", content2, "Error:", error);
        return createNodeFromContent("", schema, options);
      }
    }
    if (typeof content2 === "string") {
      const parser2 = DOMParser$1.fromSchema(schema);
      return options.slice ? parser2.parseSlice(elementFromString(content2), options.parseOptions).content : parser2.parse(elementFromString(content2), options.parseOptions);
    }
    return createNodeFromContent("", schema, options);
  }
  function selectionToInsertionEnd(tr2, startLen, bias) {
    const last2 = tr2.steps.length - 1;
    if (last2 < startLen) {
      return;
    }
    const step = tr2.steps[last2];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
      return;
    }
    const map2 = tr2.mapping.maps[last2];
    let end = 0;
    map2.forEach((_from, _to, _newFrom, newTo) => {
      if (end === 0) {
        end = newTo;
      }
    });
    tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
  }
  const isFragment = (nodeOrFragment) => {
    return nodeOrFragment.toString().startsWith("<");
  };
  const insertContentAt = (position2, value, options) => ({ tr: tr2, dispatch, editor: editor2 }) => {
    if (dispatch) {
      options = {
        parseOptions: {},
        updateSelection: true,
        ...options
      };
      const content2 = createNodeFromContent(value, editor2.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...options.parseOptions
        }
      });
      if (content2.toString() === "<>") {
        return true;
      }
      let { from: from2, to } = typeof position2 === "number" ? { from: position2, to: position2 } : { from: position2.from, to: position2.to };
      let isOnlyTextContent = true;
      let isOnlyBlockContent = true;
      const nodes = isFragment(content2) ? content2 : [content2];
      nodes.forEach((node2) => {
        node2.check();
        isOnlyTextContent = isOnlyTextContent ? node2.isText && node2.marks.length === 0 : false;
        isOnlyBlockContent = isOnlyBlockContent ? node2.isBlock : false;
      });
      if (from2 === to && isOnlyBlockContent) {
        const { parent } = tr2.doc.resolve(from2);
        const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
        if (isEmptyTextBlock) {
          from2 -= 1;
          to += 1;
        }
      }
      if (isOnlyTextContent) {
        if (Array.isArray(value)) {
          tr2.insertText(value.map((v) => v.text || "").join(""), from2, to);
        } else if (typeof value === "object" && !!value && !!value.text) {
          tr2.insertText(value.text, from2, to);
        } else {
          tr2.insertText(value, from2, to);
        }
      } else {
        tr2.replaceWith(from2, to, content2);
      }
      if (options.updateSelection) {
        selectionToInsertionEnd(tr2, tr2.steps.length - 1, -1);
      }
    }
    return true;
  };
  const joinUp = () => ({ state, dispatch }) => {
    return joinUp$1(state, dispatch);
  };
  const joinDown = () => ({ state, dispatch }) => {
    return joinDown$1(state, dispatch);
  };
  const joinBackward = () => ({ state, dispatch }) => {
    return joinBackward$1(state, dispatch);
  };
  const joinForward = () => ({ state, dispatch }) => {
    return joinForward$1(state, dispatch);
  };
  const joinItemBackward = () => ({ tr: tr2, state, dispatch }) => {
    try {
      const point2 = joinPoint(state.doc, state.selection.$from.pos, -1);
      if (point2 === null || point2 === void 0) {
        return false;
      }
      tr2.join(point2, 2);
      if (dispatch) {
        dispatch(tr2);
      }
      return true;
    } catch {
      return false;
    }
  };
  const joinItemForward = () => ({ state, dispatch, tr: tr2 }) => {
    try {
      const point2 = joinPoint(state.doc, state.selection.$from.pos, 1);
      if (point2 === null || point2 === void 0) {
        return false;
      }
      tr2.join(point2, 2);
      if (dispatch) {
        dispatch(tr2);
      }
      return true;
    } catch (e) {
      return false;
    }
  };
  const joinTextblockBackward = () => ({ state, dispatch }) => {
    return joinTextblockBackward$1(state, dispatch);
  };
  const joinTextblockForward = () => ({ state, dispatch }) => {
    return joinTextblockForward$1(state, dispatch);
  };
  function isMacOS() {
    return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
  }
  function normalizeKeyName(name) {
    const parts = name.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result === "Space") {
      result = " ";
    }
    let alt;
    let ctrl;
    let shift2;
    let meta2;
    for (let i2 = 0; i2 < parts.length - 1; i2 += 1) {
      const mod = parts[i2];
      if (/^(cmd|meta|m)$/i.test(mod)) {
        meta2 = true;
      } else if (/^a(lt)?$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?$/i.test(mod)) {
        shift2 = true;
      } else if (/^mod$/i.test(mod)) {
        if (isiOS() || isMacOS()) {
          meta2 = true;
        } else {
          ctrl = true;
        }
      } else {
        throw new Error(`Unrecognized modifier name: ${mod}`);
      }
    }
    if (alt) {
      result = `Alt-${result}`;
    }
    if (ctrl) {
      result = `Ctrl-${result}`;
    }
    if (meta2) {
      result = `Meta-${result}`;
    }
    if (shift2) {
      result = `Shift-${result}`;
    }
    return result;
  }
  const keyboardShortcut = (name) => ({ editor: editor2, view, tr: tr2, dispatch }) => {
    const keys2 = normalizeKeyName(name).split(/-(?!$)/);
    const key2 = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
    const event = new KeyboardEvent("keydown", {
      key: key2 === "Space" ? " " : key2,
      altKey: keys2.includes("Alt"),
      ctrlKey: keys2.includes("Ctrl"),
      metaKey: keys2.includes("Meta"),
      shiftKey: keys2.includes("Shift"),
      bubbles: true,
      cancelable: true
    });
    const capturedTransaction = editor2.captureTransaction(() => {
      view.someProp("handleKeyDown", (f) => f(view, event));
    });
    capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
      const newStep = step.map(tr2.mapping);
      if (newStep && dispatch) {
        tr2.maybeStep(newStep);
      }
    });
    return true;
  };
  function isNodeActive(state, typeOrName, attributes = {}) {
    const { from: from2, to, empty: empty2 } = state.selection;
    const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
    const nodeRanges = [];
    state.doc.nodesBetween(from2, to, (node2, pos) => {
      if (node2.isText) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node2.nodeSize);
      nodeRanges.push({
        node: node2,
        from: relativeFrom,
        to: relativeTo
      });
    });
    const selectionRange = to - from2;
    const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
      if (!type) {
        return true;
      }
      return type.name === nodeRange.node.type.name;
    }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
    if (empty2) {
      return !!matchedNodeRanges.length;
    }
    const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
    return range >= selectionRange;
  }
  const lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    const isActive2 = isNodeActive(state, type, attributes);
    if (!isActive2) {
      return false;
    }
    return lift$1(state, dispatch);
  };
  const liftEmptyBlock = () => ({ state, dispatch }) => {
    return liftEmptyBlock$1(state, dispatch);
  };
  const liftListItem = (typeOrName) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return liftListItem$1(type)(state, dispatch);
  };
  const newlineInCode = () => ({ state, dispatch }) => {
    return newlineInCode$1(state, dispatch);
  };
  function getSchemaTypeNameByName(name, schema) {
    if (schema.nodes[name]) {
      return "node";
    }
    if (schema.marks[name]) {
      return "mark";
    }
    return null;
  }
  function deleteProps(obj, propOrProps) {
    const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
    return Object.keys(obj).reduce((newObj, prop) => {
      if (!props.includes(prop)) {
        newObj[prop] = obj[prop];
      }
      return newObj;
    }, {});
  }
  const resetAttributes = (typeOrName, attributes) => ({ tr: tr2, state, dispatch }) => {
    let nodeType = null;
    let markType = null;
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (!schemaType) {
      return false;
    }
    if (schemaType === "node") {
      nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === "mark") {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch) {
      tr2.selection.ranges.forEach((range) => {
        state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node2, pos) => {
          if (nodeType && nodeType === node2.type) {
            tr2.setNodeMarkup(pos, void 0, deleteProps(node2.attrs, attributes));
          }
          if (markType && node2.marks.length) {
            node2.marks.forEach((mark2) => {
              if (markType === mark2.type) {
                tr2.addMark(pos, pos + node2.nodeSize, markType.create(deleteProps(mark2.attrs, attributes)));
              }
            });
          }
        });
      });
    }
    return true;
  };
  const scrollIntoView = () => ({ tr: tr2, dispatch }) => {
    if (dispatch) {
      tr2.scrollIntoView();
    }
    return true;
  };
  const selectAll = () => ({ tr: tr2, commands: commands2 }) => {
    return commands2.setTextSelection({
      from: 0,
      to: tr2.doc.content.size
    });
  };
  const selectNodeBackward = () => ({ state, dispatch }) => {
    return selectNodeBackward$1(state, dispatch);
  };
  const selectNodeForward = () => ({ state, dispatch }) => {
    return selectNodeForward$1(state, dispatch);
  };
  const selectParentNode = () => ({ state, dispatch }) => {
    return selectParentNode$1(state, dispatch);
  };
  const selectTextblockEnd = () => ({ state, dispatch }) => {
    return selectTextblockEnd$1(state, dispatch);
  };
  const selectTextblockStart = () => ({ state, dispatch }) => {
    return selectTextblockStart$1(state, dispatch);
  };
  function createDocument(content2, schema, parseOptions = {}) {
    return createNodeFromContent(content2, schema, { slice: false, parseOptions });
  }
  const setContent = (content2, emitUpdate = false, parseOptions = {}) => ({ tr: tr2, editor: editor2, dispatch }) => {
    const { doc: doc2 } = tr2;
    const document2 = createDocument(content2, editor2.schema, parseOptions);
    if (dispatch) {
      tr2.replaceWith(0, doc2.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  };
  function getMarkAttributes(state, typeOrName) {
    const type = getMarkType(typeOrName, state.schema);
    const { from: from2, to, empty: empty2 } = state.selection;
    const marks = [];
    if (empty2) {
      if (state.storedMarks) {
        marks.push(...state.storedMarks);
      }
      marks.push(...state.selection.$head.marks());
    } else {
      state.doc.nodesBetween(from2, to, (node2) => {
        marks.push(...node2.marks);
      });
    }
    const mark2 = marks.find((markItem) => markItem.type.name === type.name);
    if (!mark2) {
      return {};
    }
    return { ...mark2.attrs };
  }
  function combineTransactionSteps(oldDoc, transactions) {
    const transform2 = new Transform(oldDoc);
    transactions.forEach((transaction) => {
      transaction.steps.forEach((step) => {
        transform2.step(step);
      });
    });
    return transform2;
  }
  function defaultBlockAt(match) {
    for (let i2 = 0; i2 < match.edgeCount; i2 += 1) {
      const { type } = match.edge(i2);
      if (type.isTextblock && !type.hasRequiredAttrs()) {
        return type;
      }
    }
    return null;
  }
  function findChildren(node2, predicate) {
    const nodesWithPos = [];
    node2.descendants((child, pos) => {
      if (predicate(child)) {
        nodesWithPos.push({
          node: child,
          pos
        });
      }
    });
    return nodesWithPos;
  }
  function findChildrenInRange(node2, range, predicate) {
    const nodesWithPos = [];
    node2.nodesBetween(range.from, range.to, (child, pos) => {
      if (predicate(child)) {
        nodesWithPos.push({
          node: child,
          pos
        });
      }
    });
    return nodesWithPos;
  }
  function findParentNodeClosestToPos($pos, predicate) {
    for (let i2 = $pos.depth; i2 > 0; i2 -= 1) {
      const node2 = $pos.node(i2);
      if (predicate(node2)) {
        return {
          pos: i2 > 0 ? $pos.before(i2) : 0,
          start: $pos.start(i2),
          depth: i2,
          node: node2
        };
      }
    }
  }
  function findParentNode(predicate) {
    return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
  }
  function getHTMLFromFragment(fragment, schema) {
    const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
    const temporaryDocument = document.implementation.createHTMLDocument();
    const container = temporaryDocument.createElement("div");
    container.appendChild(documentFragment);
    return container.innerHTML;
  }
  function getText(node2, options) {
    const range = {
      from: 0,
      to: node2.content.size
    };
    return getTextBetween(node2, range, options);
  }
  function getNodeAttributes(state, typeOrName) {
    const type = getNodeType(typeOrName, state.schema);
    const { from: from2, to } = state.selection;
    const nodes = [];
    state.doc.nodesBetween(from2, to, (node3) => {
      nodes.push(node3);
    });
    const node2 = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
    if (!node2) {
      return {};
    }
    return { ...node2.attrs };
  }
  function getAttributes(state, typeOrName) {
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (schemaType === "node") {
      return getNodeAttributes(state, typeOrName);
    }
    if (schemaType === "mark") {
      return getMarkAttributes(state, typeOrName);
    }
    return {};
  }
  function removeDuplicates$1(array, by = JSON.stringify) {
    const seen = {};
    return array.filter((item) => {
      const key2 = by(item);
      return Object.prototype.hasOwnProperty.call(seen, key2) ? false : seen[key2] = true;
    });
  }
  function simplifyChangedRanges(changes) {
    const uniqueChanges = removeDuplicates$1(changes);
    return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index2) => {
      const rest = uniqueChanges.filter((_, i2) => i2 !== index2);
      return !rest.some((otherChange) => {
        return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
      });
    });
  }
  function getChangedRanges(transform2) {
    const { mapping, steps } = transform2;
    const changes = [];
    mapping.maps.forEach((stepMap, index2) => {
      const ranges = [];
      if (!stepMap.ranges.length) {
        const { from: from2, to } = steps[index2];
        if (from2 === void 0 || to === void 0) {
          return;
        }
        ranges.push({ from: from2, to });
      } else {
        stepMap.forEach((from2, to) => {
          ranges.push({ from: from2, to });
        });
      }
      ranges.forEach(({ from: from2, to }) => {
        const newStart = mapping.slice(index2).map(from2, -1);
        const newEnd = mapping.slice(index2).map(to);
        const oldStart = mapping.invert().map(newStart, -1);
        const oldEnd = mapping.invert().map(newEnd);
        changes.push({
          oldRange: {
            from: oldStart,
            to: oldEnd
          },
          newRange: {
            from: newStart,
            to: newEnd
          }
        });
      });
    });
    return simplifyChangedRanges(changes);
  }
  function getMarksBetween(from2, to, doc2) {
    const marks = [];
    if (from2 === to) {
      doc2.resolve(from2).marks().forEach((mark2) => {
        const $pos = doc2.resolve(from2 - 1);
        const range = getMarkRange($pos, mark2.type);
        if (!range) {
          return;
        }
        marks.push({
          mark: mark2,
          ...range
        });
      });
    } else {
      doc2.nodesBetween(from2, to, (node2, pos) => {
        if (!node2 || (node2 === null || node2 === void 0 ? void 0 : node2.nodeSize) === void 0) {
          return;
        }
        marks.push(...node2.marks.map((mark2) => ({
          from: pos,
          to: pos + node2.nodeSize,
          mark: mark2
        })));
      });
    }
    return marks;
  }
  function getSplittedAttributes(extensionAttributes, typeName, attributes) {
    return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
      const extensionAttribute = extensionAttributes.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttribute) {
        return false;
      }
      return extensionAttribute.attribute.keepOnSplit;
    }));
  }
  function isMarkActive(state, typeOrName, attributes = {}) {
    const { empty: empty2, ranges } = state.selection;
    const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
    if (empty2) {
      return !!(state.storedMarks || state.selection.$from.marks()).filter((mark2) => {
        if (!type) {
          return true;
        }
        return type.name === mark2.type.name;
      }).find((mark2) => objectIncludes(mark2.attrs, attributes, { strict: false }));
    }
    let selectionRange = 0;
    const markRanges = [];
    ranges.forEach(({ $from, $to }) => {
      const from2 = $from.pos;
      const to = $to.pos;
      state.doc.nodesBetween(from2, to, (node2, pos) => {
        if (!node2.isText && !node2.marks.length) {
          return;
        }
        const relativeFrom = Math.max(from2, pos);
        const relativeTo = Math.min(to, pos + node2.nodeSize);
        const range2 = relativeTo - relativeFrom;
        selectionRange += range2;
        markRanges.push(...node2.marks.map((mark2) => ({
          mark: mark2,
          from: relativeFrom,
          to: relativeTo
        })));
      });
    });
    if (selectionRange === 0) {
      return false;
    }
    const matchedRange = markRanges.filter((markRange) => {
      if (!type) {
        return true;
      }
      return type.name === markRange.mark.type.name;
    }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    const excludedRange = markRanges.filter((markRange) => {
      if (!type) {
        return true;
      }
      return markRange.mark.type !== type && markRange.mark.type.excludes(type);
    }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
    return range >= selectionRange;
  }
  function isActive(state, name, attributes = {}) {
    if (!name) {
      return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
    }
    const schemaType = getSchemaTypeNameByName(name, state.schema);
    if (schemaType === "node") {
      return isNodeActive(state, name, attributes);
    }
    if (schemaType === "mark") {
      return isMarkActive(state, name, attributes);
    }
    return false;
  }
  function isList(name, extensions2) {
    const { nodeExtensions } = splitExtensions(extensions2);
    const extension2 = nodeExtensions.find((item) => item.name === name);
    if (!extension2) {
      return false;
    }
    const context = {
      name: extension2.name,
      options: extension2.options,
      storage: extension2.storage
    };
    const group = callOrReturn(getExtensionField(extension2, "group", context));
    if (typeof group !== "string") {
      return false;
    }
    return group.split(" ").includes("list");
  }
  function isNodeEmpty(node2) {
    var _a;
    const defaultContent = (_a = node2.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();
    const content2 = node2.toJSON();
    return JSON.stringify(defaultContent) === JSON.stringify(content2);
  }
  function isNodeSelection(value) {
    return value instanceof NodeSelection;
  }
  function posToDOMRect(view, from2, to) {
    const minPos = 0;
    const maxPos = view.state.doc.content.size;
    const resolvedFrom = minMax(from2, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const start = view.coordsAtPos(resolvedFrom);
    const end = view.coordsAtPos(resolvedEnd, -1);
    const top = Math.min(start.top, end.top);
    const bottom = Math.max(start.bottom, end.bottom);
    const left = Math.min(start.left, end.left);
    const right = Math.max(start.right, end.right);
    const width = right - left;
    const height = bottom - top;
    const x = left;
    const y = top;
    const data = {
      top,
      bottom,
      left,
      right,
      width,
      height,
      x,
      y
    };
    return {
      ...data,
      toJSON: () => data
    };
  }
  function canSetMark(state, tr2, newMarkType) {
    var _a;
    const { selection } = tr2;
    let cursor = null;
    if (isTextSelection(selection)) {
      cursor = selection.$cursor;
    }
    if (cursor) {
      const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();
      return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark2) => mark2.type.excludes(newMarkType));
    }
    const { ranges } = selection;
    return ranges.some(({ $from, $to }) => {
      let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
      state.doc.nodesBetween($from.pos, $to.pos, (node2, _pos, parent) => {
        if (someNodeSupportsMark) {
          return false;
        }
        if (node2.isInline) {
          const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
          const currentMarksAllowMarkType = !!newMarkType.isInSet(node2.marks) || !node2.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
          someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
        }
        return !someNodeSupportsMark;
      });
      return someNodeSupportsMark;
    });
  }
  const setMark = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
    const { selection } = tr2;
    const { empty: empty2, ranges } = selection;
    const type = getMarkType(typeOrName, state.schema);
    if (dispatch) {
      if (empty2) {
        const oldAttributes = getMarkAttributes(state, type);
        tr2.addStoredMark(type.create({
          ...oldAttributes,
          ...attributes
        }));
      } else {
        ranges.forEach((range) => {
          const from2 = range.$from.pos;
          const to = range.$to.pos;
          state.doc.nodesBetween(from2, to, (node2, pos) => {
            const trimmedFrom = Math.max(pos, from2);
            const trimmedTo = Math.min(pos + node2.nodeSize, to);
            const someHasMark = node2.marks.find((mark2) => mark2.type === type);
            if (someHasMark) {
              node2.marks.forEach((mark2) => {
                if (type === mark2.type) {
                  tr2.addMark(trimmedFrom, trimmedTo, type.create({
                    ...mark2.attrs,
                    ...attributes
                  }));
                }
              });
            } else {
              tr2.addMark(trimmedFrom, trimmedTo, type.create(attributes));
            }
          });
        });
      }
    }
    return canSetMark(state, tr2, type);
  };
  const setMeta$1 = (key2, value) => ({ tr: tr2 }) => {
    tr2.setMeta(key2, value);
    return true;
  };
  const setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
    const type = getNodeType(typeOrName, state.schema);
    if (!type.isTextblock) {
      console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
      return false;
    }
    return chain().command(({ commands: commands2 }) => {
      const canSetBlock = setBlockType(type, attributes)(state);
      if (canSetBlock) {
        return true;
      }
      return commands2.clearNodes();
    }).command(({ state: updatedState }) => {
      return setBlockType(type, attributes)(updatedState, dispatch);
    }).run();
  };
  const setNodeSelection = (position2) => ({ tr: tr2, dispatch }) => {
    if (dispatch) {
      const { doc: doc2 } = tr2;
      const from2 = minMax(position2, 0, doc2.content.size);
      const selection = NodeSelection.create(doc2, from2);
      tr2.setSelection(selection);
    }
    return true;
  };
  const setTextSelection = (position2) => ({ tr: tr2, dispatch }) => {
    if (dispatch) {
      const { doc: doc2 } = tr2;
      const { from: from2, to } = typeof position2 === "number" ? { from: position2, to: position2 } : position2;
      const minPos = TextSelection.atStart(doc2).from;
      const maxPos = TextSelection.atEnd(doc2).to;
      const resolvedFrom = minMax(from2, minPos, maxPos);
      const resolvedEnd = minMax(to, minPos, maxPos);
      const selection = TextSelection.create(doc2, resolvedFrom, resolvedEnd);
      tr2.setSelection(selection);
    }
    return true;
  };
  const sinkListItem = (typeOrName) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return sinkListItem$1(type)(state, dispatch);
  };
  function ensureMarks(state, splittableMarks) {
    const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
    if (marks) {
      const filteredMarks = marks.filter((mark2) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark2.type.name));
      state.tr.ensureMarks(filteredMarks);
    }
  }
  const splitBlock = ({ keepMarks = true } = {}) => ({ tr: tr2, state, dispatch, editor: editor2 }) => {
    const { selection, doc: doc2 } = tr2;
    const { $from, $to } = selection;
    const extensionAttributes = editor2.extensionManager.attributes;
    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
    if (selection instanceof NodeSelection && selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
        return false;
      }
      if (dispatch) {
        if (keepMarks) {
          ensureMarks(state, editor2.extensionManager.splittableMarks);
        }
        tr2.split($from.pos).scrollIntoView();
      }
      return true;
    }
    if (!$from.parent.isBlock) {
      return false;
    }
    if (dispatch) {
      const atEnd = $to.parentOffset === $to.parent.content.size;
      if (selection instanceof TextSelection) {
        tr2.deleteSelection();
      }
      const deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      let types2 = atEnd && deflt ? [
        {
          type: deflt,
          attrs: newAttributes
        }
      ] : void 0;
      let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types2);
      if (!types2 && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
        can = true;
        types2 = deflt ? [
          {
            type: deflt,
            attrs: newAttributes
          }
        ] : void 0;
      }
      if (can) {
        tr2.split(tr2.mapping.map($from.pos), 1, types2);
        if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
          const first2 = tr2.mapping.map($from.before());
          const $first = tr2.doc.resolve(first2);
          if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
            tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
          }
        }
      }
      if (keepMarks) {
        ensureMarks(state, editor2.extensionManager.splittableMarks);
      }
      tr2.scrollIntoView();
    }
    return true;
  };
  const splitListItem = (typeOrName) => ({ tr: tr2, state, dispatch, editor: editor2 }) => {
    var _a;
    const type = getNodeType(typeOrName, state.schema);
    const { $from, $to } = state.selection;
    const node2 = state.selection.node;
    if (node2 && node2.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
      return false;
    }
    const grandParent = $from.node(-1);
    if (grandParent.type !== type) {
      return false;
    }
    const extensionAttributes = editor2.extensionManager.attributes;
    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
      if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
        return false;
      }
      if (dispatch) {
        let wrap2 = Fragment.empty;
        const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
        for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
          wrap2 = Fragment.from($from.node(d).copy(wrap2));
        }
        const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        const newNextTypeAttributes2 = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
        const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
        wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
        const start = $from.before($from.depth - (depthBefore - 1));
        tr2.replace(start, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
        let sel = -1;
        tr2.doc.nodesBetween(start, tr2.doc.content.size, (n, pos) => {
          if (sel > -1) {
            return false;
          }
          if (n.isTextblock && n.content.size === 0) {
            sel = pos + 1;
          }
        });
        if (sel > -1) {
          tr2.setSelection(TextSelection.near(tr2.doc.resolve(sel)));
        }
        tr2.scrollIntoView();
      }
      return true;
    }
    const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
    const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
    tr2.delete($from.pos, $to.pos);
    const types2 = nextType ? [
      { type, attrs: newTypeAttributes },
      { type: nextType, attrs: newNextTypeAttributes }
    ] : [{ type, attrs: newTypeAttributes }];
    if (!canSplit(tr2.doc, $from.pos, 2)) {
      return false;
    }
    if (dispatch) {
      const { selection, storedMarks } = state;
      const { splittableMarks } = editor2.extensionManager;
      const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
      tr2.split($from.pos, 2, types2).scrollIntoView();
      if (!marks || !dispatch) {
        return true;
      }
      const filteredMarks = marks.filter((mark2) => splittableMarks.includes(mark2.type.name));
      tr2.ensureMarks(filteredMarks);
    }
    return true;
  };
  const joinListBackwards = (tr2, listType) => {
    const list2 = findParentNode((node2) => node2.type === listType)(tr2.selection);
    if (!list2) {
      return true;
    }
    const before = tr2.doc.resolve(Math.max(0, list2.pos - 1)).before(list2.depth);
    if (before === void 0) {
      return true;
    }
    const nodeBefore = tr2.doc.nodeAt(before);
    const canJoinBackwards = list2.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr2.doc, list2.pos);
    if (!canJoinBackwards) {
      return true;
    }
    tr2.join(list2.pos);
    return true;
  };
  const joinListForwards = (tr2, listType) => {
    const list2 = findParentNode((node2) => node2.type === listType)(tr2.selection);
    if (!list2) {
      return true;
    }
    const after = tr2.doc.resolve(list2.start).after(list2.depth);
    if (after === void 0) {
      return true;
    }
    const nodeAfter = tr2.doc.nodeAt(after);
    const canJoinForwards = list2.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr2.doc, after);
    if (!canJoinForwards) {
      return true;
    }
    tr2.join(after);
    return true;
  };
  const toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor: editor2, tr: tr2, state, dispatch, chain, commands: commands2, can }) => {
    const { extensions: extensions2, splittableMarks } = editor2.extensionManager;
    const listType = getNodeType(listTypeOrName, state.schema);
    const itemType = getNodeType(itemTypeOrName, state.schema);
    const { selection, storedMarks } = state;
    const { $from, $to } = selection;
    const range = $from.blockRange($to);
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    if (!range) {
      return false;
    }
    const parentList = findParentNode((node2) => isList(node2.type.name, extensions2))(selection);
    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
      if (parentList.node.type === listType) {
        return commands2.liftListItem(itemType);
      }
      if (isList(parentList.node.type.name, extensions2) && listType.validContent(parentList.node.content) && dispatch) {
        return chain().command(() => {
          tr2.setNodeMarkup(parentList.pos, listType);
          return true;
        }).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
      }
    }
    if (!keepMarks || !marks || !dispatch) {
      return chain().command(() => {
        const canWrapInList = can().wrapInList(listType, attributes);
        if (canWrapInList) {
          return true;
        }
        return commands2.clearNodes();
      }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
    }
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      const filteredMarks = marks.filter((mark2) => splittableMarks.includes(mark2.type.name));
      tr2.ensureMarks(filteredMarks);
      if (canWrapInList) {
        return true;
      }
      return commands2.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
  };
  const toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {
    const { extendEmptyMarkRange = false } = options;
    const type = getMarkType(typeOrName, state.schema);
    const isActive2 = isMarkActive(state, type, attributes);
    if (isActive2) {
      return commands2.unsetMark(type, { extendEmptyMarkRange });
    }
    return commands2.setMark(type, attributes);
  };
  const toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    const toggleType = getNodeType(toggleTypeOrName, state.schema);
    const isActive2 = isNodeActive(state, type, attributes);
    if (isActive2) {
      return commands2.setNode(toggleType);
    }
    return commands2.setNode(type, attributes);
  };
  const toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    const isActive2 = isNodeActive(state, type, attributes);
    if (isActive2) {
      return commands2.lift(type);
    }
    return commands2.wrapIn(type, attributes);
  };
  const undoInputRule = () => ({ state, dispatch }) => {
    const plugins = state.plugins;
    for (let i2 = 0; i2 < plugins.length; i2 += 1) {
      const plugin = plugins[i2];
      let undoable;
      if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
        if (dispatch) {
          const tr2 = state.tr;
          const toUndo = undoable.transform;
          for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
            tr2.step(toUndo.steps[j].invert(toUndo.docs[j]));
          }
          if (undoable.text) {
            const marks = tr2.doc.resolve(undoable.from).marks();
            tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
          } else {
            tr2.delete(undoable.from, undoable.to);
          }
        }
        return true;
      }
    }
    return false;
  };
  const unsetAllMarks = () => ({ tr: tr2, dispatch }) => {
    const { selection } = tr2;
    const { empty: empty2, ranges } = selection;
    if (empty2) {
      return true;
    }
    if (dispatch) {
      ranges.forEach((range) => {
        tr2.removeMark(range.$from.pos, range.$to.pos);
      });
    }
    return true;
  };
  const unsetMark = (typeOrName, options = {}) => ({ tr: tr2, state, dispatch }) => {
    var _a;
    const { extendEmptyMarkRange = false } = options;
    const { selection } = tr2;
    const type = getMarkType(typeOrName, state.schema);
    const { $from, empty: empty2, ranges } = selection;
    if (!dispatch) {
      return true;
    }
    if (empty2 && extendEmptyMarkRange) {
      let { from: from2, to } = selection;
      const attrs = (_a = $from.marks().find((mark2) => mark2.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
      const range = getMarkRange($from, type, attrs);
      if (range) {
        from2 = range.from;
        to = range.to;
      }
      tr2.removeMark(from2, to, type);
    } else {
      ranges.forEach((range) => {
        tr2.removeMark(range.$from.pos, range.$to.pos, type);
      });
    }
    tr2.removeStoredMark(type);
    return true;
  };
  const updateAttributes = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
    let nodeType = null;
    let markType = null;
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (!schemaType) {
      return false;
    }
    if (schemaType === "node") {
      nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === "mark") {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch) {
      tr2.selection.ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node2, pos) => {
          if (nodeType && nodeType === node2.type) {
            tr2.setNodeMarkup(pos, void 0, {
              ...node2.attrs,
              ...attributes
            });
          }
          if (markType && node2.marks.length) {
            node2.marks.forEach((mark2) => {
              if (markType === mark2.type) {
                const trimmedFrom = Math.max(pos, from2);
                const trimmedTo = Math.min(pos + node2.nodeSize, to);
                tr2.addMark(trimmedFrom, trimmedTo, markType.create({
                  ...mark2.attrs,
                  ...attributes
                }));
              }
            });
          }
        });
      });
    }
    return true;
  };
  const wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return wrapIn$1(type, attributes)(state, dispatch);
  };
  const wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return wrapInList$1(type, attributes)(state, dispatch);
  };
  var commands = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    blur,
    clearContent,
    clearNodes,
    command,
    createParagraphNear,
    cut,
    deleteCurrentNode,
    deleteNode,
    deleteRange,
    deleteSelection,
    enter,
    exitCode,
    extendMarkRange,
    first,
    focus,
    forEach: forEach$1,
    insertContent,
    insertContentAt,
    joinUp,
    joinDown,
    joinBackward,
    joinForward,
    joinItemBackward,
    joinItemForward,
    joinTextblockBackward,
    joinTextblockForward,
    keyboardShortcut,
    lift,
    liftEmptyBlock,
    liftListItem,
    newlineInCode,
    resetAttributes,
    scrollIntoView,
    selectAll,
    selectNodeBackward,
    selectNodeForward,
    selectParentNode,
    selectTextblockEnd,
    selectTextblockStart,
    setContent,
    setMark,
    setMeta: setMeta$1,
    setNode,
    setNodeSelection,
    setTextSelection,
    sinkListItem,
    splitBlock,
    splitListItem,
    toggleList,
    toggleMark,
    toggleNode,
    toggleWrap,
    undoInputRule,
    unsetAllMarks,
    unsetMark,
    updateAttributes,
    wrapIn,
    wrapInList
  });
  const Commands = Extension.create({
    name: "commands",
    addCommands() {
      return {
        ...commands
      };
    }
  });
  const Editable = Extension.create({
    name: "editable",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("editable"),
          props: {
            editable: () => this.editor.options.editable
          }
        })
      ];
    }
  });
  const FocusEvents = Extension.create({
    name: "focusEvents",
    addProseMirrorPlugins() {
      const { editor: editor2 } = this;
      return [
        new Plugin({
          key: new PluginKey("focusEvents"),
          props: {
            handleDOMEvents: {
              focus: (view, event) => {
                editor2.isFocused = true;
                const transaction = editor2.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
                view.dispatch(transaction);
                return false;
              },
              blur: (view, event) => {
                editor2.isFocused = false;
                const transaction = editor2.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
                view.dispatch(transaction);
                return false;
              }
            }
          }
        })
      ];
    }
  });
  const Keymap = Extension.create({
    name: "keymap",
    addKeyboardShortcuts() {
      const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
        () => commands2.undoInputRule(),
        // maybe convert first text block node to default node
        () => commands2.command(({ tr: tr2 }) => {
          const { selection, doc: doc2 } = tr2;
          const { empty: empty2, $anchor } = selection;
          const { pos, parent } = $anchor;
          const $parentPos = $anchor.parent.isTextblock ? tr2.doc.resolve(pos - 1) : $anchor;
          const parentIsIsolating = $parentPos.parent.type.spec.isolating;
          const parentPos = $anchor.pos - $anchor.parentOffset;
          const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc2).from === pos;
          if (!empty2 || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {
            return false;
          }
          return commands2.clearNodes();
        }),
        () => commands2.deleteSelection(),
        () => commands2.joinBackward(),
        () => commands2.selectNodeBackward()
      ]);
      const handleDelete2 = () => this.editor.commands.first(({ commands: commands2 }) => [
        () => commands2.deleteSelection(),
        () => commands2.deleteCurrentNode(),
        () => commands2.joinForward(),
        () => commands2.selectNodeForward()
      ]);
      const handleEnter2 = () => this.editor.commands.first(({ commands: commands2 }) => [
        () => commands2.newlineInCode(),
        () => commands2.createParagraphNear(),
        () => commands2.liftEmptyBlock(),
        () => commands2.splitBlock()
      ]);
      const baseKeymap = {
        Enter: handleEnter2,
        "Mod-Enter": () => this.editor.commands.exitCode(),
        Backspace: handleBackspace,
        "Mod-Backspace": handleBackspace,
        "Shift-Backspace": handleBackspace,
        Delete: handleDelete2,
        "Mod-Delete": handleDelete2,
        "Mod-a": () => this.editor.commands.selectAll()
      };
      const pcKeymap = {
        ...baseKeymap
      };
      const macKeymap = {
        ...baseKeymap,
        "Ctrl-h": handleBackspace,
        "Alt-Backspace": handleBackspace,
        "Ctrl-d": handleDelete2,
        "Ctrl-Alt-Backspace": handleDelete2,
        "Alt-Delete": handleDelete2,
        "Alt-d": handleDelete2,
        "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
        "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
      };
      if (isiOS() || isMacOS()) {
        return macKeymap;
      }
      return pcKeymap;
    },
    addProseMirrorPlugins() {
      return [
        // With this plugin we check if the whole document was selected and deleted.
        // In this case we will additionally call `clearNodes()` to convert e.g. a heading
        // to a paragraph if necessary.
        // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
        // with many other commands.
        new Plugin({
          key: new PluginKey("clearDocument"),
          appendTransaction: (transactions, oldState, newState) => {
            const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
            if (!docChanges) {
              return;
            }
            const { empty: empty2, from: from2, to } = oldState.selection;
            const allFrom = Selection.atStart(oldState.doc).from;
            const allEnd = Selection.atEnd(oldState.doc).to;
            const allWasSelected = from2 === allFrom && to === allEnd;
            if (empty2 || !allWasSelected) {
              return;
            }
            const isEmpty2 = newState.doc.textBetween(0, newState.doc.content.size, " ", " ").length === 0;
            if (!isEmpty2) {
              return;
            }
            const tr2 = newState.tr;
            const state = createChainableState({
              state: newState,
              transaction: tr2
            });
            const { commands: commands2 } = new CommandManager({
              editor: this.editor,
              state
            });
            commands2.clearNodes();
            if (!tr2.steps.length) {
              return;
            }
            return tr2;
          }
        })
      ];
    }
  });
  const Tabindex = Extension.create({
    name: "tabindex",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("tabindex"),
          props: {
            attributes: this.editor.isEditable ? { tabindex: "0" } : {}
          }
        })
      ];
    }
  });
  var extensions = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ClipboardTextSerializer,
    Commands,
    Editable,
    FocusEvents,
    Keymap,
    Tabindex
  });
  class NodePos {
    constructor(pos, editor2, isBlock = false, node2 = null) {
      this.currentNode = null;
      this.actualDepth = null;
      this.isBlock = isBlock;
      this.resolvedPos = pos;
      this.editor = editor2;
      this.currentNode = node2;
    }
    get name() {
      return this.node.type.name;
    }
    get node() {
      return this.currentNode || this.resolvedPos.node();
    }
    get element() {
      return this.editor.view.domAtPos(this.pos).node;
    }
    get depth() {
      var _a;
      return (_a = this.actualDepth) !== null && _a !== void 0 ? _a : this.resolvedPos.depth;
    }
    get pos() {
      return this.resolvedPos.pos;
    }
    get content() {
      return this.node.content;
    }
    set content(content2) {
      let from2 = this.from;
      let to = this.to;
      if (this.isBlock) {
        if (this.content.size === 0) {
          console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
          return;
        }
        from2 = this.from + 1;
        to = this.to - 1;
      }
      this.editor.commands.insertContentAt({ from: from2, to }, content2);
    }
    get attributes() {
      return this.node.attrs;
    }
    get textContent() {
      return this.node.textContent;
    }
    get size() {
      return this.node.nodeSize;
    }
    get from() {
      if (this.isBlock) {
        return this.pos;
      }
      return this.resolvedPos.start(this.resolvedPos.depth);
    }
    get range() {
      return {
        from: this.from,
        to: this.to
      };
    }
    get to() {
      if (this.isBlock) {
        return this.pos + this.size;
      }
      return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
    }
    get parent() {
      if (this.depth === 0) {
        return null;
      }
      const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
      const $pos = this.resolvedPos.doc.resolve(parentPos);
      return new NodePos($pos, this.editor);
    }
    get before() {
      let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
      if ($pos.depth !== this.depth) {
        $pos = this.resolvedPos.doc.resolve(this.from - 3);
      }
      return new NodePos($pos, this.editor);
    }
    get after() {
      let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
      if ($pos.depth !== this.depth) {
        $pos = this.resolvedPos.doc.resolve(this.to + 3);
      }
      return new NodePos($pos, this.editor);
    }
    get children() {
      const children = [];
      this.node.content.forEach((node2, offset) => {
        const isBlock = node2.isBlock && !node2.isTextblock;
        const targetPos = this.pos + offset + (isBlock ? 0 : 1);
        const $pos = this.resolvedPos.doc.resolve(targetPos);
        if (!isBlock && $pos.depth <= this.depth) {
          return;
        }
        const childNodePos = new NodePos($pos, this.editor, isBlock, isBlock ? node2 : null);
        if (isBlock) {
          childNodePos.actualDepth = this.depth + 1;
        }
        children.push(new NodePos($pos, this.editor, isBlock, isBlock ? node2 : null));
      });
      return children;
    }
    get firstChild() {
      return this.children[0] || null;
    }
    get lastChild() {
      const children = this.children;
      return children[children.length - 1] || null;
    }
    closest(selector, attributes = {}) {
      let node2 = null;
      let currentNode = this.parent;
      while (currentNode && !node2) {
        if (currentNode.node.type.name === selector) {
          if (Object.keys(attributes).length > 0) {
            const nodeAttributes2 = currentNode.node.attrs;
            const attrKeys = Object.keys(attributes);
            for (let index2 = 0; index2 < attrKeys.length; index2 += 1) {
              const key2 = attrKeys[index2];
              if (nodeAttributes2[key2] !== attributes[key2]) {
                break;
              }
            }
          } else {
            node2 = currentNode;
          }
        }
        currentNode = currentNode.parent;
      }
      return node2;
    }
    querySelector(selector, attributes = {}) {
      return this.querySelectorAll(selector, attributes, true)[0] || null;
    }
    querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
      let nodes = [];
      if (this.isBlock || !this.children || this.children.length === 0) {
        return nodes;
      }
      this.children.forEach((childPos) => {
        if (childPos.node.type.name === selector) {
          if (Object.keys(attributes).length > 0) {
            const nodeAttributes2 = childPos.node.attrs;
            const attrKeys = Object.keys(attributes);
            for (let index2 = 0; index2 < attrKeys.length; index2 += 1) {
              const key2 = attrKeys[index2];
              if (nodeAttributes2[key2] !== attributes[key2]) {
                return;
              }
            }
          }
          nodes.push(childPos);
          if (firstItemOnly) {
            return;
          }
        }
        nodes = nodes.concat(childPos.querySelectorAll(selector));
      });
      return nodes;
    }
    setAttribute(attributes) {
      const oldSelection = this.editor.state.selection;
      this.editor.chain().setTextSelection(this.from).updateAttributes(this.node.type.name, attributes).setTextSelection(oldSelection.from).run();
    }
  }
  const style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
  function createStyleTag(style2, nonce, suffix) {
    const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
    if (tiptapStyleTag !== null) {
      return tiptapStyleTag;
    }
    const styleNode = document.createElement("style");
    if (nonce) {
      styleNode.setAttribute("nonce", nonce);
    }
    styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
    styleNode.innerHTML = style2;
    document.getElementsByTagName("head")[0].appendChild(styleNode);
    return styleNode;
  }
  class Editor extends EventEmitter$1 {
    constructor(options = {}) {
      super();
      this.isFocused = false;
      this.extensionStorage = {};
      this.options = {
        element: document.createElement("div"),
        content: "",
        injectCSS: true,
        injectNonce: void 0,
        extensions: [],
        autofocus: false,
        editable: true,
        editorProps: {},
        parseOptions: {},
        enableInputRules: true,
        enablePasteRules: true,
        enableCoreExtensions: true,
        onBeforeCreate: () => null,
        onCreate: () => null,
        onUpdate: () => null,
        onSelectionUpdate: () => null,
        onTransaction: () => null,
        onFocus: () => null,
        onBlur: () => null,
        onDestroy: () => null
      };
      this.isCapturingTransaction = false;
      this.capturedTransaction = null;
      this.setOptions(options);
      this.createExtensionManager();
      this.createCommandManager();
      this.createSchema();
      this.on("beforeCreate", this.options.onBeforeCreate);
      this.emit("beforeCreate", { editor: this });
      this.createView();
      this.injectCSS();
      this.on("create", this.options.onCreate);
      this.on("update", this.options.onUpdate);
      this.on("selectionUpdate", this.options.onSelectionUpdate);
      this.on("transaction", this.options.onTransaction);
      this.on("focus", this.options.onFocus);
      this.on("blur", this.options.onBlur);
      this.on("destroy", this.options.onDestroy);
      window.setTimeout(() => {
        if (this.isDestroyed) {
          return;
        }
        this.commands.focus(this.options.autofocus);
        this.emit("create", { editor: this });
      }, 0);
    }
    /**
     * Returns the editor storage.
     */
    get storage() {
      return this.extensionStorage;
    }
    /**
     * An object of all registered commands.
     */
    get commands() {
      return this.commandManager.commands;
    }
    /**
     * Create a command chain to call multiple commands at once.
     */
    chain() {
      return this.commandManager.chain();
    }
    /**
     * Check if a command or a command chain can be executed. Without executing it.
     */
    can() {
      return this.commandManager.can();
    }
    /**
     * Inject CSS styles.
     */
    injectCSS() {
      if (this.options.injectCSS && document) {
        this.css = createStyleTag(style, this.options.injectNonce);
      }
    }
    /**
     * Update editor options.
     *
     * @param options A list of options
     */
    setOptions(options = {}) {
      this.options = {
        ...this.options,
        ...options
      };
      if (!this.view || !this.state || this.isDestroyed) {
        return;
      }
      if (this.options.editorProps) {
        this.view.setProps(this.options.editorProps);
      }
      this.view.updateState(this.state);
    }
    /**
     * Update editable state of the editor.
     */
    setEditable(editable, emitUpdate = true) {
      this.setOptions({ editable });
      if (emitUpdate) {
        this.emit("update", { editor: this, transaction: this.state.tr });
      }
    }
    /**
     * Returns whether the editor is editable.
     */
    get isEditable() {
      return this.options.editable && this.view && this.view.editable;
    }
    /**
     * Returns the editor state.
     */
    get state() {
      return this.view.state;
    }
    /**
     * Register a ProseMirror plugin.
     *
     * @param plugin A ProseMirror plugin
     * @param handlePlugins Control how to merge the plugin into the existing plugins.
     */
    registerPlugin(plugin, handlePlugins) {
      const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
      const state = this.state.reconfigure({ plugins });
      this.view.updateState(state);
    }
    /**
     * Unregister a ProseMirror plugin.
     *
     * @param nameOrPluginKey The plugins name
     */
    unregisterPlugin(nameOrPluginKey) {
      if (this.isDestroyed) {
        return;
      }
      const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
      const state = this.state.reconfigure({
        // @ts-ignore
        plugins: this.state.plugins.filter((plugin) => !plugin.key.startsWith(name))
      });
      this.view.updateState(state);
    }
    /**
     * Creates an extension manager.
     */
    createExtensionManager() {
      const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];
      const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension2) => {
        return ["extension", "node", "mark"].includes(extension2 === null || extension2 === void 0 ? void 0 : extension2.type);
      });
      this.extensionManager = new ExtensionManager(allExtensions, this);
    }
    /**
     * Creates an command manager.
     */
    createCommandManager() {
      this.commandManager = new CommandManager({
        editor: this
      });
    }
    /**
     * Creates a ProseMirror schema.
     */
    createSchema() {
      this.schema = this.extensionManager.schema;
    }
    /**
     * Creates a ProseMirror view.
     */
    createView() {
      const doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions);
      const selection = resolveFocusPosition(doc2, this.options.autofocus);
      this.view = new EditorView(this.options.element, {
        ...this.options.editorProps,
        dispatchTransaction: this.dispatchTransaction.bind(this),
        state: EditorState.create({
          doc: doc2,
          selection: selection || void 0
        })
      });
      const newState = this.state.reconfigure({
        plugins: this.extensionManager.plugins
      });
      this.view.updateState(newState);
      this.createNodeViews();
      this.prependClass();
      const dom = this.view.dom;
      dom.editor = this;
    }
    /**
     * Creates all node views.
     */
    createNodeViews() {
      this.view.setProps({
        nodeViews: this.extensionManager.nodeViews
      });
    }
    /**
     * Prepend class name to element.
     */
    prependClass() {
      this.view.dom.className = `tiptap ${this.view.dom.className}`;
    }
    captureTransaction(fn) {
      this.isCapturingTransaction = true;
      fn();
      this.isCapturingTransaction = false;
      const tr2 = this.capturedTransaction;
      this.capturedTransaction = null;
      return tr2;
    }
    /**
     * The callback over which to send transactions (state updates) produced by the view.
     *
     * @param transaction An editor state transaction
     */
    dispatchTransaction(transaction) {
      if (this.view.isDestroyed) {
        return;
      }
      if (this.isCapturingTransaction) {
        if (!this.capturedTransaction) {
          this.capturedTransaction = transaction;
          return;
        }
        transaction.steps.forEach((step) => {
          var _a;
          return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);
        });
        return;
      }
      const state = this.state.apply(transaction);
      const selectionHasChanged = !this.state.selection.eq(state.selection);
      this.view.updateState(state);
      this.emit("transaction", {
        editor: this,
        transaction
      });
      if (selectionHasChanged) {
        this.emit("selectionUpdate", {
          editor: this,
          transaction
        });
      }
      const focus2 = transaction.getMeta("focus");
      const blur2 = transaction.getMeta("blur");
      if (focus2) {
        this.emit("focus", {
          editor: this,
          event: focus2.event,
          transaction
        });
      }
      if (blur2) {
        this.emit("blur", {
          editor: this,
          event: blur2.event,
          transaction
        });
      }
      if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
        return;
      }
      this.emit("update", {
        editor: this,
        transaction
      });
    }
    /**
     * Get attributes of the currently selected node or mark.
     */
    getAttributes(nameOrType) {
      return getAttributes(this.state, nameOrType);
    }
    isActive(nameOrAttributes, attributesOrUndefined) {
      const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
      const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
      return isActive(this.state, name, attributes);
    }
    /**
     * Get the document as JSON.
     */
    getJSON() {
      return this.state.doc.toJSON();
    }
    /**
     * Get the document as HTML.
     */
    getHTML() {
      return getHTMLFromFragment(this.state.doc.content, this.schema);
    }
    /**
     * Get the document as text.
     */
    getText(options) {
      const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
      return getText(this.state.doc, {
        blockSeparator,
        textSerializers: {
          ...getTextSerializersFromSchema(this.schema),
          ...textSerializers
        }
      });
    }
    /**
     * Check if there is no content.
     */
    get isEmpty() {
      return isNodeEmpty(this.state.doc);
    }
    /**
     * Get the number of characters for the current document.
     *
     * @deprecated
     */
    getCharacterCount() {
      console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
      return this.state.doc.content.size - 2;
    }
    /**
     * Destroy the editor.
     */
    destroy() {
      this.emit("destroy");
      if (this.view) {
        this.view.destroy();
      }
      this.removeAllListeners();
    }
    /**
     * Check if the editor is already destroyed.
     */
    get isDestroyed() {
      var _a;
      return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
    }
    $node(selector, attributes) {
      var _a;
      return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelector(selector, attributes)) || null;
    }
    $nodes(selector, attributes) {
      var _a;
      return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector, attributes)) || null;
    }
    $pos(pos) {
      const $pos = this.state.doc.resolve(pos);
      return new NodePos($pos, this);
    }
    get $doc() {
      return this.$pos(0);
    }
  }
  function markInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        const attributes = callOrReturn(config.getAttributes, void 0, match);
        if (attributes === false || attributes === null) {
          return null;
        }
        const { tr: tr2 } = state;
        const captureGroup = match[match.length - 1];
        const fullMatch = match[0];
        if (captureGroup) {
          const startSpaces = fullMatch.search(/\S/);
          const textStart = range.from + fullMatch.indexOf(captureGroup);
          const textEnd = textStart + captureGroup.length;
          const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
            const excluded = item.mark.type.excluded;
            return excluded.find((type) => type === config.type && type !== item.mark.type);
          }).filter((item) => item.to > textStart);
          if (excludedMarks.length) {
            return null;
          }
          if (textEnd < range.to) {
            tr2.delete(textEnd, range.to);
          }
          if (textStart > range.from) {
            tr2.delete(range.from + startSpaces, textStart);
          }
          const markEnd = range.from + startSpaces + captureGroup.length;
          tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
          tr2.removeStoredMark(config.type);
        }
      }
    });
  }
  function nodeInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
        const { tr: tr2 } = state;
        const start = range.from;
        let end = range.to;
        const newNode = config.type.create(attributes);
        if (match[1]) {
          const offset = match[0].lastIndexOf(match[1]);
          let matchStart = start + offset;
          if (matchStart > end) {
            matchStart = end;
          } else {
            end = matchStart + match[1].length;
          }
          const lastChar = match[0][match[0].length - 1];
          tr2.insertText(lastChar, start + match[0].length - 1);
          tr2.replaceWith(matchStart, end, newNode);
        } else if (match[0]) {
          tr2.insert(start - 1, config.type.create(attributes)).delete(tr2.mapping.map(start), tr2.mapping.map(end));
        }
        tr2.scrollIntoView();
      }
    });
  }
  function textblockTypeInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        const $start = state.doc.resolve(range.from);
        const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
          return null;
        }
        state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
      }
    });
  }
  class Mark {
    constructor(config = {}) {
      this.type = "mark";
      this.name = "mark";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = {
        ...this.config,
        ...config
      };
      this.name = this.config.name;
      if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config = {}) {
      return new Mark(config);
    }
    configure(options = {}) {
      const extension2 = this.extend();
      extension2.options = mergeDeep(this.options, options);
      extension2.storage = callOrReturn(getExtensionField(extension2, "addStorage", {
        name: extension2.name,
        options: extension2.options
      }));
      return extension2;
    }
    extend(extendedConfig = {}) {
      const extension2 = new Mark({ ...this.config, ...extendedConfig });
      extension2.parent = this;
      this.child = extension2;
      extension2.name = extendedConfig.name ? extendedConfig.name : extension2.parent.name;
      if (extendedConfig.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension2.name}".`);
      }
      extension2.options = callOrReturn(getExtensionField(extension2, "addOptions", {
        name: extension2.name
      }));
      extension2.storage = callOrReturn(getExtensionField(extension2, "addStorage", {
        name: extension2.name,
        options: extension2.options
      }));
      return extension2;
    }
    static handleExit({ editor: editor2, mark: mark2 }) {
      const { tr: tr2 } = editor2.state;
      const currentPos = editor2.state.selection.$from;
      const isAtEnd = currentPos.pos === currentPos.end();
      if (isAtEnd) {
        const currentMarks = currentPos.marks();
        const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark2.name);
        if (!isInMark) {
          return false;
        }
        const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark2.name);
        if (removeMark2) {
          tr2.removeStoredMark(removeMark2);
        }
        tr2.insertText(" ", currentPos.pos);
        editor2.view.dispatch(tr2);
        return true;
      }
      return false;
    }
  }
  class Node {
    constructor(config = {}) {
      this.type = "node";
      this.name = "node";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = {
        ...this.config,
        ...config
      };
      this.name = this.config.name;
      if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config = {}) {
      return new Node(config);
    }
    configure(options = {}) {
      const extension2 = this.extend();
      extension2.options = mergeDeep(this.options, options);
      extension2.storage = callOrReturn(getExtensionField(extension2, "addStorage", {
        name: extension2.name,
        options: extension2.options
      }));
      return extension2;
    }
    extend(extendedConfig = {}) {
      const extension2 = new Node({ ...this.config, ...extendedConfig });
      extension2.parent = this;
      this.child = extension2;
      extension2.name = extendedConfig.name ? extendedConfig.name : extension2.parent.name;
      if (extendedConfig.defaultOptions) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension2.name}".`);
      }
      extension2.options = callOrReturn(getExtensionField(extension2, "addOptions", {
        name: extension2.name
      }));
      extension2.storage = callOrReturn(getExtensionField(extension2, "addStorage", {
        name: extension2.name,
        options: extension2.options
      }));
      return extension2;
    }
  }
  function markPasteRule(config) {
    return new PasteRule({
      find: config.find,
      handler: ({ state, range, match, pasteEvent }) => {
        const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
        if (attributes === false || attributes === null) {
          return null;
        }
        const { tr: tr2 } = state;
        const captureGroup = match[match.length - 1];
        const fullMatch = match[0];
        let markEnd = range.to;
        if (captureGroup) {
          const startSpaces = fullMatch.search(/\S/);
          const textStart = range.from + fullMatch.indexOf(captureGroup);
          const textEnd = textStart + captureGroup.length;
          const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
            const excluded = item.mark.type.excluded;
            return excluded.find((type) => type === config.type && type !== item.mark.type);
          }).filter((item) => item.to > textStart);
          if (excludedMarks.length) {
            return null;
          }
          if (textEnd < range.to) {
            tr2.delete(textEnd, range.to);
          }
          if (textStart > range.from) {
            tr2.delete(range.from + startSpaces, textStart);
          }
          markEnd = range.from + startSpaces + captureGroup.length;
          tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
          tr2.removeStoredMark(config.type);
        }
      }
    });
  }
  var getRandomValues$1;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues$1) {
      getRandomValues$1 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (!getRandomValues$1) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues$1(rnds8);
  }
  const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function validate(uuid) {
    return typeof uuid === "string" && REGEX.test(uuid);
  }
  var byteToHex = [];
  for (var i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).substr(1));
  }
  function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = rnds[i2];
      }
      return buf;
    }
    return stringify(rnds);
  }
  function removeDuplicates(array, by = JSON.stringify) {
    const seen = {};
    return array.filter((item) => {
      const key2 = by(item);
      return Object.prototype.hasOwnProperty.call(seen, key2) ? false : seen[key2] = true;
    });
  }
  function findDuplicates(items) {
    const filtered = items.filter(
      (el, index2) => items.indexOf(el) !== index2
    );
    const duplicates = removeDuplicates(filtered);
    return duplicates;
  }
  const UniqueID = Extension.create({
    name: "uniqueID",
    // we’ll set a very high priority to make sure this runs first
    // and is compatible with `appendTransaction` hooks of other extensions
    priority: 1e4,
    addOptions() {
      return {
        attributeName: "id",
        types: [],
        generateID: () => {
          if (typeof window !== "undefined" && window.__TEST_OPTIONS) {
            const testOptions = window.__TEST_OPTIONS;
            if (testOptions.mockID === void 0) {
              testOptions.mockID = 0;
            } else {
              testOptions.mockID++;
            }
            return testOptions.mockID.toString();
          }
          return v4();
        },
        filterTransaction: null
      };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            [this.options.attributeName]: {
              default: null,
              parseHTML: (element2) => element2.getAttribute(`data-${this.options.attributeName}`),
              renderHTML: (attributes) => ({
                [`data-${this.options.attributeName}`]: attributes[this.options.attributeName]
              })
            }
          }
        }
      ];
    },
    // check initial content for missing ids
    // onCreate() {
    //   // Don’t do this when the collaboration extension is active
    //   // because this may update the content, so Y.js tries to merge these changes.
    //   // This leads to empty block nodes.
    //   // See: https://github.com/ueberdosis/tiptap/issues/2400
    //   if (
    //     this.editor.extensionManager.extensions.find(
    //       (extension) => extension.name === "collaboration"
    //     )
    //   ) {
    //     return;
    //   }
    //   const { view, state } = this.editor;
    //   const { tr, doc } = state;
    //   const { types, attributeName, generateID } = this.options;
    //   const nodesWithoutId = findChildren(doc, (node) => {
    //     return (
    //       types.includes(node.type.name) && node.attrs[attributeName] === null
    //     );
    //   });
    //   nodesWithoutId.forEach(({ node, pos }) => {
    //     tr.setNodeMarkup(pos, undefined, {
    //       ...node.attrs,
    //       [attributeName]: generateID(),
    //     });
    //   });
    //   tr.setMeta("addToHistory", false);
    //   view.dispatch(tr);
    // },
    addProseMirrorPlugins() {
      let dragSourceElement = null;
      let transformPasted2 = false;
      return [
        new Plugin({
          key: new PluginKey("uniqueID"),
          appendTransaction: (transactions, oldState, newState) => {
            const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
            const filterTransactions = this.options.filterTransaction && transactions.some((tr22) => {
              let _a, _b;
              return !((_b = (_a = this.options).filterTransaction) === null || _b === void 0 ? void 0 : _b.call(_a, tr22));
            });
            if (!docChanges || filterTransactions) {
              return;
            }
            const { tr: tr2 } = newState;
            const { types: types2, attributeName, generateID } = this.options;
            const transform2 = combineTransactionSteps(
              oldState.doc,
              transactions
            );
            const { mapping } = transform2;
            const changes = getChangedRanges(transform2);
            changes.forEach(({ newRange }) => {
              const newNodes = findChildrenInRange(
                newState.doc,
                newRange,
                (node2) => {
                  return types2.includes(node2.type.name);
                }
              );
              const newIds = newNodes.map(({ node: node2 }) => node2.attrs[attributeName]).filter((id) => id !== null);
              const duplicatedNewIds = findDuplicates(newIds);
              newNodes.forEach(({ node: node2, pos }) => {
                let _a;
                const id = (_a = tr2.doc.nodeAt(pos)) === null || _a === void 0 ? void 0 : _a.attrs[attributeName];
                if (id === null) {
                  const initialDoc = oldState.doc.type.createAndFill().content;
                  const wasInitial = oldState.doc.content.findDiffStart(initialDoc) === null;
                  if (wasInitial) {
                    const jsonNode = JSON.parse(
                      JSON.stringify(newState.doc.toJSON())
                    );
                    jsonNode.content[0].content[0].attrs.id = "initialBlockId";
                    if (JSON.stringify(jsonNode.content) === JSON.stringify(initialDoc.toJSON())) {
                      tr2.setNodeMarkup(pos, void 0, {
                        ...node2.attrs,
                        [attributeName]: "initialBlockId"
                      });
                      return;
                    }
                  }
                  tr2.setNodeMarkup(pos, void 0, {
                    ...node2.attrs,
                    [attributeName]: generateID()
                  });
                  return;
                }
                const { deleted } = mapping.invert().mapResult(pos);
                const newNode = deleted && duplicatedNewIds.includes(id);
                if (newNode) {
                  tr2.setNodeMarkup(pos, void 0, {
                    ...node2.attrs,
                    [attributeName]: generateID()
                  });
                }
              });
            });
            if (!tr2.steps.length) {
              return;
            }
            return tr2;
          },
          // we register a global drag handler to track the current drag source element
          view(view) {
            const handleDragstart = (event) => {
              let _a;
              dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
            };
            window.addEventListener("dragstart", handleDragstart);
            return {
              destroy() {
                window.removeEventListener("dragstart", handleDragstart);
              }
            };
          },
          props: {
            // `handleDOMEvents` is called before `transformPasted`
            // so we can do some checks before
            handleDOMEvents: {
              // only create new ids for dropped content while holding `alt`
              // or content is dragged from another editor
              drop: (view, event) => {
                let _a;
                if (dragSourceElement !== view.dom.parentElement || ((_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.effectAllowed) === "copy") {
                  dragSourceElement = null;
                  transformPasted2 = true;
                }
                return false;
              },
              // always create new ids on pasted content
              paste: () => {
                transformPasted2 = true;
                return false;
              }
            },
            // we’ll remove ids for every pasted node
            // so we can create a new one within `appendTransaction`
            transformPasted: (slice) => {
              if (!transformPasted2) {
                return slice;
              }
              const { types: types2, attributeName } = this.options;
              const removeId = (fragment) => {
                const list2 = [];
                fragment.forEach((node2) => {
                  if (node2.isText) {
                    list2.push(node2);
                    return;
                  }
                  if (!types2.includes(node2.type.name)) {
                    list2.push(node2.copy(removeId(node2.content)));
                    return;
                  }
                  const nodeWithoutId = node2.type.create(
                    {
                      ...node2.attrs,
                      [attributeName]: null
                    },
                    removeId(node2.content),
                    node2.marks
                  );
                  list2.push(nodeWithoutId);
                });
                return Fragment.from(list2);
              };
              transformPasted2 = false;
              return new Slice(
                removeId(slice.content),
                slice.openStart,
                slice.openEnd
              );
            }
          }
        })
      ];
    }
  });
  function getBlockInfo(blockContainer) {
    const id = blockContainer.attrs["id"];
    const contentNode = blockContainer.firstChild;
    const contentType = contentNode.type;
    const numChildBlocks = blockContainer.childCount === 2 ? blockContainer.lastChild.childCount : 0;
    return {
      id,
      node: blockContainer,
      contentNode,
      contentType,
      numChildBlocks
    };
  }
  function getBlockInfoFromPos(doc2, pos) {
    const outerBlockGroupStartPos = 1;
    const outerBlockGroupEndPos = doc2.nodeSize - 2;
    if (pos <= outerBlockGroupStartPos) {
      pos = outerBlockGroupStartPos + 1;
      while (doc2.resolve(pos).parent.type.name !== "blockContainer" && pos < outerBlockGroupEndPos) {
        pos++;
      }
    } else if (pos >= outerBlockGroupEndPos) {
      pos = outerBlockGroupEndPos - 1;
      while (doc2.resolve(pos).parent.type.name !== "blockContainer" && pos > outerBlockGroupStartPos) {
        pos--;
      }
    }
    if (doc2.resolve(pos).parent.type.name === "blockGroup") {
      pos++;
    }
    const $pos = doc2.resolve(pos);
    const maxDepth = $pos.depth;
    let node2 = $pos.node(maxDepth);
    let depth = maxDepth;
    while (true) {
      if (depth < 0) {
        throw new Error(
          "Could not find blockContainer node. This can only happen if the underlying BlockNote schema has been edited."
        );
      }
      if (node2.type.name === "blockContainer") {
        break;
      }
      depth -= 1;
      node2 = $pos.node(depth);
    }
    const { id, contentNode, contentType, numChildBlocks } = getBlockInfo(node2);
    const startPos = $pos.start(depth);
    const endPos = $pos.end(depth);
    return {
      id,
      node: node2,
      contentNode,
      contentType,
      numChildBlocks,
      startPos,
      endPos,
      depth
    };
  }
  function isLinkInlineContent(content2) {
    return content2.type === "link";
  }
  function isPartialLinkInlineContent(content2) {
    return typeof content2 !== "string" && content2.type === "link";
  }
  function isStyledTextInlineContent(content2) {
    return typeof content2 !== "string" && content2.type === "text";
  }
  class UnreachableCaseError extends Error {
    constructor(val) {
      super(`Unreachable case: ${val}`);
    }
  }
  function styledTextToNodes(styledText, schema, styleSchema) {
    const marks = [];
    for (const [style2, value] of Object.entries(styledText.styles)) {
      const config = styleSchema[style2];
      if (!config) {
        throw new Error(`style ${style2} not found in styleSchema`);
      }
      if (config.propSchema === "boolean") {
        marks.push(schema.mark(style2));
      } else if (config.propSchema === "string") {
        marks.push(schema.mark(style2, { stringValue: value }));
      } else {
        throw new UnreachableCaseError(config.propSchema);
      }
    }
    return styledText.text.split(/(\n)/g).filter((text2) => text2.length > 0).map((text2) => {
      if (text2 === "\n") {
        return schema.nodes["hardBreak"].create();
      } else {
        return schema.text(text2, marks);
      }
    });
  }
  function linkToNodes(link2, schema, styleSchema) {
    const linkMark = schema.marks.link.create({
      href: link2.href
    });
    return styledTextArrayToNodes(link2.content, schema, styleSchema).map(
      (node2) => {
        if (node2.type.name === "text") {
          return node2.mark([...node2.marks, linkMark]);
        }
        if (node2.type.name === "hardBreak") {
          return node2;
        }
        throw new Error("unexpected node type");
      }
    );
  }
  function styledTextArrayToNodes(content2, schema, styleSchema) {
    const nodes = [];
    if (typeof content2 === "string") {
      nodes.push(
        ...styledTextToNodes(
          { type: "text", text: content2, styles: {} },
          schema,
          styleSchema
        )
      );
      return nodes;
    }
    for (const styledText of content2) {
      nodes.push(...styledTextToNodes(styledText, schema, styleSchema));
    }
    return nodes;
  }
  function inlineContentToNodes(blockContent, schema, styleSchema) {
    const nodes = [];
    for (const content2 of blockContent) {
      if (typeof content2 === "string") {
        nodes.push(...styledTextArrayToNodes(content2, schema, styleSchema));
      } else if (isPartialLinkInlineContent(content2)) {
        nodes.push(...linkToNodes(content2, schema, styleSchema));
      } else if (isStyledTextInlineContent(content2)) {
        nodes.push(...styledTextArrayToNodes([content2], schema, styleSchema));
      } else {
        nodes.push(
          blockOrInlineContentToContentNode(content2, schema, styleSchema)
        );
      }
    }
    return nodes;
  }
  function tableContentToNodes(tableContent, schema, styleSchema) {
    const rowNodes = [];
    for (let i2 = 0; i2 < tableContent.rows.length; i2++) {
      const row2 = tableContent.rows[i2];
      const columnNodes = [];
      for (const cell2 of row2.cells) {
        let pNode;
        let cellAttrs = {};
        if (!cell2) {
          const contentNode = schema.nodes["paragraph"].create({});
          const containerNode = schema.nodes["blockContainer"].create(
            {},
            contentNode
          );
          pNode = schema.nodes["tableParagraph"].create({}, containerNode);
        } else if (typeof cell2 === "string") {
          const contentNode = schema.nodes["paragraph"].create(
            {},
            schema.text(cell2)
          );
          const containerNode = schema.nodes["blockContainer"].create(
            {},
            contentNode
          );
          pNode = schema.nodes["tableParagraph"].create({}, containerNode);
        } else {
          const nodes = [];
          for (const content2 of cell2) {
            const node2 = blockToNode(content2, schema, styleSchema);
            nodes.push(node2);
          }
          const firstItem = cell2[0];
          const { colspan, rowspan, colwidth } = (firstItem == null ? void 0 : firstItem.props) ?? {};
          cellAttrs = { colspan, rowspan, colwidth };
          pNode = schema.nodes["tableParagraph"].create(cellAttrs, nodes);
        }
        let cellNode;
        if (i2 === 0) {
          cellNode = schema.nodes["tableHeader"].create(cellAttrs, pNode);
        } else {
          cellNode = schema.nodes["tableCell"].create(cellAttrs, pNode);
        }
        columnNodes.push(cellNode);
      }
      const rowNode = schema.nodes["tableRow"].create({}, columnNodes);
      rowNodes.push(rowNode);
    }
    return rowNodes;
  }
  function blockOrInlineContentToContentNode(block2, schema, styleSchema) {
    let contentNode;
    let type = block2.type;
    if (type === void 0) {
      type = "paragraph";
    }
    if (!schema.nodes[type]) {
      throw new Error(`node type ${type} not found in schema`);
    }
    if (!block2.content) {
      contentNode = schema.nodes[type].create(block2.props);
    } else if (typeof block2.content === "string") {
      contentNode = schema.nodes[type].create(
        block2.props,
        schema.text(block2.content)
      );
    } else if (Array.isArray(block2.content)) {
      const nodes = inlineContentToNodes(block2.content, schema, styleSchema);
      contentNode = schema.nodes[type].create(block2.props, nodes);
    } else if (block2.content.type === "tableContent") {
      const nodes = tableContentToNodes(block2.content, schema, styleSchema);
      contentNode = schema.nodes[type].create(block2.props, nodes);
    } else {
      throw new UnreachableCaseError(block2.content.type);
    }
    return contentNode;
  }
  function blockToNode(block2, schema, styleSchema) {
    let id = block2.id;
    if (id === void 0) {
      id = UniqueID.options.generateID();
    }
    const contentNode = blockOrInlineContentToContentNode(
      block2,
      schema,
      styleSchema
    );
    const children = [];
    if (block2.children) {
      for (const child of block2.children) {
        children.push(blockToNode(child, schema, styleSchema));
      }
    }
    const groupNode = schema.nodes["blockGroup"].create({}, children);
    return schema.nodes["blockContainer"].create(
      {
        id,
        ...block2.props
      },
      children.length > 0 ? [contentNode, groupNode] : contentNode
    );
  }
  function contentNodeToTableContent(contentNode, blockSchema, inlineContentSchema, styleSchema, blockCache) {
    const ret = {
      type: "tableContent",
      rows: []
    };
    contentNode.content.forEach((rowNode) => {
      const row2 = {
        cells: []
      };
      rowNode.content.forEach((cellNode) => {
        if (cellNode == null ? void 0 : cellNode.content) {
          const contentBlocks = [];
          const cellAttrs = cellNode.attrs;
          cellNode.content.forEach((node2) => {
            node2.content.forEach((childNode) => {
              const block2 = nodeToBlock(
                childNode,
                blockSchema,
                inlineContentSchema,
                styleSchema,
                blockCache
              );
              block2.props = { ...block2.props, ...cellAttrs };
              contentBlocks.push(block2);
            });
          });
          row2.cells.push(contentBlocks);
        }
      });
      ret.rows.push(row2);
    });
    return ret;
  }
  function contentNodeToInlineContent(contentNode, inlineContentSchema, styleSchema) {
    const content2 = [];
    let currentContent = void 0;
    contentNode.content.forEach((node2) => {
      if (node2.type.name === "hardBreak") {
        if (currentContent) {
          if (isStyledTextInlineContent(currentContent)) {
            currentContent.text += "\n";
          } else if (isLinkInlineContent(currentContent)) {
            currentContent.content[currentContent.content.length - 1].text += "\n";
          } else {
            throw new Error("unexpected");
          }
        } else {
          currentContent = {
            type: "text",
            text: "\n",
            styles: {}
          };
        }
        return;
      }
      if (node2.type.name !== "link" && node2.type.name !== "text" && inlineContentSchema[node2.type.name]) {
        if (currentContent) {
          content2.push(currentContent);
          currentContent = void 0;
        }
        content2.push(
          nodeToCustomInlineContent(node2, inlineContentSchema, styleSchema)
        );
        return;
      }
      const styles = {};
      let linkMark;
      for (const mark2 of node2.marks) {
        if (mark2.type.name === "link") {
          linkMark = mark2;
        } else {
          const config = styleSchema[mark2.type.name];
          if (!config) {
            throw new Error(`style ${mark2.type.name} not found in styleSchema`);
          }
          if (config.propSchema === "boolean") {
            styles[config.type] = true;
          } else if (config.propSchema === "string") {
            styles[config.type] = mark2.attrs.stringValue;
          } else {
            throw new UnreachableCaseError(config.propSchema);
          }
        }
      }
      if (currentContent) {
        if (isStyledTextInlineContent(currentContent)) {
          if (!linkMark) {
            if (JSON.stringify(currentContent.styles) === JSON.stringify(styles)) {
              currentContent.text += node2.textContent;
            } else {
              content2.push(currentContent);
              currentContent = {
                type: "text",
                text: node2.textContent,
                styles
              };
            }
          } else {
            content2.push(currentContent);
            currentContent = {
              type: "link",
              href: linkMark.attrs.href,
              content: [
                {
                  type: "text",
                  text: node2.textContent,
                  styles
                }
              ]
            };
          }
        } else if (isLinkInlineContent(currentContent)) {
          if (linkMark) {
            if (currentContent.href === linkMark.attrs.href) {
              if (JSON.stringify(
                currentContent.content[currentContent.content.length - 1].styles
              ) === JSON.stringify(styles)) {
                currentContent.content[currentContent.content.length - 1].text += node2.textContent;
              } else {
                currentContent.content.push({
                  type: "text",
                  text: node2.textContent,
                  styles
                });
              }
            } else {
              content2.push(currentContent);
              currentContent = {
                type: "link",
                href: linkMark.attrs.href,
                content: [
                  {
                    type: "text",
                    text: node2.textContent,
                    styles
                  }
                ]
              };
            }
          } else {
            content2.push(currentContent);
            currentContent = {
              type: "text",
              text: node2.textContent,
              styles
            };
          }
        } else
          ;
      } else {
        if (!linkMark) {
          currentContent = {
            type: "text",
            text: node2.textContent,
            styles
          };
        } else {
          currentContent = {
            type: "link",
            href: linkMark.attrs.href,
            content: [
              {
                type: "text",
                text: node2.textContent,
                styles
              }
            ]
          };
        }
      }
    });
    if (currentContent) {
      content2.push(currentContent);
    }
    return content2;
  }
  function nodeToCustomInlineContent(node2, inlineContentSchema, styleSchema) {
    if (node2.type.name === "text" || node2.type.name === "link") {
      throw new Error("unexpected");
    }
    const props = {};
    const icConfig = inlineContentSchema[node2.type.name];
    for (const [attr, value] of Object.entries(node2.attrs)) {
      if (!icConfig) {
        throw Error("ic node is of an unrecognized type: " + node2.type.name);
      }
      const propSchema = icConfig.propSchema;
      if (attr in propSchema) {
        props[attr] = value;
      }
    }
    let content2;
    if (icConfig.content === "styled") {
      content2 = contentNodeToInlineContent(
        node2,
        inlineContentSchema,
        styleSchema
      );
    } else {
      content2 = void 0;
    }
    const ic = {
      type: node2.type.name,
      props,
      content: content2
    };
    return ic;
  }
  function nodeToBlock(node2, blockSchema, inlineContentSchema, styleSchema, blockCache) {
    if (node2.type.name !== "blockContainer") {
      throw Error(
        "Node must be of type blockContainer, but is of type" + node2.type.name + "."
      );
    }
    const cachedBlock = blockCache == null ? void 0 : blockCache.get(node2);
    if (cachedBlock) {
      return cachedBlock;
    }
    const blockInfo = getBlockInfo(node2);
    let id = blockInfo.id;
    if (id === null) {
      id = UniqueID.options.generateID();
    }
    const props = {};
    for (const [attr, value] of Object.entries({
      ...node2.attrs,
      ...blockInfo.contentNode.attrs
    })) {
      const blockSpec = blockSchema[blockInfo.contentType.name];
      if (!blockSpec) {
        throw Error(
          "Block is of an unrecognized type: " + blockInfo.contentType.name
        );
      }
      const propSchema = blockSpec.propSchema;
      if (attr in propSchema) {
        props[attr] = value;
      }
    }
    const blockConfig = blockSchema[blockInfo.contentType.name];
    const children = [];
    for (let i2 = 0; i2 < blockInfo.numChildBlocks; i2++) {
      children.push(
        nodeToBlock(
          node2.lastChild.child(i2),
          blockSchema,
          inlineContentSchema,
          styleSchema,
          blockCache
        )
      );
    }
    let content2;
    if (blockConfig.content === "inline") {
      content2 = contentNodeToInlineContent(
        blockInfo.contentNode,
        inlineContentSchema,
        styleSchema
      );
    } else if (blockConfig.content === "table") {
      content2 = contentNodeToTableContent(
        blockInfo.contentNode,
        blockSchema,
        inlineContentSchema,
        styleSchema,
        blockCache
      );
    } else if (blockConfig.content === "none") {
      content2 = void 0;
    } else {
      throw new UnreachableCaseError(blockConfig.content);
    }
    const block2 = {
      id,
      type: blockConfig.type,
      props,
      content: content2,
      children
    };
    blockCache == null ? void 0 : blockCache.set(node2, block2);
    return block2;
  }
  function doc$1(options) {
    return options.document || window.document;
  }
  const serializeNodeInner = (node2, options, serializer, editor2, toExternalHTML) => {
    if (!serializer.nodes[node2.type.name]) {
      throw new Error("Serializer is missing a node type: " + node2.type.name);
    }
    const { dom, contentDOM } = DOMSerializer.renderSpec(
      doc$1(options),
      serializer.nodes[node2.type.name](node2)
    );
    if (contentDOM) {
      if (node2.isLeaf) {
        throw new RangeError("Content hole not allowed in a leaf node spec");
      }
      if (node2.type.name === "blockContainer") {
        const blockContentNode = node2.childCount > 0 && node2.firstChild.type.spec.group === "blockContent" ? node2.firstChild : void 0;
        const blockGroupNode = node2.childCount > 0 && node2.lastChild.type.spec.group === "blockGroup" ? node2.lastChild : void 0;
        if (blockContentNode !== void 0) {
          const impl = editor2.blockImplementations[blockContentNode.type.name].implementation;
          const toHTML = toExternalHTML ? impl.toExternalHTML : impl.toInternalHTML;
          const blockContent = toHTML(
            nodeToBlock(
              node2,
              editor2.blockSchema,
              editor2.inlineContentSchema,
              editor2.styleSchema,
              editor2.blockCache
            ),
            editor2
          );
          if (blockContent.contentDOM !== void 0) {
            if (node2.isLeaf) {
              throw new RangeError(
                "Content hole not allowed in a leaf node spec"
              );
            }
            blockContent.contentDOM.appendChild(
              serializer.serializeFragment(blockContentNode.content, options)
            );
          }
          contentDOM.appendChild(blockContent.dom);
        }
        if (blockGroupNode !== void 0) {
          serializer.serializeFragment(
            Fragment.from(blockGroupNode),
            options,
            contentDOM
          );
        }
      } else {
        serializer.serializeFragment(node2.content, options, contentDOM);
      }
    }
    return dom;
  };
  const serializeProseMirrorFragment = (fragment, serializer) => {
    const internalHTML = serializer.serializeFragment(fragment);
    const parent = document.createElement("div");
    parent.appendChild(internalHTML);
    return parent.innerHTML;
  };
  function fromDom(tree, options) {
    const result = tree ? transform(tree, options || {}) : void 0;
    return result || { type: "root", children: [] };
  }
  function transform(node2, options) {
    const transformed = one$3(node2, options);
    if (transformed && options.afterTransform)
      options.afterTransform(node2, transformed);
    return transformed;
  }
  function one$3(node2, options) {
    switch (node2.nodeType) {
      case 1: {
        return element$3(node2, options);
      }
      case 3: {
        return text$6(node2);
      }
      case 8: {
        return comment$1(node2);
      }
      case 9: {
        return root$3(node2, options);
      }
      case 10: {
        return doctype();
      }
      case 11: {
        return root$3(node2, options);
      }
      default: {
        return void 0;
      }
    }
  }
  function root$3(node2, options) {
    return { type: "root", children: all$4(node2, options) };
  }
  function doctype() {
    return { type: "doctype" };
  }
  function text$6(node2) {
    return { type: "text", value: node2.nodeValue || "" };
  }
  function comment$1(node2) {
    return { type: "comment", value: node2.nodeValue || "" };
  }
  function element$3(node2, options) {
    const space2 = node2.namespaceURI;
    const fn = space2 === webNamespaces.svg ? s : h;
    const tagName = space2 === webNamespaces.html ? node2.tagName.toLowerCase() : node2.tagName;
    const content2 = (
      // @ts-expect-error Types are wrong.
      space2 === webNamespaces.html && tagName === "template" ? node2.content : node2
    );
    const attributes = node2.getAttributeNames();
    const props = {};
    let index2 = -1;
    while (++index2 < attributes.length) {
      props[attributes[index2]] = node2.getAttribute(attributes[index2]) || "";
    }
    return fn(tagName, props, all$4(content2, options));
  }
  function all$4(node2, options) {
    const nodes = node2.childNodes;
    const children = [];
    let index2 = -1;
    while (++index2 < nodes.length) {
      const child = transform(nodes[index2], options);
      if (child !== void 0) {
        children.push(child);
      }
    }
    return children;
  }
  function simplifyBlocks(options) {
    const listItemBlockTypes = /* @__PURE__ */ new Set([
      ...options.orderedListItemBlockTypes,
      ...options.unorderedListItemBlockTypes
    ]);
    const simplifyBlocksHelper = (tree) => {
      var _a, _b;
      if (tree.children.length === 1 && ((_a = tree.children[0].properties) == null ? void 0 : _a["dataNodeType"]) === "blockGroup") {
        const blockGroup = tree.children[0];
        tree.children.pop();
        tree.children.push(...blockGroup.children);
      }
      let numChildElements = tree.children.length;
      let activeList;
      for (let i2 = 0; i2 < numChildElements; i2++) {
        const blockOuter = tree.children[i2];
        const blockContainer = blockOuter.children[0];
        const blockContent = blockContainer.children[0];
        const blockContentType = blockContent.properties["dataContentType"];
        if (blockContentType === "table") {
          const tboby = (_b = blockContent.children[0]) == null ? void 0 : _b.children[0];
          if (tboby) {
            for (const tr2 of tboby.children) {
              const row2 = tr2;
              for (const td of row2.children) {
                const col = td;
                for (const cell2 of col.children) {
                  const c = cell2;
                  simplifyBlocksHelper(c);
                }
              }
            }
          }
        }
        const blockGroup = blockContainer.children.length === 2 ? blockContainer.children[1] : null;
        const isListItemBlock = listItemBlockTypes.has(
          blockContent.properties["dataContentType"]
        );
        const listItemBlockType = isListItemBlock ? options.orderedListItemBlockTypes.has(
          blockContent.properties["dataContentType"]
        ) ? "ol" : "ul" : null;
        if (blockGroup !== null) {
          simplifyBlocksHelper(blockGroup);
        }
        if (activeList && activeList.tagName !== listItemBlockType) {
          tree.children.splice(
            i2 - activeList.children.length,
            activeList.children.length,
            activeList
          );
          const numElementsRemoved = activeList.children.length - 1;
          i2 -= numElementsRemoved;
          numChildElements -= numElementsRemoved;
          activeList = void 0;
        }
        if (isListItemBlock) {
          if (!activeList) {
            activeList = fromDom(
              document.createElement(listItemBlockType)
            );
          }
          const listItemElement = fromDom(
            document.createElement("li")
          );
          listItemElement.children.push(blockContent.children[0]);
          if (blockGroup !== null) {
            listItemElement.children.push(...blockGroup.children);
          }
          activeList.children.push(listItemElement);
        } else if (blockGroup !== null) {
          tree.children.splice(i2 + 1, 0, ...blockGroup.children);
          tree.children[i2] = blockContent.children[0];
          const numElementsAdded = blockGroup.children.length;
          i2 += numElementsAdded;
          numChildElements += numElementsAdded;
        } else {
          if (blockContent.children[0]) {
            tree.children[i2] = blockContent.children[0];
          }
        }
      }
      if (activeList) {
        tree.children.splice(
          numChildElements - activeList.children.length,
          activeList.children.length,
          activeList
        );
      }
    };
    return simplifyBlocksHelper;
  }
  const createExternalHTMLExporter = (schema, editor2) => {
    const serializer = DOMSerializer.fromSchema(schema);
    serializer.serializeNodeInner = (node2, options) => serializeNodeInner(node2, options, serializer, editor2, true);
    serializer.exportProseMirrorFragment = (fragment) => {
      const externalHTML = unified().use(rehypeParse, { fragment: true }).use(simplifyBlocks, {
        orderedListItemBlockTypes: /* @__PURE__ */ new Set(["numberedListItem"]),
        unorderedListItemBlockTypes: /* @__PURE__ */ new Set(["bulletListItem"])
      }).use(rehypeStringify).processSync(serializeProseMirrorFragment(fragment, serializer));
      return externalHTML.value;
    };
    serializer.exportBlocks = (blocks2) => {
      const nodes = blocks2.map(
        (block2) => blockToNode(block2, schema, editor2.styleSchema)
      );
      const blockGroup = schema.nodes["blockGroup"].create(null, nodes);
      return serializer.exportProseMirrorFragment(Fragment.from(blockGroup));
    };
    return serializer;
  };
  const createInternalHTMLSerializer = (schema, editor2) => {
    const serializer = DOMSerializer.fromSchema(schema);
    serializer.serializeNodeInner = (node2, options) => serializeNodeInner(node2, options, serializer, editor2, false);
    serializer.serializeProseMirrorFragment = (fragment) => serializeProseMirrorFragment(fragment, serializer);
    serializer.serializeBlocks = (blocks2) => {
      const nodes = blocks2.map(
        (block2) => blockToNode(block2, schema, editor2.styleSchema)
      );
      const blockGroup = schema.nodes["blockGroup"].create(null, nodes);
      return serializer.serializeProseMirrorFragment(Fragment.from(blockGroup));
    };
    return serializer;
  };
  const uploadToTmpFilesDotOrg_DEV_ONLY = async (file) => {
    const body2 = new FormData();
    body2.append("file", file);
    const ret = await fetch("https://tmpfiles.org/api/v1/upload", {
      method: "POST",
      body: body2
    });
    return (await ret.json()).data.url.replace(
      "tmpfiles.org/",
      "tmpfiles.org/dl/"
    );
  };
  const starInputRegex$1 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/;
  const starPasteRegex$1 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g;
  const underscoreInputRegex$1 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/;
  const underscorePasteRegex$1 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;
  const Bold = Mark.create({
    name: "bold",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "strong"
        },
        {
          tag: "b",
          getAttrs: (node2) => node2.style.fontWeight !== "normal" && null
        },
        {
          style: "font-weight",
          getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setBold: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleBold: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetBold: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-b": () => this.editor.commands.toggleBold(),
        "Mod-B": () => this.editor.commands.toggleBold()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: starInputRegex$1,
          type: this.type
        }),
        markInputRule({
          find: underscoreInputRegex$1,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: starPasteRegex$1,
          type: this.type
        }),
        markPasteRule({
          find: underscorePasteRegex$1,
          type: this.type
        })
      ];
    }
  });
  const inputRegex$1 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/;
  const pasteRegex$1 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g;
  const Code = Mark.create({
    name: "code",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    excludes: "_",
    code: true,
    exitable: true,
    parseHTML() {
      return [
        { tag: "code" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setCode: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleCode: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetCode: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-e": () => this.editor.commands.toggleCode()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: inputRegex$1,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: pasteRegex$1,
          type: this.type
        })
      ];
    }
  });
  const starInputRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/;
  const starPasteRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g;
  const underscoreInputRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/;
  const underscorePasteRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;
  const Italic = Mark.create({
    name: "italic",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "em"
        },
        {
          tag: "i",
          getAttrs: (node2) => node2.style.fontStyle !== "normal" && null
        },
        {
          style: "font-style=italic"
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setItalic: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleItalic: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetItalic: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-i": () => this.editor.commands.toggleItalic(),
        "Mod-I": () => this.editor.commands.toggleItalic()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: starInputRegex,
          type: this.type
        }),
        markInputRule({
          find: underscoreInputRegex,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: starPasteRegex,
          type: this.type
        }),
        markPasteRule({
          find: underscorePasteRegex,
          type: this.type
        })
      ];
    }
  });
  const inputRegex = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/;
  const pasteRegex = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g;
  const Strike = Mark.create({
    name: "strike",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "s"
        },
        {
          tag: "del"
        },
        {
          tag: "strike"
        },
        {
          style: "text-decoration",
          consuming: false,
          getAttrs: (style2) => style2.includes("line-through") ? {} : false
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setStrike: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleStrike: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetStrike: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      const shortcuts = {};
      if (isMacOS()) {
        shortcuts["Mod-Shift-s"] = () => this.editor.commands.toggleStrike();
      } else {
        shortcuts["Ctrl-Shift-s"] = () => this.editor.commands.toggleStrike();
      }
      return shortcuts;
    },
    addInputRules() {
      return [
        markInputRule({
          find: inputRegex,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: pasteRegex,
          type: this.type
        })
      ];
    }
  });
  const Underline = Mark.create({
    name: "underline",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "u"
        },
        {
          style: "text-decoration",
          consuming: false,
          getAttrs: (style2) => style2.includes("underline") ? {} : false
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setUnderline: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleUnderline: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetUnderline: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-u": () => this.editor.commands.toggleUnderline(),
        "Mod-U": () => this.editor.commands.toggleUnderline()
      };
    }
  });
  const isAppleOS = () => typeof navigator !== "undefined" && (/Mac/.test(navigator.platform) || /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent));
  function formatKeyboardShortcut(shortcut) {
    if (isAppleOS()) {
      return shortcut.replace("Mod", "⌘");
    } else {
      return shortcut.replace("Mod", "Ctrl");
    }
  }
  function mergeCSSClasses(...classes) {
    return classes.filter((c) => c).join(" ");
  }
  function createDefaultBlockDOMOutputSpec(blockName, htmlTag, blockContentHTMLAttributes, inlineContentHTMLAttributes) {
    const blockContent = document.createElement("div");
    blockContent.className = mergeCSSClasses(
      "bn-block-content",
      blockContentHTMLAttributes.class
    );
    blockContent.setAttribute("data-content-type", blockName);
    for (const [attribute, value] of Object.entries(blockContentHTMLAttributes)) {
      if (attribute !== "class") {
        blockContent.setAttribute(attribute, value);
      }
    }
    const inlineContent = document.createElement(htmlTag);
    inlineContent.className = mergeCSSClasses(
      "bn-inline-content",
      inlineContentHTMLAttributes.class
    );
    for (const [attribute, value] of Object.entries(
      inlineContentHTMLAttributes
    )) {
      if (attribute !== "class") {
        inlineContent.setAttribute(attribute, value);
      }
    }
    blockContent.appendChild(inlineContent);
    return {
      dom: blockContent,
      contentDOM: inlineContent
    };
  }
  const defaultBlockToHTML = (block2, editor2) => {
    const node2 = blockToNode(
      block2,
      editor2._tiptapEditor.schema,
      editor2.styleSchema
    ).firstChild;
    const toDOM = editor2._tiptapEditor.schema.nodes[node2.type.name].spec.toDOM;
    if (toDOM === void 0) {
      throw new Error(
        "This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`."
      );
    }
    const renderSpec = toDOM(node2);
    if (typeof renderSpec !== "object" || !("dom" in renderSpec)) {
      throw new Error(
        "Cannot use this block's default HTML serialization as its corresponding TipTap node's `renderHTML` function does not return an object with the `dom` property."
      );
    }
    return renderSpec;
  };
  const defaultProps = {
    backgroundColor: {
      default: "default"
    },
    textColor: {
      default: "default"
    },
    textAlignment: {
      default: "left",
      values: ["left", "center", "right", "justify"]
    }
  };
  const inheritedProps = ["backgroundColor", "textColor"];
  function camelToDataKebab(str) {
    return "data-" + str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  function propsToAttributes(propSchema) {
    const tiptapAttributes = {};
    Object.entries(propSchema).filter(([name, _spec]) => !inheritedProps.includes(name)).forEach(([name, spec]) => {
      tiptapAttributes[name] = {
        default: spec.default,
        keepOnSplit: true,
        // Props are displayed in kebab-case as HTML attributes. If a prop's
        // value is the same as its default, we don't display an HTML
        // attribute for it.
        parseHTML: (element2) => {
          const value = element2.getAttribute(camelToDataKebab(name));
          if (value === null) {
            return null;
          }
          if (typeof spec.default === "boolean") {
            if (value === "true") {
              return true;
            }
            if (value === "false") {
              return false;
            }
            return null;
          }
          if (typeof spec.default === "number") {
            const asNumber = parseFloat(value);
            const isNumeric = !Number.isNaN(asNumber) && Number.isFinite(asNumber);
            if (isNumeric) {
              return asNumber;
            }
            return null;
          }
          return value;
        },
        renderHTML: (attributes) => attributes[name] !== spec.default ? {
          [camelToDataKebab(name)]: attributes[name]
        } : {}
      };
    });
    return tiptapAttributes;
  }
  function getBlockFromPos(getPos, editor2, tipTapEditor, type) {
    if (typeof getPos === "boolean") {
      throw new Error(
        "Cannot find node position as getPos is a boolean, not a function."
      );
    }
    const pos = getPos();
    const blockContainer = tipTapEditor.state.doc.resolve(pos).node();
    const blockIdentifier = blockContainer.attrs.id;
    const block2 = editor2.getBlock(blockIdentifier);
    if (block2.type !== type) {
      throw new Error("Block type does not match");
    }
    return block2;
  }
  function wrapInBlockStructure(element2, blockType, blockProps, propSchema, domAttributes) {
    var _a;
    const blockContent = document.createElement("div");
    if (domAttributes !== void 0) {
      for (const [attr, value] of Object.entries(domAttributes)) {
        if (attr !== "class") {
          blockContent.setAttribute(attr, value);
        }
      }
    }
    blockContent.className = mergeCSSClasses(
      "bn-block-content",
      (domAttributes == null ? void 0 : domAttributes.class) || ""
    );
    blockContent.setAttribute("data-content-type", blockType);
    for (const [prop, value] of Object.entries(blockProps)) {
      if (!inheritedProps.includes(prop) && ((_a = propSchema[prop]) == null ? void 0 : _a.default) && value !== propSchema[prop].default) {
        blockContent.setAttribute(camelToDataKebab(prop), value);
      }
    }
    blockContent.appendChild(element2.dom);
    if (element2.contentDOM !== void 0) {
      element2.contentDOM.className = mergeCSSClasses(
        "bn-inline-content",
        element2.contentDOM.className
      );
      element2.contentDOM.setAttribute("data-editable", "");
    }
    return {
      ...element2,
      dom: blockContent
    };
  }
  function createStronglyTypedTiptapNode(config) {
    return Node.create(config);
  }
  function createInternalBlockSpec(config, implementation) {
    return {
      config,
      implementation
    };
  }
  function createBlockSpecFromStronglyTypedTiptapNode(node2, propSchema, requiredExtensions) {
    return createInternalBlockSpec(
      {
        type: node2.name,
        content: node2.config.content === "inline*" ? "inline" : node2.config.content === "tableRow+" ? "table" : "none",
        propSchema
      },
      {
        node: node2,
        requiredExtensions,
        toInternalHTML: defaultBlockToHTML,
        toExternalHTML: defaultBlockToHTML
        // parse: () => undefined, // parse rules are in node already
      }
    );
  }
  function getBlockSchemaFromSpecs(specs) {
    return Object.fromEntries(
      Object.entries(specs).map(([key2, value]) => [key2, value.config])
    );
  }
  function getParseRules(config, customParseFunction) {
    const rules = [
      {
        tag: "[data-content-type=" + config.type + "]",
        contentElement: "[data-editable]"
      }
    ];
    if (customParseFunction) {
      rules.push({
        tag: "*",
        getAttrs(node2) {
          if (typeof node2 === "string") {
            return false;
          }
          const props = customParseFunction == null ? void 0 : customParseFunction(node2);
          if (props === void 0) {
            return false;
          }
          return props;
        }
      });
    }
    return rules;
  }
  function createBlockSpec(blockConfig, blockImplementation) {
    const node2 = createStronglyTypedTiptapNode({
      name: blockConfig.type,
      content: blockConfig.content === "inline" ? "inline*" : "",
      group: "blockContent",
      selectable: true,
      addAttributes() {
        return propsToAttributes(blockConfig.propSchema);
      },
      parseHTML() {
        return blockImplementation.parseFn ? blockImplementation.parseFn() : getParseRules(blockConfig, blockImplementation.parse);
      },
      renderHTML() {
        const div2 = document.createElement("div");
        div2.setAttribute("data-tmp-placeholder", "true");
        return {
          dom: div2
        };
      },
      addNodeView() {
        return ({ getPos }) => {
          var _a;
          const editor2 = this.options.editor;
          const block2 = getBlockFromPos(
            getPos,
            editor2,
            this.editor,
            blockConfig.type
          );
          const blockContentDOMAttributes = ((_a = this.options.domAttributes) == null ? void 0 : _a.blockContent) || {};
          const output = blockImplementation.render(block2, editor2);
          return wrapInBlockStructure(
            output,
            block2.type,
            block2.props,
            blockConfig.propSchema,
            blockContentDOMAttributes
          );
        };
      },
      addPasteRules() {
        if (!blockImplementation.pasteRules) {
          return [];
        }
        return blockImplementation.pasteRules.map((rule) => {
          return new PasteRule({
            find: rule.find,
            handler(props) {
              rule.handler(props);
            }
          });
        });
      },
      addInputRules() {
        if (!blockImplementation.inputRules) {
          return [];
        }
        return blockImplementation.inputRules.map((rule) => {
          if (this.type.isBlock) {
            return nodeInputRule({
              find: rule.find,
              type: this.type,
              getAttributes: rule.getAttributes
            });
          }
          return textblockTypeInputRule({
            find: rule.find,
            type: this.type,
            getAttributes: rule.getAttributes
          });
        });
      }
    });
    if (node2.name !== blockConfig.type) {
      throw new Error(
        "Node name does not match block type. This is a bug in BlockNote."
      );
    }
    return createInternalBlockSpec(blockConfig, {
      node: node2,
      toInternalHTML: (block2, editor2) => {
        var _a;
        const blockContentDOMAttributes = ((_a = node2.options.domAttributes) == null ? void 0 : _a.blockContent) || {};
        const output = blockImplementation.render(block2, editor2);
        return wrapInBlockStructure(
          output,
          block2.type,
          block2.props,
          blockConfig.propSchema,
          blockContentDOMAttributes
        );
      },
      toExternalHTML: (block2, editor2) => {
        var _a, _b;
        const blockContentDOMAttributes = ((_a = node2.options.domAttributes) == null ? void 0 : _a.blockContent) || {};
        let output = (_b = blockImplementation.toExternalHTML) == null ? void 0 : _b.call(
          blockImplementation,
          block2,
          editor2
        );
        if (output === void 0) {
          output = blockImplementation.render(block2, editor2);
        }
        return wrapInBlockStructure(
          output,
          block2.type,
          block2.props,
          blockConfig.propSchema,
          blockContentDOMAttributes
        );
      }
    });
  }
  function addInlineContentAttributes(element2, inlineContentType, inlineContentProps, propSchema) {
    element2.dom.setAttribute("data-inline-content-type", inlineContentType);
    Object.entries(inlineContentProps).filter(([prop, value]) => value !== propSchema[prop].default).map(([prop, value]) => {
      return [camelToDataKebab(prop), value];
    }).forEach(([prop, value]) => element2.dom.setAttribute(prop, value));
    if (element2.contentDOM !== void 0) {
      element2.contentDOM.setAttribute("data-editable", "");
    }
    return element2;
  }
  function addInlineContentKeyboardShortcuts(config) {
    return {
      Backspace: ({ editor: editor2 }) => {
        const resolvedPos = editor2.state.selection.$from;
        return editor2.state.selection.empty && resolvedPos.node().type.name === config.type && resolvedPos.parentOffset === 0;
      }
    };
  }
  function createInternalInlineContentSpec(config, implementation) {
    return {
      config,
      implementation
    };
  }
  function createInlineContentSpecFromTipTapNode(node2, propSchema) {
    return createInternalInlineContentSpec(
      {
        type: node2.name,
        propSchema,
        content: node2.config.content === "inline*" ? "styled" : "none"
      },
      {
        node: node2
      }
    );
  }
  function getInlineContentSchemaFromSpecs(specs) {
    return Object.fromEntries(
      Object.entries(specs).map(([key2, value]) => [key2, value.config])
    );
  }
  function getInlineContentParseRules(config) {
    return [
      {
        tag: `[data-inline-content-type="${config.type}"]`,
        contentElement: (element2) => {
          const htmlElement = element2;
          if (htmlElement.matches("[data-editable]")) {
            return htmlElement;
          }
          return htmlElement.querySelector("[data-editable]") || htmlElement;
        }
      }
    ];
  }
  function createInlineContentSpec(inlineContentConfig, inlineContentImplementation) {
    const node2 = Node.create({
      name: inlineContentConfig.type,
      inline: true,
      group: "inline",
      selectable: inlineContentConfig.content === "styled",
      atom: inlineContentConfig.content === "none",
      content: inlineContentConfig.content === "styled" ? "inline*" : "",
      addAttributes() {
        return propsToAttributes(inlineContentConfig.propSchema);
      },
      addKeyboardShortcuts() {
        return addInlineContentKeyboardShortcuts(inlineContentConfig);
      },
      parseHTML() {
        return getInlineContentParseRules(inlineContentConfig);
      },
      renderHTML({ node: node22 }) {
        const editor2 = this.options.editor;
        const output = inlineContentImplementation.render(
          nodeToCustomInlineContent(
            node22,
            editor2.inlineContentSchema,
            editor2.styleSchema
          )
          // TODO: fix cast
        );
        return addInlineContentAttributes(
          output,
          inlineContentConfig.type,
          node22.attrs,
          inlineContentConfig.propSchema
        );
      }
    });
    return createInlineContentSpecFromTipTapNode(
      node2,
      inlineContentConfig.propSchema
    );
  }
  function stylePropsToAttributes(propSchema) {
    if (propSchema === "boolean") {
      return {};
    }
    return {
      stringValue: {
        default: void 0,
        keepOnSplit: true,
        parseHTML: (element2) => element2.getAttribute("data-value"),
        renderHTML: (attributes) => attributes.stringValue !== void 0 ? {
          "data-value": attributes.stringValue
        } : {}
      }
    };
  }
  function addStyleAttributes(element2, styleType, styleValue, propSchema) {
    element2.dom.setAttribute("data-style-type", styleType);
    if (propSchema === "string") {
      element2.dom.setAttribute("data-value", styleValue);
    }
    if (element2.contentDOM !== void 0) {
      element2.contentDOM.setAttribute("data-editable", "");
    }
    return element2;
  }
  function createInternalStyleSpec(config, implementation) {
    return {
      config,
      implementation
    };
  }
  function createStyleSpecFromTipTapMark(mark2, propSchema) {
    return createInternalStyleSpec(
      {
        type: mark2.name,
        propSchema
      },
      {
        mark: mark2
      }
    );
  }
  function getStyleSchemaFromSpecs(specs) {
    return Object.fromEntries(
      Object.entries(specs).map(([key2, value]) => [key2, value.config])
    );
  }
  function getStyleParseRules(config) {
    return [
      {
        tag: `[data-style-type="${config.type}"]`,
        contentElement: (element2) => {
          const htmlElement = element2;
          if (htmlElement.matches("[data-editable]")) {
            return htmlElement;
          }
          return htmlElement.querySelector("[data-editable]") || htmlElement;
        }
      }
    ];
  }
  function createStyleSpec(styleConfig, styleImplementation) {
    const mark2 = Mark.create({
      name: styleConfig.type,
      addAttributes() {
        return stylePropsToAttributes(styleConfig.propSchema);
      },
      parseHTML() {
        return getStyleParseRules(styleConfig);
      },
      renderHTML({ mark: mark22 }) {
        let renderResult;
        if (styleConfig.propSchema === "boolean") {
          renderResult = styleImplementation.render();
        } else if (styleConfig.propSchema === "string") {
          renderResult = styleImplementation.render(mark22.attrs.stringValue);
        } else {
          throw new UnreachableCaseError(styleConfig.propSchema);
        }
        return addStyleAttributes(
          renderResult,
          styleConfig.type,
          mark22.attrs.stringValue,
          styleConfig.propSchema
        );
      }
    });
    return createInternalStyleSpec(styleConfig, {
      mark: mark2
    });
  }
  const BackgroundColorMark = Mark.create({
    name: "backgroundColor",
    addAttributes() {
      return {
        stringValue: {
          default: void 0,
          parseHTML: (element2) => element2.getAttribute("data-background-color"),
          renderHTML: (attributes) => ({
            "data-background-color": attributes.stringValue
          })
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: "span",
          getAttrs: (element2) => {
            if (typeof element2 === "string") {
              return false;
            }
            if (element2.hasAttribute("data-background-color")) {
              return {
                stringValue: element2.getAttribute("data-background-color")
              };
            }
            return false;
          }
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      const { "data-background-color": stringValue = "" } = HTMLAttributes;
      return [
        "span",
        { ...HTMLAttributes, style: `background-color: ${stringValue};` },
        0
      ];
    }
  });
  const BackgroundColor = createStyleSpecFromTipTapMark(
    BackgroundColorMark,
    "string"
  );
  const TextColorMark = Mark.create({
    name: "textColor",
    addAttributes() {
      return {
        stringValue: {
          default: void 0,
          parseHTML: (element2) => element2.getAttribute("data-text-color"),
          renderHTML: (attributes) => ({
            "data-text-color": attributes.stringValue
          })
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: "span",
          getAttrs: (element2) => {
            if (typeof element2 === "string") {
              return false;
            }
            if (element2.hasAttribute("data-text-color")) {
              return { stringValue: element2.getAttribute("data-text-color") };
            }
            return false;
          }
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      const { "data-text-color": stringValue = "" } = HTMLAttributes;
      return ["span", { ...HTMLAttributes, style: `color: ${stringValue};` }, 0];
    }
  });
  const TextColor = createStyleSpecFromTipTapMark(TextColorMark, "string");
  function splice(list2, start, remove, items) {
    const end = list2.length;
    let chunkStart = 0;
    let parameters;
    if (start < 0) {
      start = -start > end ? 0 : end + start;
    } else {
      start = start > end ? end : start;
    }
    remove = remove > 0 ? remove : 0;
    if (items.length < 1e4) {
      parameters = Array.from(items);
      parameters.unshift(start, remove);
      list2.splice(...parameters);
    } else {
      if (remove)
        list2.splice(start, remove);
      while (chunkStart < items.length) {
        parameters = items.slice(chunkStart, chunkStart + 1e4);
        parameters.unshift(start, 0);
        list2.splice(...parameters);
        chunkStart += 1e4;
        start += 1e4;
      }
    }
  }
  function push(list2, items) {
    if (list2.length > 0) {
      splice(list2, list2.length, 0, items);
      return list2;
    }
    return items;
  }
  const hasOwnProperty = {}.hasOwnProperty;
  function combineExtensions(extensions2) {
    const all2 = {};
    let index2 = -1;
    while (++index2 < extensions2.length) {
      syntaxExtension(all2, extensions2[index2]);
    }
    return all2;
  }
  function syntaxExtension(all2, extension2) {
    let hook;
    for (hook in extension2) {
      const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
      const left = maybe || (all2[hook] = {});
      const right = extension2[hook];
      let code2;
      if (right) {
        for (code2 in right) {
          if (!hasOwnProperty.call(left, code2))
            left[code2] = [];
          const value = right[code2];
          constructs(
            // @ts-expect-error Looks like a list.
            left[code2],
            Array.isArray(value) ? value : value ? [value] : []
          );
        }
      }
    }
  }
  function constructs(existing, list2) {
    let index2 = -1;
    const before = [];
    while (++index2 < list2.length) {
      (list2[index2].add === "after" ? existing : before).push(list2[index2]);
    }
    splice(existing, 0, 0, before);
  }
  const unicodePunctuationRegex = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
  const asciiAlpha = regexCheck(/[A-Za-z]/);
  const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
  const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
  function asciiControl(code2) {
    return (
      // Special whitespace codes (which have negative values), C0 and Control
      // character DEL
      code2 !== null && (code2 < 32 || code2 === 127)
    );
  }
  const asciiDigit = regexCheck(/\d/);
  const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
  const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
  function markdownLineEnding(code2) {
    return code2 !== null && code2 < -2;
  }
  function markdownLineEndingOrSpace(code2) {
    return code2 !== null && (code2 < 0 || code2 === 32);
  }
  function markdownSpace(code2) {
    return code2 === -2 || code2 === -1 || code2 === 32;
  }
  const unicodePunctuation = regexCheck(unicodePunctuationRegex);
  const unicodeWhitespace = regexCheck(/\s/);
  function regexCheck(regex) {
    return check;
    function check(code2) {
      return code2 !== null && regex.test(String.fromCharCode(code2));
    }
  }
  const wwwPrefix = {
    tokenize: tokenizeWwwPrefix,
    partial: true
  };
  const domain$1 = {
    tokenize: tokenizeDomain,
    partial: true
  };
  const path = {
    tokenize: tokenizePath,
    partial: true
  };
  const trail = {
    tokenize: tokenizeTrail,
    partial: true
  };
  const emailDomainDotTrail = {
    tokenize: tokenizeEmailDomainDotTrail,
    partial: true
  };
  const wwwAutolink = {
    tokenize: tokenizeWwwAutolink,
    previous: previousWww
  };
  const protocolAutolink = {
    tokenize: tokenizeProtocolAutolink,
    previous: previousProtocol
  };
  const emailAutolink = {
    tokenize: tokenizeEmailAutolink,
    previous: previousEmail
  };
  const text$5 = {};
  const gfmAutolinkLiteral = {
    text: text$5
  };
  let code$4 = 48;
  while (code$4 < 123) {
    text$5[code$4] = emailAutolink;
    code$4++;
    if (code$4 === 58)
      code$4 = 65;
    else if (code$4 === 91)
      code$4 = 97;
  }
  text$5[43] = emailAutolink;
  text$5[45] = emailAutolink;
  text$5[46] = emailAutolink;
  text$5[95] = emailAutolink;
  text$5[72] = [emailAutolink, protocolAutolink];
  text$5[104] = [emailAutolink, protocolAutolink];
  text$5[87] = [emailAutolink, wwwAutolink];
  text$5[119] = [emailAutolink, wwwAutolink];
  function tokenizeEmailAutolink(effects, ok2, nok) {
    const self2 = this;
    let dot;
    let data;
    return start;
    function start(code2) {
      if (!gfmAtext(code2) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
        return nok(code2);
      }
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkEmail");
      return atext(code2);
    }
    function atext(code2) {
      if (gfmAtext(code2)) {
        effects.consume(code2);
        return atext;
      }
      if (code2 === 64) {
        effects.consume(code2);
        return emailDomain;
      }
      return nok(code2);
    }
    function emailDomain(code2) {
      if (code2 === 46) {
        return effects.check(
          emailDomainDotTrail,
          emailDomainAfter,
          emailDomainDot
        )(code2);
      }
      if (code2 === 45 || code2 === 95 || asciiAlphanumeric(code2)) {
        data = true;
        effects.consume(code2);
        return emailDomain;
      }
      return emailDomainAfter(code2);
    }
    function emailDomainDot(code2) {
      effects.consume(code2);
      dot = true;
      return emailDomain;
    }
    function emailDomainAfter(code2) {
      if (data && dot && asciiAlpha(self2.previous)) {
        effects.exit("literalAutolinkEmail");
        effects.exit("literalAutolink");
        return ok2(code2);
      }
      return nok(code2);
    }
  }
  function tokenizeWwwAutolink(effects, ok2, nok) {
    const self2 = this;
    return wwwStart;
    function wwwStart(code2) {
      if (code2 !== 87 && code2 !== 119 || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
        return nok(code2);
      }
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkWww");
      return effects.check(
        wwwPrefix,
        effects.attempt(domain$1, effects.attempt(path, wwwAfter), nok),
        nok
      )(code2);
    }
    function wwwAfter(code2) {
      effects.exit("literalAutolinkWww");
      effects.exit("literalAutolink");
      return ok2(code2);
    }
  }
  function tokenizeProtocolAutolink(effects, ok2, nok) {
    const self2 = this;
    let buffer2 = "";
    let seen = false;
    return protocolStart;
    function protocolStart(code2) {
      if ((code2 === 72 || code2 === 104) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkHttp");
        buffer2 += String.fromCodePoint(code2);
        effects.consume(code2);
        return protocolPrefixInside;
      }
      return nok(code2);
    }
    function protocolPrefixInside(code2) {
      if (asciiAlpha(code2) && buffer2.length < 5) {
        buffer2 += String.fromCodePoint(code2);
        effects.consume(code2);
        return protocolPrefixInside;
      }
      if (code2 === 58) {
        const protocol = buffer2.toLowerCase();
        if (protocol === "http" || protocol === "https") {
          effects.consume(code2);
          return protocolSlashesInside;
        }
      }
      return nok(code2);
    }
    function protocolSlashesInside(code2) {
      if (code2 === 47) {
        effects.consume(code2);
        if (seen) {
          return afterProtocol;
        }
        seen = true;
        return protocolSlashesInside;
      }
      return nok(code2);
    }
    function afterProtocol(code2) {
      return code2 === null || asciiControl(code2) || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || unicodePunctuation(code2) ? nok(code2) : effects.attempt(domain$1, effects.attempt(path, protocolAfter), nok)(code2);
    }
    function protocolAfter(code2) {
      effects.exit("literalAutolinkHttp");
      effects.exit("literalAutolink");
      return ok2(code2);
    }
  }
  function tokenizeWwwPrefix(effects, ok2, nok) {
    let size = 0;
    return wwwPrefixInside;
    function wwwPrefixInside(code2) {
      if ((code2 === 87 || code2 === 119) && size < 3) {
        size++;
        effects.consume(code2);
        return wwwPrefixInside;
      }
      if (code2 === 46 && size === 3) {
        effects.consume(code2);
        return wwwPrefixAfter;
      }
      return nok(code2);
    }
    function wwwPrefixAfter(code2) {
      return code2 === null ? nok(code2) : ok2(code2);
    }
  }
  function tokenizeDomain(effects, ok2, nok) {
    let underscoreInLastSegment;
    let underscoreInLastLastSegment;
    let seen;
    return domainInside;
    function domainInside(code2) {
      if (code2 === 46 || code2 === 95) {
        return effects.check(trail, domainAfter, domainAtPunctuation)(code2);
      }
      if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || code2 !== 45 && unicodePunctuation(code2)) {
        return domainAfter(code2);
      }
      seen = true;
      effects.consume(code2);
      return domainInside;
    }
    function domainAtPunctuation(code2) {
      if (code2 === 95) {
        underscoreInLastSegment = true;
      } else {
        underscoreInLastLastSegment = underscoreInLastSegment;
        underscoreInLastSegment = void 0;
      }
      effects.consume(code2);
      return domainInside;
    }
    function domainAfter(code2) {
      if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
        return nok(code2);
      }
      return ok2(code2);
    }
  }
  function tokenizePath(effects, ok2) {
    let sizeOpen = 0;
    let sizeClose = 0;
    return pathInside;
    function pathInside(code2) {
      if (code2 === 40) {
        sizeOpen++;
        effects.consume(code2);
        return pathInside;
      }
      if (code2 === 41 && sizeClose < sizeOpen) {
        return pathAtPunctuation(code2);
      }
      if (code2 === 33 || code2 === 34 || code2 === 38 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 93 || code2 === 95 || code2 === 126) {
        return effects.check(trail, ok2, pathAtPunctuation)(code2);
      }
      if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
        return ok2(code2);
      }
      effects.consume(code2);
      return pathInside;
    }
    function pathAtPunctuation(code2) {
      if (code2 === 41) {
        sizeClose++;
      }
      effects.consume(code2);
      return pathInside;
    }
  }
  function tokenizeTrail(effects, ok2, nok) {
    return trail2;
    function trail2(code2) {
      if (code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 63 || code2 === 95 || code2 === 126) {
        effects.consume(code2);
        return trail2;
      }
      if (code2 === 38) {
        effects.consume(code2);
        return trailCharRefStart;
      }
      if (code2 === 93) {
        effects.consume(code2);
        return trailBracketAfter;
      }
      if (
        // `<` is an end.
        code2 === 60 || // So is whitespace.
        code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)
      ) {
        return ok2(code2);
      }
      return nok(code2);
    }
    function trailBracketAfter(code2) {
      if (code2 === null || code2 === 40 || code2 === 91 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
        return ok2(code2);
      }
      return trail2(code2);
    }
    function trailCharRefStart(code2) {
      return asciiAlpha(code2) ? trailCharRefInside(code2) : nok(code2);
    }
    function trailCharRefInside(code2) {
      if (code2 === 59) {
        effects.consume(code2);
        return trail2;
      }
      if (asciiAlpha(code2)) {
        effects.consume(code2);
        return trailCharRefInside;
      }
      return nok(code2);
    }
  }
  function tokenizeEmailDomainDotTrail(effects, ok2, nok) {
    return start;
    function start(code2) {
      effects.consume(code2);
      return after;
    }
    function after(code2) {
      return asciiAlphanumeric(code2) ? nok(code2) : ok2(code2);
    }
  }
  function previousWww(code2) {
    return code2 === null || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 91 || code2 === 93 || code2 === 126 || markdownLineEndingOrSpace(code2);
  }
  function previousProtocol(code2) {
    return !asciiAlpha(code2);
  }
  function previousEmail(code2) {
    return !(code2 === 47 || gfmAtext(code2));
  }
  function gfmAtext(code2) {
    return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
  }
  function previousUnbalanced(events) {
    let index2 = events.length;
    let result = false;
    while (index2--) {
      const token = events[index2][1];
      if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
        result = true;
        break;
      }
      if (token._gfmAutolinkLiteralWalkedInto) {
        result = false;
        break;
      }
    }
    if (events.length > 0 && !result) {
      events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
    }
    return result;
  }
  function normalizeUri(value) {
    const result = [];
    let index2 = -1;
    let start = 0;
    let skip = 0;
    while (++index2 < value.length) {
      const code2 = value.charCodeAt(index2);
      let replace2 = "";
      if (code2 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
        skip = 2;
      } else if (code2 < 128) {
        if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
          replace2 = String.fromCharCode(code2);
        }
      } else if (code2 > 55295 && code2 < 57344) {
        const next = value.charCodeAt(index2 + 1);
        if (code2 < 56320 && next > 56319 && next < 57344) {
          replace2 = String.fromCharCode(code2, next);
          skip = 1;
        } else {
          replace2 = "�";
        }
      } else {
        replace2 = String.fromCharCode(code2);
      }
      if (replace2) {
        result.push(value.slice(start, index2), encodeURIComponent(replace2));
        start = index2 + skip + 1;
        replace2 = "";
      }
      if (skip) {
        index2 += skip;
        skip = 0;
      }
    }
    return result.join("") + value.slice(start);
  }
  function classifyCharacter(code2) {
    if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      return 1;
    }
    if (unicodePunctuation(code2)) {
      return 2;
    }
  }
  function resolveAll(constructs2, events, context) {
    const called = [];
    let index2 = -1;
    while (++index2 < constructs2.length) {
      const resolve2 = constructs2[index2].resolveAll;
      if (resolve2 && !called.includes(resolve2)) {
        events = resolve2(events, context);
        called.push(resolve2);
      }
    }
    return events;
  }
  const attention = {
    name: "attention",
    tokenize: tokenizeAttention,
    resolveAll: resolveAllAttention
  };
  function resolveAllAttention(events, context) {
    let index2 = -1;
    let open;
    let group;
    let text2;
    let openingSequence;
    let closingSequence;
    let use;
    let nextEvents;
    let offset;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
        open = index2;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
          context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
            if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
              continue;
            }
            use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
            const start = Object.assign({}, events[open][1].end);
            const end = Object.assign({}, events[index2][1].start);
            movePoint(start, -use);
            movePoint(end, use);
            openingSequence = {
              type: use > 1 ? "strongSequence" : "emphasisSequence",
              start,
              end: Object.assign({}, events[open][1].end)
            };
            closingSequence = {
              type: use > 1 ? "strongSequence" : "emphasisSequence",
              start: Object.assign({}, events[index2][1].start),
              end
            };
            text2 = {
              type: use > 1 ? "strongText" : "emphasisText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index2][1].start)
            };
            group = {
              type: use > 1 ? "strong" : "emphasis",
              start: Object.assign({}, openingSequence.start),
              end: Object.assign({}, closingSequence.end)
            };
            events[open][1].end = Object.assign({}, openingSequence.start);
            events[index2][1].start = Object.assign({}, closingSequence.end);
            nextEvents = [];
            if (events[open][1].end.offset - events[open][1].start.offset) {
              nextEvents = push(nextEvents, [
                ["enter", events[open][1], context],
                ["exit", events[open][1], context]
              ]);
            }
            nextEvents = push(nextEvents, [
              ["enter", group, context],
              ["enter", openingSequence, context],
              ["exit", openingSequence, context],
              ["enter", text2, context]
            ]);
            nextEvents = push(
              nextEvents,
              resolveAll(
                context.parser.constructs.insideSpan.null,
                events.slice(open + 1, index2),
                context
              )
            );
            nextEvents = push(nextEvents, [
              ["exit", text2, context],
              ["enter", closingSequence, context],
              ["exit", closingSequence, context],
              ["exit", group, context]
            ]);
            if (events[index2][1].end.offset - events[index2][1].start.offset) {
              offset = 2;
              nextEvents = push(nextEvents, [
                ["enter", events[index2][1], context],
                ["exit", events[index2][1], context]
              ]);
            } else {
              offset = 0;
            }
            splice(events, open - 1, index2 - open + 3, nextEvents);
            index2 = open + nextEvents.length - offset - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "attentionSequence") {
        events[index2][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeAttention(effects, ok2) {
    const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
    const previous2 = this.previous;
    const before = classifyCharacter(previous2);
    let marker;
    return start;
    function start(code2) {
      marker = code2;
      effects.enter("attentionSequence");
      return inside(code2);
    }
    function inside(code2) {
      if (code2 === marker) {
        effects.consume(code2);
        return inside;
      }
      const token = effects.exit("attentionSequence");
      const after = classifyCharacter(code2);
      const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
      const close2 = !before || before === 2 && after || attentionMarkers2.includes(previous2);
      token._open = Boolean(marker === 42 ? open : open && (before || !close2));
      token._close = Boolean(marker === 42 ? close2 : close2 && (after || !open));
      return ok2(code2);
    }
  }
  function movePoint(point2, offset) {
    point2.column += offset;
    point2.offset += offset;
    point2._bufferIndex += offset;
  }
  const autolink$1 = {
    name: "autolink",
    tokenize: tokenizeAutolink
  };
  function tokenizeAutolink(effects, ok2, nok) {
    let size = 0;
    return start;
    function start(code2) {
      effects.enter("autolink");
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.enter("autolinkProtocol");
      return open;
    }
    function open(code2) {
      if (asciiAlpha(code2)) {
        effects.consume(code2);
        return schemeOrEmailAtext;
      }
      return emailAtext(code2);
    }
    function schemeOrEmailAtext(code2) {
      if (code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) {
        size = 1;
        return schemeInsideOrEmailAtext(code2);
      }
      return emailAtext(code2);
    }
    function schemeInsideOrEmailAtext(code2) {
      if (code2 === 58) {
        effects.consume(code2);
        size = 0;
        return urlInside;
      }
      if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size++ < 32) {
        effects.consume(code2);
        return schemeInsideOrEmailAtext;
      }
      size = 0;
      return emailAtext(code2);
    }
    function urlInside(code2) {
      if (code2 === 62) {
        effects.exit("autolinkProtocol");
        effects.enter("autolinkMarker");
        effects.consume(code2);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok2;
      }
      if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
        return nok(code2);
      }
      effects.consume(code2);
      return urlInside;
    }
    function emailAtext(code2) {
      if (code2 === 64) {
        effects.consume(code2);
        return emailAtSignOrDot;
      }
      if (asciiAtext(code2)) {
        effects.consume(code2);
        return emailAtext;
      }
      return nok(code2);
    }
    function emailAtSignOrDot(code2) {
      return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
    }
    function emailLabel(code2) {
      if (code2 === 46) {
        effects.consume(code2);
        size = 0;
        return emailAtSignOrDot;
      }
      if (code2 === 62) {
        effects.exit("autolinkProtocol").type = "autolinkEmail";
        effects.enter("autolinkMarker");
        effects.consume(code2);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok2;
      }
      return emailValue(code2);
    }
    function emailValue(code2) {
      if ((code2 === 45 || asciiAlphanumeric(code2)) && size++ < 63) {
        const next = code2 === 45 ? emailValue : emailLabel;
        effects.consume(code2);
        return next;
      }
      return nok(code2);
    }
  }
  function factorySpace(effects, ok2, type, max2) {
    const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
    let size = 0;
    return start;
    function start(code2) {
      if (markdownSpace(code2)) {
        effects.enter(type);
        return prefix2(code2);
      }
      return ok2(code2);
    }
    function prefix2(code2) {
      if (markdownSpace(code2) && size++ < limit) {
        effects.consume(code2);
        return prefix2;
      }
      effects.exit(type);
      return ok2(code2);
    }
  }
  const blankLine = {
    tokenize: tokenizeBlankLine,
    partial: true
  };
  function tokenizeBlankLine(effects, ok2, nok) {
    return start;
    function start(code2) {
      return markdownSpace(code2) ? factorySpace(effects, after, "linePrefix")(code2) : after(code2);
    }
    function after(code2) {
      return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
    }
  }
  const blockQuote = {
    name: "blockQuote",
    tokenize: tokenizeBlockQuoteStart,
    continuation: {
      tokenize: tokenizeBlockQuoteContinuation
    },
    exit: exit$1
  };
  function tokenizeBlockQuoteStart(effects, ok2, nok) {
    const self2 = this;
    return start;
    function start(code2) {
      if (code2 === 62) {
        const state = self2.containerState;
        if (!state.open) {
          effects.enter("blockQuote", {
            _container: true
          });
          state.open = true;
        }
        effects.enter("blockQuotePrefix");
        effects.enter("blockQuoteMarker");
        effects.consume(code2);
        effects.exit("blockQuoteMarker");
        return after;
      }
      return nok(code2);
    }
    function after(code2) {
      if (markdownSpace(code2)) {
        effects.enter("blockQuotePrefixWhitespace");
        effects.consume(code2);
        effects.exit("blockQuotePrefixWhitespace");
        effects.exit("blockQuotePrefix");
        return ok2;
      }
      effects.exit("blockQuotePrefix");
      return ok2(code2);
    }
  }
  function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
    const self2 = this;
    return contStart;
    function contStart(code2) {
      if (markdownSpace(code2)) {
        return factorySpace(
          effects,
          contBefore,
          "linePrefix",
          self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
        )(code2);
      }
      return contBefore(code2);
    }
    function contBefore(code2) {
      return effects.attempt(blockQuote, ok2, nok)(code2);
    }
  }
  function exit$1(effects) {
    effects.exit("blockQuote");
  }
  const characterEscape = {
    name: "characterEscape",
    tokenize: tokenizeCharacterEscape
  };
  function tokenizeCharacterEscape(effects, ok2, nok) {
    return start;
    function start(code2) {
      effects.enter("characterEscape");
      effects.enter("escapeMarker");
      effects.consume(code2);
      effects.exit("escapeMarker");
      return inside;
    }
    function inside(code2) {
      if (asciiPunctuation(code2)) {
        effects.enter("characterEscapeValue");
        effects.consume(code2);
        effects.exit("characterEscapeValue");
        effects.exit("characterEscape");
        return ok2;
      }
      return nok(code2);
    }
  }
  const element$2 = document.createElement("i");
  function decodeNamedCharacterReference(value) {
    const characterReference2 = "&" + value + ";";
    element$2.innerHTML = characterReference2;
    const char = element$2.textContent;
    if (char.charCodeAt(char.length - 1) === 59 && value !== "semi") {
      return false;
    }
    return char === characterReference2 ? false : char;
  }
  const characterReference = {
    name: "characterReference",
    tokenize: tokenizeCharacterReference
  };
  function tokenizeCharacterReference(effects, ok2, nok) {
    const self2 = this;
    let size = 0;
    let max2;
    let test;
    return start;
    function start(code2) {
      effects.enter("characterReference");
      effects.enter("characterReferenceMarker");
      effects.consume(code2);
      effects.exit("characterReferenceMarker");
      return open;
    }
    function open(code2) {
      if (code2 === 35) {
        effects.enter("characterReferenceMarkerNumeric");
        effects.consume(code2);
        effects.exit("characterReferenceMarkerNumeric");
        return numeric2;
      }
      effects.enter("characterReferenceValue");
      max2 = 31;
      test = asciiAlphanumeric;
      return value(code2);
    }
    function numeric2(code2) {
      if (code2 === 88 || code2 === 120) {
        effects.enter("characterReferenceMarkerHexadecimal");
        effects.consume(code2);
        effects.exit("characterReferenceMarkerHexadecimal");
        effects.enter("characterReferenceValue");
        max2 = 6;
        test = asciiHexDigit;
        return value;
      }
      effects.enter("characterReferenceValue");
      max2 = 7;
      test = asciiDigit;
      return value(code2);
    }
    function value(code2) {
      if (code2 === 59 && size) {
        const token = effects.exit("characterReferenceValue");
        if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
          return nok(code2);
        }
        effects.enter("characterReferenceMarker");
        effects.consume(code2);
        effects.exit("characterReferenceMarker");
        effects.exit("characterReference");
        return ok2;
      }
      if (test(code2) && size++ < max2) {
        effects.consume(code2);
        return value;
      }
      return nok(code2);
    }
  }
  const nonLazyContinuation = {
    tokenize: tokenizeNonLazyContinuation,
    partial: true
  };
  const codeFenced = {
    name: "codeFenced",
    tokenize: tokenizeCodeFenced,
    concrete: true
  };
  function tokenizeCodeFenced(effects, ok2, nok) {
    const self2 = this;
    const closeStart = {
      tokenize: tokenizeCloseStart,
      partial: true
    };
    let initialPrefix = 0;
    let sizeOpen = 0;
    let marker;
    return start;
    function start(code2) {
      return beforeSequenceOpen(code2);
    }
    function beforeSequenceOpen(code2) {
      const tail = self2.events[self2.events.length - 1];
      initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
      marker = code2;
      effects.enter("codeFenced");
      effects.enter("codeFencedFence");
      effects.enter("codeFencedFenceSequence");
      return sequenceOpen(code2);
    }
    function sequenceOpen(code2) {
      if (code2 === marker) {
        sizeOpen++;
        effects.consume(code2);
        return sequenceOpen;
      }
      if (sizeOpen < 3) {
        return nok(code2);
      }
      effects.exit("codeFencedFenceSequence");
      return markdownSpace(code2) ? factorySpace(effects, infoBefore, "whitespace")(code2) : infoBefore(code2);
    }
    function infoBefore(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("codeFencedFence");
        return self2.interrupt ? ok2(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
      }
      effects.enter("codeFencedFenceInfo");
      effects.enter("chunkString", {
        contentType: "string"
      });
      return info(code2);
    }
    function info(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceInfo");
        return infoBefore(code2);
      }
      if (markdownSpace(code2)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceInfo");
        return factorySpace(effects, metaBefore, "whitespace")(code2);
      }
      if (code2 === 96 && code2 === marker) {
        return nok(code2);
      }
      effects.consume(code2);
      return info;
    }
    function metaBefore(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        return infoBefore(code2);
      }
      effects.enter("codeFencedFenceMeta");
      effects.enter("chunkString", {
        contentType: "string"
      });
      return meta2(code2);
    }
    function meta2(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceMeta");
        return infoBefore(code2);
      }
      if (code2 === 96 && code2 === marker) {
        return nok(code2);
      }
      effects.consume(code2);
      return meta2;
    }
    function atNonLazyBreak(code2) {
      return effects.attempt(closeStart, after, contentBefore)(code2);
    }
    function contentBefore(code2) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return contentStart;
    }
    function contentStart(code2) {
      return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(
        effects,
        beforeContentChunk,
        "linePrefix",
        initialPrefix + 1
      )(code2) : beforeContentChunk(code2);
    }
    function beforeContentChunk(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
      }
      effects.enter("codeFlowValue");
      return contentChunk(code2);
    }
    function contentChunk(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("codeFlowValue");
        return beforeContentChunk(code2);
      }
      effects.consume(code2);
      return contentChunk;
    }
    function after(code2) {
      effects.exit("codeFenced");
      return ok2(code2);
    }
    function tokenizeCloseStart(effects2, ok3, nok2) {
      let size = 0;
      return startBefore;
      function startBefore(code2) {
        effects2.enter("lineEnding");
        effects2.consume(code2);
        effects2.exit("lineEnding");
        return start2;
      }
      function start2(code2) {
        effects2.enter("codeFencedFence");
        return markdownSpace(code2) ? factorySpace(
          effects2,
          beforeSequenceClose,
          "linePrefix",
          self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
        )(code2) : beforeSequenceClose(code2);
      }
      function beforeSequenceClose(code2) {
        if (code2 === marker) {
          effects2.enter("codeFencedFenceSequence");
          return sequenceClose(code2);
        }
        return nok2(code2);
      }
      function sequenceClose(code2) {
        if (code2 === marker) {
          size++;
          effects2.consume(code2);
          return sequenceClose;
        }
        if (size >= sizeOpen) {
          effects2.exit("codeFencedFenceSequence");
          return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code2) : sequenceCloseAfter(code2);
        }
        return nok2(code2);
      }
      function sequenceCloseAfter(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects2.exit("codeFencedFence");
          return ok3(code2);
        }
        return nok2(code2);
      }
    }
  }
  function tokenizeNonLazyContinuation(effects, ok2, nok) {
    const self2 = this;
    return start;
    function start(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code2) {
      return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
    }
  }
  const codeIndented = {
    name: "codeIndented",
    tokenize: tokenizeCodeIndented
  };
  const furtherStart = {
    tokenize: tokenizeFurtherStart,
    partial: true
  };
  function tokenizeCodeIndented(effects, ok2, nok) {
    const self2 = this;
    return start;
    function start(code2) {
      effects.enter("codeIndented");
      return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
    }
    function afterPrefix(code2) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code2) : nok(code2);
    }
    function atBreak(code2) {
      if (code2 === null) {
        return after(code2);
      }
      if (markdownLineEnding(code2)) {
        return effects.attempt(furtherStart, atBreak, after)(code2);
      }
      effects.enter("codeFlowValue");
      return inside(code2);
    }
    function inside(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("codeFlowValue");
        return atBreak(code2);
      }
      effects.consume(code2);
      return inside;
    }
    function after(code2) {
      effects.exit("codeIndented");
      return ok2(code2);
    }
  }
  function tokenizeFurtherStart(effects, ok2, nok) {
    const self2 = this;
    return furtherStart2;
    function furtherStart2(code2) {
      if (self2.parser.lazy[self2.now().line]) {
        return nok(code2);
      }
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return furtherStart2;
      }
      return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
    }
    function afterPrefix(code2) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
    }
  }
  const codeText = {
    name: "codeText",
    tokenize: tokenizeCodeText,
    resolve: resolveCodeText,
    previous: previous$1
  };
  function resolveCodeText(events) {
    let tailExitIndex = events.length - 4;
    let headEnterIndex = 3;
    let index2;
    let enter2;
    if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
      index2 = headEnterIndex;
      while (++index2 < tailExitIndex) {
        if (events[index2][1].type === "codeTextData") {
          events[headEnterIndex][1].type = "codeTextPadding";
          events[tailExitIndex][1].type = "codeTextPadding";
          headEnterIndex += 2;
          tailExitIndex -= 2;
          break;
        }
      }
    }
    index2 = headEnterIndex - 1;
    tailExitIndex++;
    while (++index2 <= tailExitIndex) {
      if (enter2 === void 0) {
        if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
          enter2 = index2;
        }
      } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
        events[enter2][1].type = "codeTextData";
        if (index2 !== enter2 + 2) {
          events[enter2][1].end = events[index2 - 1][1].end;
          events.splice(enter2 + 2, index2 - enter2 - 2);
          tailExitIndex -= index2 - enter2 - 2;
          index2 = enter2 + 2;
        }
        enter2 = void 0;
      }
    }
    return events;
  }
  function previous$1(code2) {
    return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
  }
  function tokenizeCodeText(effects, ok2, nok) {
    let sizeOpen = 0;
    let size;
    let token;
    return start;
    function start(code2) {
      effects.enter("codeText");
      effects.enter("codeTextSequence");
      return sequenceOpen(code2);
    }
    function sequenceOpen(code2) {
      if (code2 === 96) {
        effects.consume(code2);
        sizeOpen++;
        return sequenceOpen;
      }
      effects.exit("codeTextSequence");
      return between2(code2);
    }
    function between2(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (code2 === 32) {
        effects.enter("space");
        effects.consume(code2);
        effects.exit("space");
        return between2;
      }
      if (code2 === 96) {
        token = effects.enter("codeTextSequence");
        size = 0;
        return sequenceClose(code2);
      }
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return between2;
      }
      effects.enter("codeTextData");
      return data(code2);
    }
    function data(code2) {
      if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
        effects.exit("codeTextData");
        return between2(code2);
      }
      effects.consume(code2);
      return data;
    }
    function sequenceClose(code2) {
      if (code2 === 96) {
        effects.consume(code2);
        size++;
        return sequenceClose;
      }
      if (size === sizeOpen) {
        effects.exit("codeTextSequence");
        effects.exit("codeText");
        return ok2(code2);
      }
      token.type = "codeTextData";
      return data(code2);
    }
  }
  function subtokenize(events) {
    const jumps = {};
    let index2 = -1;
    let event;
    let lineIndex;
    let otherIndex;
    let otherEvent;
    let parameters;
    let subevents;
    let more;
    while (++index2 < events.length) {
      while (index2 in jumps) {
        index2 = jumps[index2];
      }
      event = events[index2];
      if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
        subevents = event[1]._tokenizer.events;
        otherIndex = 0;
        if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
          otherIndex += 2;
        }
        if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
          while (++otherIndex < subevents.length) {
            if (subevents[otherIndex][1].type === "content") {
              break;
            }
            if (subevents[otherIndex][1].type === "chunkText") {
              subevents[otherIndex][1]._isInFirstContentOfListItem = true;
              otherIndex++;
            }
          }
        }
      }
      if (event[0] === "enter") {
        if (event[1].contentType) {
          Object.assign(jumps, subcontent(events, index2));
          index2 = jumps[index2];
          more = true;
        }
      } else if (event[1]._container) {
        otherIndex = index2;
        lineIndex = void 0;
        while (otherIndex--) {
          otherEvent = events[otherIndex];
          if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
            if (otherEvent[0] === "enter") {
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
              }
              otherEvent[1].type = "lineEnding";
              lineIndex = otherIndex;
            }
          } else {
            break;
          }
        }
        if (lineIndex) {
          event[1].end = Object.assign({}, events[lineIndex][1].start);
          parameters = events.slice(lineIndex, index2);
          parameters.unshift(event);
          splice(events, lineIndex, index2 - lineIndex + 1, parameters);
        }
      }
    }
    return !more;
  }
  function subcontent(events, eventIndex) {
    const token = events[eventIndex][1];
    const context = events[eventIndex][2];
    let startPosition = eventIndex - 1;
    const startPositions = [];
    const tokenizer2 = token._tokenizer || context.parser[token.contentType](token.start);
    const childEvents = tokenizer2.events;
    const jumps = [];
    const gaps = {};
    let stream;
    let previous2;
    let index2 = -1;
    let current = token;
    let adjust = 0;
    let start = 0;
    const breaks = [start];
    while (current) {
      while (events[++startPosition][1] !== current) {
      }
      startPositions.push(startPosition);
      if (!current._tokenizer) {
        stream = context.sliceStream(current);
        if (!current.next) {
          stream.push(null);
        }
        if (previous2) {
          tokenizer2.defineSkip(current.start);
        }
        if (current._isInFirstContentOfListItem) {
          tokenizer2._gfmTasklistFirstContentOfListItem = true;
        }
        tokenizer2.write(stream);
        if (current._isInFirstContentOfListItem) {
          tokenizer2._gfmTasklistFirstContentOfListItem = void 0;
        }
      }
      previous2 = current;
      current = current.next;
    }
    current = token;
    while (++index2 < childEvents.length) {
      if (
        // Find a void token that includes a break.
        childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
      ) {
        start = index2 + 1;
        breaks.push(start);
        current._tokenizer = void 0;
        current.previous = void 0;
        current = current.next;
      }
    }
    tokenizer2.events = [];
    if (current) {
      current._tokenizer = void 0;
      current.previous = void 0;
    } else {
      breaks.pop();
    }
    index2 = breaks.length;
    while (index2--) {
      const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
      const start2 = startPositions.pop();
      jumps.unshift([start2, start2 + slice.length - 1]);
      splice(events, start2, 2, slice);
    }
    index2 = -1;
    while (++index2 < jumps.length) {
      gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
      adjust += jumps[index2][1] - jumps[index2][0] - 1;
    }
    return gaps;
  }
  const content$3 = {
    tokenize: tokenizeContent,
    resolve: resolveContent
  };
  const continuationConstruct = {
    tokenize: tokenizeContinuation,
    partial: true
  };
  function resolveContent(events) {
    subtokenize(events);
    return events;
  }
  function tokenizeContent(effects, ok2) {
    let previous2;
    return chunkStart;
    function chunkStart(code2) {
      effects.enter("content");
      previous2 = effects.enter("chunkContent", {
        contentType: "content"
      });
      return chunkInside(code2);
    }
    function chunkInside(code2) {
      if (code2 === null) {
        return contentEnd(code2);
      }
      if (markdownLineEnding(code2)) {
        return effects.check(
          continuationConstruct,
          contentContinue,
          contentEnd
        )(code2);
      }
      effects.consume(code2);
      return chunkInside;
    }
    function contentEnd(code2) {
      effects.exit("chunkContent");
      effects.exit("content");
      return ok2(code2);
    }
    function contentContinue(code2) {
      effects.consume(code2);
      effects.exit("chunkContent");
      previous2.next = effects.enter("chunkContent", {
        contentType: "content",
        previous: previous2
      });
      previous2 = previous2.next;
      return chunkInside;
    }
  }
  function tokenizeContinuation(effects, ok2, nok) {
    const self2 = this;
    return startLookahead;
    function startLookahead(code2) {
      effects.exit("chunkContent");
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, prefixed, "linePrefix");
    }
    function prefixed(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        return nok(code2);
      }
      const tail = self2.events[self2.events.length - 1];
      if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
        return ok2(code2);
      }
      return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
    }
  }
  function factoryDestination(effects, ok2, nok, type, literalType, literalMarkerType, rawType, stringType, max2) {
    const limit = max2 || Number.POSITIVE_INFINITY;
    let balance = 0;
    return start;
    function start(code2) {
      if (code2 === 60) {
        effects.enter(type);
        effects.enter(literalType);
        effects.enter(literalMarkerType);
        effects.consume(code2);
        effects.exit(literalMarkerType);
        return enclosedBefore;
      }
      if (code2 === null || code2 === 32 || code2 === 41 || asciiControl(code2)) {
        return nok(code2);
      }
      effects.enter(type);
      effects.enter(rawType);
      effects.enter(stringType);
      effects.enter("chunkString", {
        contentType: "string"
      });
      return raw2(code2);
    }
    function enclosedBefore(code2) {
      if (code2 === 62) {
        effects.enter(literalMarkerType);
        effects.consume(code2);
        effects.exit(literalMarkerType);
        effects.exit(literalType);
        effects.exit(type);
        return ok2;
      }
      effects.enter(stringType);
      effects.enter("chunkString", {
        contentType: "string"
      });
      return enclosed(code2);
    }
    function enclosed(code2) {
      if (code2 === 62) {
        effects.exit("chunkString");
        effects.exit(stringType);
        return enclosedBefore(code2);
      }
      if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
        return nok(code2);
      }
      effects.consume(code2);
      return code2 === 92 ? enclosedEscape : enclosed;
    }
    function enclosedEscape(code2) {
      if (code2 === 60 || code2 === 62 || code2 === 92) {
        effects.consume(code2);
        return enclosed;
      }
      return enclosed(code2);
    }
    function raw2(code2) {
      if (!balance && (code2 === null || code2 === 41 || markdownLineEndingOrSpace(code2))) {
        effects.exit("chunkString");
        effects.exit(stringType);
        effects.exit(rawType);
        effects.exit(type);
        return ok2(code2);
      }
      if (balance < limit && code2 === 40) {
        effects.consume(code2);
        balance++;
        return raw2;
      }
      if (code2 === 41) {
        effects.consume(code2);
        balance--;
        return raw2;
      }
      if (code2 === null || code2 === 32 || code2 === 40 || asciiControl(code2)) {
        return nok(code2);
      }
      effects.consume(code2);
      return code2 === 92 ? rawEscape : raw2;
    }
    function rawEscape(code2) {
      if (code2 === 40 || code2 === 41 || code2 === 92) {
        effects.consume(code2);
        return raw2;
      }
      return raw2(code2);
    }
  }
  function factoryLabel(effects, ok2, nok, type, markerType, stringType) {
    const self2 = this;
    let size = 0;
    let seen;
    return start;
    function start(code2) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.enter(stringType);
      return atBreak;
    }
    function atBreak(code2) {
      if (size > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen || // To do: remove in the future once we’ve switched from
      // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
      // which doesn’t need this.
      // Hidden footnotes hook.
      /* c8 ignore next 3 */
      code2 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
        return nok(code2);
      }
      if (code2 === 93) {
        effects.exit(stringType);
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        effects.exit(type);
        return ok2;
      }
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return atBreak;
      }
      effects.enter("chunkString", {
        contentType: "string"
      });
      return labelInside(code2);
    }
    function labelInside(code2) {
      if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
        effects.exit("chunkString");
        return atBreak(code2);
      }
      effects.consume(code2);
      if (!seen)
        seen = !markdownSpace(code2);
      return code2 === 92 ? labelEscape : labelInside;
    }
    function labelEscape(code2) {
      if (code2 === 91 || code2 === 92 || code2 === 93) {
        effects.consume(code2);
        size++;
        return labelInside;
      }
      return labelInside(code2);
    }
  }
  function factoryTitle(effects, ok2, nok, type, markerType, stringType) {
    let marker;
    return start;
    function start(code2) {
      if (code2 === 34 || code2 === 39 || code2 === 40) {
        effects.enter(type);
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        marker = code2 === 40 ? 41 : code2;
        return begin;
      }
      return nok(code2);
    }
    function begin(code2) {
      if (code2 === marker) {
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        effects.exit(type);
        return ok2;
      }
      effects.enter(stringType);
      return atBreak(code2);
    }
    function atBreak(code2) {
      if (code2 === marker) {
        effects.exit(stringType);
        return begin(marker);
      }
      if (code2 === null) {
        return nok(code2);
      }
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace(effects, atBreak, "linePrefix");
      }
      effects.enter("chunkString", {
        contentType: "string"
      });
      return inside(code2);
    }
    function inside(code2) {
      if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
        effects.exit("chunkString");
        return atBreak(code2);
      }
      effects.consume(code2);
      return code2 === 92 ? escape : inside;
    }
    function escape(code2) {
      if (code2 === marker || code2 === 92) {
        effects.consume(code2);
        return inside;
      }
      return inside(code2);
    }
  }
  function factoryWhitespace(effects, ok2) {
    let seen;
    return start;
    function start(code2) {
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        seen = true;
        return start;
      }
      if (markdownSpace(code2)) {
        return factorySpace(
          effects,
          start,
          seen ? "linePrefix" : "lineSuffix"
        )(code2);
      }
      return ok2(code2);
    }
  }
  function normalizeIdentifier(value) {
    return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
  }
  const definition$1 = {
    name: "definition",
    tokenize: tokenizeDefinition
  };
  const titleBefore = {
    tokenize: tokenizeTitleBefore,
    partial: true
  };
  function tokenizeDefinition(effects, ok2, nok) {
    const self2 = this;
    let identifier;
    return start;
    function start(code2) {
      effects.enter("definition");
      return before(code2);
    }
    function before(code2) {
      return factoryLabel.call(
        self2,
        effects,
        labelAfter,
        // Note: we don’t need to reset the way `markdown-rs` does.
        nok,
        "definitionLabel",
        "definitionLabelMarker",
        "definitionLabelString"
      )(code2);
    }
    function labelAfter(code2) {
      identifier = normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      );
      if (code2 === 58) {
        effects.enter("definitionMarker");
        effects.consume(code2);
        effects.exit("definitionMarker");
        return markerAfter;
      }
      return nok(code2);
    }
    function markerAfter(code2) {
      return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
    }
    function destinationBefore(code2) {
      return factoryDestination(
        effects,
        destinationAfter,
        // Note: we don’t need to reset the way `markdown-rs` does.
        nok,
        "definitionDestination",
        "definitionDestinationLiteral",
        "definitionDestinationLiteralMarker",
        "definitionDestinationRaw",
        "definitionDestinationString"
      )(code2);
    }
    function destinationAfter(code2) {
      return effects.attempt(titleBefore, after, after)(code2);
    }
    function after(code2) {
      return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, "whitespace")(code2) : afterWhitespace(code2);
    }
    function afterWhitespace(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("definition");
        self2.parser.defined.push(identifier);
        return ok2(code2);
      }
      return nok(code2);
    }
  }
  function tokenizeTitleBefore(effects, ok2, nok) {
    return titleBefore2;
    function titleBefore2(code2) {
      return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
    }
    function beforeMarker(code2) {
      return factoryTitle(
        effects,
        titleAfter,
        nok,
        "definitionTitle",
        "definitionTitleMarker",
        "definitionTitleString"
      )(code2);
    }
    function titleAfter(code2) {
      return markdownSpace(code2) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code2) : titleAfterOptionalWhitespace(code2);
    }
    function titleAfterOptionalWhitespace(code2) {
      return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
    }
  }
  const hardBreakEscape = {
    name: "hardBreakEscape",
    tokenize: tokenizeHardBreakEscape
  };
  function tokenizeHardBreakEscape(effects, ok2, nok) {
    return start;
    function start(code2) {
      effects.enter("hardBreakEscape");
      effects.consume(code2);
      return after;
    }
    function after(code2) {
      if (markdownLineEnding(code2)) {
        effects.exit("hardBreakEscape");
        return ok2(code2);
      }
      return nok(code2);
    }
  }
  const headingAtx = {
    name: "headingAtx",
    tokenize: tokenizeHeadingAtx,
    resolve: resolveHeadingAtx
  };
  function resolveHeadingAtx(events, context) {
    let contentEnd = events.length - 2;
    let contentStart = 3;
    let content2;
    let text2;
    if (events[contentStart][1].type === "whitespace") {
      contentStart += 2;
    }
    if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
      contentEnd -= 2;
    }
    if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
      contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
    }
    if (contentEnd > contentStart) {
      content2 = {
        type: "atxHeadingText",
        start: events[contentStart][1].start,
        end: events[contentEnd][1].end
      };
      text2 = {
        type: "chunkText",
        start: events[contentStart][1].start,
        end: events[contentEnd][1].end,
        contentType: "text"
      };
      splice(events, contentStart, contentEnd - contentStart + 1, [
        ["enter", content2, context],
        ["enter", text2, context],
        ["exit", text2, context],
        ["exit", content2, context]
      ]);
    }
    return events;
  }
  function tokenizeHeadingAtx(effects, ok2, nok) {
    let size = 0;
    return start;
    function start(code2) {
      effects.enter("atxHeading");
      return before(code2);
    }
    function before(code2) {
      effects.enter("atxHeadingSequence");
      return sequenceOpen(code2);
    }
    function sequenceOpen(code2) {
      if (code2 === 35 && size++ < 6) {
        effects.consume(code2);
        return sequenceOpen;
      }
      if (code2 === null || markdownLineEndingOrSpace(code2)) {
        effects.exit("atxHeadingSequence");
        return atBreak(code2);
      }
      return nok(code2);
    }
    function atBreak(code2) {
      if (code2 === 35) {
        effects.enter("atxHeadingSequence");
        return sequenceFurther(code2);
      }
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("atxHeading");
        return ok2(code2);
      }
      if (markdownSpace(code2)) {
        return factorySpace(effects, atBreak, "whitespace")(code2);
      }
      effects.enter("atxHeadingText");
      return data(code2);
    }
    function sequenceFurther(code2) {
      if (code2 === 35) {
        effects.consume(code2);
        return sequenceFurther;
      }
      effects.exit("atxHeadingSequence");
      return atBreak(code2);
    }
    function data(code2) {
      if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
        effects.exit("atxHeadingText");
        return atBreak(code2);
      }
      effects.consume(code2);
      return data;
    }
  }
  const htmlBlockNames = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "search",
    "section",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
  ];
  const htmlRawNames = ["pre", "script", "style", "textarea"];
  const htmlFlow = {
    name: "htmlFlow",
    tokenize: tokenizeHtmlFlow,
    resolveTo: resolveToHtmlFlow,
    concrete: true
  };
  const blankLineBefore = {
    tokenize: tokenizeBlankLineBefore,
    partial: true
  };
  const nonLazyContinuationStart = {
    tokenize: tokenizeNonLazyContinuationStart,
    partial: true
  };
  function resolveToHtmlFlow(events) {
    let index2 = events.length;
    while (index2--) {
      if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
        break;
      }
    }
    if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
      events[index2][1].start = events[index2 - 2][1].start;
      events[index2 + 1][1].start = events[index2 - 2][1].start;
      events.splice(index2 - 2, 2);
    }
    return events;
  }
  function tokenizeHtmlFlow(effects, ok2, nok) {
    const self2 = this;
    let marker;
    let closingTag;
    let buffer2;
    let index2;
    let markerB;
    return start;
    function start(code2) {
      return before(code2);
    }
    function before(code2) {
      effects.enter("htmlFlow");
      effects.enter("htmlFlowData");
      effects.consume(code2);
      return open;
    }
    function open(code2) {
      if (code2 === 33) {
        effects.consume(code2);
        return declarationOpen;
      }
      if (code2 === 47) {
        effects.consume(code2);
        closingTag = true;
        return tagCloseStart;
      }
      if (code2 === 63) {
        effects.consume(code2);
        marker = 3;
        return self2.interrupt ? ok2 : continuationDeclarationInside;
      }
      if (asciiAlpha(code2)) {
        effects.consume(code2);
        buffer2 = String.fromCharCode(code2);
        return tagName;
      }
      return nok(code2);
    }
    function declarationOpen(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        marker = 2;
        return commentOpenInside;
      }
      if (code2 === 91) {
        effects.consume(code2);
        marker = 5;
        index2 = 0;
        return cdataOpenInside;
      }
      if (asciiAlpha(code2)) {
        effects.consume(code2);
        marker = 4;
        return self2.interrupt ? ok2 : continuationDeclarationInside;
      }
      return nok(code2);
    }
    function commentOpenInside(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        return self2.interrupt ? ok2 : continuationDeclarationInside;
      }
      return nok(code2);
    }
    function cdataOpenInside(code2) {
      const value = "CDATA[";
      if (code2 === value.charCodeAt(index2++)) {
        effects.consume(code2);
        if (index2 === value.length) {
          return self2.interrupt ? ok2 : continuation;
        }
        return cdataOpenInside;
      }
      return nok(code2);
    }
    function tagCloseStart(code2) {
      if (asciiAlpha(code2)) {
        effects.consume(code2);
        buffer2 = String.fromCharCode(code2);
        return tagName;
      }
      return nok(code2);
    }
    function tagName(code2) {
      if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
        const slash = code2 === 47;
        const name = buffer2.toLowerCase();
        if (!slash && !closingTag && htmlRawNames.includes(name)) {
          marker = 1;
          return self2.interrupt ? ok2(code2) : continuation(code2);
        }
        if (htmlBlockNames.includes(buffer2.toLowerCase())) {
          marker = 6;
          if (slash) {
            effects.consume(code2);
            return basicSelfClosing;
          }
          return self2.interrupt ? ok2(code2) : continuation(code2);
        }
        marker = 7;
        return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
      }
      if (code2 === 45 || asciiAlphanumeric(code2)) {
        effects.consume(code2);
        buffer2 += String.fromCharCode(code2);
        return tagName;
      }
      return nok(code2);
    }
    function basicSelfClosing(code2) {
      if (code2 === 62) {
        effects.consume(code2);
        return self2.interrupt ? ok2 : continuation;
      }
      return nok(code2);
    }
    function completeClosingTagAfter(code2) {
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return completeClosingTagAfter;
      }
      return completeEnd(code2);
    }
    function completeAttributeNameBefore(code2) {
      if (code2 === 47) {
        effects.consume(code2);
        return completeEnd;
      }
      if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
        effects.consume(code2);
        return completeAttributeName;
      }
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return completeAttributeNameBefore;
      }
      return completeEnd(code2);
    }
    function completeAttributeName(code2) {
      if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
        effects.consume(code2);
        return completeAttributeName;
      }
      return completeAttributeNameAfter(code2);
    }
    function completeAttributeNameAfter(code2) {
      if (code2 === 61) {
        effects.consume(code2);
        return completeAttributeValueBefore;
      }
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return completeAttributeNameAfter;
      }
      return completeAttributeNameBefore(code2);
    }
    function completeAttributeValueBefore(code2) {
      if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
        return nok(code2);
      }
      if (code2 === 34 || code2 === 39) {
        effects.consume(code2);
        markerB = code2;
        return completeAttributeValueQuoted;
      }
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return completeAttributeValueBefore;
      }
      return completeAttributeValueUnquoted(code2);
    }
    function completeAttributeValueQuoted(code2) {
      if (code2 === markerB) {
        effects.consume(code2);
        markerB = null;
        return completeAttributeValueQuotedAfter;
      }
      if (code2 === null || markdownLineEnding(code2)) {
        return nok(code2);
      }
      effects.consume(code2);
      return completeAttributeValueQuoted;
    }
    function completeAttributeValueUnquoted(code2) {
      if (code2 === null || code2 === 34 || code2 === 39 || code2 === 47 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
        return completeAttributeNameAfter(code2);
      }
      effects.consume(code2);
      return completeAttributeValueUnquoted;
    }
    function completeAttributeValueQuotedAfter(code2) {
      if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
        return completeAttributeNameBefore(code2);
      }
      return nok(code2);
    }
    function completeEnd(code2) {
      if (code2 === 62) {
        effects.consume(code2);
        return completeAfter;
      }
      return nok(code2);
    }
    function completeAfter(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        return continuation(code2);
      }
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return completeAfter;
      }
      return nok(code2);
    }
    function continuation(code2) {
      if (code2 === 45 && marker === 2) {
        effects.consume(code2);
        return continuationCommentInside;
      }
      if (code2 === 60 && marker === 1) {
        effects.consume(code2);
        return continuationRawTagOpen;
      }
      if (code2 === 62 && marker === 4) {
        effects.consume(code2);
        return continuationClose;
      }
      if (code2 === 63 && marker === 3) {
        effects.consume(code2);
        return continuationDeclarationInside;
      }
      if (code2 === 93 && marker === 5) {
        effects.consume(code2);
        return continuationCdataInside;
      }
      if (markdownLineEnding(code2) && (marker === 6 || marker === 7)) {
        effects.exit("htmlFlowData");
        return effects.check(
          blankLineBefore,
          continuationAfter,
          continuationStart
        )(code2);
      }
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("htmlFlowData");
        return continuationStart(code2);
      }
      effects.consume(code2);
      return continuation;
    }
    function continuationStart(code2) {
      return effects.check(
        nonLazyContinuationStart,
        continuationStartNonLazy,
        continuationAfter
      )(code2);
    }
    function continuationStartNonLazy(code2) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return continuationBefore;
    }
    function continuationBefore(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        return continuationStart(code2);
      }
      effects.enter("htmlFlowData");
      return continuation(code2);
    }
    function continuationCommentInside(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        return continuationDeclarationInside;
      }
      return continuation(code2);
    }
    function continuationRawTagOpen(code2) {
      if (code2 === 47) {
        effects.consume(code2);
        buffer2 = "";
        return continuationRawEndTag;
      }
      return continuation(code2);
    }
    function continuationRawEndTag(code2) {
      if (code2 === 62) {
        const name = buffer2.toLowerCase();
        if (htmlRawNames.includes(name)) {
          effects.consume(code2);
          return continuationClose;
        }
        return continuation(code2);
      }
      if (asciiAlpha(code2) && buffer2.length < 8) {
        effects.consume(code2);
        buffer2 += String.fromCharCode(code2);
        return continuationRawEndTag;
      }
      return continuation(code2);
    }
    function continuationCdataInside(code2) {
      if (code2 === 93) {
        effects.consume(code2);
        return continuationDeclarationInside;
      }
      return continuation(code2);
    }
    function continuationDeclarationInside(code2) {
      if (code2 === 62) {
        effects.consume(code2);
        return continuationClose;
      }
      if (code2 === 45 && marker === 2) {
        effects.consume(code2);
        return continuationDeclarationInside;
      }
      return continuation(code2);
    }
    function continuationClose(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("htmlFlowData");
        return continuationAfter(code2);
      }
      effects.consume(code2);
      return continuationClose;
    }
    function continuationAfter(code2) {
      effects.exit("htmlFlow");
      return ok2(code2);
    }
  }
  function tokenizeNonLazyContinuationStart(effects, ok2, nok) {
    const self2 = this;
    return start;
    function start(code2) {
      if (markdownLineEnding(code2)) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return after;
      }
      return nok(code2);
    }
    function after(code2) {
      return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
    }
  }
  function tokenizeBlankLineBefore(effects, ok2, nok) {
    return start;
    function start(code2) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return effects.attempt(blankLine, ok2, nok);
    }
  }
  const htmlText = {
    name: "htmlText",
    tokenize: tokenizeHtmlText
  };
  function tokenizeHtmlText(effects, ok2, nok) {
    const self2 = this;
    let marker;
    let index2;
    let returnState;
    return start;
    function start(code2) {
      effects.enter("htmlText");
      effects.enter("htmlTextData");
      effects.consume(code2);
      return open;
    }
    function open(code2) {
      if (code2 === 33) {
        effects.consume(code2);
        return declarationOpen;
      }
      if (code2 === 47) {
        effects.consume(code2);
        return tagCloseStart;
      }
      if (code2 === 63) {
        effects.consume(code2);
        return instruction;
      }
      if (asciiAlpha(code2)) {
        effects.consume(code2);
        return tagOpen;
      }
      return nok(code2);
    }
    function declarationOpen(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        return commentOpenInside;
      }
      if (code2 === 91) {
        effects.consume(code2);
        index2 = 0;
        return cdataOpenInside;
      }
      if (asciiAlpha(code2)) {
        effects.consume(code2);
        return declaration;
      }
      return nok(code2);
    }
    function commentOpenInside(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        return commentEnd;
      }
      return nok(code2);
    }
    function comment2(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (code2 === 45) {
        effects.consume(code2);
        return commentClose;
      }
      if (markdownLineEnding(code2)) {
        returnState = comment2;
        return lineEndingBefore(code2);
      }
      effects.consume(code2);
      return comment2;
    }
    function commentClose(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        return commentEnd;
      }
      return comment2(code2);
    }
    function commentEnd(code2) {
      return code2 === 62 ? end(code2) : code2 === 45 ? commentClose(code2) : comment2(code2);
    }
    function cdataOpenInside(code2) {
      const value = "CDATA[";
      if (code2 === value.charCodeAt(index2++)) {
        effects.consume(code2);
        return index2 === value.length ? cdata : cdataOpenInside;
      }
      return nok(code2);
    }
    function cdata(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (code2 === 93) {
        effects.consume(code2);
        return cdataClose;
      }
      if (markdownLineEnding(code2)) {
        returnState = cdata;
        return lineEndingBefore(code2);
      }
      effects.consume(code2);
      return cdata;
    }
    function cdataClose(code2) {
      if (code2 === 93) {
        effects.consume(code2);
        return cdataEnd;
      }
      return cdata(code2);
    }
    function cdataEnd(code2) {
      if (code2 === 62) {
        return end(code2);
      }
      if (code2 === 93) {
        effects.consume(code2);
        return cdataEnd;
      }
      return cdata(code2);
    }
    function declaration(code2) {
      if (code2 === null || code2 === 62) {
        return end(code2);
      }
      if (markdownLineEnding(code2)) {
        returnState = declaration;
        return lineEndingBefore(code2);
      }
      effects.consume(code2);
      return declaration;
    }
    function instruction(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (code2 === 63) {
        effects.consume(code2);
        return instructionClose;
      }
      if (markdownLineEnding(code2)) {
        returnState = instruction;
        return lineEndingBefore(code2);
      }
      effects.consume(code2);
      return instruction;
    }
    function instructionClose(code2) {
      return code2 === 62 ? end(code2) : instruction(code2);
    }
    function tagCloseStart(code2) {
      if (asciiAlpha(code2)) {
        effects.consume(code2);
        return tagClose;
      }
      return nok(code2);
    }
    function tagClose(code2) {
      if (code2 === 45 || asciiAlphanumeric(code2)) {
        effects.consume(code2);
        return tagClose;
      }
      return tagCloseBetween(code2);
    }
    function tagCloseBetween(code2) {
      if (markdownLineEnding(code2)) {
        returnState = tagCloseBetween;
        return lineEndingBefore(code2);
      }
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return tagCloseBetween;
      }
      return end(code2);
    }
    function tagOpen(code2) {
      if (code2 === 45 || asciiAlphanumeric(code2)) {
        effects.consume(code2);
        return tagOpen;
      }
      if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
        return tagOpenBetween(code2);
      }
      return nok(code2);
    }
    function tagOpenBetween(code2) {
      if (code2 === 47) {
        effects.consume(code2);
        return end;
      }
      if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
        effects.consume(code2);
        return tagOpenAttributeName;
      }
      if (markdownLineEnding(code2)) {
        returnState = tagOpenBetween;
        return lineEndingBefore(code2);
      }
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return tagOpenBetween;
      }
      return end(code2);
    }
    function tagOpenAttributeName(code2) {
      if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
        effects.consume(code2);
        return tagOpenAttributeName;
      }
      return tagOpenAttributeNameAfter(code2);
    }
    function tagOpenAttributeNameAfter(code2) {
      if (code2 === 61) {
        effects.consume(code2);
        return tagOpenAttributeValueBefore;
      }
      if (markdownLineEnding(code2)) {
        returnState = tagOpenAttributeNameAfter;
        return lineEndingBefore(code2);
      }
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return tagOpenAttributeNameAfter;
      }
      return tagOpenBetween(code2);
    }
    function tagOpenAttributeValueBefore(code2) {
      if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
        return nok(code2);
      }
      if (code2 === 34 || code2 === 39) {
        effects.consume(code2);
        marker = code2;
        return tagOpenAttributeValueQuoted;
      }
      if (markdownLineEnding(code2)) {
        returnState = tagOpenAttributeValueBefore;
        return lineEndingBefore(code2);
      }
      if (markdownSpace(code2)) {
        effects.consume(code2);
        return tagOpenAttributeValueBefore;
      }
      effects.consume(code2);
      return tagOpenAttributeValueUnquoted;
    }
    function tagOpenAttributeValueQuoted(code2) {
      if (code2 === marker) {
        effects.consume(code2);
        marker = void 0;
        return tagOpenAttributeValueQuotedAfter;
      }
      if (code2 === null) {
        return nok(code2);
      }
      if (markdownLineEnding(code2)) {
        returnState = tagOpenAttributeValueQuoted;
        return lineEndingBefore(code2);
      }
      effects.consume(code2);
      return tagOpenAttributeValueQuoted;
    }
    function tagOpenAttributeValueUnquoted(code2) {
      if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
        return nok(code2);
      }
      if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
        return tagOpenBetween(code2);
      }
      effects.consume(code2);
      return tagOpenAttributeValueUnquoted;
    }
    function tagOpenAttributeValueQuotedAfter(code2) {
      if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
        return tagOpenBetween(code2);
      }
      return nok(code2);
    }
    function end(code2) {
      if (code2 === 62) {
        effects.consume(code2);
        effects.exit("htmlTextData");
        effects.exit("htmlText");
        return ok2;
      }
      return nok(code2);
    }
    function lineEndingBefore(code2) {
      effects.exit("htmlTextData");
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return lineEndingAfter;
    }
    function lineEndingAfter(code2) {
      return markdownSpace(code2) ? factorySpace(
        effects,
        lineEndingAfterPrefix,
        "linePrefix",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(code2) : lineEndingAfterPrefix(code2);
    }
    function lineEndingAfterPrefix(code2) {
      effects.enter("htmlTextData");
      return returnState(code2);
    }
  }
  const labelEnd = {
    name: "labelEnd",
    tokenize: tokenizeLabelEnd,
    resolveTo: resolveToLabelEnd,
    resolveAll: resolveAllLabelEnd
  };
  const resourceConstruct = {
    tokenize: tokenizeResource
  };
  const referenceFullConstruct = {
    tokenize: tokenizeReferenceFull
  };
  const referenceCollapsedConstruct = {
    tokenize: tokenizeReferenceCollapsed
  };
  function resolveAllLabelEnd(events) {
    let index2 = -1;
    while (++index2 < events.length) {
      const token = events[index2][1];
      if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
        events.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
        token.type = "data";
        index2++;
      }
    }
    return events;
  }
  function resolveToLabelEnd(events, context) {
    let index2 = events.length;
    let offset = 0;
    let token;
    let open;
    let close2;
    let media2;
    while (index2--) {
      token = events[index2][1];
      if (open) {
        if (token.type === "link" || token.type === "labelLink" && token._inactive) {
          break;
        }
        if (events[index2][0] === "enter" && token.type === "labelLink") {
          token._inactive = true;
        }
      } else if (close2) {
        if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
          open = index2;
          if (token.type !== "labelLink") {
            offset = 2;
            break;
          }
        }
      } else if (token.type === "labelEnd") {
        close2 = index2;
      }
    }
    const group = {
      type: events[open][1].type === "labelLink" ? "link" : "image",
      start: Object.assign({}, events[open][1].start),
      end: Object.assign({}, events[events.length - 1][1].end)
    };
    const label = {
      type: "label",
      start: Object.assign({}, events[open][1].start),
      end: Object.assign({}, events[close2][1].end)
    };
    const text2 = {
      type: "labelText",
      start: Object.assign({}, events[open + offset + 2][1].end),
      end: Object.assign({}, events[close2 - 2][1].start)
    };
    media2 = [
      ["enter", group, context],
      ["enter", label, context]
    ];
    media2 = push(media2, events.slice(open + 1, open + offset + 3));
    media2 = push(media2, [["enter", text2, context]]);
    media2 = push(
      media2,
      resolveAll(
        context.parser.constructs.insideSpan.null,
        events.slice(open + offset + 4, close2 - 3),
        context
      )
    );
    media2 = push(media2, [
      ["exit", text2, context],
      events[close2 - 2],
      events[close2 - 1],
      ["exit", label, context]
    ]);
    media2 = push(media2, events.slice(close2 + 1));
    media2 = push(media2, [["exit", group, context]]);
    splice(events, open, events.length, media2);
    return events;
  }
  function tokenizeLabelEnd(effects, ok2, nok) {
    const self2 = this;
    let index2 = self2.events.length;
    let labelStart;
    let defined;
    while (index2--) {
      if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
        labelStart = self2.events[index2][1];
        break;
      }
    }
    return start;
    function start(code2) {
      if (!labelStart) {
        return nok(code2);
      }
      if (labelStart._inactive) {
        return labelEndNok(code2);
      }
      defined = self2.parser.defined.includes(
        normalizeIdentifier(
          self2.sliceSerialize({
            start: labelStart.end,
            end: self2.now()
          })
        )
      );
      effects.enter("labelEnd");
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelEnd");
      return after;
    }
    function after(code2) {
      if (code2 === 40) {
        return effects.attempt(
          resourceConstruct,
          labelEndOk,
          defined ? labelEndOk : labelEndNok
        )(code2);
      }
      if (code2 === 91) {
        return effects.attempt(
          referenceFullConstruct,
          labelEndOk,
          defined ? referenceNotFull : labelEndNok
        )(code2);
      }
      return defined ? labelEndOk(code2) : labelEndNok(code2);
    }
    function referenceNotFull(code2) {
      return effects.attempt(
        referenceCollapsedConstruct,
        labelEndOk,
        labelEndNok
      )(code2);
    }
    function labelEndOk(code2) {
      return ok2(code2);
    }
    function labelEndNok(code2) {
      labelStart._balanced = true;
      return nok(code2);
    }
  }
  function tokenizeResource(effects, ok2, nok) {
    return resourceStart;
    function resourceStart(code2) {
      effects.enter("resource");
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      return resourceBefore;
    }
    function resourceBefore(code2) {
      return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
    }
    function resourceOpen(code2) {
      if (code2 === 41) {
        return resourceEnd(code2);
      }
      return factoryDestination(
        effects,
        resourceDestinationAfter,
        resourceDestinationMissing,
        "resourceDestination",
        "resourceDestinationLiteral",
        "resourceDestinationLiteralMarker",
        "resourceDestinationRaw",
        "resourceDestinationString",
        32
      )(code2);
    }
    function resourceDestinationAfter(code2) {
      return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
    }
    function resourceDestinationMissing(code2) {
      return nok(code2);
    }
    function resourceBetween(code2) {
      if (code2 === 34 || code2 === 39 || code2 === 40) {
        return factoryTitle(
          effects,
          resourceTitleAfter,
          nok,
          "resourceTitle",
          "resourceTitleMarker",
          "resourceTitleString"
        )(code2);
      }
      return resourceEnd(code2);
    }
    function resourceTitleAfter(code2) {
      return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
    }
    function resourceEnd(code2) {
      if (code2 === 41) {
        effects.enter("resourceMarker");
        effects.consume(code2);
        effects.exit("resourceMarker");
        effects.exit("resource");
        return ok2;
      }
      return nok(code2);
    }
  }
  function tokenizeReferenceFull(effects, ok2, nok) {
    const self2 = this;
    return referenceFull;
    function referenceFull(code2) {
      return factoryLabel.call(
        self2,
        effects,
        referenceFullAfter,
        referenceFullMissing,
        "reference",
        "referenceMarker",
        "referenceString"
      )(code2);
    }
    function referenceFullAfter(code2) {
      return self2.parser.defined.includes(
        normalizeIdentifier(
          self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
        )
      ) ? ok2(code2) : nok(code2);
    }
    function referenceFullMissing(code2) {
      return nok(code2);
    }
  }
  function tokenizeReferenceCollapsed(effects, ok2, nok) {
    return referenceCollapsedStart;
    function referenceCollapsedStart(code2) {
      effects.enter("reference");
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      return referenceCollapsedOpen;
    }
    function referenceCollapsedOpen(code2) {
      if (code2 === 93) {
        effects.enter("referenceMarker");
        effects.consume(code2);
        effects.exit("referenceMarker");
        effects.exit("reference");
        return ok2;
      }
      return nok(code2);
    }
  }
  const labelStartImage = {
    name: "labelStartImage",
    tokenize: tokenizeLabelStartImage,
    resolveAll: labelEnd.resolveAll
  };
  function tokenizeLabelStartImage(effects, ok2, nok) {
    const self2 = this;
    return start;
    function start(code2) {
      effects.enter("labelImage");
      effects.enter("labelImageMarker");
      effects.consume(code2);
      effects.exit("labelImageMarker");
      return open;
    }
    function open(code2) {
      if (code2 === 91) {
        effects.enter("labelMarker");
        effects.consume(code2);
        effects.exit("labelMarker");
        effects.exit("labelImage");
        return after;
      }
      return nok(code2);
    }
    function after(code2) {
      return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
    }
  }
  const labelStartLink = {
    name: "labelStartLink",
    tokenize: tokenizeLabelStartLink,
    resolveAll: labelEnd.resolveAll
  };
  function tokenizeLabelStartLink(effects, ok2, nok) {
    const self2 = this;
    return start;
    function start(code2) {
      effects.enter("labelLink");
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelLink");
      return after;
    }
    function after(code2) {
      return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
    }
  }
  const lineEnding = {
    name: "lineEnding",
    tokenize: tokenizeLineEnding
  };
  function tokenizeLineEnding(effects, ok2) {
    return start;
    function start(code2) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, ok2, "linePrefix");
    }
  }
  const thematicBreak$2 = {
    name: "thematicBreak",
    tokenize: tokenizeThematicBreak
  };
  function tokenizeThematicBreak(effects, ok2, nok) {
    let size = 0;
    let marker;
    return start;
    function start(code2) {
      effects.enter("thematicBreak");
      return before(code2);
    }
    function before(code2) {
      marker = code2;
      return atBreak(code2);
    }
    function atBreak(code2) {
      if (code2 === marker) {
        effects.enter("thematicBreakSequence");
        return sequence(code2);
      }
      if (size >= 3 && (code2 === null || markdownLineEnding(code2))) {
        effects.exit("thematicBreak");
        return ok2(code2);
      }
      return nok(code2);
    }
    function sequence(code2) {
      if (code2 === marker) {
        effects.consume(code2);
        size++;
        return sequence;
      }
      effects.exit("thematicBreakSequence");
      return markdownSpace(code2) ? factorySpace(effects, atBreak, "whitespace")(code2) : atBreak(code2);
    }
  }
  const list$4 = {
    name: "list",
    tokenize: tokenizeListStart,
    continuation: {
      tokenize: tokenizeListContinuation
    },
    exit: tokenizeListEnd
  };
  const listItemPrefixWhitespaceConstruct = {
    tokenize: tokenizeListItemPrefixWhitespace,
    partial: true
  };
  const indentConstruct = {
    tokenize: tokenizeIndent$1,
    partial: true
  };
  function tokenizeListStart(effects, ok2, nok) {
    const self2 = this;
    const tail = self2.events[self2.events.length - 1];
    let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    let size = 0;
    return start;
    function start(code2) {
      const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
      if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
        if (!self2.containerState.type) {
          self2.containerState.type = kind;
          effects.enter(kind, {
            _container: true
          });
        }
        if (kind === "listUnordered") {
          effects.enter("listItemPrefix");
          return code2 === 42 || code2 === 45 ? effects.check(thematicBreak$2, nok, atMarker)(code2) : atMarker(code2);
        }
        if (!self2.interrupt || code2 === 49) {
          effects.enter("listItemPrefix");
          effects.enter("listItemValue");
          return inside(code2);
        }
      }
      return nok(code2);
    }
    function inside(code2) {
      if (asciiDigit(code2) && ++size < 10) {
        effects.consume(code2);
        return inside;
      }
      if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
        effects.exit("listItemValue");
        return atMarker(code2);
      }
      return nok(code2);
    }
    function atMarker(code2) {
      effects.enter("listItemMarker");
      effects.consume(code2);
      effects.exit("listItemMarker");
      self2.containerState.marker = self2.containerState.marker || code2;
      return effects.check(
        blankLine,
        // Can’t be empty when interrupting.
        self2.interrupt ? nok : onBlank,
        effects.attempt(
          listItemPrefixWhitespaceConstruct,
          endOfPrefix,
          otherPrefix
        )
      );
    }
    function onBlank(code2) {
      self2.containerState.initialBlankLine = true;
      initialSize++;
      return endOfPrefix(code2);
    }
    function otherPrefix(code2) {
      if (markdownSpace(code2)) {
        effects.enter("listItemPrefixWhitespace");
        effects.consume(code2);
        effects.exit("listItemPrefixWhitespace");
        return endOfPrefix;
      }
      return nok(code2);
    }
    function endOfPrefix(code2) {
      self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
      return ok2(code2);
    }
  }
  function tokenizeListContinuation(effects, ok2, nok) {
    const self2 = this;
    self2.containerState._closeFlow = void 0;
    return effects.check(blankLine, onBlank, notBlank);
    function onBlank(code2) {
      self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
      return factorySpace(
        effects,
        ok2,
        "listItemIndent",
        self2.containerState.size + 1
      )(code2);
    }
    function notBlank(code2) {
      if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
        self2.containerState.furtherBlankLines = void 0;
        self2.containerState.initialBlankLine = void 0;
        return notInCurrentItem(code2);
      }
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
    }
    function notInCurrentItem(code2) {
      self2.containerState._closeFlow = true;
      self2.interrupt = void 0;
      return factorySpace(
        effects,
        effects.attempt(list$4, ok2, nok),
        "linePrefix",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(code2);
    }
  }
  function tokenizeIndent$1(effects, ok2, nok) {
    const self2 = this;
    return factorySpace(
      effects,
      afterPrefix,
      "listItemIndent",
      self2.containerState.size + 1
    );
    function afterPrefix(code2) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code2) : nok(code2);
    }
  }
  function tokenizeListEnd(effects) {
    effects.exit(this.containerState.type);
  }
  function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
    const self2 = this;
    return factorySpace(
      effects,
      afterPrefix,
      "listItemPrefixWhitespace",
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
    );
    function afterPrefix(code2) {
      const tail = self2.events[self2.events.length - 1];
      return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
    }
  }
  const setextUnderline = {
    name: "setextUnderline",
    tokenize: tokenizeSetextUnderline,
    resolveTo: resolveToSetextUnderline
  };
  function resolveToSetextUnderline(events, context) {
    let index2 = events.length;
    let content2;
    let text2;
    let definition2;
    while (index2--) {
      if (events[index2][0] === "enter") {
        if (events[index2][1].type === "content") {
          content2 = index2;
          break;
        }
        if (events[index2][1].type === "paragraph") {
          text2 = index2;
        }
      } else {
        if (events[index2][1].type === "content") {
          events.splice(index2, 1);
        }
        if (!definition2 && events[index2][1].type === "definition") {
          definition2 = index2;
        }
      }
    }
    const heading2 = {
      type: "setextHeading",
      start: Object.assign({}, events[text2][1].start),
      end: Object.assign({}, events[events.length - 1][1].end)
    };
    events[text2][1].type = "setextHeadingText";
    if (definition2) {
      events.splice(text2, 0, ["enter", heading2, context]);
      events.splice(definition2 + 1, 0, ["exit", events[content2][1], context]);
      events[content2][1].end = Object.assign({}, events[definition2][1].end);
    } else {
      events[content2][1] = heading2;
    }
    events.push(["exit", heading2, context]);
    return events;
  }
  function tokenizeSetextUnderline(effects, ok2, nok) {
    const self2 = this;
    let marker;
    return start;
    function start(code2) {
      let index2 = self2.events.length;
      let paragraph2;
      while (index2--) {
        if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
          paragraph2 = self2.events[index2][1].type === "paragraph";
          break;
        }
      }
      if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
        effects.enter("setextHeadingLine");
        marker = code2;
        return before(code2);
      }
      return nok(code2);
    }
    function before(code2) {
      effects.enter("setextHeadingLineSequence");
      return inside(code2);
    }
    function inside(code2) {
      if (code2 === marker) {
        effects.consume(code2);
        return inside;
      }
      effects.exit("setextHeadingLineSequence");
      return markdownSpace(code2) ? factorySpace(effects, after, "lineSuffix")(code2) : after(code2);
    }
    function after(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("setextHeadingLine");
        return ok2(code2);
      }
      return nok(code2);
    }
  }
  const indent = {
    tokenize: tokenizeIndent,
    partial: true
  };
  function gfmFootnote() {
    return {
      document: {
        [91]: {
          tokenize: tokenizeDefinitionStart,
          continuation: {
            tokenize: tokenizeDefinitionContinuation
          },
          exit: gfmFootnoteDefinitionEnd
        }
      },
      text: {
        [91]: {
          tokenize: tokenizeGfmFootnoteCall
        },
        [93]: {
          add: "after",
          tokenize: tokenizePotentialGfmFootnoteCall,
          resolveTo: resolveToPotentialGfmFootnoteCall
        }
      }
    };
  }
  function tokenizePotentialGfmFootnoteCall(effects, ok2, nok) {
    const self2 = this;
    let index2 = self2.events.length;
    const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
    let labelStart;
    while (index2--) {
      const token = self2.events[index2][1];
      if (token.type === "labelImage") {
        labelStart = token;
        break;
      }
      if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") {
        break;
      }
    }
    return start;
    function start(code2) {
      if (!labelStart || !labelStart._balanced) {
        return nok(code2);
      }
      const id = normalizeIdentifier(
        self2.sliceSerialize({
          start: labelStart.end,
          end: self2.now()
        })
      );
      if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {
        return nok(code2);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteCallLabelMarker");
      return ok2(code2);
    }
  }
  function resolveToPotentialGfmFootnoteCall(events, context) {
    let index2 = events.length;
    while (index2--) {
      if (events[index2][1].type === "labelImage" && events[index2][0] === "enter") {
        events[index2][1];
        break;
      }
    }
    events[index2 + 1][1].type = "data";
    events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
    const call = {
      type: "gfmFootnoteCall",
      start: Object.assign({}, events[index2 + 3][1].start),
      end: Object.assign({}, events[events.length - 1][1].end)
    };
    const marker = {
      type: "gfmFootnoteCallMarker",
      start: Object.assign({}, events[index2 + 3][1].end),
      end: Object.assign({}, events[index2 + 3][1].end)
    };
    marker.end.column++;
    marker.end.offset++;
    marker.end._bufferIndex++;
    const string2 = {
      type: "gfmFootnoteCallString",
      start: Object.assign({}, marker.end),
      end: Object.assign({}, events[events.length - 1][1].start)
    };
    const chunk = {
      type: "chunkString",
      contentType: "string",
      start: Object.assign({}, string2.start),
      end: Object.assign({}, string2.end)
    };
    const replacement = [
      // Take the `labelImageMarker` (now `data`, the `!`)
      events[index2 + 1],
      events[index2 + 2],
      ["enter", call, context],
      // The `[`
      events[index2 + 3],
      events[index2 + 4],
      // The `^`.
      ["enter", marker, context],
      ["exit", marker, context],
      // Everything in between.
      ["enter", string2, context],
      ["enter", chunk, context],
      ["exit", chunk, context],
      ["exit", string2, context],
      // The ending (`]`, properly parsed and labelled).
      events[events.length - 2],
      events[events.length - 1],
      ["exit", call, context]
    ];
    events.splice(index2, events.length - index2 + 1, ...replacement);
    return events;
  }
  function tokenizeGfmFootnoteCall(effects, ok2, nok) {
    const self2 = this;
    const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
    let size = 0;
    let data;
    return start;
    function start(code2) {
      effects.enter("gfmFootnoteCall");
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteCallLabelMarker");
      return callStart;
    }
    function callStart(code2) {
      if (code2 !== 94)
        return nok(code2);
      effects.enter("gfmFootnoteCallMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteCallMarker");
      effects.enter("gfmFootnoteCallString");
      effects.enter("chunkString").contentType = "string";
      return callData;
    }
    function callData(code2) {
      if (
        // Too long.
        size > 999 || // Closing brace with nothing.
        code2 === 93 && !data || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)
      ) {
        return nok(code2);
      }
      if (code2 === 93) {
        effects.exit("chunkString");
        const token = effects.exit("gfmFootnoteCallString");
        if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token)))) {
          return nok(code2);
        }
        effects.enter("gfmFootnoteCallLabelMarker");
        effects.consume(code2);
        effects.exit("gfmFootnoteCallLabelMarker");
        effects.exit("gfmFootnoteCall");
        return ok2;
      }
      if (!markdownLineEndingOrSpace(code2)) {
        data = true;
      }
      size++;
      effects.consume(code2);
      return code2 === 92 ? callEscape : callData;
    }
    function callEscape(code2) {
      if (code2 === 91 || code2 === 92 || code2 === 93) {
        effects.consume(code2);
        size++;
        return callData;
      }
      return callData(code2);
    }
  }
  function tokenizeDefinitionStart(effects, ok2, nok) {
    const self2 = this;
    const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
    let identifier;
    let size = 0;
    let data;
    return start;
    function start(code2) {
      effects.enter("gfmFootnoteDefinition")._container = true;
      effects.enter("gfmFootnoteDefinitionLabel");
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      return labelAtMarker;
    }
    function labelAtMarker(code2) {
      if (code2 === 94) {
        effects.enter("gfmFootnoteDefinitionMarker");
        effects.consume(code2);
        effects.exit("gfmFootnoteDefinitionMarker");
        effects.enter("gfmFootnoteDefinitionLabelString");
        effects.enter("chunkString").contentType = "string";
        return labelInside;
      }
      return nok(code2);
    }
    function labelInside(code2) {
      if (
        // Too long.
        size > 999 || // Closing brace with nothing.
        code2 === 93 && !data || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)
      ) {
        return nok(code2);
      }
      if (code2 === 93) {
        effects.exit("chunkString");
        const token = effects.exit("gfmFootnoteDefinitionLabelString");
        identifier = normalizeIdentifier(self2.sliceSerialize(token));
        effects.enter("gfmFootnoteDefinitionLabelMarker");
        effects.consume(code2);
        effects.exit("gfmFootnoteDefinitionLabelMarker");
        effects.exit("gfmFootnoteDefinitionLabel");
        return labelAfter;
      }
      if (!markdownLineEndingOrSpace(code2)) {
        data = true;
      }
      size++;
      effects.consume(code2);
      return code2 === 92 ? labelEscape : labelInside;
    }
    function labelEscape(code2) {
      if (code2 === 91 || code2 === 92 || code2 === 93) {
        effects.consume(code2);
        size++;
        return labelInside;
      }
      return labelInside(code2);
    }
    function labelAfter(code2) {
      if (code2 === 58) {
        effects.enter("definitionMarker");
        effects.consume(code2);
        effects.exit("definitionMarker");
        if (!defined.includes(identifier)) {
          defined.push(identifier);
        }
        return factorySpace(
          effects,
          whitespaceAfter,
          "gfmFootnoteDefinitionWhitespace"
        );
      }
      return nok(code2);
    }
    function whitespaceAfter(code2) {
      return ok2(code2);
    }
  }
  function tokenizeDefinitionContinuation(effects, ok2, nok) {
    return effects.check(blankLine, ok2, effects.attempt(indent, ok2, nok));
  }
  function gfmFootnoteDefinitionEnd(effects) {
    effects.exit("gfmFootnoteDefinition");
  }
  function tokenizeIndent(effects, ok2, nok) {
    const self2 = this;
    return factorySpace(
      effects,
      afterPrefix,
      "gfmFootnoteDefinitionIndent",
      4 + 1
    );
    function afterPrefix(code2) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok2(code2) : nok(code2);
    }
  }
  function gfmStrikethrough(options) {
    const options_ = options || {};
    let single = options_.singleTilde;
    const tokenizer2 = {
      tokenize: tokenizeStrikethrough,
      resolveAll: resolveAllStrikethrough
    };
    if (single === null || single === void 0) {
      single = true;
    }
    return {
      text: {
        [126]: tokenizer2
      },
      insideSpan: {
        null: [tokenizer2]
      },
      attentionMarkers: {
        null: [126]
      }
    };
    function resolveAllStrikethrough(events, context) {
      let index2 = -1;
      while (++index2 < events.length) {
        if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
          let open = index2;
          while (open--) {
            if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
            events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
              events[index2][1].type = "strikethroughSequence";
              events[open][1].type = "strikethroughSequence";
              const strikethrough2 = {
                type: "strikethrough",
                start: Object.assign({}, events[open][1].start),
                end: Object.assign({}, events[index2][1].end)
              };
              const text2 = {
                type: "strikethroughText",
                start: Object.assign({}, events[open][1].end),
                end: Object.assign({}, events[index2][1].start)
              };
              const nextEvents = [
                ["enter", strikethrough2, context],
                ["enter", events[open][1], context],
                ["exit", events[open][1], context],
                ["enter", text2, context]
              ];
              const insideSpan2 = context.parser.constructs.insideSpan.null;
              if (insideSpan2) {
                splice(
                  nextEvents,
                  nextEvents.length,
                  0,
                  resolveAll(insideSpan2, events.slice(open + 1, index2), context)
                );
              }
              splice(nextEvents, nextEvents.length, 0, [
                ["exit", text2, context],
                ["enter", events[index2][1], context],
                ["exit", events[index2][1], context],
                ["exit", strikethrough2, context]
              ]);
              splice(events, open - 1, index2 - open + 3, nextEvents);
              index2 = open + nextEvents.length - 2;
              break;
            }
          }
        }
      }
      index2 = -1;
      while (++index2 < events.length) {
        if (events[index2][1].type === "strikethroughSequenceTemporary") {
          events[index2][1].type = "data";
        }
      }
      return events;
    }
    function tokenizeStrikethrough(effects, ok2, nok) {
      const previous2 = this.previous;
      const events = this.events;
      let size = 0;
      return start;
      function start(code2) {
        if (previous2 === 126 && events[events.length - 1][1].type !== "characterEscape") {
          return nok(code2);
        }
        effects.enter("strikethroughSequenceTemporary");
        return more(code2);
      }
      function more(code2) {
        const before = classifyCharacter(previous2);
        if (code2 === 126) {
          if (size > 1)
            return nok(code2);
          effects.consume(code2);
          size++;
          return more;
        }
        if (size < 2 && !single)
          return nok(code2);
        const token = effects.exit("strikethroughSequenceTemporary");
        const after = classifyCharacter(code2);
        token._open = !after || after === 2 && Boolean(before);
        token._close = !before || before === 2 && Boolean(after);
        return ok2(code2);
      }
    }
  }
  class EditMap {
    /**
     * Create a new edit map.
     */
    constructor() {
      this.map = [];
    }
    /**
     * Create an edit: a remove and/or add at a certain place.
     *
     * @param {number} index
     * @param {number} remove
     * @param {Array<Event>} add
     * @returns {void}
     */
    add(index2, remove, add) {
      addImpl(this, index2, remove, add);
    }
    // To do: not used here.
    // /**
    //  * Create an edit: but insert `add` before existing additions.
    //  *
    //  * @param {number} index
    //  * @param {number} remove
    //  * @param {Array<Event>} add
    //  * @returns {void}
    //  */
    // addBefore(index, remove, add) {
    //   addImpl(this, index, remove, add, true)
    // }
    /**
     * Done, change the events.
     *
     * @param {Array<Event>} events
     * @returns {void}
     */
    consume(events) {
      this.map.sort((a2, b) => a2[0] - b[0]);
      if (this.map.length === 0) {
        return;
      }
      let index2 = this.map.length;
      const vecs = [];
      while (index2 > 0) {
        index2 -= 1;
        vecs.push(events.slice(this.map[index2][0] + this.map[index2][1]));
        vecs.push(this.map[index2][2]);
        events.length = this.map[index2][0];
      }
      vecs.push([...events]);
      events.length = 0;
      let slice = vecs.pop();
      while (slice) {
        events.push(...slice);
        slice = vecs.pop();
      }
      this.map.length = 0;
    }
  }
  function addImpl(editMap, at, remove, add) {
    let index2 = 0;
    if (remove === 0 && add.length === 0) {
      return;
    }
    while (index2 < editMap.map.length) {
      if (editMap.map[index2][0] === at) {
        editMap.map[index2][1] += remove;
        editMap.map[index2][2].push(...add);
        return;
      }
      index2 += 1;
    }
    editMap.map.push([at, remove, add]);
  }
  function gfmTableAlign(events, index2) {
    let inDelimiterRow = false;
    const align = [];
    while (index2 < events.length) {
      const event = events[index2];
      if (inDelimiterRow) {
        if (event[0] === "enter") {
          if (event[1].type === "tableContent") {
            align.push(
              events[index2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
            );
          }
        } else if (event[1].type === "tableContent") {
          if (events[index2 - 1][1].type === "tableDelimiterMarker") {
            const alignIndex = align.length - 1;
            align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
          }
        } else if (event[1].type === "tableDelimiterRow") {
          break;
        }
      } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
        inDelimiterRow = true;
      }
      index2 += 1;
    }
    return align;
  }
  const gfmTable = {
    flow: {
      null: {
        tokenize: tokenizeTable,
        resolveAll: resolveTable
      }
    }
  };
  function tokenizeTable(effects, ok2, nok) {
    const self2 = this;
    let size = 0;
    let sizeB = 0;
    let seen;
    return start;
    function start(code2) {
      let index2 = self2.events.length - 1;
      while (index2 > -1) {
        const type = self2.events[index2][1].type;
        if (type === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
        type === "linePrefix")
          index2--;
        else
          break;
      }
      const tail = index2 > -1 ? self2.events[index2][1].type : null;
      const next = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
      if (next === bodyRowStart && self2.parser.lazy[self2.now().line]) {
        return nok(code2);
      }
      return next(code2);
    }
    function headRowBefore(code2) {
      effects.enter("tableHead");
      effects.enter("tableRow");
      return headRowStart(code2);
    }
    function headRowStart(code2) {
      if (code2 === 124) {
        return headRowBreak(code2);
      }
      seen = true;
      sizeB += 1;
      return headRowBreak(code2);
    }
    function headRowBreak(code2) {
      if (code2 === null) {
        return nok(code2);
      }
      if (markdownLineEnding(code2)) {
        if (sizeB > 1) {
          sizeB = 0;
          self2.interrupt = true;
          effects.exit("tableRow");
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return headDelimiterStart;
        }
        return nok(code2);
      }
      if (markdownSpace(code2)) {
        return factorySpace(effects, headRowBreak, "whitespace")(code2);
      }
      sizeB += 1;
      if (seen) {
        seen = false;
        size += 1;
      }
      if (code2 === 124) {
        effects.enter("tableCellDivider");
        effects.consume(code2);
        effects.exit("tableCellDivider");
        seen = true;
        return headRowBreak;
      }
      effects.enter("data");
      return headRowData(code2);
    }
    function headRowData(code2) {
      if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
        effects.exit("data");
        return headRowBreak(code2);
      }
      effects.consume(code2);
      return code2 === 92 ? headRowEscape : headRowData;
    }
    function headRowEscape(code2) {
      if (code2 === 92 || code2 === 124) {
        effects.consume(code2);
        return headRowData;
      }
      return headRowData(code2);
    }
    function headDelimiterStart(code2) {
      self2.interrupt = false;
      if (self2.parser.lazy[self2.now().line]) {
        return nok(code2);
      }
      effects.enter("tableDelimiterRow");
      seen = false;
      if (markdownSpace(code2)) {
        return factorySpace(
          effects,
          headDelimiterBefore,
          "linePrefix",
          self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
        )(code2);
      }
      return headDelimiterBefore(code2);
    }
    function headDelimiterBefore(code2) {
      if (code2 === 45 || code2 === 58) {
        return headDelimiterValueBefore(code2);
      }
      if (code2 === 124) {
        seen = true;
        effects.enter("tableCellDivider");
        effects.consume(code2);
        effects.exit("tableCellDivider");
        return headDelimiterCellBefore;
      }
      return headDelimiterNok(code2);
    }
    function headDelimiterCellBefore(code2) {
      if (markdownSpace(code2)) {
        return factorySpace(effects, headDelimiterValueBefore, "whitespace")(code2);
      }
      return headDelimiterValueBefore(code2);
    }
    function headDelimiterValueBefore(code2) {
      if (code2 === 58) {
        sizeB += 1;
        seen = true;
        effects.enter("tableDelimiterMarker");
        effects.consume(code2);
        effects.exit("tableDelimiterMarker");
        return headDelimiterLeftAlignmentAfter;
      }
      if (code2 === 45) {
        sizeB += 1;
        return headDelimiterLeftAlignmentAfter(code2);
      }
      if (code2 === null || markdownLineEnding(code2)) {
        return headDelimiterCellAfter(code2);
      }
      return headDelimiterNok(code2);
    }
    function headDelimiterLeftAlignmentAfter(code2) {
      if (code2 === 45) {
        effects.enter("tableDelimiterFiller");
        return headDelimiterFiller(code2);
      }
      return headDelimiterNok(code2);
    }
    function headDelimiterFiller(code2) {
      if (code2 === 45) {
        effects.consume(code2);
        return headDelimiterFiller;
      }
      if (code2 === 58) {
        seen = true;
        effects.exit("tableDelimiterFiller");
        effects.enter("tableDelimiterMarker");
        effects.consume(code2);
        effects.exit("tableDelimiterMarker");
        return headDelimiterRightAlignmentAfter;
      }
      effects.exit("tableDelimiterFiller");
      return headDelimiterRightAlignmentAfter(code2);
    }
    function headDelimiterRightAlignmentAfter(code2) {
      if (markdownSpace(code2)) {
        return factorySpace(effects, headDelimiterCellAfter, "whitespace")(code2);
      }
      return headDelimiterCellAfter(code2);
    }
    function headDelimiterCellAfter(code2) {
      if (code2 === 124) {
        return headDelimiterBefore(code2);
      }
      if (code2 === null || markdownLineEnding(code2)) {
        if (!seen || size !== sizeB) {
          return headDelimiterNok(code2);
        }
        effects.exit("tableDelimiterRow");
        effects.exit("tableHead");
        return ok2(code2);
      }
      return headDelimiterNok(code2);
    }
    function headDelimiterNok(code2) {
      return nok(code2);
    }
    function bodyRowStart(code2) {
      effects.enter("tableRow");
      return bodyRowBreak(code2);
    }
    function bodyRowBreak(code2) {
      if (code2 === 124) {
        effects.enter("tableCellDivider");
        effects.consume(code2);
        effects.exit("tableCellDivider");
        return bodyRowBreak;
      }
      if (code2 === null || markdownLineEnding(code2)) {
        effects.exit("tableRow");
        return ok2(code2);
      }
      if (markdownSpace(code2)) {
        return factorySpace(effects, bodyRowBreak, "whitespace")(code2);
      }
      effects.enter("data");
      return bodyRowData(code2);
    }
    function bodyRowData(code2) {
      if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
        effects.exit("data");
        return bodyRowBreak(code2);
      }
      effects.consume(code2);
      return code2 === 92 ? bodyRowEscape : bodyRowData;
    }
    function bodyRowEscape(code2) {
      if (code2 === 92 || code2 === 124) {
        effects.consume(code2);
        return bodyRowData;
      }
      return bodyRowData(code2);
    }
  }
  function resolveTable(events, context) {
    let index2 = -1;
    let inFirstCellAwaitingPipe = true;
    let rowKind = 0;
    let lastCell = [0, 0, 0, 0];
    let cell2 = [0, 0, 0, 0];
    let afterHeadAwaitingFirstBodyRow = false;
    let lastTableEnd = 0;
    let currentTable;
    let currentBody;
    let currentCell;
    const map2 = new EditMap();
    while (++index2 < events.length) {
      const event = events[index2];
      const token = event[1];
      if (event[0] === "enter") {
        if (token.type === "tableHead") {
          afterHeadAwaitingFirstBodyRow = false;
          if (lastTableEnd !== 0) {
            flushTableEnd(map2, context, lastTableEnd, currentTable, currentBody);
            currentBody = void 0;
            lastTableEnd = 0;
          }
          currentTable = {
            type: "table",
            start: Object.assign({}, token.start),
            // Note: correct end is set later.
            end: Object.assign({}, token.end)
          };
          map2.add(index2, 0, [["enter", currentTable, context]]);
        } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
          inFirstCellAwaitingPipe = true;
          currentCell = void 0;
          lastCell = [0, 0, 0, 0];
          cell2 = [0, index2 + 1, 0, 0];
          if (afterHeadAwaitingFirstBodyRow) {
            afterHeadAwaitingFirstBodyRow = false;
            currentBody = {
              type: "tableBody",
              start: Object.assign({}, token.start),
              // Note: correct end is set later.
              end: Object.assign({}, token.end)
            };
            map2.add(index2, 0, [["enter", currentBody, context]]);
          }
          rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
        } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
          inFirstCellAwaitingPipe = false;
          if (cell2[2] === 0) {
            if (lastCell[1] !== 0) {
              cell2[0] = cell2[1];
              currentCell = flushCell(
                map2,
                context,
                lastCell,
                rowKind,
                void 0,
                currentCell
              );
              lastCell = [0, 0, 0, 0];
            }
            cell2[2] = index2;
          }
        } else if (token.type === "tableCellDivider") {
          if (inFirstCellAwaitingPipe) {
            inFirstCellAwaitingPipe = false;
          } else {
            if (lastCell[1] !== 0) {
              cell2[0] = cell2[1];
              currentCell = flushCell(
                map2,
                context,
                lastCell,
                rowKind,
                void 0,
                currentCell
              );
            }
            lastCell = cell2;
            cell2 = [lastCell[1], index2, 0, 0];
          }
        }
      } else if (token.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = true;
        lastTableEnd = index2;
      } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
        lastTableEnd = index2;
        if (lastCell[1] !== 0) {
          cell2[0] = cell2[1];
          currentCell = flushCell(
            map2,
            context,
            lastCell,
            rowKind,
            index2,
            currentCell
          );
        } else if (cell2[1] !== 0) {
          currentCell = flushCell(map2, context, cell2, rowKind, index2, currentCell);
        }
        rowKind = 0;
      } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
        cell2[3] = index2;
      }
    }
    if (lastTableEnd !== 0) {
      flushTableEnd(map2, context, lastTableEnd, currentTable, currentBody);
    }
    map2.consume(context.events);
    index2 = -1;
    while (++index2 < context.events.length) {
      const event = context.events[index2];
      if (event[0] === "enter" && event[1].type === "table") {
        event[1]._align = gfmTableAlign(context.events, index2);
      }
    }
    return events;
  }
  function flushCell(map2, context, range, rowKind, rowEnd, previousCell) {
    const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
    const valueName = "tableContent";
    if (range[0] !== 0) {
      previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
      map2.add(range[0], 0, [["exit", previousCell, context]]);
    }
    const now = getPoint(context.events, range[1]);
    previousCell = {
      type: groupName,
      start: Object.assign({}, now),
      // Note: correct end is set later.
      end: Object.assign({}, now)
    };
    map2.add(range[1], 0, [["enter", previousCell, context]]);
    if (range[2] !== 0) {
      const relatedStart = getPoint(context.events, range[2]);
      const relatedEnd = getPoint(context.events, range[3]);
      const valueToken = {
        type: valueName,
        start: Object.assign({}, relatedStart),
        end: Object.assign({}, relatedEnd)
      };
      map2.add(range[2], 0, [["enter", valueToken, context]]);
      if (rowKind !== 2) {
        const start = context.events[range[2]];
        const end = context.events[range[3]];
        start[1].end = Object.assign({}, end[1].end);
        start[1].type = "chunkText";
        start[1].contentType = "text";
        if (range[3] > range[2] + 1) {
          const a2 = range[2] + 1;
          const b = range[3] - range[2] - 1;
          map2.add(a2, b, []);
        }
      }
      map2.add(range[3] + 1, 0, [["exit", valueToken, context]]);
    }
    if (rowEnd !== void 0) {
      previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
      map2.add(rowEnd, 0, [["exit", previousCell, context]]);
      previousCell = void 0;
    }
    return previousCell;
  }
  function flushTableEnd(map2, context, index2, table2, tableBody) {
    const exits = [];
    const related = getPoint(context.events, index2);
    if (tableBody) {
      tableBody.end = Object.assign({}, related);
      exits.push(["exit", tableBody, context]);
    }
    table2.end = Object.assign({}, related);
    exits.push(["exit", table2, context]);
    map2.add(index2 + 1, 0, exits);
  }
  function getPoint(events, index2) {
    const event = events[index2];
    const side = event[0] === "enter" ? "start" : "end";
    return event[1][side];
  }
  const tasklistCheck = {
    tokenize: tokenizeTasklistCheck
  };
  const gfmTaskListItem = {
    text: {
      [91]: tasklistCheck
    }
  };
  function tokenizeTasklistCheck(effects, ok2, nok) {
    const self2 = this;
    return open;
    function open(code2) {
      if (
        // Exit if there’s stuff before.
        self2.previous !== null || // Exit if not in the first content that is the first child of a list
        // item.
        !self2._gfmTasklistFirstContentOfListItem
      ) {
        return nok(code2);
      }
      effects.enter("taskListCheck");
      effects.enter("taskListCheckMarker");
      effects.consume(code2);
      effects.exit("taskListCheckMarker");
      return inside;
    }
    function inside(code2) {
      if (markdownLineEndingOrSpace(code2)) {
        effects.enter("taskListCheckValueUnchecked");
        effects.consume(code2);
        effects.exit("taskListCheckValueUnchecked");
        return close2;
      }
      if (code2 === 88 || code2 === 120) {
        effects.enter("taskListCheckValueChecked");
        effects.consume(code2);
        effects.exit("taskListCheckValueChecked");
        return close2;
      }
      return nok(code2);
    }
    function close2(code2) {
      if (code2 === 93) {
        effects.enter("taskListCheckMarker");
        effects.consume(code2);
        effects.exit("taskListCheckMarker");
        effects.exit("taskListCheck");
        return after;
      }
      return nok(code2);
    }
    function after(code2) {
      if (markdownLineEnding(code2)) {
        return ok2(code2);
      }
      if (markdownSpace(code2)) {
        return effects.check(
          {
            tokenize: spaceThenNonSpace
          },
          ok2,
          nok
        )(code2);
      }
      return nok(code2);
    }
  }
  function spaceThenNonSpace(effects, ok2, nok) {
    return factorySpace(effects, after, "whitespace");
    function after(code2) {
      return code2 === null ? nok(code2) : ok2(code2);
    }
  }
  function gfm(options) {
    return combineExtensions([
      gfmAutolinkLiteral,
      gfmFootnote(),
      gfmStrikethrough(options),
      gfmTable,
      gfmTaskListItem
    ]);
  }
  function escapeStringRegexp(string2) {
    if (typeof string2 !== "string") {
      throw new TypeError("Expected a string");
    }
    return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }
  const convert$4 = (
    /**
     * @type {(
     *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
     *   ((test?: Test) => AssertAnything)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */
    function(test) {
      if (test === void 0 || test === null) {
        return ok$4;
      }
      if (typeof test === "string") {
        return typeFactory$4(test);
      }
      if (typeof test === "object") {
        return Array.isArray(test) ? anyFactory$6(test) : propsFactory$4(test);
      }
      if (typeof test === "function") {
        return castFactory$6(test);
      }
      throw new Error("Expected function, string, or object as test");
    }
  );
  function anyFactory$6(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convert$4(tests[index2]);
    }
    return castFactory$6(any2);
    function any2(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].call(this, ...parameters))
          return true;
      }
      return false;
    }
  }
  function propsFactory$4(check) {
    return castFactory$6(all2);
    function all2(node2) {
      let key2;
      for (key2 in check) {
        if (node2[key2] !== check[key2])
          return false;
      }
      return true;
    }
  }
  function typeFactory$4(check) {
    return castFactory$6(type);
    function type(node2) {
      return node2 && node2.type === check;
    }
  }
  function castFactory$6(check) {
    return assertion;
    function assertion(node2, ...parameters) {
      return Boolean(
        node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
        Boolean(check.call(this, node2, ...parameters))
      );
    }
  }
  function ok$4() {
    return true;
  }
  function color$1(d) {
    return d;
  }
  const CONTINUE$1 = true;
  const EXIT$1 = false;
  const SKIP$1 = "skip";
  const visitParents$1 = (
    /**
     * @type {(
     *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
     *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
     * )}
     */
    /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor<Node>} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */
    function(tree, test, visitor, reverse) {
      if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
      }
      const is = convert$4(test);
      const step = reverse ? -1 : 1;
      factory(tree, void 0, [])();
      function factory(node2, index2, parents) {
        const value = node2 && typeof node2 === "object" ? node2 : {};
        if (typeof value.type === "string") {
          const name = (
            // `hast`
            typeof value.tagName === "string" ? value.tagName : (
              // `xast`
              typeof value.name === "string" ? value.name : void 0
            )
          );
          Object.defineProperty(visit2, "name", {
            value: "node (" + color$1(node2.type + (name ? "<" + name + ">" : "")) + ")"
          });
        }
        return visit2;
        function visit2() {
          let result = [];
          let subresult;
          let offset;
          let grandparents;
          if (!test || is(node2, index2, parents[parents.length - 1] || null)) {
            result = toResult$1(visitor(node2, parents));
            if (result[0] === EXIT$1) {
              return result;
            }
          }
          if (node2.children && result[0] !== SKIP$1) {
            offset = (reverse ? node2.children.length : -1) + step;
            grandparents = parents.concat(node2);
            while (offset > -1 && offset < node2.children.length) {
              subresult = factory(node2.children[offset], offset, grandparents)();
              if (subresult[0] === EXIT$1) {
                return subresult;
              }
              offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
            }
          }
          return result;
        }
      }
    }
  );
  function toResult$1(value) {
    if (Array.isArray(value)) {
      return value;
    }
    if (typeof value === "number") {
      return [CONTINUE$1, value];
    }
    return [value];
  }
  const own$5 = {}.hasOwnProperty;
  const findAndReplace = (
    /**
     * @type {(
     *   (<Tree extends Node>(tree: Tree, find: Find, replace?: Replace | null | undefined, options?: Options | null | undefined) => Tree) &
     *   (<Tree extends Node>(tree: Tree, schema: FindAndReplaceSchema | FindAndReplaceList, options?: Options | null | undefined) => Tree)
     * )}
     **/
    /**
     * @template {Node} Tree
     * @param {Tree} tree
     * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find
     * @param {Replace | Options | null | undefined} [replace]
     * @param {Options | null | undefined} [options]
     * @returns {Tree}
     */
    function(tree, find2, replace2, options) {
      let settings;
      let schema;
      if (typeof find2 === "string" || find2 instanceof RegExp) {
        schema = [[find2, replace2]];
        settings = options;
      } else {
        schema = find2;
        settings = replace2;
      }
      if (!settings) {
        settings = {};
      }
      const ignored = convert$4(settings.ignore || []);
      const pairs = toPairs(schema);
      let pairIndex = -1;
      while (++pairIndex < pairs.length) {
        visitParents$1(tree, "text", visitor);
      }
      return tree;
      function visitor(node2, parents) {
        let index2 = -1;
        let grandparent;
        while (++index2 < parents.length) {
          const parent = parents[index2];
          if (ignored(
            parent,
            // @ts-expect-error: TS doesn’t understand but it’s perfect.
            grandparent ? grandparent.children.indexOf(parent) : void 0,
            grandparent
          )) {
            return;
          }
          grandparent = parent;
        }
        if (grandparent) {
          return handler(node2, parents);
        }
      }
      function handler(node2, parents) {
        const parent = parents[parents.length - 1];
        const find3 = pairs[pairIndex][0];
        const replace3 = pairs[pairIndex][1];
        let start = 0;
        const index2 = parent.children.indexOf(node2);
        let change = false;
        let nodes = [];
        find3.lastIndex = 0;
        let match = find3.exec(node2.value);
        while (match) {
          const position2 = match.index;
          const matchObject = {
            index: match.index,
            input: match.input,
            // @ts-expect-error: stack is fine.
            stack: [...parents, node2]
          };
          let value = replace3(...match, matchObject);
          if (typeof value === "string") {
            value = value.length > 0 ? { type: "text", value } : void 0;
          }
          if (value !== false) {
            if (start !== position2) {
              nodes.push({
                type: "text",
                value: node2.value.slice(start, position2)
              });
            }
            if (Array.isArray(value)) {
              nodes.push(...value);
            } else if (value) {
              nodes.push(value);
            }
            start = position2 + match[0].length;
            change = true;
          }
          if (!find3.global) {
            break;
          }
          match = find3.exec(node2.value);
        }
        if (change) {
          if (start < node2.value.length) {
            nodes.push({ type: "text", value: node2.value.slice(start) });
          }
          parent.children.splice(index2, 1, ...nodes);
        } else {
          nodes = [node2];
        }
        return index2 + nodes.length;
      }
    }
  );
  function toPairs(schema) {
    const result = [];
    if (typeof schema !== "object") {
      throw new TypeError("Expected array or object as schema");
    }
    if (Array.isArray(schema)) {
      let index2 = -1;
      while (++index2 < schema.length) {
        result.push([
          toExpression(schema[index2][0]),
          toFunction(schema[index2][1])
        ]);
      }
    } else {
      let key2;
      for (key2 in schema) {
        if (own$5.call(schema, key2)) {
          result.push([toExpression(key2), toFunction(schema[key2])]);
        }
      }
    }
    return result;
  }
  function toExpression(find2) {
    return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
  }
  function toFunction(replace2) {
    return typeof replace2 === "function" ? replace2 : () => replace2;
  }
  const inConstruct = "phrasing";
  const notInConstruct = ["autolink", "link", "image", "label"];
  const gfmAutolinkLiteralFromMarkdown = {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    }
  };
  const gfmAutolinkLiteralToMarkdown = {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      { character: ":", before: "[ps]", after: "\\/", inConstruct, notInConstruct }
    ]
  };
  function enterLiteralAutolink(token) {
    this.enter({ type: "link", title: null, url: "", children: [] }, token);
  }
  function enterLiteralAutolinkValue(token) {
    this.config.enter.autolinkProtocol.call(this, token);
  }
  function exitLiteralAutolinkHttp(token) {
    this.config.exit.autolinkProtocol.call(this, token);
  }
  function exitLiteralAutolinkWww(token) {
    this.config.exit.data.call(this, token);
    const node2 = (
      /** @type {Link} */
      this.stack[this.stack.length - 1]
    );
    node2.url = "http://" + this.sliceSerialize(token);
  }
  function exitLiteralAutolinkEmail(token) {
    this.config.exit.autolinkEmail.call(this, token);
  }
  function exitLiteralAutolink(token) {
    this.exit(token);
  }
  function transformGfmAutolinkLiterals(tree) {
    findAndReplace(
      tree,
      [
        [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
        [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
      ],
      { ignore: ["link", "linkReference"] }
    );
  }
  function findUrl(_, protocol, domain2, path2, match) {
    let prefix2 = "";
    if (!previous(match)) {
      return false;
    }
    if (/^w/i.test(protocol)) {
      domain2 = protocol + domain2;
      protocol = "";
      prefix2 = "http://";
    }
    if (!isCorrectDomain(domain2)) {
      return false;
    }
    const parts = splitUrl(domain2 + path2);
    if (!parts[0])
      return false;
    const result = {
      type: "link",
      title: null,
      url: prefix2 + protocol + parts[0],
      children: [{ type: "text", value: protocol + parts[0] }]
    };
    if (parts[1]) {
      return [result, { type: "text", value: parts[1] }];
    }
    return result;
  }
  function findEmail(_, atext, label, match) {
    if (
      // Not an expected previous character.
      !previous(match, true) || // Label ends in not allowed character.
      /[-\d_]$/.test(label)
    ) {
      return false;
    }
    return {
      type: "link",
      title: null,
      url: "mailto:" + atext + "@" + label,
      children: [{ type: "text", value: atext + "@" + label }]
    };
  }
  function isCorrectDomain(domain2) {
    const parts = domain2.split(".");
    if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
      return false;
    }
    return true;
  }
  function splitUrl(url) {
    const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
    if (!trailExec) {
      return [url, void 0];
    }
    url = url.slice(0, trailExec.index);
    let trail2 = trailExec[0];
    let closingParenIndex = trail2.indexOf(")");
    const openingParens = ccount(url, "(");
    let closingParens = ccount(url, ")");
    while (closingParenIndex !== -1 && openingParens > closingParens) {
      url += trail2.slice(0, closingParenIndex + 1);
      trail2 = trail2.slice(closingParenIndex + 1);
      closingParenIndex = trail2.indexOf(")");
      closingParens++;
    }
    return [url, trail2];
  }
  function previous(match, email) {
    const code2 = match.input.charCodeAt(match.index - 1);
    return (match.index === 0 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && (!email || code2 !== 47);
  }
  function decodeNumericCharacterReference(value, base2) {
    const code2 = Number.parseInt(value, base2);
    if (
      // C0 except for HT, LF, FF, CR, space.
      code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of C0, and C1 controls.
      code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
      code2 > 55295 && code2 < 57344 || // Noncharacters.
      code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || // Out of range
      code2 > 1114111
    ) {
      return "�";
    }
    return String.fromCharCode(code2);
  }
  const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
  function decodeString(value) {
    return value.replace(characterEscapeOrReference, decode);
  }
  function decode($0, $1, $2) {
    if ($1) {
      return $1;
    }
    const head2 = $2.charCodeAt(0);
    if (head2 === 35) {
      const head3 = $2.charCodeAt(1);
      const hex = head3 === 120 || head3 === 88;
      return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
    }
    return decodeNamedCharacterReference($2) || $0;
  }
  function association(node2) {
    if (node2.label || !node2.identifier) {
      return node2.label || "";
    }
    return decodeString(node2.identifier);
  }
  function containerFlow(parent, state, info) {
    const indexStack = state.indexStack;
    const children = parent.children || [];
    const tracker = state.createTracker(info);
    const results = [];
    let index2 = -1;
    indexStack.push(-1);
    while (++index2 < children.length) {
      const child = children[index2];
      indexStack[indexStack.length - 1] = index2;
      results.push(
        tracker.move(
          state.handle(child, parent, state, {
            before: "\n",
            after: "\n",
            ...tracker.current()
          })
        )
      );
      if (child.type !== "list") {
        state.bulletLastUsed = void 0;
      }
      if (index2 < children.length - 1) {
        results.push(
          tracker.move(between(child, children[index2 + 1], parent, state))
        );
      }
    }
    indexStack.pop();
    return results.join("");
  }
  function between(left, right, parent, state) {
    let index2 = state.join.length;
    while (index2--) {
      const result = state.join[index2](left, right, parent, state);
      if (result === true || result === 1) {
        break;
      }
      if (typeof result === "number") {
        return "\n".repeat(1 + result);
      }
      if (result === false) {
        return "\n\n<!---->\n\n";
      }
    }
    return "\n\n";
  }
  const eol = /\r?\n|\r/g;
  function indentLines(value, map2) {
    const result = [];
    let start = 0;
    let line = 0;
    let match;
    while (match = eol.exec(value)) {
      one2(value.slice(start, match.index));
      result.push(match[0]);
      start = match.index + match[0].length;
      line++;
    }
    one2(value.slice(start));
    return result.join("");
    function one2(value2) {
      result.push(map2(value2, line, !value2));
    }
  }
  function patternCompile(pattern) {
    if (!pattern._compiled) {
      const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
      pattern._compiled = new RegExp(
        (before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""),
        "g"
      );
    }
    return pattern._compiled;
  }
  function patternInScope(stack, pattern) {
    return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
  }
  function listInScope(stack, list2, none2) {
    if (typeof list2 === "string") {
      list2 = [list2];
    }
    if (!list2 || list2.length === 0) {
      return none2;
    }
    let index2 = -1;
    while (++index2 < list2.length) {
      if (stack.includes(list2[index2])) {
        return true;
      }
    }
    return false;
  }
  function safe(state, input2, config) {
    const value = (config.before || "") + (input2 || "") + (config.after || "");
    const positions = [];
    const result = [];
    const infos = {};
    let index2 = -1;
    while (++index2 < state.unsafe.length) {
      const pattern = state.unsafe[index2];
      if (!patternInScope(state.stack, pattern)) {
        continue;
      }
      const expression = patternCompile(pattern);
      let match;
      while (match = expression.exec(value)) {
        const before = "before" in pattern || Boolean(pattern.atBreak);
        const after = "after" in pattern;
        const position2 = match.index + (before ? match[1].length : 0);
        if (positions.includes(position2)) {
          if (infos[position2].before && !before) {
            infos[position2].before = false;
          }
          if (infos[position2].after && !after) {
            infos[position2].after = false;
          }
        } else {
          positions.push(position2);
          infos[position2] = { before, after };
        }
      }
    }
    positions.sort(numerical);
    let start = config.before ? config.before.length : 0;
    const end = value.length - (config.after ? config.after.length : 0);
    index2 = -1;
    while (++index2 < positions.length) {
      const position2 = positions[index2];
      if (position2 < start || position2 >= end) {
        continue;
      }
      if (position2 + 1 < end && positions[index2 + 1] === position2 + 1 && infos[position2].after && !infos[position2 + 1].before && !infos[position2 + 1].after || positions[index2 - 1] === position2 - 1 && infos[position2].before && !infos[position2 - 1].before && !infos[position2 - 1].after) {
        continue;
      }
      if (start !== position2) {
        result.push(escapeBackslashes(value.slice(start, position2), "\\"));
      }
      start = position2;
      if (/[!-/:-@[-`{-~]/.test(value.charAt(position2)) && (!config.encode || !config.encode.includes(value.charAt(position2)))) {
        result.push("\\");
      } else {
        result.push(
          "&#x" + value.charCodeAt(position2).toString(16).toUpperCase() + ";"
        );
        start++;
      }
    }
    result.push(escapeBackslashes(value.slice(start, end), config.after));
    return result.join("");
  }
  function numerical(a2, b) {
    return a2 - b;
  }
  function escapeBackslashes(value, after) {
    const expression = /\\(?=[!-/:-@[-`{-~])/g;
    const positions = [];
    const results = [];
    const whole = value + after;
    let index2 = -1;
    let start = 0;
    let match;
    while (match = expression.exec(whole)) {
      positions.push(match.index);
    }
    while (++index2 < positions.length) {
      if (start !== positions[index2]) {
        results.push(value.slice(start, positions[index2]));
      }
      results.push("\\");
      start = positions[index2];
    }
    results.push(value.slice(start));
    return results.join("");
  }
  function track(config) {
    const options = config || {};
    const now = options.now || {};
    let lineShift = options.lineShift || 0;
    let line = now.line || 1;
    let column = now.column || 1;
    return { move, current, shift: shift2 };
    function current() {
      return { now: { line, column }, lineShift };
    }
    function shift2(value) {
      lineShift += value;
    }
    function move(input2) {
      const value = input2 || "";
      const chunks = value.split(/\r?\n|\r/g);
      const tail = chunks[chunks.length - 1];
      line += chunks.length - 1;
      column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
      return value;
    }
  }
  footnoteReference$1.peek = footnoteReferencePeek;
  function gfmFootnoteFromMarkdown() {
    return {
      enter: {
        gfmFootnoteDefinition: enterFootnoteDefinition,
        gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
        gfmFootnoteCall: enterFootnoteCall,
        gfmFootnoteCallString: enterFootnoteCallString
      },
      exit: {
        gfmFootnoteDefinition: exitFootnoteDefinition,
        gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
        gfmFootnoteCall: exitFootnoteCall,
        gfmFootnoteCallString: exitFootnoteCallString
      }
    };
  }
  function gfmFootnoteToMarkdown() {
    return {
      // This is on by default already.
      unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
      handlers: { footnoteDefinition, footnoteReference: footnoteReference$1 }
    };
  }
  function enterFootnoteDefinition(token) {
    this.enter(
      { type: "footnoteDefinition", identifier: "", label: "", children: [] },
      token
    );
  }
  function enterFootnoteDefinitionLabelString() {
    this.buffer();
  }
  function exitFootnoteDefinitionLabelString(token) {
    const label = this.resume();
    const node2 = (
      /** @type {FootnoteDefinition} */
      this.stack[this.stack.length - 1]
    );
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  function exitFootnoteDefinition(token) {
    this.exit(token);
  }
  function enterFootnoteCall(token) {
    this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
  }
  function enterFootnoteCallString() {
    this.buffer();
  }
  function exitFootnoteCallString(token) {
    const label = this.resume();
    const node2 = (
      /** @type {FootnoteDefinition} */
      this.stack[this.stack.length - 1]
    );
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  function exitFootnoteCall(token) {
    this.exit(token);
  }
  function footnoteReference$1(node2, _, context, safeOptions) {
    const tracker = track(safeOptions);
    let value = tracker.move("[^");
    const exit2 = context.enter("footnoteReference");
    const subexit = context.enter("reference");
    value += tracker.move(
      safe(context, association(node2), {
        ...tracker.current(),
        before: value,
        after: "]"
      })
    );
    subexit();
    exit2();
    value += tracker.move("]");
    return value;
  }
  function footnoteReferencePeek() {
    return "[";
  }
  function footnoteDefinition(node2, _, context, safeOptions) {
    const tracker = track(safeOptions);
    let value = tracker.move("[^");
    const exit2 = context.enter("footnoteDefinition");
    const subexit = context.enter("label");
    value += tracker.move(
      safe(context, association(node2), {
        ...tracker.current(),
        before: value,
        after: "]"
      })
    );
    subexit();
    value += tracker.move(
      "]:" + (node2.children && node2.children.length > 0 ? " " : "")
    );
    tracker.shift(4);
    value += tracker.move(
      indentLines(containerFlow(node2, context, tracker.current()), map$3)
    );
    exit2();
    return value;
  }
  function map$3(line, index2, blank) {
    if (index2 === 0) {
      return line;
    }
    return (blank ? "" : "    ") + line;
  }
  function containerPhrasing(parent, state, info) {
    const indexStack = state.indexStack;
    const children = parent.children || [];
    const results = [];
    let index2 = -1;
    let before = info.before;
    indexStack.push(-1);
    let tracker = state.createTracker(info);
    while (++index2 < children.length) {
      const child = children[index2];
      let after;
      indexStack[indexStack.length - 1] = index2;
      if (index2 + 1 < children.length) {
        let handle2 = state.handle.handlers[children[index2 + 1].type];
        if (handle2 && handle2.peek)
          handle2 = handle2.peek;
        after = handle2 ? handle2(children[index2 + 1], parent, state, {
          before: "",
          after: "",
          ...tracker.current()
        }).charAt(0) : "";
      } else {
        after = info.after;
      }
      if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
        results[results.length - 1] = results[results.length - 1].replace(
          /(\r?\n|\r)$/,
          " "
        );
        before = " ";
        tracker = state.createTracker(info);
        tracker.move(results.join(""));
      }
      results.push(
        tracker.move(
          state.handle(child, parent, state, {
            ...tracker.current(),
            before,
            after
          })
        )
      );
      before = results[results.length - 1].slice(-1);
    }
    indexStack.pop();
    return results.join("");
  }
  const constructsWithoutStrikethrough = [
    "autolink",
    "destinationLiteral",
    "destinationRaw",
    "reference",
    "titleQuote",
    "titleApostrophe"
  ];
  handleDelete.peek = peekDelete;
  const gfmStrikethroughFromMarkdown = {
    canContainEols: ["delete"],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough }
  };
  const gfmStrikethroughToMarkdown = {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: constructsWithoutStrikethrough
      }
    ],
    handlers: { delete: handleDelete }
  };
  function enterStrikethrough(token) {
    this.enter({ type: "delete", children: [] }, token);
  }
  function exitStrikethrough(token) {
    this.exit(token);
  }
  function handleDelete(node2, _, context, safeOptions) {
    const tracker = track(safeOptions);
    const exit2 = context.enter("strikethrough");
    let value = tracker.move("~~");
    value += containerPhrasing(node2, context, {
      ...tracker.current(),
      before: value,
      after: "~"
    });
    value += tracker.move("~~");
    exit2();
    return value;
  }
  function peekDelete() {
    return "~";
  }
  inlineCode$2.peek = inlineCodePeek;
  function inlineCode$2(node2, _, state) {
    let value = node2.value || "";
    let sequence = "`";
    let index2 = -1;
    while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
      sequence += "`";
    }
    if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
      value = " " + value + " ";
    }
    while (++index2 < state.unsafe.length) {
      const pattern = state.unsafe[index2];
      const expression = patternCompile(pattern);
      let match;
      if (!pattern.atBreak)
        continue;
      while (match = expression.exec(value)) {
        let position2 = match.index;
        if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
          position2--;
        }
        value = value.slice(0, position2) + " " + value.slice(match.index + 1);
      }
    }
    return sequence + value + sequence;
  }
  function inlineCodePeek() {
    return "`";
  }
  function markdownTable(table2, options = {}) {
    const align = (options.align || []).concat();
    const stringLength = options.stringLength || defaultStringLength;
    const alignments = [];
    const cellMatrix = [];
    const sizeMatrix = [];
    const longestCellByColumn = [];
    let mostCellsPerRow = 0;
    let rowIndex = -1;
    while (++rowIndex < table2.length) {
      const row3 = [];
      const sizes2 = [];
      let columnIndex2 = -1;
      if (table2[rowIndex].length > mostCellsPerRow) {
        mostCellsPerRow = table2[rowIndex].length;
      }
      while (++columnIndex2 < table2[rowIndex].length) {
        const cell2 = serialize(table2[rowIndex][columnIndex2]);
        if (options.alignDelimiters !== false) {
          const size = stringLength(cell2);
          sizes2[columnIndex2] = size;
          if (longestCellByColumn[columnIndex2] === void 0 || size > longestCellByColumn[columnIndex2]) {
            longestCellByColumn[columnIndex2] = size;
          }
        }
        row3.push(cell2);
      }
      cellMatrix[rowIndex] = row3;
      sizeMatrix[rowIndex] = sizes2;
    }
    let columnIndex = -1;
    if (typeof align === "object" && "length" in align) {
      while (++columnIndex < mostCellsPerRow) {
        alignments[columnIndex] = toAlignment(align[columnIndex]);
      }
    } else {
      const code2 = toAlignment(align);
      while (++columnIndex < mostCellsPerRow) {
        alignments[columnIndex] = code2;
      }
    }
    columnIndex = -1;
    const row2 = [];
    const sizes = [];
    while (++columnIndex < mostCellsPerRow) {
      const code2 = alignments[columnIndex];
      let before = "";
      let after = "";
      if (code2 === 99) {
        before = ":";
        after = ":";
      } else if (code2 === 108) {
        before = ":";
      } else if (code2 === 114) {
        after = ":";
      }
      let size = options.alignDelimiters === false ? 1 : Math.max(
        1,
        longestCellByColumn[columnIndex] - before.length - after.length
      );
      const cell2 = before + "-".repeat(size) + after;
      if (options.alignDelimiters !== false) {
        size = before.length + size + after.length;
        if (size > longestCellByColumn[columnIndex]) {
          longestCellByColumn[columnIndex] = size;
        }
        sizes[columnIndex] = size;
      }
      row2[columnIndex] = cell2;
    }
    cellMatrix.splice(1, 0, row2);
    sizeMatrix.splice(1, 0, sizes);
    rowIndex = -1;
    const lines = [];
    while (++rowIndex < cellMatrix.length) {
      const row3 = cellMatrix[rowIndex];
      const sizes2 = sizeMatrix[rowIndex];
      columnIndex = -1;
      const line = [];
      while (++columnIndex < mostCellsPerRow) {
        const cell2 = row3[columnIndex] || "";
        let before = "";
        let after = "";
        if (options.alignDelimiters !== false) {
          const size = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
          const code2 = alignments[columnIndex];
          if (code2 === 114) {
            before = " ".repeat(size);
          } else if (code2 === 99) {
            if (size % 2) {
              before = " ".repeat(size / 2 + 0.5);
              after = " ".repeat(size / 2 - 0.5);
            } else {
              before = " ".repeat(size / 2);
              after = before;
            }
          } else {
            after = " ".repeat(size);
          }
        }
        if (options.delimiterStart !== false && !columnIndex) {
          line.push("|");
        }
        if (options.padding !== false && // Don’t add the opening space if we’re not aligning and the cell is
        // empty: there will be a closing space.
        !(options.alignDelimiters === false && cell2 === "") && (options.delimiterStart !== false || columnIndex)) {
          line.push(" ");
        }
        if (options.alignDelimiters !== false) {
          line.push(before);
        }
        line.push(cell2);
        if (options.alignDelimiters !== false) {
          line.push(after);
        }
        if (options.padding !== false) {
          line.push(" ");
        }
        if (options.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
          line.push("|");
        }
      }
      lines.push(
        options.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
      );
    }
    return lines.join("\n");
  }
  function serialize(value) {
    return value === null || value === void 0 ? "" : String(value);
  }
  function defaultStringLength(value) {
    return value.length;
  }
  function toAlignment(value) {
    const code2 = typeof value === "string" ? value.codePointAt(0) : 0;
    return code2 === 67 || code2 === 99 ? 99 : code2 === 76 || code2 === 108 ? 108 : code2 === 82 || code2 === 114 ? 114 : 0;
  }
  const gfmTableFromMarkdown = {
    enter: {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    },
    exit: {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit,
      tableHeader: exit,
      tableRow: exit
    }
  };
  function enterTable(token) {
    const align = token._align;
    this.enter(
      {
        type: "table",
        align: align.map((d) => d === "none" ? null : d),
        children: []
      },
      token
    );
    this.setData("inTable", true);
  }
  function exitTable(token) {
    this.exit(token);
    this.setData("inTable");
  }
  function enterRow(token) {
    this.enter({ type: "tableRow", children: [] }, token);
  }
  function exit(token) {
    this.exit(token);
  }
  function enterCell(token) {
    this.enter({ type: "tableCell", children: [] }, token);
  }
  function exitCodeText(token) {
    let value = this.resume();
    if (this.getData("inTable")) {
      value = value.replace(/\\([\\|])/g, replace);
    }
    const node2 = (
      /** @type {InlineCode} */
      this.stack[this.stack.length - 1]
    );
    node2.value = value;
    this.exit(token);
  }
  function replace($0, $1) {
    return $1 === "|" ? $1 : $0;
  }
  function gfmTableToMarkdown(options) {
    const settings = options || {};
    const padding = settings.tableCellPadding;
    const alignDelimiters = settings.tablePipeAlign;
    const stringLength = settings.stringLength;
    const around = padding ? " " : "|";
    return {
      unsafe: [
        { character: "\r", inConstruct: "tableCell" },
        { character: "\n", inConstruct: "tableCell" },
        // A pipe, when followed by a tab or space (padding), or a dash or colon
        // (unpadded delimiter row), could result in a table.
        { atBreak: true, character: "|", after: "[	 :-]" },
        // A pipe in a cell must be encoded.
        { character: "|", inConstruct: "tableCell" },
        // A colon must be followed by a dash, in which case it could start a
        // delimiter row.
        { atBreak: true, character: ":", after: "-" },
        // A delimiter row can also start with a dash, when followed by more
        // dashes, a colon, or a pipe.
        // This is a stricter version than the built in check for lists, thematic
        // breaks, and setex heading underlines though:
        // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
        { atBreak: true, character: "-", after: "[:|-]" }
      ],
      handlers: {
        table: handleTable,
        tableRow: handleTableRow,
        tableCell: handleTableCell,
        inlineCode: inlineCodeWithTable
      }
    };
    function handleTable(node2, _, context, safeOptions) {
      return serializeData(
        handleTableAsData(node2, context, safeOptions),
        node2.align
      );
    }
    function handleTableRow(node2, _, context, safeOptions) {
      const row2 = handleTableRowAsData(node2, context, safeOptions);
      const value = serializeData([row2]);
      return value.slice(0, value.indexOf("\n"));
    }
    function handleTableCell(node2, _, context, safeOptions) {
      const exit2 = context.enter("tableCell");
      const subexit = context.enter("phrasing");
      const value = containerPhrasing(node2, context, {
        ...safeOptions,
        before: around,
        after: around
      });
      subexit();
      exit2();
      return value;
    }
    function serializeData(matrix, align) {
      return markdownTable(matrix, {
        align,
        // @ts-expect-error: `markdown-table` types should support `null`.
        alignDelimiters,
        // @ts-expect-error: `markdown-table` types should support `null`.
        padding,
        // @ts-expect-error: `markdown-table` types should support `null`.
        stringLength
      });
    }
    function handleTableAsData(node2, context, safeOptions) {
      const children = node2.children;
      let index2 = -1;
      const result = [];
      const subexit = context.enter("table");
      while (++index2 < children.length) {
        result[index2] = handleTableRowAsData(
          children[index2],
          context,
          safeOptions
        );
      }
      subexit();
      return result;
    }
    function handleTableRowAsData(node2, context, safeOptions) {
      const children = node2.children;
      let index2 = -1;
      const result = [];
      const subexit = context.enter("tableRow");
      while (++index2 < children.length) {
        result[index2] = handleTableCell(
          children[index2],
          node2,
          context,
          safeOptions
        );
      }
      subexit();
      return result;
    }
    function inlineCodeWithTable(node2, parent, context) {
      let value = inlineCode$2(node2, parent, context);
      if (context.stack.includes("tableCell")) {
        value = value.replace(/\|/g, "\\$&");
      }
      return value;
    }
  }
  function checkBullet(state) {
    const marker = state.options.bullet || "*";
    if (marker !== "*" && marker !== "+" && marker !== "-") {
      throw new Error(
        "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
      );
    }
    return marker;
  }
  function checkListItemIndent(state) {
    const style2 = state.options.listItemIndent || "tab";
    if (style2 === 1 || style2 === "1") {
      return "one";
    }
    if (style2 !== "tab" && style2 !== "one" && style2 !== "mixed") {
      throw new Error(
        "Cannot serialize items with `" + style2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
      );
    }
    return style2;
  }
  function listItem$1(node2, parent, state, info) {
    const listItemIndent = checkListItemIndent(state);
    let bullet = state.bulletCurrent || checkBullet(state);
    if (parent && parent.type === "list" && parent.ordered) {
      bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
    }
    let size = bullet.length + 1;
    if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
      size = Math.ceil(size / 4) * 4;
    }
    const tracker = state.createTracker(info);
    tracker.move(bullet + " ".repeat(size - bullet.length));
    tracker.shift(size);
    const exit2 = state.enter("listItem");
    const value = state.indentLines(
      state.containerFlow(node2, tracker.current()),
      map2
    );
    exit2();
    return value;
    function map2(line, index2, blank) {
      if (index2) {
        return (blank ? "" : " ".repeat(size)) + line;
      }
      return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
    }
  }
  const gfmTaskListItemFromMarkdown = {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
  };
  const gfmTaskListItemToMarkdown = {
    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
    handlers: { listItem: listItemWithTaskListItem }
  };
  function exitCheck(token) {
    const node2 = (
      /** @type {ListItem} */
      this.stack[this.stack.length - 2]
    );
    node2.checked = token.type === "taskListCheckValueChecked";
  }
  function exitParagraphWithTaskListItem(token) {
    const parent = (
      /** @type {Parents} */
      this.stack[this.stack.length - 2]
    );
    if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
      const node2 = (
        /** @type {Paragraph} */
        this.stack[this.stack.length - 1]
      );
      const head2 = node2.children[0];
      if (head2 && head2.type === "text") {
        const siblings2 = parent.children;
        let index2 = -1;
        let firstParaghraph;
        while (++index2 < siblings2.length) {
          const sibling = siblings2[index2];
          if (sibling.type === "paragraph") {
            firstParaghraph = sibling;
            break;
          }
        }
        if (firstParaghraph === node2) {
          head2.value = head2.value.slice(1);
          if (head2.value.length === 0) {
            node2.children.shift();
          } else if (node2.position && head2.position && typeof head2.position.start.offset === "number") {
            head2.position.start.column++;
            head2.position.start.offset++;
            node2.position.start = Object.assign({}, head2.position.start);
          }
        }
      }
    }
    this.exit(token);
  }
  function listItemWithTaskListItem(node2, parent, context, safeOptions) {
    const head2 = node2.children[0];
    const checkable = typeof node2.checked === "boolean" && head2 && head2.type === "paragraph";
    const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
    const tracker = track(safeOptions);
    if (checkable) {
      tracker.move(checkbox);
    }
    let value = listItem$1(node2, parent, context, {
      ...safeOptions,
      ...tracker.current()
    });
    if (checkable) {
      value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
    }
    return value;
    function check($0) {
      return $0 + checkbox;
    }
  }
  function gfmFromMarkdown() {
    return [
      gfmAutolinkLiteralFromMarkdown,
      gfmFootnoteFromMarkdown(),
      gfmStrikethroughFromMarkdown,
      gfmTableFromMarkdown,
      gfmTaskListItemFromMarkdown
    ];
  }
  function gfmToMarkdown(options) {
    return {
      extensions: [
        gfmAutolinkLiteralToMarkdown,
        gfmFootnoteToMarkdown(),
        gfmStrikethroughToMarkdown,
        gfmTableToMarkdown(options),
        gfmTaskListItemToMarkdown
      ]
    };
  }
  function remarkGfm(options = {}) {
    const data = this.data();
    add("micromarkExtensions", gfm(options));
    add("fromMarkdownExtensions", gfmFromMarkdown());
    add("toMarkdownExtensions", gfmToMarkdown(options));
    function add(field, value) {
      const list2 = (
        /** @type {unknown[]} */
        // Other extensions
        /* c8 ignore next 2 */
        data[field] ? data[field] : data[field] = []
      );
      list2.push(value);
    }
  }
  const emptyOptions = {};
  function toString(value, options) {
    const settings = options || emptyOptions;
    const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
    const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
    return one$2(value, includeImageAlt, includeHtml);
  }
  function one$2(value, includeImageAlt, includeHtml) {
    if (node$1(value)) {
      if ("value" in value) {
        return value.type === "html" && !includeHtml ? "" : value.value;
      }
      if (includeImageAlt && "alt" in value && value.alt) {
        return value.alt;
      }
      if ("children" in value) {
        return all$3(value.children, includeImageAlt, includeHtml);
      }
    }
    if (Array.isArray(value)) {
      return all$3(value, includeImageAlt, includeHtml);
    }
    return "";
  }
  function all$3(values, includeImageAlt, includeHtml) {
    const result = [];
    let index2 = -1;
    while (++index2 < values.length) {
      result[index2] = one$2(values[index2], includeImageAlt, includeHtml);
    }
    return result.join("");
  }
  function node$1(value) {
    return Boolean(value && typeof value === "object");
  }
  const content$2 = {
    tokenize: initializeContent
  };
  function initializeContent(effects) {
    const contentStart = effects.attempt(
      this.parser.constructs.contentInitial,
      afterContentStartConstruct,
      paragraphInitial
    );
    let previous2;
    return contentStart;
    function afterContentStartConstruct(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, contentStart, "linePrefix");
    }
    function paragraphInitial(code2) {
      effects.enter("paragraph");
      return lineStart(code2);
    }
    function lineStart(code2) {
      const token = effects.enter("chunkText", {
        contentType: "text",
        previous: previous2
      });
      if (previous2) {
        previous2.next = token;
      }
      previous2 = token;
      return data(code2);
    }
    function data(code2) {
      if (code2 === null) {
        effects.exit("chunkText");
        effects.exit("paragraph");
        effects.consume(code2);
        return;
      }
      if (markdownLineEnding(code2)) {
        effects.consume(code2);
        effects.exit("chunkText");
        return lineStart;
      }
      effects.consume(code2);
      return data;
    }
  }
  const document$2 = {
    tokenize: initializeDocument
  };
  const containerConstruct = {
    tokenize: tokenizeContainer
  };
  function initializeDocument(effects) {
    const self2 = this;
    const stack = [];
    let continued = 0;
    let childFlow;
    let childToken;
    let lineStartOffset;
    return start;
    function start(code2) {
      if (continued < stack.length) {
        const item = stack[continued];
        self2.containerState = item[1];
        return effects.attempt(
          item[0].continuation,
          documentContinue,
          checkNewContainers
        )(code2);
      }
      return checkNewContainers(code2);
    }
    function documentContinue(code2) {
      continued++;
      if (self2.containerState._closeFlow) {
        self2.containerState._closeFlow = void 0;
        if (childFlow) {
          closeFlow();
        }
        const indexBeforeExits = self2.events.length;
        let indexBeforeFlow = indexBeforeExits;
        let point2;
        while (indexBeforeFlow--) {
          if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
            point2 = self2.events[indexBeforeFlow][1].end;
            break;
          }
        }
        exitContainers(continued);
        let index2 = indexBeforeExits;
        while (index2 < self2.events.length) {
          self2.events[index2][1].end = Object.assign({}, point2);
          index2++;
        }
        splice(
          self2.events,
          indexBeforeFlow + 1,
          0,
          self2.events.slice(indexBeforeExits)
        );
        self2.events.length = index2;
        return checkNewContainers(code2);
      }
      return start(code2);
    }
    function checkNewContainers(code2) {
      if (continued === stack.length) {
        if (!childFlow) {
          return documentContinued(code2);
        }
        if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
          return flowStart(code2);
        }
        self2.interrupt = Boolean(
          childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
        );
      }
      self2.containerState = {};
      return effects.check(
        containerConstruct,
        thereIsANewContainer,
        thereIsNoNewContainer
      )(code2);
    }
    function thereIsANewContainer(code2) {
      if (childFlow)
        closeFlow();
      exitContainers(continued);
      return documentContinued(code2);
    }
    function thereIsNoNewContainer(code2) {
      self2.parser.lazy[self2.now().line] = continued !== stack.length;
      lineStartOffset = self2.now().offset;
      return flowStart(code2);
    }
    function documentContinued(code2) {
      self2.containerState = {};
      return effects.attempt(
        containerConstruct,
        containerContinue,
        flowStart
      )(code2);
    }
    function containerContinue(code2) {
      continued++;
      stack.push([self2.currentConstruct, self2.containerState]);
      return documentContinued(code2);
    }
    function flowStart(code2) {
      if (code2 === null) {
        if (childFlow)
          closeFlow();
        exitContainers(0);
        effects.consume(code2);
        return;
      }
      childFlow = childFlow || self2.parser.flow(self2.now());
      effects.enter("chunkFlow", {
        contentType: "flow",
        previous: childToken,
        _tokenizer: childFlow
      });
      return flowContinue(code2);
    }
    function flowContinue(code2) {
      if (code2 === null) {
        writeToChild(effects.exit("chunkFlow"), true);
        exitContainers(0);
        effects.consume(code2);
        return;
      }
      if (markdownLineEnding(code2)) {
        effects.consume(code2);
        writeToChild(effects.exit("chunkFlow"));
        continued = 0;
        self2.interrupt = void 0;
        return start;
      }
      effects.consume(code2);
      return flowContinue;
    }
    function writeToChild(token, eof) {
      const stream = self2.sliceStream(token);
      if (eof)
        stream.push(null);
      token.previous = childToken;
      if (childToken)
        childToken.next = token;
      childToken = token;
      childFlow.defineSkip(token.start);
      childFlow.write(stream);
      if (self2.parser.lazy[token.start.line]) {
        let index2 = childFlow.events.length;
        while (index2--) {
          if (
            // The token starts before the line ending…
            childFlow.events[index2][1].start.offset < lineStartOffset && // …and either is not ended yet…
            (!childFlow.events[index2][1].end || // …or ends after it.
            childFlow.events[index2][1].end.offset > lineStartOffset)
          ) {
            return;
          }
        }
        const indexBeforeExits = self2.events.length;
        let indexBeforeFlow = indexBeforeExits;
        let seen;
        let point2;
        while (indexBeforeFlow--) {
          if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
            if (seen) {
              point2 = self2.events[indexBeforeFlow][1].end;
              break;
            }
            seen = true;
          }
        }
        exitContainers(continued);
        index2 = indexBeforeExits;
        while (index2 < self2.events.length) {
          self2.events[index2][1].end = Object.assign({}, point2);
          index2++;
        }
        splice(
          self2.events,
          indexBeforeFlow + 1,
          0,
          self2.events.slice(indexBeforeExits)
        );
        self2.events.length = index2;
      }
    }
    function exitContainers(size) {
      let index2 = stack.length;
      while (index2-- > size) {
        const entry = stack[index2];
        self2.containerState = entry[1];
        entry[0].exit.call(self2, effects);
      }
      stack.length = size;
    }
    function closeFlow() {
      childFlow.write([null]);
      childToken = void 0;
      childFlow = void 0;
      self2.containerState._closeFlow = void 0;
    }
  }
  function tokenizeContainer(effects, ok2, nok) {
    return factorySpace(
      effects,
      effects.attempt(this.parser.constructs.document, ok2, nok),
      "linePrefix",
      this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    );
  }
  const flow$1 = {
    tokenize: initializeFlow
  };
  function initializeFlow(effects) {
    const self2 = this;
    const initial = effects.attempt(
      // Try to parse a blank line.
      blankLine,
      atBlankEnding,
      // Try to parse initial flow (essentially, only code).
      effects.attempt(
        this.parser.constructs.flowInitial,
        afterConstruct,
        factorySpace(
          effects,
          effects.attempt(
            this.parser.constructs.flow,
            afterConstruct,
            effects.attempt(content$3, afterConstruct)
          ),
          "linePrefix"
        )
      )
    );
    return initial;
    function atBlankEnding(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("lineEndingBlank");
      effects.consume(code2);
      effects.exit("lineEndingBlank");
      self2.currentConstruct = void 0;
      return initial;
    }
    function afterConstruct(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      self2.currentConstruct = void 0;
      return initial;
    }
  }
  const resolver = {
    resolveAll: createResolver()
  };
  const string$1 = initializeFactory("string");
  const text$4 = initializeFactory("text");
  function initializeFactory(field) {
    return {
      tokenize: initializeText,
      resolveAll: createResolver(
        field === "text" ? resolveAllLineSuffixes : void 0
      )
    };
    function initializeText(effects) {
      const self2 = this;
      const constructs2 = this.parser.constructs[field];
      const text2 = effects.attempt(constructs2, start, notText);
      return start;
      function start(code2) {
        return atBreak(code2) ? text2(code2) : notText(code2);
      }
      function notText(code2) {
        if (code2 === null) {
          effects.consume(code2);
          return;
        }
        effects.enter("data");
        effects.consume(code2);
        return data;
      }
      function data(code2) {
        if (atBreak(code2)) {
          effects.exit("data");
          return text2(code2);
        }
        effects.consume(code2);
        return data;
      }
      function atBreak(code2) {
        if (code2 === null) {
          return true;
        }
        const list2 = constructs2[code2];
        let index2 = -1;
        if (list2) {
          while (++index2 < list2.length) {
            const item = list2[index2];
            if (!item.previous || item.previous.call(self2, self2.previous)) {
              return true;
            }
          }
        }
        return false;
      }
    }
  }
  function createResolver(extraResolver) {
    return resolveAllText;
    function resolveAllText(events, context) {
      let index2 = -1;
      let enter2;
      while (++index2 <= events.length) {
        if (enter2 === void 0) {
          if (events[index2] && events[index2][1].type === "data") {
            enter2 = index2;
            index2++;
          }
        } else if (!events[index2] || events[index2][1].type !== "data") {
          if (index2 !== enter2 + 2) {
            events[enter2][1].end = events[index2 - 1][1].end;
            events.splice(enter2 + 2, index2 - enter2 - 2);
            index2 = enter2 + 2;
          }
          enter2 = void 0;
        }
      }
      return extraResolver ? extraResolver(events, context) : events;
    }
  }
  function resolveAllLineSuffixes(events, context) {
    let eventIndex = 0;
    while (++eventIndex <= events.length) {
      if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
        const data = events[eventIndex - 1][1];
        const chunks = context.sliceStream(data);
        let index2 = chunks.length;
        let bufferIndex = -1;
        let size = 0;
        let tabs;
        while (index2--) {
          const chunk = chunks[index2];
          if (typeof chunk === "string") {
            bufferIndex = chunk.length;
            while (chunk.charCodeAt(bufferIndex - 1) === 32) {
              size++;
              bufferIndex--;
            }
            if (bufferIndex)
              break;
            bufferIndex = -1;
          } else if (chunk === -2) {
            tabs = true;
            size++;
          } else if (chunk === -1)
            ;
          else {
            index2++;
            break;
          }
        }
        if (size) {
          const token = {
            type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
            start: {
              line: data.end.line,
              column: data.end.column - size,
              offset: data.end.offset - size,
              _index: data.start._index + index2,
              _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex
            },
            end: Object.assign({}, data.end)
          };
          data.end = Object.assign({}, token.start);
          if (data.start.offset === data.end.offset) {
            Object.assign(data, token);
          } else {
            events.splice(
              eventIndex,
              0,
              ["enter", token, context],
              ["exit", token, context]
            );
            eventIndex += 2;
          }
        }
        eventIndex++;
      }
    }
    return events;
  }
  function createTokenizer(parser2, initialize, from2) {
    let point2 = Object.assign(
      from2 ? Object.assign({}, from2) : {
        line: 1,
        column: 1,
        offset: 0
      },
      {
        _index: 0,
        _bufferIndex: -1
      }
    );
    const columnStart = {};
    const resolveAllConstructs = [];
    let chunks = [];
    let stack = [];
    const effects = {
      consume,
      enter: enter2,
      exit: exit2,
      attempt: constructFactory(onsuccessfulconstruct),
      check: constructFactory(onsuccessfulcheck),
      interrupt: constructFactory(onsuccessfulcheck, {
        interrupt: true
      })
    };
    const context = {
      previous: null,
      code: null,
      containerState: {},
      events: [],
      parser: parser2,
      sliceStream,
      sliceSerialize,
      now,
      defineSkip,
      write: write2
    };
    let state = initialize.tokenize.call(context, effects);
    if (initialize.resolveAll) {
      resolveAllConstructs.push(initialize);
    }
    return context;
    function write2(slice) {
      chunks = push(chunks, slice);
      main();
      if (chunks[chunks.length - 1] !== null) {
        return [];
      }
      addResult(initialize, 0);
      context.events = resolveAll(resolveAllConstructs, context.events, context);
      return context.events;
    }
    function sliceSerialize(token, expandTabs) {
      return serializeChunks(sliceStream(token), expandTabs);
    }
    function sliceStream(token) {
      return sliceChunks(chunks, token);
    }
    function now() {
      const { line, column, offset, _index, _bufferIndex } = point2;
      return {
        line,
        column,
        offset,
        _index,
        _bufferIndex
      };
    }
    function defineSkip(value) {
      columnStart[value.line] = value.column;
      accountForPotentialSkip();
    }
    function main() {
      let chunkIndex;
      while (point2._index < chunks.length) {
        const chunk = chunks[point2._index];
        if (typeof chunk === "string") {
          chunkIndex = point2._index;
          if (point2._bufferIndex < 0) {
            point2._bufferIndex = 0;
          }
          while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
            go(chunk.charCodeAt(point2._bufferIndex));
          }
        } else {
          go(chunk);
        }
      }
    }
    function go(code2) {
      state = state(code2);
    }
    function consume(code2) {
      if (markdownLineEnding(code2)) {
        point2.line++;
        point2.column = 1;
        point2.offset += code2 === -3 ? 2 : 1;
        accountForPotentialSkip();
      } else if (code2 !== -1) {
        point2.column++;
        point2.offset++;
      }
      if (point2._bufferIndex < 0) {
        point2._index++;
      } else {
        point2._bufferIndex++;
        if (point2._bufferIndex === chunks[point2._index].length) {
          point2._bufferIndex = -1;
          point2._index++;
        }
      }
      context.previous = code2;
    }
    function enter2(type, fields) {
      const token = fields || {};
      token.type = type;
      token.start = now();
      context.events.push(["enter", token, context]);
      stack.push(token);
      return token;
    }
    function exit2(type) {
      const token = stack.pop();
      token.end = now();
      context.events.push(["exit", token, context]);
      return token;
    }
    function onsuccessfulconstruct(construct, info) {
      addResult(construct, info.from);
    }
    function onsuccessfulcheck(_, info) {
      info.restore();
    }
    function constructFactory(onreturn, fields) {
      return hook;
      function hook(constructs2, returnState, bogusState) {
        let listOfConstructs;
        let constructIndex;
        let currentConstruct;
        let info;
        return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? (
          // @ts-expect-error Looks like a construct.
          handleListOfConstructs([constructs2])
        ) : handleMapOfConstructs(constructs2);
        function handleMapOfConstructs(map2) {
          return start;
          function start(code2) {
            const def = code2 !== null && map2[code2];
            const all2 = code2 !== null && map2.null;
            const list2 = [
              // To do: add more extension tests.
              /* c8 ignore next 2 */
              ...Array.isArray(def) ? def : def ? [def] : [],
              ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
            ];
            return handleListOfConstructs(list2)(code2);
          }
        }
        function handleListOfConstructs(list2) {
          listOfConstructs = list2;
          constructIndex = 0;
          if (list2.length === 0) {
            return bogusState;
          }
          return handleConstruct(list2[constructIndex]);
        }
        function handleConstruct(construct) {
          return start;
          function start(code2) {
            info = store();
            currentConstruct = construct;
            if (!construct.partial) {
              context.currentConstruct = construct;
            }
            if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
              return nok();
            }
            return construct.tokenize.call(
              // If we do have fields, create an object w/ `context` as its
              // prototype.
              // This allows a “live binding”, which is needed for `interrupt`.
              fields ? Object.assign(Object.create(context), fields) : context,
              effects,
              ok2,
              nok
            )(code2);
          }
        }
        function ok2(code2) {
          onreturn(currentConstruct, info);
          return returnState;
        }
        function nok(code2) {
          info.restore();
          if (++constructIndex < listOfConstructs.length) {
            return handleConstruct(listOfConstructs[constructIndex]);
          }
          return bogusState;
        }
      }
    }
    function addResult(construct, from3) {
      if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
        resolveAllConstructs.push(construct);
      }
      if (construct.resolve) {
        splice(
          context.events,
          from3,
          context.events.length - from3,
          construct.resolve(context.events.slice(from3), context)
        );
      }
      if (construct.resolveTo) {
        context.events = construct.resolveTo(context.events, context);
      }
    }
    function store() {
      const startPoint = now();
      const startPrevious = context.previous;
      const startCurrentConstruct = context.currentConstruct;
      const startEventsIndex = context.events.length;
      const startStack = Array.from(stack);
      return {
        restore,
        from: startEventsIndex
      };
      function restore() {
        point2 = startPoint;
        context.previous = startPrevious;
        context.currentConstruct = startCurrentConstruct;
        context.events.length = startEventsIndex;
        stack = startStack;
        accountForPotentialSkip();
      }
    }
    function accountForPotentialSkip() {
      if (point2.line in columnStart && point2.column < 2) {
        point2.column = columnStart[point2.line];
        point2.offset += columnStart[point2.line] - 1;
      }
    }
  }
  function sliceChunks(chunks, token) {
    const startIndex = token.start._index;
    const startBufferIndex = token.start._bufferIndex;
    const endIndex = token.end._index;
    const endBufferIndex = token.end._bufferIndex;
    let view;
    if (startIndex === endIndex) {
      view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
    } else {
      view = chunks.slice(startIndex, endIndex);
      if (startBufferIndex > -1) {
        const head2 = view[0];
        if (typeof head2 === "string") {
          view[0] = head2.slice(startBufferIndex);
        } else {
          view.shift();
        }
      }
      if (endBufferIndex > 0) {
        view.push(chunks[endIndex].slice(0, endBufferIndex));
      }
    }
    return view;
  }
  function serializeChunks(chunks, expandTabs) {
    let index2 = -1;
    const result = [];
    let atTab;
    while (++index2 < chunks.length) {
      const chunk = chunks[index2];
      let value;
      if (typeof chunk === "string") {
        value = chunk;
      } else
        switch (chunk) {
          case -5: {
            value = "\r";
            break;
          }
          case -4: {
            value = "\n";
            break;
          }
          case -3: {
            value = "\r\n";
            break;
          }
          case -2: {
            value = expandTabs ? " " : "	";
            break;
          }
          case -1: {
            if (!expandTabs && atTab)
              continue;
            value = " ";
            break;
          }
          default: {
            value = String.fromCharCode(chunk);
          }
        }
      atTab = chunk === -2;
      result.push(value);
    }
    return result.join("");
  }
  const document$1 = {
    [42]: list$4,
    [43]: list$4,
    [45]: list$4,
    [48]: list$4,
    [49]: list$4,
    [50]: list$4,
    [51]: list$4,
    [52]: list$4,
    [53]: list$4,
    [54]: list$4,
    [55]: list$4,
    [56]: list$4,
    [57]: list$4,
    [62]: blockQuote
  };
  const contentInitial = {
    [91]: definition$1
  };
  const flowInitial = {
    [-2]: codeIndented,
    [-1]: codeIndented,
    [32]: codeIndented
  };
  const flow = {
    [35]: headingAtx,
    [42]: thematicBreak$2,
    [45]: [setextUnderline, thematicBreak$2],
    [60]: htmlFlow,
    [61]: setextUnderline,
    [95]: thematicBreak$2,
    [96]: codeFenced,
    [126]: codeFenced
  };
  const string = {
    [38]: characterReference,
    [92]: characterEscape
  };
  const text$3 = {
    [-5]: lineEnding,
    [-4]: lineEnding,
    [-3]: lineEnding,
    [33]: labelStartImage,
    [38]: characterReference,
    [42]: attention,
    [60]: [autolink$1, htmlText],
    [91]: labelStartLink,
    [92]: [hardBreakEscape, characterEscape],
    [93]: labelEnd,
    [95]: attention,
    [96]: codeText
  };
  const insideSpan = {
    null: [attention, resolver]
  };
  const attentionMarkers = {
    null: [42, 95]
  };
  const disable = {
    null: []
  };
  const defaultConstructs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    attentionMarkers,
    contentInitial,
    disable,
    document: document$1,
    flow,
    flowInitial,
    insideSpan,
    string,
    text: text$3
  }, Symbol.toStringTag, { value: "Module" }));
  function parse(options) {
    const settings = options || {};
    const constructs2 = (
      /** @type {FullNormalizedExtension} */
      combineExtensions([defaultConstructs, ...settings.extensions || []])
    );
    const parser2 = {
      defined: [],
      lazy: {},
      constructs: constructs2,
      content: create2(content$2),
      document: create2(document$2),
      flow: create2(flow$1),
      string: create2(string$1),
      text: create2(text$4)
    };
    return parser2;
    function create2(initial) {
      return creator;
      function creator(from2) {
        return createTokenizer(parser2, initial, from2);
      }
    }
  }
  const search = /[\0\t\n\r]/g;
  function preprocess() {
    let column = 1;
    let buffer2 = "";
    let start = true;
    let atCarriageReturn;
    return preprocessor2;
    function preprocessor2(value, encoding, end) {
      const chunks = [];
      let match;
      let next;
      let startPosition;
      let endPosition;
      let code2;
      value = buffer2 + value.toString(encoding);
      startPosition = 0;
      buffer2 = "";
      if (start) {
        if (value.charCodeAt(0) === 65279) {
          startPosition++;
        }
        start = void 0;
      }
      while (startPosition < value.length) {
        search.lastIndex = startPosition;
        match = search.exec(value);
        endPosition = match && match.index !== void 0 ? match.index : value.length;
        code2 = value.charCodeAt(endPosition);
        if (!match) {
          buffer2 = value.slice(startPosition);
          break;
        }
        if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
          chunks.push(-3);
          atCarriageReturn = void 0;
        } else {
          if (atCarriageReturn) {
            chunks.push(-5);
            atCarriageReturn = void 0;
          }
          if (startPosition < endPosition) {
            chunks.push(value.slice(startPosition, endPosition));
            column += endPosition - startPosition;
          }
          switch (code2) {
            case 0: {
              chunks.push(65533);
              column++;
              break;
            }
            case 9: {
              next = Math.ceil(column / 4) * 4;
              chunks.push(-2);
              while (column++ < next)
                chunks.push(-1);
              break;
            }
            case 10: {
              chunks.push(-4);
              column = 1;
              break;
            }
            default: {
              atCarriageReturn = true;
              column = 1;
            }
          }
        }
        startPosition = endPosition + 1;
      }
      if (end) {
        if (atCarriageReturn)
          chunks.push(-5);
        if (buffer2)
          chunks.push(buffer2);
        chunks.push(null);
      }
      return chunks;
    }
  }
  function postprocess(events) {
    while (!subtokenize(events)) {
    }
    return events;
  }
  const own$4 = {}.hasOwnProperty;
  const fromMarkdown = (
    /**
     * @type {(
     *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &
     *   ((value: Value, options?: Options | null | undefined) => Root)
     * )}
     */
    /**
     * @param {Value} value
     * @param {Encoding | Options | null | undefined} [encoding]
     * @param {Options | null | undefined} [options]
     * @returns {Root}
     */
    function(value, encoding, options) {
      if (typeof encoding !== "string") {
        options = encoding;
        encoding = void 0;
      }
      return compiler(options)(
        postprocess(
          parse(options).document().write(preprocess()(value, encoding, true))
        )
      );
    }
  );
  function compiler(options) {
    const config = {
      transforms: [],
      canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
      enter: {
        autolink: opener(link2),
        autolinkProtocol: onenterdata,
        autolinkEmail: onenterdata,
        atxHeading: opener(heading2),
        blockQuote: opener(blockQuote2),
        characterEscape: onenterdata,
        characterReference: onenterdata,
        codeFenced: opener(codeFlow),
        codeFencedFenceInfo: buffer2,
        codeFencedFenceMeta: buffer2,
        codeIndented: opener(codeFlow, buffer2),
        codeText: opener(codeText2, buffer2),
        codeTextData: onenterdata,
        data: onenterdata,
        codeFlowValue: onenterdata,
        definition: opener(definition2),
        definitionDestinationString: buffer2,
        definitionLabelString: buffer2,
        definitionTitleString: buffer2,
        emphasis: opener(emphasis2),
        hardBreakEscape: opener(hardBreak2),
        hardBreakTrailing: opener(hardBreak2),
        htmlFlow: opener(html2, buffer2),
        htmlFlowData: onenterdata,
        htmlText: opener(html2, buffer2),
        htmlTextData: onenterdata,
        image: opener(image2),
        label: buffer2,
        link: opener(link2),
        listItem: opener(listItem2),
        listItemValue: onenterlistitemvalue,
        listOrdered: opener(list2, onenterlistordered),
        listUnordered: opener(list2),
        paragraph: opener(paragraph2),
        reference: onenterreference,
        referenceString: buffer2,
        resourceDestinationString: buffer2,
        resourceTitleString: buffer2,
        setextHeading: opener(heading2),
        strong: opener(strong2),
        thematicBreak: opener(thematicBreak2)
      },
      exit: {
        atxHeading: closer(),
        atxHeadingSequence: onexitatxheadingsequence,
        autolink: closer(),
        autolinkEmail: onexitautolinkemail,
        autolinkProtocol: onexitautolinkprotocol,
        blockQuote: closer(),
        characterEscapeValue: onexitdata,
        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
        characterReferenceValue: onexitcharacterreferencevalue,
        codeFenced: closer(onexitcodefenced),
        codeFencedFence: onexitcodefencedfence,
        codeFencedFenceInfo: onexitcodefencedfenceinfo,
        codeFencedFenceMeta: onexitcodefencedfencemeta,
        codeFlowValue: onexitdata,
        codeIndented: closer(onexitcodeindented),
        codeText: closer(onexitcodetext),
        codeTextData: onexitdata,
        data: onexitdata,
        definition: closer(),
        definitionDestinationString: onexitdefinitiondestinationstring,
        definitionLabelString: onexitdefinitionlabelstring,
        definitionTitleString: onexitdefinitiontitlestring,
        emphasis: closer(),
        hardBreakEscape: closer(onexithardbreak),
        hardBreakTrailing: closer(onexithardbreak),
        htmlFlow: closer(onexithtmlflow),
        htmlFlowData: onexitdata,
        htmlText: closer(onexithtmltext),
        htmlTextData: onexitdata,
        image: closer(onexitimage),
        label: onexitlabel,
        labelText: onexitlabeltext,
        lineEnding: onexitlineending,
        link: closer(onexitlink),
        listItem: closer(),
        listOrdered: closer(),
        listUnordered: closer(),
        paragraph: closer(),
        referenceString: onexitreferencestring,
        resourceDestinationString: onexitresourcedestinationstring,
        resourceTitleString: onexitresourcetitlestring,
        resource: onexitresource,
        setextHeading: closer(onexitsetextheading),
        setextHeadingLineSequence: onexitsetextheadinglinesequence,
        setextHeadingText: onexitsetextheadingtext,
        strong: closer(),
        thematicBreak: closer()
      }
    };
    configure$1(config, (options || {}).mdastExtensions || []);
    const data = {};
    return compile;
    function compile(events) {
      let tree = {
        type: "root",
        children: []
      };
      const context = {
        stack: [tree],
        tokenStack: [],
        config,
        enter: enter2,
        exit: exit2,
        buffer: buffer2,
        resume,
        setData,
        getData
      };
      const listStack = [];
      let index2 = -1;
      while (++index2 < events.length) {
        if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
          if (events[index2][0] === "enter") {
            listStack.push(index2);
          } else {
            const tail = listStack.pop();
            index2 = prepareList(events, tail, index2);
          }
        }
      }
      index2 = -1;
      while (++index2 < events.length) {
        const handler = config[events[index2][0]];
        if (own$4.call(handler, events[index2][1].type)) {
          handler[events[index2][1].type].call(
            Object.assign(
              {
                sliceSerialize: events[index2][2].sliceSerialize
              },
              context
            ),
            events[index2][1]
          );
        }
      }
      if (context.tokenStack.length > 0) {
        const tail = context.tokenStack[context.tokenStack.length - 1];
        const handler = tail[1] || defaultOnError;
        handler.call(context, void 0, tail[0]);
      }
      tree.position = {
        start: point$1(
          events.length > 0 ? events[0][1].start : {
            line: 1,
            column: 1,
            offset: 0
          }
        ),
        end: point$1(
          events.length > 0 ? events[events.length - 2][1].end : {
            line: 1,
            column: 1,
            offset: 0
          }
        )
      };
      index2 = -1;
      while (++index2 < config.transforms.length) {
        tree = config.transforms[index2](tree) || tree;
      }
      return tree;
    }
    function prepareList(events, start, length2) {
      let index2 = start - 1;
      let containerBalance = -1;
      let listSpread = false;
      let listItem3;
      let lineIndex;
      let firstBlankLineIndex;
      let atMarker;
      while (++index2 <= length2) {
        const event = events[index2];
        if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
        } else if (event[1].type === "lineEndingBlank") {
          if (event[0] === "enter") {
            if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index2;
            }
            atMarker = void 0;
          }
        } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace")
          ;
        else {
          atMarker = void 0;
        }
        if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
          if (listItem3) {
            let tailIndex = index2;
            lineIndex = void 0;
            while (tailIndex--) {
              const tailEvent = events[tailIndex];
              if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
                if (tailEvent[0] === "exit")
                  continue;
                if (lineIndex) {
                  events[lineIndex][1].type = "lineEndingBlank";
                  listSpread = true;
                }
                tailEvent[1].type = "lineEnding";
                lineIndex = tailIndex;
              } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent")
                ;
              else {
                break;
              }
            }
            if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
              listItem3._spread = true;
            }
            listItem3.end = Object.assign(
              {},
              lineIndex ? events[lineIndex][1].start : event[1].end
            );
            events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
            index2++;
            length2++;
          }
          if (event[1].type === "listItemPrefix") {
            listItem3 = {
              type: "listItem",
              _spread: false,
              start: Object.assign({}, event[1].start),
              // @ts-expect-error: we’ll add `end` in a second.
              end: void 0
            };
            events.splice(index2, 0, ["enter", listItem3, event[2]]);
            index2++;
            length2++;
            firstBlankLineIndex = void 0;
            atMarker = true;
          }
        }
      }
      events[start][1]._spread = listSpread;
      return length2;
    }
    function setData(key2, value) {
      data[key2] = value;
    }
    function getData(key2) {
      return data[key2];
    }
    function opener(create2, and) {
      return open;
      function open(token) {
        enter2.call(this, create2(token), token);
        if (and)
          and.call(this, token);
      }
    }
    function buffer2() {
      this.stack.push({
        type: "fragment",
        children: []
      });
    }
    function enter2(node2, token, errorHandler) {
      const parent = this.stack[this.stack.length - 1];
      parent.children.push(node2);
      this.stack.push(node2);
      this.tokenStack.push([token, errorHandler]);
      node2.position = {
        start: point$1(token.start)
      };
      return node2;
    }
    function closer(and) {
      return close2;
      function close2(token) {
        if (and)
          and.call(this, token);
        exit2.call(this, token);
      }
    }
    function exit2(token, onExitError) {
      const node2 = this.stack.pop();
      const open = this.tokenStack.pop();
      if (!open) {
        throw new Error(
          "Cannot close `" + token.type + "` (" + stringifyPosition({
            start: token.start,
            end: token.end
          }) + "): it’s not open"
        );
      } else if (open[0].type !== token.type) {
        if (onExitError) {
          onExitError.call(this, token, open[0]);
        } else {
          const handler = open[1] || defaultOnError;
          handler.call(this, token, open[0]);
        }
      }
      node2.position.end = point$1(token.end);
      return node2;
    }
    function resume() {
      return toString(this.stack.pop());
    }
    function onenterlistordered() {
      setData("expectingFirstListItemValue", true);
    }
    function onenterlistitemvalue(token) {
      if (getData("expectingFirstListItemValue")) {
        const ancestor = this.stack[this.stack.length - 2];
        ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
        setData("expectingFirstListItemValue");
      }
    }
    function onexitcodefencedfenceinfo() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.lang = data2;
    }
    function onexitcodefencedfencemeta() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.meta = data2;
    }
    function onexitcodefencedfence() {
      if (getData("flowCodeInside"))
        return;
      this.buffer();
      setData("flowCodeInside", true);
    }
    function onexitcodefenced() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
      setData("flowCodeInside");
    }
    function onexitcodeindented() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2.replace(/(\r?\n|\r)$/g, "");
    }
    function onexitdefinitionlabelstring(token) {
      const label = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.label = label;
      node2.identifier = normalizeIdentifier(
        this.sliceSerialize(token)
      ).toLowerCase();
    }
    function onexitdefinitiontitlestring() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.title = data2;
    }
    function onexitdefinitiondestinationstring() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.url = data2;
    }
    function onexitatxheadingsequence(token) {
      const node2 = this.stack[this.stack.length - 1];
      if (!node2.depth) {
        const depth = this.sliceSerialize(token).length;
        node2.depth = depth;
      }
    }
    function onexitsetextheadingtext() {
      setData("setextHeadingSlurpLineEnding", true);
    }
    function onexitsetextheadinglinesequence(token) {
      const node2 = this.stack[this.stack.length - 1];
      node2.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
    }
    function onexitsetextheading() {
      setData("setextHeadingSlurpLineEnding");
    }
    function onenterdata(token) {
      const node2 = this.stack[this.stack.length - 1];
      let tail = node2.children[node2.children.length - 1];
      if (!tail || tail.type !== "text") {
        tail = text2();
        tail.position = {
          start: point$1(token.start)
        };
        node2.children.push(tail);
      }
      this.stack.push(tail);
    }
    function onexitdata(token) {
      const tail = this.stack.pop();
      tail.value += this.sliceSerialize(token);
      tail.position.end = point$1(token.end);
    }
    function onexitlineending(token) {
      const context = this.stack[this.stack.length - 1];
      if (getData("atHardBreak")) {
        const tail = context.children[context.children.length - 1];
        tail.position.end = point$1(token.end);
        setData("atHardBreak");
        return;
      }
      if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.includes(context.type)) {
        onenterdata.call(this, token);
        onexitdata.call(this, token);
      }
    }
    function onexithardbreak() {
      setData("atHardBreak", true);
    }
    function onexithtmlflow() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2;
    }
    function onexithtmltext() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2;
    }
    function onexitcodetext() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2;
    }
    function onexitlink() {
      const node2 = this.stack[this.stack.length - 1];
      if (getData("inReference")) {
        const referenceType = getData("referenceType") || "shortcut";
        node2.type += "Reference";
        node2.referenceType = referenceType;
        delete node2.url;
        delete node2.title;
      } else {
        delete node2.identifier;
        delete node2.label;
      }
      setData("referenceType");
    }
    function onexitimage() {
      const node2 = this.stack[this.stack.length - 1];
      if (getData("inReference")) {
        const referenceType = getData("referenceType") || "shortcut";
        node2.type += "Reference";
        node2.referenceType = referenceType;
        delete node2.url;
        delete node2.title;
      } else {
        delete node2.identifier;
        delete node2.label;
      }
      setData("referenceType");
    }
    function onexitlabeltext(token) {
      const string2 = this.sliceSerialize(token);
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.label = decodeString(string2);
      ancestor.identifier = normalizeIdentifier(string2).toLowerCase();
    }
    function onexitlabel() {
      const fragment = this.stack[this.stack.length - 1];
      const value = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      setData("inReference", true);
      if (node2.type === "link") {
        const children = fragment.children;
        node2.children = children;
      } else {
        node2.alt = value;
      }
    }
    function onexitresourcedestinationstring() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.url = data2;
    }
    function onexitresourcetitlestring() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.title = data2;
    }
    function onexitresource() {
      setData("inReference");
    }
    function onenterreference() {
      setData("referenceType", "collapsed");
    }
    function onexitreferencestring(token) {
      const label = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.label = label;
      node2.identifier = normalizeIdentifier(
        this.sliceSerialize(token)
      ).toLowerCase();
      setData("referenceType", "full");
    }
    function onexitcharacterreferencemarker(token) {
      setData("characterReferenceType", token.type);
    }
    function onexitcharacterreferencevalue(token) {
      const data2 = this.sliceSerialize(token);
      const type = getData("characterReferenceType");
      let value;
      if (type) {
        value = decodeNumericCharacterReference(
          data2,
          type === "characterReferenceMarkerNumeric" ? 10 : 16
        );
        setData("characterReferenceType");
      } else {
        const result = decodeNamedCharacterReference(data2);
        value = result;
      }
      const tail = this.stack.pop();
      tail.value += value;
      tail.position.end = point$1(token.end);
    }
    function onexitautolinkprotocol(token) {
      onexitdata.call(this, token);
      const node2 = this.stack[this.stack.length - 1];
      node2.url = this.sliceSerialize(token);
    }
    function onexitautolinkemail(token) {
      onexitdata.call(this, token);
      const node2 = this.stack[this.stack.length - 1];
      node2.url = "mailto:" + this.sliceSerialize(token);
    }
    function blockQuote2() {
      return {
        type: "blockquote",
        children: []
      };
    }
    function codeFlow() {
      return {
        type: "code",
        lang: null,
        meta: null,
        value: ""
      };
    }
    function codeText2() {
      return {
        type: "inlineCode",
        value: ""
      };
    }
    function definition2() {
      return {
        type: "definition",
        identifier: "",
        label: null,
        title: null,
        url: ""
      };
    }
    function emphasis2() {
      return {
        type: "emphasis",
        children: []
      };
    }
    function heading2() {
      return {
        type: "heading",
        depth: void 0,
        children: []
      };
    }
    function hardBreak2() {
      return {
        type: "break"
      };
    }
    function html2() {
      return {
        type: "html",
        value: ""
      };
    }
    function image2() {
      return {
        type: "image",
        title: null,
        url: "",
        alt: null
      };
    }
    function link2() {
      return {
        type: "link",
        title: null,
        url: "",
        children: []
      };
    }
    function list2(token) {
      return {
        type: "list",
        ordered: token.type === "listOrdered",
        start: null,
        spread: token._spread,
        children: []
      };
    }
    function listItem2(token) {
      return {
        type: "listItem",
        spread: token._spread,
        checked: null,
        children: []
      };
    }
    function paragraph2() {
      return {
        type: "paragraph",
        children: []
      };
    }
    function strong2() {
      return {
        type: "strong",
        children: []
      };
    }
    function text2() {
      return {
        type: "text",
        value: ""
      };
    }
    function thematicBreak2() {
      return {
        type: "thematicBreak"
      };
    }
  }
  function point$1(d) {
    return {
      line: d.line,
      column: d.column,
      offset: d.offset
    };
  }
  function configure$1(combined, extensions2) {
    let index2 = -1;
    while (++index2 < extensions2.length) {
      const value = extensions2[index2];
      if (Array.isArray(value)) {
        configure$1(combined, value);
      } else {
        extension(combined, value);
      }
    }
  }
  function extension(combined, extension2) {
    let key2;
    for (key2 in extension2) {
      if (own$4.call(extension2, key2)) {
        if (key2 === "canContainEols") {
          const right = extension2[key2];
          if (right) {
            combined[key2].push(...right);
          }
        } else if (key2 === "transforms") {
          const right = extension2[key2];
          if (right) {
            combined[key2].push(...right);
          }
        } else if (key2 === "enter" || key2 === "exit") {
          const right = extension2[key2];
          if (right) {
            Object.assign(combined[key2], right);
          }
        }
      }
    }
  }
  function defaultOnError(left, right) {
    if (left) {
      throw new Error(
        "Cannot close `" + left.type + "` (" + stringifyPosition({
          start: left.start,
          end: left.end
        }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
          start: right.start,
          end: right.end
        }) + ") is open"
      );
    } else {
      throw new Error(
        "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
          start: right.start,
          end: right.end
        }) + ") is still open"
      );
    }
  }
  function remarkParse(options) {
    const parser2 = (doc2) => {
      const settings = (
        /** @type {Options} */
        this.data("settings")
      );
      return fromMarkdown(
        doc2,
        Object.assign({}, settings, options, {
          // Note: these options are not in the readme.
          // The goal is for them to be set by plugins on `data` instead of being
          // passed by users.
          extensions: this.data("micromarkExtensions") || [],
          mdastExtensions: this.data("fromMarkdownExtensions") || []
        })
      );
    };
    Object.assign(this, { Parser: parser2 });
  }
  function blockquote$2(state, node2) {
    const result = {
      type: "element",
      tagName: "blockquote",
      properties: {},
      children: state.wrap(state.all(node2), true)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function hardBreak$1(state, node2) {
    const result = { type: "element", tagName: "br", properties: {}, children: [] };
    state.patch(node2, result);
    return [state.applyData(node2, result), { type: "text", value: "\n" }];
  }
  function code$3(state, node2) {
    const value = node2.value ? node2.value + "\n" : "";
    const lang = node2.lang ? node2.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null;
    const properties = {};
    if (lang) {
      properties.className = ["language-" + lang];
    }
    let result = {
      type: "element",
      tagName: "code",
      properties,
      children: [{ type: "text", value }]
    };
    if (node2.meta) {
      result.data = { meta: node2.meta };
    }
    state.patch(node2, result);
    result = state.applyData(node2, result);
    result = { type: "element", tagName: "pre", properties: {}, children: [result] };
    state.patch(node2, result);
    return result;
  }
  function strikethrough(state, node2) {
    const result = {
      type: "element",
      tagName: "del",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function emphasis$1(state, node2) {
    const result = {
      type: "element",
      tagName: "em",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function footnoteReference(state, node2) {
    const id = String(node2.identifier).toUpperCase();
    const safeId = normalizeUri(id.toLowerCase());
    const index2 = state.footnoteOrder.indexOf(id);
    let counter;
    if (index2 === -1) {
      state.footnoteOrder.push(id);
      state.footnoteCounts[id] = 1;
      counter = state.footnoteOrder.length;
    } else {
      state.footnoteCounts[id]++;
      counter = index2 + 1;
    }
    const reuseCounter = state.footnoteCounts[id];
    const link2 = {
      type: "element",
      tagName: "a",
      properties: {
        href: "#" + state.clobberPrefix + "fn-" + safeId,
        id: state.clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
        dataFootnoteRef: true,
        ariaDescribedBy: ["footnote-label"]
      },
      children: [{ type: "text", value: String(counter) }]
    };
    state.patch(node2, link2);
    const sup = {
      type: "element",
      tagName: "sup",
      properties: {},
      children: [link2]
    };
    state.patch(node2, sup);
    return state.applyData(node2, sup);
  }
  function footnote(state, node2) {
    const footnoteById = state.footnoteById;
    let no = 1;
    while (no in footnoteById)
      no++;
    const identifier = String(no);
    footnoteById[identifier] = {
      type: "footnoteDefinition",
      identifier,
      children: [{ type: "paragraph", children: node2.children }],
      position: node2.position
    };
    return footnoteReference(state, {
      type: "footnoteReference",
      identifier,
      position: node2.position
    });
  }
  function heading$2(state, node2) {
    const result = {
      type: "element",
      tagName: "h" + node2.depth,
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function html$1(state, node2) {
    if (state.dangerous) {
      const result = { type: "raw", value: node2.value };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    return null;
  }
  function revert(state, node2) {
    const subtype = node2.referenceType;
    let suffix = "]";
    if (subtype === "collapsed") {
      suffix += "[]";
    } else if (subtype === "full") {
      suffix += "[" + (node2.label || node2.identifier) + "]";
    }
    if (node2.type === "imageReference") {
      return { type: "text", value: "![" + node2.alt + suffix };
    }
    const contents = state.all(node2);
    const head2 = contents[0];
    if (head2 && head2.type === "text") {
      head2.value = "[" + head2.value;
    } else {
      contents.unshift({ type: "text", value: "[" });
    }
    const tail = contents[contents.length - 1];
    if (tail && tail.type === "text") {
      tail.value += suffix;
    } else {
      contents.push({ type: "text", value: suffix });
    }
    return contents;
  }
  function imageReference$1(state, node2) {
    const def = state.definition(node2.identifier);
    if (!def) {
      return revert(state, node2);
    }
    const properties = { src: normalizeUri(def.url || ""), alt: node2.alt };
    if (def.title !== null && def.title !== void 0) {
      properties.title = def.title;
    }
    const result = { type: "element", tagName: "img", properties, children: [] };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function image$1(state, node2) {
    const properties = { src: normalizeUri(node2.url) };
    if (node2.alt !== null && node2.alt !== void 0) {
      properties.alt = node2.alt;
    }
    if (node2.title !== null && node2.title !== void 0) {
      properties.title = node2.title;
    }
    const result = { type: "element", tagName: "img", properties, children: [] };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function inlineCode$1(state, node2) {
    const text2 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
    state.patch(node2, text2);
    const result = {
      type: "element",
      tagName: "code",
      properties: {},
      children: [text2]
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function linkReference$1(state, node2) {
    const def = state.definition(node2.identifier);
    if (!def) {
      return revert(state, node2);
    }
    const properties = { href: normalizeUri(def.url || "") };
    if (def.title !== null && def.title !== void 0) {
      properties.title = def.title;
    }
    const result = {
      type: "element",
      tagName: "a",
      properties,
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function link$1(state, node2) {
    const properties = { href: normalizeUri(node2.url) };
    if (node2.title !== null && node2.title !== void 0) {
      properties.title = node2.title;
    }
    const result = {
      type: "element",
      tagName: "a",
      properties,
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function listItem(state, node2, parent) {
    const results = state.all(node2);
    const loose = parent ? listLoose(parent) : listItemLoose(node2);
    const properties = {};
    const children = [];
    if (typeof node2.checked === "boolean") {
      const head2 = results[0];
      let paragraph2;
      if (head2 && head2.type === "element" && head2.tagName === "p") {
        paragraph2 = head2;
      } else {
        paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] };
        results.unshift(paragraph2);
      }
      if (paragraph2.children.length > 0) {
        paragraph2.children.unshift({ type: "text", value: " " });
      }
      paragraph2.children.unshift({
        type: "element",
        tagName: "input",
        properties: { type: "checkbox", checked: node2.checked, disabled: true },
        children: []
      });
      properties.className = ["task-list-item"];
    }
    let index2 = -1;
    while (++index2 < results.length) {
      const child = results[index2];
      if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
        children.push({ type: "text", value: "\n" });
      }
      if (child.type === "element" && child.tagName === "p" && !loose) {
        children.push(...child.children);
      } else {
        children.push(child);
      }
    }
    const tail = results[results.length - 1];
    if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
      children.push({ type: "text", value: "\n" });
    }
    const result = { type: "element", tagName: "li", properties, children };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function listLoose(node2) {
    let loose = false;
    if (node2.type === "list") {
      loose = node2.spread || false;
      const children = node2.children;
      let index2 = -1;
      while (!loose && ++index2 < children.length) {
        loose = listItemLoose(children[index2]);
      }
    }
    return loose;
  }
  function listItemLoose(node2) {
    const spread = node2.spread;
    return spread === void 0 || spread === null ? node2.children.length > 1 : spread;
  }
  function list$3(state, node2) {
    const properties = {};
    const results = state.all(node2);
    let index2 = -1;
    if (typeof node2.start === "number" && node2.start !== 1) {
      properties.start = node2.start;
    }
    while (++index2 < results.length) {
      const child = results[index2];
      if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
        properties.className = ["contains-task-list"];
        break;
      }
    }
    const result = {
      type: "element",
      tagName: node2.ordered ? "ol" : "ul",
      properties,
      children: state.wrap(results, true)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function paragraph$1(state, node2) {
    const result = {
      type: "element",
      tagName: "p",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function root$2(state, node2) {
    const result = { type: "root", children: state.wrap(state.all(node2)) };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function strong$2(state, node2) {
    const result = {
      type: "element",
      tagName: "strong",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  const pointStart = point("start");
  const pointEnd = point("end");
  function position(node2) {
    return { start: pointStart(node2), end: pointEnd(node2) };
  }
  function point(type) {
    return point2;
    function point2(node2) {
      const point3 = node2 && node2.position && node2.position[type] || {};
      return {
        // @ts-expect-error: in practice, null is allowed.
        line: point3.line || null,
        // @ts-expect-error: in practice, null is allowed.
        column: point3.column || null,
        // @ts-expect-error: in practice, null is allowed.
        offset: point3.offset > -1 ? point3.offset : null
      };
    }
  }
  function table$1(state, node2) {
    const rows = state.all(node2);
    const firstRow = rows.shift();
    const tableContent = [];
    if (firstRow) {
      const head2 = {
        type: "element",
        tagName: "thead",
        properties: {},
        children: state.wrap([firstRow], true)
      };
      state.patch(node2.children[0], head2);
      tableContent.push(head2);
    }
    if (rows.length > 0) {
      const body2 = {
        type: "element",
        tagName: "tbody",
        properties: {},
        children: state.wrap(rows, true)
      };
      const start = pointStart(node2.children[1]);
      const end = pointEnd(node2.children[node2.children.length - 1]);
      if (start.line && end.line)
        body2.position = { start, end };
      tableContent.push(body2);
    }
    const result = {
      type: "element",
      tagName: "table",
      properties: {},
      children: state.wrap(tableContent, true)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function tableRow$1(state, node2, parent) {
    const siblings2 = parent ? parent.children : void 0;
    const rowIndex = siblings2 ? siblings2.indexOf(node2) : 1;
    const tagName = rowIndex === 0 ? "th" : "td";
    const align = parent && parent.type === "table" ? parent.align : void 0;
    const length2 = align ? align.length : node2.children.length;
    let cellIndex = -1;
    const cells2 = [];
    while (++cellIndex < length2) {
      const cell2 = node2.children[cellIndex];
      const properties = {};
      const alignValue = align ? align[cellIndex] : void 0;
      if (alignValue) {
        properties.align = alignValue;
      }
      let result2 = { type: "element", tagName, properties, children: [] };
      if (cell2) {
        result2.children = state.all(cell2);
        state.patch(cell2, result2);
        result2 = state.applyData(node2, result2);
      }
      cells2.push(result2);
    }
    const result = {
      type: "element",
      tagName: "tr",
      properties: {},
      children: state.wrap(cells2, true)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function tableCell$1(state, node2) {
    const result = {
      type: "element",
      tagName: "td",
      // Assume body cell.
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  const tab = 9;
  const space = 32;
  function trimLines(value) {
    const source2 = String(value);
    const search2 = /\r?\n|\r/g;
    let match = search2.exec(source2);
    let last2 = 0;
    const lines = [];
    while (match) {
      lines.push(
        trimLine(source2.slice(last2, match.index), last2 > 0, true),
        match[0]
      );
      last2 = match.index + match[0].length;
      match = search2.exec(source2);
    }
    lines.push(trimLine(source2.slice(last2), last2 > 0, false));
    return lines.join("");
  }
  function trimLine(value, start, end) {
    let startIndex = 0;
    let endIndex = value.length;
    if (start) {
      let code2 = value.codePointAt(startIndex);
      while (code2 === tab || code2 === space) {
        startIndex++;
        code2 = value.codePointAt(startIndex);
      }
    }
    if (end) {
      let code2 = value.codePointAt(endIndex - 1);
      while (code2 === tab || code2 === space) {
        endIndex--;
        code2 = value.codePointAt(endIndex - 1);
      }
    }
    return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
  }
  function text$2(state, node2) {
    const result = { type: "text", value: trimLines(String(node2.value)) };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function thematicBreak$1(state, node2) {
    const result = {
      type: "element",
      tagName: "hr",
      properties: {},
      children: []
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  const handlers$1 = {
    blockquote: blockquote$2,
    break: hardBreak$1,
    code: code$3,
    delete: strikethrough,
    emphasis: emphasis$1,
    footnoteReference,
    footnote,
    heading: heading$2,
    html: html$1,
    imageReference: imageReference$1,
    image: image$1,
    inlineCode: inlineCode$1,
    linkReference: linkReference$1,
    link: link$1,
    listItem,
    list: list$3,
    paragraph: paragraph$1,
    root: root$2,
    strong: strong$2,
    table: table$1,
    tableCell: tableCell$1,
    tableRow: tableRow$1,
    text: text$2,
    thematicBreak: thematicBreak$1,
    toml: ignore$1,
    yaml: ignore$1,
    definition: ignore$1,
    footnoteDefinition: ignore$1
  };
  function ignore$1() {
    return null;
  }
  const convert$3 = (
    /**
     * @type {(
     *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
     *   ((test?: Test) => AssertAnything)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */
    function(test) {
      if (test === void 0 || test === null) {
        return ok$3;
      }
      if (typeof test === "string") {
        return typeFactory$3(test);
      }
      if (typeof test === "object") {
        return Array.isArray(test) ? anyFactory$5(test) : propsFactory$3(test);
      }
      if (typeof test === "function") {
        return castFactory$5(test);
      }
      throw new Error("Expected function, string, or object as test");
    }
  );
  function anyFactory$5(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convert$3(tests[index2]);
    }
    return castFactory$5(any2);
    function any2(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].call(this, ...parameters))
          return true;
      }
      return false;
    }
  }
  function propsFactory$3(check) {
    return castFactory$5(all2);
    function all2(node2) {
      let key2;
      for (key2 in check) {
        if (node2[key2] !== check[key2])
          return false;
      }
      return true;
    }
  }
  function typeFactory$3(check) {
    return castFactory$5(type);
    function type(node2) {
      return node2 && node2.type === check;
    }
  }
  function castFactory$5(check) {
    return assertion;
    function assertion(node2, ...parameters) {
      return Boolean(
        node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
        Boolean(check.call(this, node2, ...parameters))
      );
    }
  }
  function ok$3() {
    return true;
  }
  function color(d) {
    return d;
  }
  const CONTINUE = true;
  const EXIT = false;
  const SKIP = "skip";
  const visitParents = (
    /**
     * @type {(
     *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
     *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
     * )}
     */
    /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor<Node>} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */
    function(tree, test, visitor, reverse) {
      if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
      }
      const is = convert$3(test);
      const step = reverse ? -1 : 1;
      factory(tree, void 0, [])();
      function factory(node2, index2, parents) {
        const value = node2 && typeof node2 === "object" ? node2 : {};
        if (typeof value.type === "string") {
          const name = (
            // `hast`
            typeof value.tagName === "string" ? value.tagName : (
              // `xast`
              typeof value.name === "string" ? value.name : void 0
            )
          );
          Object.defineProperty(visit2, "name", {
            value: "node (" + color(node2.type + (name ? "<" + name + ">" : "")) + ")"
          });
        }
        return visit2;
        function visit2() {
          let result = [];
          let subresult;
          let offset;
          let grandparents;
          if (!test || is(node2, index2, parents[parents.length - 1] || null)) {
            result = toResult(visitor(node2, parents));
            if (result[0] === EXIT) {
              return result;
            }
          }
          if (node2.children && result[0] !== SKIP) {
            offset = (reverse ? node2.children.length : -1) + step;
            grandparents = parents.concat(node2);
            while (offset > -1 && offset < node2.children.length) {
              subresult = factory(node2.children[offset], offset, grandparents)();
              if (subresult[0] === EXIT) {
                return subresult;
              }
              offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
            }
          }
          return result;
        }
      }
    }
  );
  function toResult(value) {
    if (Array.isArray(value)) {
      return value;
    }
    if (typeof value === "number") {
      return [CONTINUE, value];
    }
    return [value];
  }
  const visit = (
    /**
     * @type {(
     *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
     *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
     * )}
     */
    /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */
    function(tree, test, visitor, reverse) {
      if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
      }
      visitParents(tree, test, overload, reverse);
      function overload(node2, parents) {
        const parent = parents[parents.length - 1];
        return visitor(
          node2,
          parent ? parent.children.indexOf(node2) : null,
          parent
        );
      }
    }
  );
  function generated(node2) {
    return !node2 || !node2.position || !node2.position.start || !node2.position.start.line || !node2.position.start.column || !node2.position.end || !node2.position.end.line || !node2.position.end.column;
  }
  const own$3 = {}.hasOwnProperty;
  function definitions(tree) {
    const cache = /* @__PURE__ */ Object.create(null);
    if (!tree || !tree.type) {
      throw new Error("mdast-util-definitions expected node");
    }
    visit(tree, "definition", (definition3) => {
      const id = clean(definition3.identifier);
      if (id && !own$3.call(cache, id)) {
        cache[id] = definition3;
      }
    });
    return definition2;
    function definition2(identifier) {
      const id = clean(identifier);
      return id && own$3.call(cache, id) ? cache[id] : null;
    }
  }
  function clean(value) {
    return String(value || "").toUpperCase();
  }
  const own$2 = {}.hasOwnProperty;
  function createState(tree, options) {
    const settings = options || {};
    const dangerous2 = settings.allowDangerousHtml || false;
    const footnoteById = {};
    state.dangerous = dangerous2;
    state.clobberPrefix = settings.clobberPrefix === void 0 || settings.clobberPrefix === null ? "user-content-" : settings.clobberPrefix;
    state.footnoteLabel = settings.footnoteLabel || "Footnotes";
    state.footnoteLabelTagName = settings.footnoteLabelTagName || "h2";
    state.footnoteLabelProperties = settings.footnoteLabelProperties || {
      className: ["sr-only"]
    };
    state.footnoteBackLabel = settings.footnoteBackLabel || "Back to content";
    state.unknownHandler = settings.unknownHandler;
    state.passThrough = settings.passThrough;
    state.handlers = { ...handlers$1, ...settings.handlers };
    state.definition = definitions(tree);
    state.footnoteById = footnoteById;
    state.footnoteOrder = [];
    state.footnoteCounts = {};
    state.patch = patch;
    state.applyData = applyData;
    state.one = oneBound;
    state.all = allBound;
    state.wrap = wrap$1;
    state.augment = augment;
    visit(tree, "footnoteDefinition", (definition2) => {
      const id = String(definition2.identifier).toUpperCase();
      if (!own$2.call(footnoteById, id)) {
        footnoteById[id] = definition2;
      }
    });
    return state;
    function augment(left, right) {
      if (left && "data" in left && left.data) {
        const data = left.data;
        if (data.hName) {
          if (right.type !== "element") {
            right = {
              type: "element",
              tagName: "",
              properties: {},
              children: []
            };
          }
          right.tagName = data.hName;
        }
        if (right.type === "element" && data.hProperties) {
          right.properties = { ...right.properties, ...data.hProperties };
        }
        if ("children" in right && right.children && data.hChildren) {
          right.children = data.hChildren;
        }
      }
      if (left) {
        const ctx = "type" in left ? left : { position: left };
        if (!generated(ctx)) {
          right.position = { start: pointStart(ctx), end: pointEnd(ctx) };
        }
      }
      return right;
    }
    function state(node2, tagName, props, children) {
      if (Array.isArray(props)) {
        children = props;
        props = {};
      }
      return augment(node2, {
        type: "element",
        tagName,
        properties: props || {},
        children: children || []
      });
    }
    function oneBound(node2, parent) {
      return one$1(state, node2, parent);
    }
    function allBound(parent) {
      return all$2(state, parent);
    }
  }
  function patch(from2, to) {
    if (from2.position)
      to.position = position(from2);
  }
  function applyData(from2, to) {
    let result = to;
    if (from2 && from2.data) {
      const hName = from2.data.hName;
      const hChildren = from2.data.hChildren;
      const hProperties = from2.data.hProperties;
      if (typeof hName === "string") {
        if (result.type === "element") {
          result.tagName = hName;
        } else {
          result = {
            type: "element",
            tagName: hName,
            properties: {},
            children: []
          };
        }
      }
      if (result.type === "element" && hProperties) {
        result.properties = { ...result.properties, ...hProperties };
      }
      if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
        result.children = hChildren;
      }
    }
    return result;
  }
  function one$1(state, node2, parent) {
    const type = node2 && node2.type;
    if (!type) {
      throw new Error("Expected node, got `" + node2 + "`");
    }
    if (own$2.call(state.handlers, type)) {
      return state.handlers[type](state, node2, parent);
    }
    if (state.passThrough && state.passThrough.includes(type)) {
      return "children" in node2 ? { ...node2, children: all$2(state, node2) } : node2;
    }
    if (state.unknownHandler) {
      return state.unknownHandler(state, node2, parent);
    }
    return defaultUnknownHandler(state, node2);
  }
  function all$2(state, parent) {
    const values = [];
    if ("children" in parent) {
      const nodes = parent.children;
      let index2 = -1;
      while (++index2 < nodes.length) {
        const result = one$1(state, nodes[index2], parent);
        if (result) {
          if (index2 && nodes[index2 - 1].type === "break") {
            if (!Array.isArray(result) && result.type === "text") {
              result.value = result.value.replace(/^\s+/, "");
            }
            if (!Array.isArray(result) && result.type === "element") {
              const head2 = result.children[0];
              if (head2 && head2.type === "text") {
                head2.value = head2.value.replace(/^\s+/, "");
              }
            }
          }
          if (Array.isArray(result)) {
            values.push(...result);
          } else {
            values.push(result);
          }
        }
      }
    }
    return values;
  }
  function defaultUnknownHandler(state, node2) {
    const data = node2.data || {};
    const result = "value" in node2 && !(own$2.call(data, "hProperties") || own$2.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
      type: "element",
      tagName: "div",
      properties: {},
      children: all$2(state, node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function wrap$1(nodes, loose) {
    const result = [];
    let index2 = -1;
    if (loose) {
      result.push({ type: "text", value: "\n" });
    }
    while (++index2 < nodes.length) {
      if (index2)
        result.push({ type: "text", value: "\n" });
      result.push(nodes[index2]);
    }
    if (loose && nodes.length > 0) {
      result.push({ type: "text", value: "\n" });
    }
    return result;
  }
  function footer(state) {
    const listItems = [];
    let index2 = -1;
    while (++index2 < state.footnoteOrder.length) {
      const def = state.footnoteById[state.footnoteOrder[index2]];
      if (!def) {
        continue;
      }
      const content2 = state.all(def);
      const id = String(def.identifier).toUpperCase();
      const safeId = normalizeUri(id.toLowerCase());
      let referenceIndex = 0;
      const backReferences = [];
      while (++referenceIndex <= state.footnoteCounts[id]) {
        const backReference = {
          type: "element",
          tagName: "a",
          properties: {
            href: "#" + state.clobberPrefix + "fnref-" + safeId + (referenceIndex > 1 ? "-" + referenceIndex : ""),
            dataFootnoteBackref: true,
            className: ["data-footnote-backref"],
            ariaLabel: state.footnoteBackLabel
          },
          children: [{ type: "text", value: "↩" }]
        };
        if (referenceIndex > 1) {
          backReference.children.push({
            type: "element",
            tagName: "sup",
            children: [{ type: "text", value: String(referenceIndex) }]
          });
        }
        if (backReferences.length > 0) {
          backReferences.push({ type: "text", value: " " });
        }
        backReferences.push(backReference);
      }
      const tail = content2[content2.length - 1];
      if (tail && tail.type === "element" && tail.tagName === "p") {
        const tailTail = tail.children[tail.children.length - 1];
        if (tailTail && tailTail.type === "text") {
          tailTail.value += " ";
        } else {
          tail.children.push({ type: "text", value: " " });
        }
        tail.children.push(...backReferences);
      } else {
        content2.push(...backReferences);
      }
      const listItem2 = {
        type: "element",
        tagName: "li",
        properties: { id: state.clobberPrefix + "fn-" + safeId },
        children: state.wrap(content2, true)
      };
      state.patch(def, listItem2);
      listItems.push(listItem2);
    }
    if (listItems.length === 0) {
      return;
    }
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: true, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: state.footnoteLabelTagName,
          properties: {
            // To do: use structured clone.
            ...JSON.parse(JSON.stringify(state.footnoteLabelProperties)),
            id: "footnote-label"
          },
          children: [{ type: "text", value: state.footnoteLabel }]
        },
        { type: "text", value: "\n" },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: state.wrap(listItems, true)
        },
        { type: "text", value: "\n" }
      ]
    };
  }
  function toHast(tree, options) {
    const state = createState(tree, options);
    const node2 = state.one(tree, null);
    const foot = footer(state);
    if (foot) {
      node2.children.push({ type: "text", value: "\n" }, foot);
    }
    return Array.isArray(node2) ? { type: "root", children: node2 } : node2;
  }
  const remarkRehype = (
    /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */
    function(destination, options) {
      return destination && "run" in destination ? bridge$1(destination, options) : mutate$1(destination || options);
    }
  );
  const remarkRehype$1 = remarkRehype;
  function bridge$1(destination, options) {
    return (node2, file, next) => {
      destination.run(toHast(node2, options), file, (error) => {
        next(error);
      });
    };
  }
  function mutate$1(options) {
    return (node2) => toHast(node2, options);
  }
  function getChildIndex$1(node2) {
    return Array.prototype.indexOf.call(node2.parentElement.childNodes, node2);
  }
  function isWhitespaceNode(node2) {
    return node2.nodeType === 3 && !/\S/.test(node2.nodeValue || "");
  }
  function liftNestedListsToParent(element2) {
    element2.querySelectorAll("li > ul, li > ol").forEach((list2) => {
      const index2 = getChildIndex$1(list2);
      const parentListItem = list2.parentElement;
      const siblingsAfter = Array.from(parentListItem.childNodes).slice(
        index2 + 1
      );
      list2.remove();
      siblingsAfter.forEach((sibling) => {
        sibling.remove();
      });
      parentListItem.insertAdjacentElement("afterend", list2);
      siblingsAfter.reverse().forEach((sibling) => {
        if (isWhitespaceNode(sibling)) {
          return;
        }
        const siblingContainer = document.createElement("li");
        siblingContainer.append(sibling);
        list2.insertAdjacentElement("afterend", siblingContainer);
      });
      if (parentListItem.childNodes.length === 0) {
        parentListItem.remove();
      }
    });
  }
  function createGroups(element2) {
    element2.querySelectorAll("li + ul, li + ol").forEach((list2) => {
      var _a, _b;
      const listItem2 = list2.previousElementSibling;
      const blockContainer = document.createElement("div");
      listItem2.insertAdjacentElement("afterend", blockContainer);
      blockContainer.append(listItem2);
      const blockGroup = document.createElement("div");
      blockGroup.setAttribute("data-node-type", "blockGroup");
      blockContainer.append(blockGroup);
      while (((_a = blockContainer.nextElementSibling) == null ? void 0 : _a.nodeName) === "UL" || ((_b = blockContainer.nextElementSibling) == null ? void 0 : _b.nodeName) === "OL") {
        blockGroup.append(blockContainer.nextElementSibling);
      }
    });
  }
  function nestedListsToBlockNoteStructure(elementOrHTML) {
    if (typeof elementOrHTML === "string") {
      const element2 = document.createElement("div");
      element2.innerHTML = elementOrHTML;
      elementOrHTML = element2;
    }
    liftNestedListsToParent(elementOrHTML);
    createGroups(elementOrHTML);
    return elementOrHTML;
  }
  async function HTMLToBlocks(html2, blockSchema, icSchema, styleSchema, pmSchema) {
    const htmlNode = nestedListsToBlockNoteStructure(html2);
    const parser2 = DOMParser$1.fromSchema(pmSchema);
    const parentNode2 = parser2.parse(htmlNode, {
      topNode: pmSchema.nodes["blockGroup"].create()
    });
    const blocks2 = [];
    for (let i2 = 0; i2 < parentNode2.childCount; i2++) {
      blocks2.push(
        nodeToBlock(parentNode2.child(i2), blockSchema, icSchema, styleSchema)
      );
    }
    return blocks2;
  }
  function code$2(state, node2) {
    const value = node2.value ? node2.value + "\n" : "";
    const properties = {};
    if (node2.lang) {
      properties["data-language"] = node2.lang;
    }
    let result = {
      type: "element",
      tagName: "code",
      properties,
      children: [{ type: "text", value }]
    };
    if (node2.meta) {
      result.data = { meta: node2.meta };
    }
    state.patch(node2, result);
    result = state.applyData(node2, result);
    result = {
      type: "element",
      tagName: "pre",
      properties: {},
      children: [result]
    };
    state.patch(node2, result);
    return result;
  }
  function markdownToBlocks(markdown, blockSchema, icSchema, styleSchema, pmSchema) {
    const htmlString = unified().use(remarkParse).use(remarkGfm).use(remarkRehype$1, {
      allowDangerousHtml: true,
      handlers: {
        ...handlers$1,
        code: code$2
      }
    }).use(rehypeStringify, { allowDangerousHtml: true }).processSync(markdown);
    return HTMLToBlocks(
      htmlString.value,
      blockSchema,
      icSchema,
      styleSchema,
      pmSchema
    );
  }
  const headingPropSchema = {
    ...defaultProps,
    level: { default: 1, values: [1, 2, 3, 4, 5, 6] }
  };
  const HeadingBlockContent = createStronglyTypedTiptapNode({
    name: "heading",
    content: "inline*",
    group: "blockContent",
    addAttributes() {
      return {
        level: {
          default: 1,
          // instead of "level" attributes, use "data-level"
          parseHTML: (element2) => {
            const attr = element2.getAttribute("data-level");
            const parsed = parseInt(attr);
            if (isFinite(parsed)) {
              return parsed;
            }
            return void 0;
          },
          renderHTML: (attributes) => {
            return {
              "data-level": attributes.level.toString()
            };
          }
        }
      };
    },
    addInputRules() {
      return [
        ...[1, 2, 3, 4, 5, 6].map((level) => {
          return new InputRule({
            find: new RegExp(`^(#{${level}})\\s$`),
            handler: ({ state, chain, range }) => {
              chain().BNUpdateBlock(state.selection.from, {
                type: "heading",
                props: {
                  level
                }
              }).deleteRange({ from: range.from, to: range.to });
            }
          });
        })
      ];
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-1": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {
          type: "heading",
          props: {
            level: 1
          }
        }),
        "Mod-Alt-2": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {
          type: "heading",
          props: {
            level: 2
          }
        }),
        "Mod-Alt-3": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {
          type: "heading",
          props: {
            level: 3
          }
        }),
        "Mod-Alt-4": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {
          type: "heading",
          props: {
            level: 4
          }
        }),
        "Mod-Alt-5": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {
          type: "heading",
          props: {
            level: 5
          }
        }),
        "Mod-Alt-6": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {
          type: "heading",
          props: {
            level: 6
          }
        })
      };
    },
    parseHTML() {
      return [
        {
          tag: "div[data-content-type=" + this.name + "]",
          getAttrs: (element2) => {
            if (typeof element2 === "string") {
              return false;
            }
            return {
              level: element2.getAttribute("data-level")
            };
          }
        },
        {
          tag: "h1",
          attrs: { level: 1 },
          node: "heading"
        },
        {
          tag: "h2",
          attrs: { level: 2 },
          node: "heading"
        },
        {
          tag: "h3",
          attrs: { level: 3 },
          node: "heading"
        },
        {
          tag: "h4",
          attrs: { level: 4 },
          node: "heading"
        },
        {
          tag: "h5",
          attrs: { level: 5 },
          node: "heading"
        },
        {
          tag: "h6",
          attrs: { level: 6 },
          node: "heading"
        }
      ];
    },
    renderHTML({ node: node2, HTMLAttributes }) {
      var _a, _b;
      return createDefaultBlockDOMOutputSpec(
        this.name,
        `h${node2.attrs.level}`,
        {
          ...((_a = this.options.domAttributes) == null ? void 0 : _a.blockContent) || {},
          ...HTMLAttributes
        },
        ((_b = this.options.domAttributes) == null ? void 0 : _b.inlineContent) || {}
      );
    },
    addPasteRules() {
      return [
        new PasteRule({
          find: /.*/g,
          handler: ({ state, chain, range, pasteEvent }) => {
            var _a;
            const { node: node2 } = getBlockInfoFromPos(
              state.doc,
              state.selection.from
            );
            const text2 = ((_a = pasteEvent == null ? void 0 : pasteEvent.clipboardData) == null ? void 0 : _a.getData("text")) || "";
            if (text2) {
              parseMardown(text2, this.editor, {
                state,
                chain,
                range,
                node: node2
              });
            }
          }
        })
      ];
    }
  });
  const Heading = createBlockSpecFromStronglyTypedTiptapNode(
    HeadingBlockContent,
    headingPropSchema
  );
  const parseMardown = async (content2, editor2, props) => {
    const { state, range } = props;
    const blocksToInsert = await markdownToBlocks(
      content2,
      defaultBlockSchema,
      defaultInlineContentSchema,
      defaultStyleSchema,
      state.schema
    );
    if (blocksToInsert == null ? void 0 : blocksToInsert.length) {
      const nodesToInsert = [];
      for (const blockSpec of blocksToInsert) {
        nodesToInsert.push(
          blockToNode(blockSpec, editor2.schema, defaultStyleSchema)
        );
      }
      if (range.from !== range.to) {
        const slice = new Slice(Fragment.from(nodesToInsert), 0, 0);
        editor2.view.dispatch(
          editor2.state.tr.replaceRange(range.from, range.to, slice)
        );
      }
    }
  };
  class EventEmitter {
    constructor() {
      // eslint-disable-next-line @typescript-eslint/ban-types
      __publicField(this, "callbacks", {});
    }
    on(event, fn) {
      if (!this.callbacks[event]) {
        this.callbacks[event] = [];
      }
      this.callbacks[event].push(fn);
      return () => this.off(event, fn);
    }
    emit(event, ...args) {
      const callbacks = this.callbacks[event];
      if (callbacks) {
        callbacks.forEach((callback) => callback.apply(this, args));
      }
    }
    off(event, fn) {
      const callbacks = this.callbacks[event];
      if (callbacks) {
        if (fn) {
          this.callbacks[event] = callbacks.filter((callback) => callback !== fn);
        } else {
          delete this.callbacks[event];
        }
      }
    }
    removeAllListeners() {
      this.callbacks = {};
    }
  }
  class ImageToolbarView {
    constructor(pluginKey, pmView, updateImageToolbar) {
      __publicField(this, "imageToolbarState");
      __publicField(this, "updateImageToolbar");
      __publicField(this, "prevWasEditable", null);
      __publicField(this, "mouseDownHandler", () => {
        var _a;
        if ((_a = this.imageToolbarState) == null ? void 0 : _a.show) {
          this.imageToolbarState.show = false;
          this.updateImageToolbar();
        }
      });
      // For dragging the whole editor.
      __publicField(this, "dragstartHandler", () => {
        var _a;
        if ((_a = this.imageToolbarState) == null ? void 0 : _a.show) {
          this.imageToolbarState.show = false;
          this.updateImageToolbar();
        }
      });
      __publicField(this, "blurHandler", (event) => {
        var _a;
        const editorWrapper = this.pmView.dom.parentElement;
        if (
          // An element is clicked.
          event && event.relatedTarget && // Element is inside the editor.
          (editorWrapper === event.relatedTarget || editorWrapper.contains(event.relatedTarget))
        ) {
          return;
        }
        if ((_a = this.imageToolbarState) == null ? void 0 : _a.show) {
          this.imageToolbarState.show = false;
          this.updateImageToolbar();
        }
      });
      __publicField(this, "scrollHandler", () => {
        var _a;
        if ((_a = this.imageToolbarState) == null ? void 0 : _a.show) {
          const blockElement = document.querySelector(
            `[data-node-type="blockContainer"][data-id="${this.imageToolbarState.block.id}"]`
          );
          this.imageToolbarState.referencePos = blockElement.getBoundingClientRect();
          this.updateImageToolbar();
        }
      });
      this.pluginKey = pluginKey;
      this.pmView = pmView;
      this.updateImageToolbar = () => {
        if (!this.imageToolbarState) {
          throw new Error("Attempting to update uninitialized image toolbar");
        }
        updateImageToolbar(this.imageToolbarState);
      };
      pmView.dom.addEventListener("mousedown", this.mouseDownHandler);
      pmView.dom.addEventListener("dragstart", this.dragstartHandler);
      pmView.dom.addEventListener("blur", this.blurHandler);
      document.addEventListener("scroll", this.scrollHandler);
    }
    update(view, prevState) {
      var _a, _b;
      const pluginState = this.pluginKey.getState(view.state);
      if (!((_a = this.imageToolbarState) == null ? void 0 : _a.show) && pluginState.block) {
        const blockElement = document.querySelector(
          `[data-node-type="blockContainer"][data-id="${pluginState.block.id}"]`
        );
        this.imageToolbarState = {
          show: true,
          referencePos: blockElement.getBoundingClientRect(),
          block: pluginState.block
        };
        this.updateImageToolbar();
        return;
      }
      if (!view.state.selection.eq(prevState.selection) || !view.state.doc.eq(prevState.doc)) {
        if ((_b = this.imageToolbarState) == null ? void 0 : _b.show) {
          this.imageToolbarState.show = false;
          this.updateImageToolbar();
        }
      }
    }
    destroy() {
      this.pmView.dom.removeEventListener("mousedown", this.mouseDownHandler);
      this.pmView.dom.removeEventListener("dragstart", this.dragstartHandler);
      this.pmView.dom.removeEventListener("blur", this.blurHandler);
      document.removeEventListener("scroll", this.scrollHandler);
    }
  }
  const imageToolbarPluginKey = new PluginKey("ImageToolbarPlugin");
  class ImageToolbarProsemirrorPlugin extends EventEmitter {
    constructor(_editor) {
      super();
      __publicField(this, "view");
      __publicField(this, "plugin");
      this.plugin = new Plugin({
        key: imageToolbarPluginKey,
        view: (editorView) => {
          this.view = new ImageToolbarView(
            // editor,
            imageToolbarPluginKey,
            editorView,
            (state) => {
              this.emit("update", state);
            }
          );
          return this.view;
        },
        state: {
          init: () => {
            return {
              block: void 0
            };
          },
          apply: (transaction) => {
            var _a;
            const block2 = (_a = transaction.getMeta(imageToolbarPluginKey)) == null ? void 0 : _a.block;
            return {
              block: block2
            };
          }
        }
      });
    }
    onUpdate(callback) {
      return this.on("update", callback);
    }
  }
  const imagePropSchema = {
    textAlignment: defaultProps.textAlignment,
    backgroundColor: defaultProps.backgroundColor,
    // Image url.
    url: {
      default: ""
    },
    // Image caption.
    caption: {
      default: ""
    },
    // Image width in px.
    width: {
      default: 512
    }
  };
  const textAlignmentToAlignItems = (textAlignment) => {
    switch (textAlignment) {
      case "left":
        return "flex-start";
      case "center":
        return "center";
      case "right":
        return "flex-end";
      default:
        return "flex-start";
    }
  };
  const minWidth = 64;
  const renderImage = (block2, editor2) => {
    const wrapper = document.createElement("div");
    wrapper.className = "bn-image-block-content-wrapper";
    wrapper.style.alignItems = textAlignmentToAlignItems(
      block2.props.textAlignment
    );
    const addImageButton = document.createElement("div");
    addImageButton.className = "bn-add-image-button";
    const addImageButtonIcon = document.createElement("div");
    addImageButtonIcon.className = "bn-add-image-button-icon";
    const addImageButtonText = document.createElement("p");
    addImageButtonText.className = "bn-add-image-button-text";
    addImageButtonText.innerText = "Add Image";
    const imageAndCaptionWrapper = document.createElement("div");
    imageAndCaptionWrapper.className = "bn-image-and-caption-wrapper";
    const imageWrapper = document.createElement("div");
    imageWrapper.className = "bn-image-wrapper";
    const image2 = document.createElement("img");
    image2.className = "bn-image";
    image2.src = block2.props.url;
    image2.alt = "placeholder";
    image2.contentEditable = "false";
    image2.draggable = false;
    image2.style.width = `${Math.min(
      block2.props.width,
      editor2.domElement.firstElementChild.clientWidth
    )}px`;
    const leftResizeHandle = document.createElement("div");
    leftResizeHandle.className = "bn-image-resize-handle";
    leftResizeHandle.style.left = "4px";
    const rightResizeHandle = document.createElement("div");
    rightResizeHandle.className = "bn-image-resize-handle";
    rightResizeHandle.style.right = "4px";
    const caption = document.createElement("p");
    caption.className = "bn-image-caption";
    caption.innerText = block2.props.caption;
    caption.style.padding = block2.props.caption ? "4px" : "";
    const handleEditorUpdate = () => {
      var _a;
      const selection = ((_a = editor2.getSelection()) == null ? void 0 : _a.blocks) || [];
      const currentBlock = editor2.getTextCursorPosition().block;
      const isSelected = [currentBlock, ...selection].find(
        (selectedBlock) => selectedBlock.id === block2.id
      ) !== void 0;
      if (isSelected) {
        addImageButton.style.outline = "4px solid rgb(100, 160, 255)";
        imageAndCaptionWrapper.style.outline = "4px solid rgb(100, 160, 255)";
      } else {
        addImageButton.style.outline = "";
        imageAndCaptionWrapper.style.outline = "";
      }
    };
    editor2.onEditorContentChange(handleEditorUpdate);
    editor2.onEditorSelectionChange(handleEditorUpdate);
    let resizeParams;
    const windowMouseMoveHandler = (event) => {
      if (!resizeParams) {
        if (!editor2.isEditable && imageWrapper.contains(leftResizeHandle) && imageWrapper.contains(rightResizeHandle)) {
          imageWrapper.removeChild(leftResizeHandle);
          imageWrapper.removeChild(rightResizeHandle);
        }
        return;
      }
      let newWidth;
      if (textAlignmentToAlignItems(block2.props.textAlignment) === "center") {
        if (resizeParams.handleUsed === "left") {
          newWidth = resizeParams.initialWidth + (resizeParams.initialClientX - event.clientX) * 2;
        } else {
          newWidth = resizeParams.initialWidth + (event.clientX - resizeParams.initialClientX) * 2;
        }
      } else {
        if (resizeParams.handleUsed === "left") {
          newWidth = resizeParams.initialWidth + resizeParams.initialClientX - event.clientX;
        } else {
          newWidth = resizeParams.initialWidth + event.clientX - resizeParams.initialClientX;
        }
      }
      if (newWidth < minWidth) {
        image2.style.width = `${minWidth}px`;
      } else if (newWidth > editor2.domElement.firstElementChild.clientWidth) {
        image2.style.width = `${editor2.domElement.firstElementChild.clientWidth}px`;
      } else {
        image2.style.width = `${newWidth}px`;
      }
    };
    const windowMouseUpHandler = (event) => {
      if ((!event.target || !imageWrapper.contains(event.target) || !editor2.isEditable) && imageWrapper.contains(leftResizeHandle) && imageWrapper.contains(rightResizeHandle)) {
        imageWrapper.removeChild(leftResizeHandle);
        imageWrapper.removeChild(rightResizeHandle);
      }
      if (!resizeParams) {
        return;
      }
      resizeParams = void 0;
      editor2.updateBlock(block2, {
        type: "image",
        props: {
          // Removes "px" from the end of the width string and converts to float.
          width: parseFloat(image2.style.width.slice(0, -2))
        }
      });
    };
    const addImageButtonMouseDownHandler = (event) => {
      event.preventDefault();
    };
    const addImageButtonClickHandler = () => {
      editor2._tiptapEditor.view.dispatch(
        editor2._tiptapEditor.state.tr.setMeta(imageToolbarPluginKey, {
          block: block2
        })
      );
    };
    const imageMouseEnterHandler = () => {
      if (editor2.isEditable) {
        imageWrapper.appendChild(leftResizeHandle);
        imageWrapper.appendChild(rightResizeHandle);
      }
    };
    const imageMouseLeaveHandler = (event) => {
      if (event.relatedTarget === leftResizeHandle || event.relatedTarget === rightResizeHandle) {
        return;
      }
      if (resizeParams) {
        return;
      }
      if (editor2.isEditable && imageWrapper.contains(leftResizeHandle) && imageWrapper.contains(rightResizeHandle)) {
        imageWrapper.removeChild(leftResizeHandle);
        imageWrapper.removeChild(rightResizeHandle);
      }
    };
    const leftResizeHandleMouseDownHandler = (event) => {
      event.preventDefault();
      imageWrapper.appendChild(leftResizeHandle);
      imageWrapper.appendChild(rightResizeHandle);
      resizeParams = {
        handleUsed: "left",
        initialWidth: block2.props.width,
        initialClientX: event.clientX
      };
    };
    const rightResizeHandleMouseDownHandler = (event) => {
      event.preventDefault();
      imageWrapper.appendChild(leftResizeHandle);
      imageWrapper.appendChild(rightResizeHandle);
      resizeParams = {
        handleUsed: "right",
        initialWidth: block2.props.width,
        initialClientX: event.clientX
      };
    };
    addImageButton.appendChild(addImageButtonIcon);
    addImageButton.appendChild(addImageButtonText);
    imageAndCaptionWrapper.appendChild(imageWrapper);
    imageWrapper.appendChild(image2);
    imageAndCaptionWrapper.appendChild(caption);
    if (block2.props.url === "") {
      wrapper.appendChild(addImageButton);
    } else {
      wrapper.appendChild(imageAndCaptionWrapper);
    }
    window.addEventListener("mousemove", windowMouseMoveHandler);
    window.addEventListener("mouseup", windowMouseUpHandler);
    addImageButton.addEventListener("mousedown", addImageButtonMouseDownHandler);
    addImageButton.addEventListener("click", addImageButtonClickHandler);
    image2.addEventListener("mouseenter", imageMouseEnterHandler);
    image2.addEventListener("mouseleave", imageMouseLeaveHandler);
    leftResizeHandle.addEventListener(
      "mousedown",
      leftResizeHandleMouseDownHandler
    );
    rightResizeHandle.addEventListener(
      "mousedown",
      rightResizeHandleMouseDownHandler
    );
    return {
      dom: wrapper,
      destroy: () => {
        window.removeEventListener("mousemove", windowMouseMoveHandler);
        window.removeEventListener("mouseup", windowMouseUpHandler);
        addImageButton.removeEventListener(
          "mousedown",
          addImageButtonMouseDownHandler
        );
        addImageButton.removeEventListener("click", addImageButtonClickHandler);
        leftResizeHandle.removeEventListener(
          "mousedown",
          leftResizeHandleMouseDownHandler
        );
        rightResizeHandle.removeEventListener(
          "mousedown",
          rightResizeHandleMouseDownHandler
        );
      }
    };
  };
  const Image = createBlockSpec(
    {
      type: "image",
      propSchema: imagePropSchema,
      content: "none"
    },
    {
      render: renderImage,
      toExternalHTML: (block2) => {
        if (block2.props.url === "") {
          const div2 = document.createElement("p");
          div2.innerHTML = "Add Image";
          return {
            dom: div2
          };
        }
        const figure = document.createElement("figure");
        const img2 = document.createElement("img");
        img2.src = block2.props.url;
        figure.appendChild(img2);
        if (block2.props.caption !== "") {
          const figcaption = document.createElement("figcaption");
          figcaption.innerHTML = block2.props.caption;
          figure.appendChild(figcaption);
        }
        return {
          dom: figure
        };
      },
      parse: (element2) => {
        if (element2.tagName === "FIGURE") {
          const img2 = element2.querySelector("img");
          const caption = element2.querySelector("figcaption");
          return {
            url: (img2 == null ? void 0 : img2.getAttribute("src")) || "",
            caption: (caption == null ? void 0 : caption.textContent) || (img2 == null ? void 0 : img2.getAttribute("alt")) || void 0
          };
        } else if (element2.tagName === "IMG") {
          return {
            url: element2.getAttribute("src") || "",
            caption: element2.getAttribute("alt") || void 0
          };
        }
        return void 0;
      }
    }
  );
  const handleEnter = (editor2) => {
    const { node: node2, contentType } = getBlockInfoFromPos(
      editor2.state.doc,
      editor2.state.selection.from
    );
    const selectionEmpty = editor2.state.selection.anchor === editor2.state.selection.head;
    if (!contentType.name.endsWith("ListItem") || !selectionEmpty) {
      return false;
    }
    return editor2.commands.first(({ state, chain, commands: commands2 }) => [
      () => (
        // Changes list item block to a text block if the content is empty.
        commands2.command(() => {
          if (node2.textContent.length === 0) {
            const currentEl = editor2.view.domAtPos(editor2.state.selection.from).node;
            if (currentEl.closest("table")) {
              return chain().setHardBreak().BNUpdateBlock(state.selection.from, {
                type: "paragraph",
                props: {}
              }).run();
            } else {
              return commands2.BNUpdateBlock(state.selection.from, {
                type: "paragraph",
                props: {}
              });
            }
          }
          return false;
        })
      ),
      () => (
        // Splits the current block, moving content inside that's after the cursor to a new block of the same type
        // below.
        commands2.command(() => {
          if (node2.textContent.length > 0) {
            chain().deleteSelection().BNSplitBlock(state.selection.from, true).run();
            return true;
          }
          return false;
        })
      )
    ]);
  };
  const bulletListItemPropSchema = {
    ...defaultProps
  };
  const BulletListItemBlockContent = createStronglyTypedTiptapNode({
    name: "bulletListItem",
    content: "inline*",
    group: "blockContent",
    addInputRules() {
      return [
        // Creates an unordered list when starting with "-", "+", or "*".
        new InputRule({
          find: new RegExp(`^[-+*]\\s$`),
          handler: ({ state, chain, range }) => {
            chain().BNUpdateBlock(state.selection.from, {
              type: "bulletListItem",
              props: {}
            }).deleteRange({ from: range.from, to: range.to });
          }
        })
      ];
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => handleEnter(this.editor),
        "Mod-Shift-8": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {
          type: "bulletListItem",
          props: {}
        })
      };
    },
    parseHTML() {
      return [
        // Case for regular HTML list structure.
        {
          tag: "div[data-content-type=" + this.name + "]"
          // TODO: remove if we can't come up with test case that needs this
        },
        {
          tag: "li",
          getAttrs: (element2) => {
            if (typeof element2 === "string") {
              return false;
            }
            const parent = element2.parentElement;
            if (parent === null) {
              return false;
            }
            if (parent.tagName === "UL" || parent.tagName === "DIV" && parent.parentElement.tagName === "UL") {
              return {};
            }
            return false;
          },
          node: "bulletListItem"
        },
        // Case for BlockNote list structure.
        {
          tag: "p",
          getAttrs: (element2) => {
            if (typeof element2 === "string") {
              return false;
            }
            const parent = element2.parentElement;
            if (parent === null) {
              return false;
            }
            if (parent.getAttribute("data-content-type") === "bulletListItem") {
              return {};
            }
            return false;
          },
          priority: 300,
          node: "bulletListItem"
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      var _a, _b;
      return createDefaultBlockDOMOutputSpec(
        this.name,
        // We use a <p> tag, because for <li> tags we'd need a <ul> element to put
        // them in to be semantically correct, which we can't have due to the
        // schema.
        "p",
        {
          ...((_a = this.options.domAttributes) == null ? void 0 : _a.blockContent) || {},
          ...HTMLAttributes
        },
        ((_b = this.options.domAttributes) == null ? void 0 : _b.inlineContent) || {}
      );
    }
  });
  const BulletListItem = createBlockSpecFromStronglyTypedTiptapNode(
    BulletListItemBlockContent,
    bulletListItemPropSchema
  );
  const PLUGIN_KEY$3 = new PluginKey(`numbered-list-indexing`);
  const NumberedListIndexingPlugin = () => {
    return new Plugin({
      key: PLUGIN_KEY$3,
      appendTransaction: (_transactions, _oldState, newState) => {
        const tr2 = newState.tr;
        tr2.setMeta("numberedListIndexing", true);
        let modified = false;
        newState.doc.descendants((node2, pos) => {
          if (node2.type.name === "blockContainer" && node2.firstChild.type.name === "numberedListItem") {
            let newIndex = "1";
            const isFirstBlockInDoc = pos === 1;
            const blockInfo = getBlockInfoFromPos(tr2.doc, pos + 1);
            if (blockInfo === void 0) {
              return;
            }
            if (!isFirstBlockInDoc) {
              const prevBlockInfo = getBlockInfoFromPos(tr2.doc, pos - 2);
              if (prevBlockInfo === void 0) {
                return;
              }
              const isFirstBlockInNestingLevel = blockInfo.depth !== prevBlockInfo.depth;
              if (!isFirstBlockInNestingLevel) {
                const prevBlockContentNode = prevBlockInfo.contentNode;
                const prevBlockContentType = prevBlockInfo.contentType;
                const isPrevBlockOrderedListItem = prevBlockContentType.name === "numberedListItem";
                if (isPrevBlockOrderedListItem) {
                  const prevBlockIndex = prevBlockContentNode.attrs["index"];
                  newIndex = (parseInt(prevBlockIndex) + 1).toString();
                }
              }
            }
            const contentNode = blockInfo.contentNode;
            const index2 = contentNode.attrs["index"];
            if (index2 !== newIndex) {
              modified = true;
              tr2.setNodeMarkup(pos + 1, void 0, {
                index: newIndex
              });
            }
          }
        });
        return modified ? tr2 : null;
      }
    });
  };
  const numberedListItemPropSchema = {
    ...defaultProps
  };
  const NumberedListItemBlockContent = createStronglyTypedTiptapNode({
    name: "numberedListItem",
    content: "inline*",
    group: "blockContent",
    addAttributes() {
      return {
        index: {
          default: null,
          parseHTML: (element2) => element2.getAttribute("data-index"),
          renderHTML: (attributes) => {
            return {
              "data-index": attributes.index
            };
          }
        }
      };
    },
    addInputRules() {
      return [
        // Creates an ordered list when starting with "1.".
        new InputRule({
          find: new RegExp(`^1\\.\\s$`),
          handler: ({ state, chain, range }) => {
            chain().BNUpdateBlock(state.selection.from, {
              type: "numberedListItem",
              props: {}
            }).deleteRange({ from: range.from, to: range.to });
          }
        })
      ];
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => handleEnter(this.editor),
        "Mod-Shift-7": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {
          type: "numberedListItem",
          props: {}
        })
      };
    },
    addProseMirrorPlugins() {
      return [NumberedListIndexingPlugin()];
    },
    parseHTML() {
      return [
        {
          tag: "div[data-content-type=" + this.name + "]"
          // TODO: remove if we can't come up with test case that needs this
        },
        // Case for regular HTML list structure.
        // (e.g.: when pasting from other apps)
        {
          tag: "li",
          getAttrs: (element2) => {
            if (typeof element2 === "string") {
              return false;
            }
            const parent = element2.parentElement;
            if (parent === null) {
              return false;
            }
            if (parent.tagName === "OL" || parent.tagName === "DIV" && parent.parentElement.tagName === "OL") {
              return {};
            }
            return false;
          },
          node: "numberedListItem"
        },
        // Case for BlockNote list structure.
        // (e.g.: when pasting from blocknote)
        {
          tag: "p",
          getAttrs: (element2) => {
            if (typeof element2 === "string") {
              return false;
            }
            const parent = element2.parentElement;
            if (parent === null) {
              return false;
            }
            if (parent.getAttribute("data-content-type") === "numberedListItem") {
              return {};
            }
            return false;
          },
          priority: 300,
          node: "numberedListItem"
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      var _a, _b;
      return createDefaultBlockDOMOutputSpec(
        this.name,
        // We use a <p> tag, because for <li> tags we'd need an <ol> element to
        // put them in to be semantically correct, which we can't have due to the
        // schema.
        "p",
        {
          ...((_a = this.options.domAttributes) == null ? void 0 : _a.blockContent) || {},
          ...HTMLAttributes
        },
        ((_b = this.options.domAttributes) == null ? void 0 : _b.inlineContent) || {}
      );
    }
  });
  const NumberedListItem = createBlockSpecFromStronglyTypedTiptapNode(
    NumberedListItemBlockContent,
    numberedListItemPropSchema
  );
  const paragraphPropSchema = {
    ...defaultProps
  };
  const ParagraphBlockContent = createStronglyTypedTiptapNode({
    name: "paragraph",
    content: "inline*",
    group: "blockContent",
    addKeyboardShortcuts() {
      return {
        Enter: () => handleEnter(this.editor),
        "Mod-Alt-0": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {
          type: "paragraph",
          props: {}
        })
      };
    },
    parseHTML() {
      return [
        { tag: "div[data-content-type=" + this.name + "]" },
        {
          tag: "p",
          priority: 200,
          node: "paragraph"
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      var _a, _b;
      return createDefaultBlockDOMOutputSpec(
        this.name,
        "p",
        {
          ...((_a = this.options.domAttributes) == null ? void 0 : _a.blockContent) || {},
          ...HTMLAttributes
        },
        ((_b = this.options.domAttributes) == null ? void 0 : _b.inlineContent) || {}
      );
    }
  });
  const Paragraph = createBlockSpecFromStronglyTypedTiptapNode(
    ParagraphBlockContent,
    paragraphPropSchema
  );
  const TableCell = Node.create({
    name: "tableCell",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    content: "block+",
    addAttributes() {
      return {
        colspan: {
          default: 1
        },
        rowspan: {
          default: 1
        },
        colwidth: {
          default: null,
          parseHTML: (element2) => {
            const colwidth = element2.getAttribute("colwidth");
            const value = colwidth ? [parseInt(colwidth, 10)] : null;
            return value;
          }
        }
      };
    },
    tableRole: "cell",
    isolating: true,
    parseHTML() {
      return [
        { tag: "td" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["td", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    }
  });
  const TableHeader = Node.create({
    name: "tableHeader",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    content: "block+",
    addAttributes() {
      return {
        colspan: {
          default: 1
        },
        rowspan: {
          default: 1
        },
        colwidth: {
          default: null,
          parseHTML: (element2) => {
            const colwidth = element2.getAttribute("colwidth");
            const value = colwidth ? [parseInt(colwidth, 10)] : null;
            return value;
          }
        }
      };
    },
    tableRole: "header_cell",
    isolating: true,
    parseHTML() {
      return [
        { tag: "th" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["th", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    }
  });
  const TableRow = Node.create({
    name: "tableRow",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    content: "(tableCell | tableHeader)*",
    tableRole: "row",
    parseHTML() {
      return [
        { tag: "tr" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["tr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    }
  });
  var readFromCache;
  var addToCache;
  if (typeof WeakMap != "undefined") {
    let cache = /* @__PURE__ */ new WeakMap();
    readFromCache = (key2) => cache.get(key2);
    addToCache = (key2, value) => {
      cache.set(key2, value);
      return value;
    };
  } else {
    const cache = [];
    const cacheSize = 10;
    let cachePos = 0;
    readFromCache = (key2) => {
      for (let i2 = 0; i2 < cache.length; i2 += 2)
        if (cache[i2] == key2)
          return cache[i2 + 1];
    };
    addToCache = (key2, value) => {
      if (cachePos == cacheSize)
        cachePos = 0;
      cache[cachePos++] = key2;
      return cache[cachePos++] = value;
    };
  }
  var TableMap = class {
    constructor(width, height, map2, problems) {
      this.width = width;
      this.height = height;
      this.map = map2;
      this.problems = problems;
    }
    // Find the dimensions of the cell at the given position.
    findCell(pos) {
      for (let i2 = 0; i2 < this.map.length; i2++) {
        const curPos = this.map[i2];
        if (curPos != pos)
          continue;
        const left = i2 % this.width;
        const top = i2 / this.width | 0;
        let right = left + 1;
        let bottom = top + 1;
        for (let j = 1; right < this.width && this.map[i2 + j] == curPos; j++) {
          right++;
        }
        for (let j = 1; bottom < this.height && this.map[i2 + this.width * j] == curPos; j++) {
          bottom++;
        }
        return { left, top, right, bottom };
      }
      throw new RangeError(`No cell with offset ${pos} found`);
    }
    // Find the left side of the cell at the given position.
    colCount(pos) {
      for (let i2 = 0; i2 < this.map.length; i2++) {
        if (this.map[i2] == pos) {
          return i2 % this.width;
        }
      }
      throw new RangeError(`No cell with offset ${pos} found`);
    }
    // Find the next cell in the given direction, starting from the cell
    // at `pos`, if any.
    nextCell(pos, axis, dir) {
      const { left, right, top, bottom } = this.findCell(pos);
      if (axis == "horiz") {
        if (dir < 0 ? left == 0 : right == this.width)
          return null;
        return this.map[top * this.width + (dir < 0 ? left - 1 : right)];
      } else {
        if (dir < 0 ? top == 0 : bottom == this.height)
          return null;
        return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];
      }
    }
    // Get the rectangle spanning the two given cells.
    rectBetween(a2, b) {
      const {
        left: leftA,
        right: rightA,
        top: topA,
        bottom: bottomA
      } = this.findCell(a2);
      const {
        left: leftB,
        right: rightB,
        top: topB,
        bottom: bottomB
      } = this.findCell(b);
      return {
        left: Math.min(leftA, leftB),
        top: Math.min(topA, topB),
        right: Math.max(rightA, rightB),
        bottom: Math.max(bottomA, bottomB)
      };
    }
    // Return the position of all cells that have the top left corner in
    // the given rectangle.
    cellsInRect(rect) {
      const result = [];
      const seen = {};
      for (let row2 = rect.top; row2 < rect.bottom; row2++) {
        for (let col = rect.left; col < rect.right; col++) {
          const index2 = row2 * this.width + col;
          const pos = this.map[index2];
          if (seen[pos])
            continue;
          seen[pos] = true;
          if (col == rect.left && col && this.map[index2 - 1] == pos || row2 == rect.top && row2 && this.map[index2 - this.width] == pos) {
            continue;
          }
          result.push(pos);
        }
      }
      return result;
    }
    // Return the position at which the cell at the given row and column
    // starts, or would start, if a cell started there.
    positionAt(row2, col, table2) {
      for (let i2 = 0, rowStart = 0; ; i2++) {
        const rowEnd = rowStart + table2.child(i2).nodeSize;
        if (i2 == row2) {
          let index2 = col + row2 * this.width;
          const rowEndIndex = (row2 + 1) * this.width;
          while (index2 < rowEndIndex && this.map[index2] < rowStart)
            index2++;
          return index2 == rowEndIndex ? rowEnd - 1 : this.map[index2];
        }
        rowStart = rowEnd;
      }
    }
    // Find the table map for the given table node.
    static get(table2) {
      return readFromCache(table2) || addToCache(table2, computeMap(table2));
    }
  };
  function computeMap(table2) {
    if (table2.type.spec.tableRole != "table")
      throw new RangeError("Not a table node: " + table2.type.name);
    const width = findWidth(table2), height = table2.childCount;
    const map2 = [];
    let mapPos = 0;
    let problems = null;
    const colWidths = [];
    for (let i2 = 0, e = width * height; i2 < e; i2++)
      map2[i2] = 0;
    for (let row2 = 0, pos = 0; row2 < height; row2++) {
      const rowNode = table2.child(row2);
      pos++;
      for (let i2 = 0; ; i2++) {
        while (mapPos < map2.length && map2[mapPos] != 0)
          mapPos++;
        if (i2 == rowNode.childCount)
          break;
        const cellNode = rowNode.child(i2);
        const { colspan, rowspan, colwidth } = cellNode.attrs;
        for (let h2 = 0; h2 < rowspan; h2++) {
          if (h2 + row2 >= height) {
            (problems || (problems = [])).push({
              type: "overlong_rowspan",
              pos,
              n: rowspan - h2
            });
            break;
          }
          const start = mapPos + h2 * width;
          for (let w = 0; w < colspan; w++) {
            if (map2[start + w] == 0)
              map2[start + w] = pos;
            else
              (problems || (problems = [])).push({
                type: "collision",
                row: row2,
                pos,
                n: colspan - w
              });
            const colW = colwidth && colwidth[w];
            if (colW) {
              const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];
              if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
                colWidths[widthIndex] = colW;
                colWidths[widthIndex + 1] = 1;
              } else if (prev == colW) {
                colWidths[widthIndex + 1]++;
              }
            }
          }
        }
        mapPos += colspan;
        pos += cellNode.nodeSize;
      }
      const expectedPos = (row2 + 1) * width;
      let missing = 0;
      while (mapPos < expectedPos)
        if (map2[mapPos++] == 0)
          missing++;
      if (missing)
        (problems || (problems = [])).push({ type: "missing", row: row2, n: missing });
      pos++;
    }
    const tableMap = new TableMap(width, height, map2, problems);
    let badWidths = false;
    for (let i2 = 0; !badWidths && i2 < colWidths.length; i2 += 2)
      if (colWidths[i2] != null && colWidths[i2 + 1] < height)
        badWidths = true;
    if (badWidths)
      findBadColWidths(tableMap, colWidths, table2);
    return tableMap;
  }
  function findWidth(table2) {
    let width = -1;
    let hasRowSpan = false;
    for (let row2 = 0; row2 < table2.childCount; row2++) {
      const rowNode = table2.child(row2);
      let rowWidth = 0;
      if (hasRowSpan)
        for (let j = 0; j < row2; j++) {
          const prevRow = table2.child(j);
          for (let i2 = 0; i2 < prevRow.childCount; i2++) {
            const cell2 = prevRow.child(i2);
            if (j + cell2.attrs.rowspan > row2)
              rowWidth += cell2.attrs.colspan;
          }
        }
      for (let i2 = 0; i2 < rowNode.childCount; i2++) {
        const cell2 = rowNode.child(i2);
        rowWidth += cell2.attrs.colspan;
        if (cell2.attrs.rowspan > 1)
          hasRowSpan = true;
      }
      if (width == -1)
        width = rowWidth;
      else if (width != rowWidth)
        width = Math.max(width, rowWidth);
    }
    return width;
  }
  function findBadColWidths(map2, colWidths, table2) {
    if (!map2.problems)
      map2.problems = [];
    const seen = {};
    for (let i2 = 0; i2 < map2.map.length; i2++) {
      const pos = map2.map[i2];
      if (seen[pos])
        continue;
      seen[pos] = true;
      const node2 = table2.nodeAt(pos);
      if (!node2) {
        throw new RangeError(`No cell with offset ${pos} found`);
      }
      let updated = null;
      const attrs = node2.attrs;
      for (let j = 0; j < attrs.colspan; j++) {
        const col = (i2 + j) % map2.width;
        const colWidth = colWidths[col * 2];
        if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))
          (updated || (updated = freshColWidth(attrs)))[j] = colWidth;
      }
      if (updated)
        map2.problems.unshift({
          type: "colwidth mismatch",
          pos,
          colwidth: updated
        });
    }
  }
  function freshColWidth(attrs) {
    if (attrs.colwidth)
      return attrs.colwidth.slice();
    const result = [];
    for (let i2 = 0; i2 < attrs.colspan; i2++)
      result.push(0);
    return result;
  }
  function tableNodeTypes(schema) {
    let result = schema.cached.tableNodeTypes;
    if (!result) {
      result = schema.cached.tableNodeTypes = {};
      for (const name in schema.nodes) {
        const type = schema.nodes[name], role = type.spec.tableRole;
        if (role)
          result[role] = type;
      }
    }
    return result;
  }
  var tableEditingKey = new PluginKey("selectingCells");
  function cellAround($pos) {
    for (let d = $pos.depth - 1; d > 0; d--)
      if ($pos.node(d).type.spec.tableRole == "row")
        return $pos.node(0).resolve($pos.before(d + 1));
    return null;
  }
  function isInTable(state) {
    const $head = state.selection.$head;
    for (let d = $head.depth; d > 0; d--)
      if ($head.node(d).type.spec.tableRole == "row")
        return true;
    return false;
  }
  function selectionCell(state) {
    const sel = state.selection;
    if ("$anchorCell" in sel && sel.$anchorCell) {
      return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
    } else if ("node" in sel && sel.node && sel.node.type.spec.tableRole == "cell") {
      return sel.$anchor;
    }
    const $cell = cellAround(sel.$head) || cellNear(sel.$head);
    if ($cell) {
      return $cell;
    }
    throw new RangeError(`No cell found around position ${sel.head}`);
  }
  function cellNear($pos) {
    for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {
      const role = after.type.spec.tableRole;
      if (role == "cell" || role == "header_cell")
        return $pos.doc.resolve(pos);
    }
    for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {
      const role = before.type.spec.tableRole;
      if (role == "cell" || role == "header_cell")
        return $pos.doc.resolve(pos - before.nodeSize);
    }
  }
  function pointsAtCell($pos) {
    return $pos.parent.type.spec.tableRole == "row" && !!$pos.nodeAfter;
  }
  function moveCellForward($pos) {
    return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);
  }
  function inSameTable($cellA, $cellB) {
    return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);
  }
  function nextCell($pos, axis, dir) {
    const table2 = $pos.node(-1);
    const map2 = TableMap.get(table2);
    const tableStart = $pos.start(-1);
    const moved = map2.nextCell($pos.pos - tableStart, axis, dir);
    return moved == null ? null : $pos.node(0).resolve(tableStart + moved);
  }
  function removeColSpan(attrs, pos, n = 1) {
    const result = { ...attrs, colspan: attrs.colspan - n };
    if (result.colwidth) {
      result.colwidth = result.colwidth.slice();
      result.colwidth.splice(pos, n);
      if (!result.colwidth.some((w) => w > 0))
        result.colwidth = null;
    }
    return result;
  }
  var CellSelection = class _CellSelection extends Selection {
    // A table selection is identified by its anchor and head cells. The
    // positions given to this constructor should point _before_ two
    // cells in the same table. They may be the same, to select a single
    // cell.
    constructor($anchorCell, $headCell = $anchorCell) {
      const table2 = $anchorCell.node(-1);
      const map2 = TableMap.get(table2);
      const tableStart = $anchorCell.start(-1);
      const rect = map2.rectBetween(
        $anchorCell.pos - tableStart,
        $headCell.pos - tableStart
      );
      const doc2 = $anchorCell.node(0);
      const cells2 = map2.cellsInRect(rect).filter((p2) => p2 != $headCell.pos - tableStart);
      cells2.unshift($headCell.pos - tableStart);
      const ranges = cells2.map((pos) => {
        const cell2 = table2.nodeAt(pos);
        if (!cell2) {
          throw RangeError(`No cell with offset ${pos} found`);
        }
        const from2 = tableStart + pos + 1;
        return new SelectionRange(
          doc2.resolve(from2),
          doc2.resolve(from2 + cell2.content.size)
        );
      });
      super(ranges[0].$from, ranges[0].$to, ranges);
      this.$anchorCell = $anchorCell;
      this.$headCell = $headCell;
    }
    map(doc2, mapping) {
      const $anchorCell = doc2.resolve(mapping.map(this.$anchorCell.pos));
      const $headCell = doc2.resolve(mapping.map(this.$headCell.pos));
      if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
        const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
        if (tableChanged && this.isRowSelection())
          return _CellSelection.rowSelection($anchorCell, $headCell);
        else if (tableChanged && this.isColSelection())
          return _CellSelection.colSelection($anchorCell, $headCell);
        else
          return new _CellSelection($anchorCell, $headCell);
      }
      return TextSelection.between($anchorCell, $headCell);
    }
    // Returns a rectangular slice of table rows containing the selected
    // cells.
    content() {
      const table2 = this.$anchorCell.node(-1);
      const map2 = TableMap.get(table2);
      const tableStart = this.$anchorCell.start(-1);
      const rect = map2.rectBetween(
        this.$anchorCell.pos - tableStart,
        this.$headCell.pos - tableStart
      );
      const seen = {};
      const rows = [];
      for (let row2 = rect.top; row2 < rect.bottom; row2++) {
        const rowContent = [];
        for (let index2 = row2 * map2.width + rect.left, col = rect.left; col < rect.right; col++, index2++) {
          const pos = map2.map[index2];
          if (seen[pos])
            continue;
          seen[pos] = true;
          const cellRect = map2.findCell(pos);
          let cell2 = table2.nodeAt(pos);
          if (!cell2) {
            throw RangeError(`No cell with offset ${pos} found`);
          }
          const extraLeft = rect.left - cellRect.left;
          const extraRight = cellRect.right - rect.right;
          if (extraLeft > 0 || extraRight > 0) {
            let attrs = cell2.attrs;
            if (extraLeft > 0) {
              attrs = removeColSpan(attrs, 0, extraLeft);
            }
            if (extraRight > 0) {
              attrs = removeColSpan(
                attrs,
                attrs.colspan - extraRight,
                extraRight
              );
            }
            if (cellRect.left < rect.left) {
              cell2 = cell2.type.createAndFill(attrs);
              if (!cell2) {
                throw RangeError(
                  `Could not create cell with attrs ${JSON.stringify(attrs)}`
                );
              }
            } else {
              cell2 = cell2.type.create(attrs, cell2.content);
            }
          }
          if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
            const attrs = {
              ...cell2.attrs,
              rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)
            };
            if (cellRect.top < rect.top) {
              cell2 = cell2.type.createAndFill(attrs);
            } else {
              cell2 = cell2.type.create(attrs, cell2.content);
            }
          }
          rowContent.push(cell2);
        }
        rows.push(table2.child(row2).copy(Fragment.from(rowContent)));
      }
      const fragment = this.isColSelection() && this.isRowSelection() ? table2 : rows;
      return new Slice(Fragment.from(fragment), 1, 1);
    }
    replace(tr2, content2 = Slice.empty) {
      const mapFrom = tr2.steps.length, ranges = this.ranges;
      for (let i2 = 0; i2 < ranges.length; i2++) {
        const { $from, $to } = ranges[i2], mapping = tr2.mapping.slice(mapFrom);
        tr2.replace(
          mapping.map($from.pos),
          mapping.map($to.pos),
          i2 ? Slice.empty : content2
        );
      }
      const sel = Selection.findFrom(
        tr2.doc.resolve(tr2.mapping.slice(mapFrom).map(this.to)),
        -1
      );
      if (sel)
        tr2.setSelection(sel);
    }
    replaceWith(tr2, node2) {
      this.replace(tr2, new Slice(Fragment.from(node2), 0, 0));
    }
    forEachCell(f) {
      const table2 = this.$anchorCell.node(-1);
      const map2 = TableMap.get(table2);
      const tableStart = this.$anchorCell.start(-1);
      const cells2 = map2.cellsInRect(
        map2.rectBetween(
          this.$anchorCell.pos - tableStart,
          this.$headCell.pos - tableStart
        )
      );
      for (let i2 = 0; i2 < cells2.length; i2++) {
        f(table2.nodeAt(cells2[i2]), tableStart + cells2[i2]);
      }
    }
    // True if this selection goes all the way from the top to the
    // bottom of the table.
    isColSelection() {
      const anchorTop = this.$anchorCell.index(-1);
      const headTop = this.$headCell.index(-1);
      if (Math.min(anchorTop, headTop) > 0)
        return false;
      const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;
      const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;
      return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;
    }
    // Returns the smallest column selection that covers the given anchor
    // and head cell.
    static colSelection($anchorCell, $headCell = $anchorCell) {
      const table2 = $anchorCell.node(-1);
      const map2 = TableMap.get(table2);
      const tableStart = $anchorCell.start(-1);
      const anchorRect = map2.findCell($anchorCell.pos - tableStart);
      const headRect = map2.findCell($headCell.pos - tableStart);
      const doc2 = $anchorCell.node(0);
      if (anchorRect.top <= headRect.top) {
        if (anchorRect.top > 0)
          $anchorCell = doc2.resolve(tableStart + map2.map[anchorRect.left]);
        if (headRect.bottom < map2.height)
          $headCell = doc2.resolve(
            tableStart + map2.map[map2.width * (map2.height - 1) + headRect.right - 1]
          );
      } else {
        if (headRect.top > 0)
          $headCell = doc2.resolve(tableStart + map2.map[headRect.left]);
        if (anchorRect.bottom < map2.height)
          $anchorCell = doc2.resolve(
            tableStart + map2.map[map2.width * (map2.height - 1) + anchorRect.right - 1]
          );
      }
      return new _CellSelection($anchorCell, $headCell);
    }
    // True if this selection goes all the way from the left to the
    // right of the table.
    isRowSelection() {
      const table2 = this.$anchorCell.node(-1);
      const map2 = TableMap.get(table2);
      const tableStart = this.$anchorCell.start(-1);
      const anchorLeft = map2.colCount(this.$anchorCell.pos - tableStart);
      const headLeft = map2.colCount(this.$headCell.pos - tableStart);
      if (Math.min(anchorLeft, headLeft) > 0)
        return false;
      const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;
      const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
      return Math.max(anchorRight, headRight) == map2.width;
    }
    eq(other) {
      return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
    }
    // Returns the smallest row selection that covers the given anchor
    // and head cell.
    static rowSelection($anchorCell, $headCell = $anchorCell) {
      const table2 = $anchorCell.node(-1);
      const map2 = TableMap.get(table2);
      const tableStart = $anchorCell.start(-1);
      const anchorRect = map2.findCell($anchorCell.pos - tableStart);
      const headRect = map2.findCell($headCell.pos - tableStart);
      const doc2 = $anchorCell.node(0);
      if (anchorRect.left <= headRect.left) {
        if (anchorRect.left > 0)
          $anchorCell = doc2.resolve(
            tableStart + map2.map[anchorRect.top * map2.width]
          );
        if (headRect.right < map2.width)
          $headCell = doc2.resolve(
            tableStart + map2.map[map2.width * (headRect.top + 1) - 1]
          );
      } else {
        if (headRect.left > 0)
          $headCell = doc2.resolve(tableStart + map2.map[headRect.top * map2.width]);
        if (anchorRect.right < map2.width)
          $anchorCell = doc2.resolve(
            tableStart + map2.map[map2.width * (anchorRect.top + 1) - 1]
          );
      }
      return new _CellSelection($anchorCell, $headCell);
    }
    toJSON() {
      return {
        type: "cell",
        anchor: this.$anchorCell.pos,
        head: this.$headCell.pos
      };
    }
    static fromJSON(doc2, json) {
      return new _CellSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
    }
    static create(doc2, anchorCell, headCell = anchorCell) {
      return new _CellSelection(doc2.resolve(anchorCell), doc2.resolve(headCell));
    }
    getBookmark() {
      return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
    }
  };
  CellSelection.prototype.visible = false;
  Selection.jsonID("cell", CellSelection);
  var CellBookmark = class _CellBookmark {
    constructor(anchor, head2) {
      this.anchor = anchor;
      this.head = head2;
    }
    map(mapping) {
      return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));
    }
    resolve(doc2) {
      const $anchorCell = doc2.resolve(this.anchor), $headCell = doc2.resolve(this.head);
      if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))
        return new CellSelection($anchorCell, $headCell);
      else
        return Selection.near($headCell, 1);
    }
  };
  function drawCellSelection(state) {
    if (!(state.selection instanceof CellSelection))
      return null;
    const cells2 = [];
    state.selection.forEachCell((node2, pos) => {
      cells2.push(
        Decoration.node(pos, pos + node2.nodeSize, { class: "selectedCell" })
      );
    });
    return DecorationSet.create(state.doc, cells2);
  }
  function isCellBoundarySelection({ $from, $to }) {
    if ($from.pos == $to.pos || $from.pos < $from.pos - 6)
      return false;
    let afterFrom = $from.pos;
    let beforeTo = $to.pos;
    let depth = $from.depth;
    for (; depth >= 0; depth--, afterFrom++)
      if ($from.after(depth + 1) < $from.end(depth))
        break;
    for (let d = $to.depth; d >= 0; d--, beforeTo--)
      if ($to.before(d + 1) > $to.start(d))
        break;
    return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
  }
  function isTextSelectionAcrossCells({ $from, $to }) {
    let fromCellBoundaryNode;
    let toCellBoundaryNode;
    for (let i2 = $from.depth; i2 > 0; i2--) {
      const node2 = $from.node(i2);
      if (node2.type.spec.tableRole === "cell" || node2.type.spec.tableRole === "header_cell") {
        fromCellBoundaryNode = node2;
        break;
      }
    }
    for (let i2 = $to.depth; i2 > 0; i2--) {
      const node2 = $to.node(i2);
      if (node2.type.spec.tableRole === "cell" || node2.type.spec.tableRole === "header_cell") {
        toCellBoundaryNode = node2;
        break;
      }
    }
    return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
  }
  function normalizeSelection(state, tr2, allowTableNodeSelection) {
    const sel = (tr2 || state).selection;
    const doc2 = (tr2 || state).doc;
    let normalize2;
    let role;
    if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {
      if (role == "cell" || role == "header_cell") {
        normalize2 = CellSelection.create(doc2, sel.from);
      } else if (role == "row") {
        const $cell = doc2.resolve(sel.from + 1);
        normalize2 = CellSelection.rowSelection($cell, $cell);
      } else if (!allowTableNodeSelection) {
        const map2 = TableMap.get(sel.node);
        const start = sel.from + 1;
        const lastCell = start + map2.map[map2.width * map2.height - 1];
        normalize2 = CellSelection.create(doc2, start + 1, lastCell);
      }
    } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {
      normalize2 = TextSelection.create(doc2, sel.from);
    } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {
      normalize2 = TextSelection.create(doc2, sel.$from.start(), sel.$from.end());
    }
    if (normalize2)
      (tr2 || (tr2 = state.tr)).setSelection(normalize2);
    return tr2;
  }
  var fixTablesKey = new PluginKey("fix-tables");
  function changedDescendants(old, cur, offset, f) {
    const oldSize = old.childCount, curSize = cur.childCount;
    outer:
      for (let i2 = 0, j = 0; i2 < curSize; i2++) {
        const child = cur.child(i2);
        for (let scan = j, e = Math.min(oldSize, i2 + 3); scan < e; scan++) {
          if (old.child(scan) == child) {
            j = scan + 1;
            offset += child.nodeSize;
            continue outer;
          }
        }
        f(child, offset);
        if (j < oldSize && old.child(j).sameMarkup(child))
          changedDescendants(old.child(j), child, offset + 1, f);
        else
          child.nodesBetween(0, child.content.size, f, offset + 1);
        offset += child.nodeSize;
      }
  }
  function fixTables(state, oldState) {
    let tr2;
    const check = (node2, pos) => {
      if (node2.type.spec.tableRole == "table")
        tr2 = fixTable(state, node2, pos, tr2);
    };
    if (!oldState)
      state.doc.descendants(check);
    else if (oldState.doc != state.doc)
      changedDescendants(oldState.doc, state.doc, 0, check);
    return tr2;
  }
  function fixTable(state, table2, tablePos, tr2) {
    const map2 = TableMap.get(table2);
    if (!map2.problems)
      return tr2;
    if (!tr2)
      tr2 = state.tr;
    const mustAdd = [];
    for (let i2 = 0; i2 < map2.height; i2++)
      mustAdd.push(0);
    for (let i2 = 0; i2 < map2.problems.length; i2++) {
      const prob = map2.problems[i2];
      if (prob.type == "collision") {
        const cell2 = table2.nodeAt(prob.pos);
        if (!cell2)
          continue;
        const attrs = cell2.attrs;
        for (let j = 0; j < attrs.rowspan; j++)
          mustAdd[prob.row + j] += prob.n;
        tr2.setNodeMarkup(
          tr2.mapping.map(tablePos + 1 + prob.pos),
          null,
          removeColSpan(attrs, attrs.colspan - prob.n, prob.n)
        );
      } else if (prob.type == "missing") {
        mustAdd[prob.row] += prob.n;
      } else if (prob.type == "overlong_rowspan") {
        const cell2 = table2.nodeAt(prob.pos);
        if (!cell2)
          continue;
        tr2.setNodeMarkup(tr2.mapping.map(tablePos + 1 + prob.pos), null, {
          ...cell2.attrs,
          rowspan: cell2.attrs.rowspan - prob.n
        });
      } else if (prob.type == "colwidth mismatch") {
        const cell2 = table2.nodeAt(prob.pos);
        if (!cell2)
          continue;
        tr2.setNodeMarkup(tr2.mapping.map(tablePos + 1 + prob.pos), null, {
          ...cell2.attrs,
          colwidth: prob.colwidth
        });
      }
    }
    let first2, last2;
    for (let i2 = 0; i2 < mustAdd.length; i2++)
      if (mustAdd[i2]) {
        if (first2 == null)
          first2 = i2;
        last2 = i2;
      }
    for (let i2 = 0, pos = tablePos + 1; i2 < map2.height; i2++) {
      const row2 = table2.child(i2);
      const end = pos + row2.nodeSize;
      const add = mustAdd[i2];
      if (add > 0) {
        let role = "cell";
        if (row2.firstChild) {
          role = row2.firstChild.type.spec.tableRole;
        }
        const nodes = [];
        for (let j = 0; j < add; j++) {
          const node2 = tableNodeTypes(state.schema)[role].createAndFill();
          if (node2)
            nodes.push(node2);
        }
        const side = (i2 == 0 || first2 == i2 - 1) && last2 == i2 ? pos + 1 : end - 1;
        tr2.insert(tr2.mapping.map(side), nodes);
      }
      pos = end;
    }
    return tr2.setMeta(fixTablesKey, { fixTables: true });
  }
  function pastedCells(slice) {
    if (!slice.size)
      return null;
    let { content: content2, openStart, openEnd } = slice;
    while (content2.childCount == 1 && (openStart > 0 && openEnd > 0 || content2.child(0).type.spec.tableRole == "table")) {
      openStart--;
      openEnd--;
      content2 = content2.child(0).content;
    }
    const first2 = content2.child(0);
    const role = first2.type.spec.tableRole;
    const schema = first2.type.schema, rows = [];
    if (role == "row") {
      for (let i2 = 0; i2 < content2.childCount; i2++) {
        let cells2 = content2.child(i2).content;
        const left = i2 ? 0 : Math.max(0, openStart - 1);
        const right = i2 < content2.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
        if (left || right)
          cells2 = fitSlice(
            tableNodeTypes(schema).row,
            new Slice(cells2, left, right)
          ).content;
        rows.push(cells2);
      }
    } else if (role == "cell" || role == "header_cell") {
      rows.push(
        openStart || openEnd ? fitSlice(
          tableNodeTypes(schema).row,
          new Slice(content2, openStart, openEnd)
        ).content : content2
      );
    } else {
      return null;
    }
    return ensureRectangular(schema, rows);
  }
  function ensureRectangular(schema, rows) {
    const widths = [];
    for (let i2 = 0; i2 < rows.length; i2++) {
      const row2 = rows[i2];
      for (let j = row2.childCount - 1; j >= 0; j--) {
        const { rowspan, colspan } = row2.child(j).attrs;
        for (let r = i2; r < i2 + rowspan; r++)
          widths[r] = (widths[r] || 0) + colspan;
      }
    }
    let width = 0;
    for (let r = 0; r < widths.length; r++)
      width = Math.max(width, widths[r]);
    for (let r = 0; r < widths.length; r++) {
      if (r >= rows.length)
        rows.push(Fragment.empty);
      if (widths[r] < width) {
        const empty2 = tableNodeTypes(schema).cell.createAndFill();
        const cells2 = [];
        for (let i2 = widths[r]; i2 < width; i2++) {
          cells2.push(empty2);
        }
        rows[r] = rows[r].append(Fragment.from(cells2));
      }
    }
    return { height: rows.length, width, rows };
  }
  function fitSlice(nodeType, slice) {
    const node2 = nodeType.createAndFill();
    const tr2 = new Transform(node2).replace(0, node2.content.size, slice);
    return tr2.doc;
  }
  function clipCells({ width, height, rows }, newWidth, newHeight) {
    if (width != newWidth) {
      const added = [];
      const newRows = [];
      for (let row2 = 0; row2 < rows.length; row2++) {
        const frag = rows[row2], cells2 = [];
        for (let col = added[row2] || 0, i2 = 0; col < newWidth; i2++) {
          let cell2 = frag.child(i2 % frag.childCount);
          if (col + cell2.attrs.colspan > newWidth)
            cell2 = cell2.type.createChecked(
              removeColSpan(
                cell2.attrs,
                cell2.attrs.colspan,
                col + cell2.attrs.colspan - newWidth
              ),
              cell2.content
            );
          cells2.push(cell2);
          col += cell2.attrs.colspan;
          for (let j = 1; j < cell2.attrs.rowspan; j++)
            added[row2 + j] = (added[row2 + j] || 0) + cell2.attrs.colspan;
        }
        newRows.push(Fragment.from(cells2));
      }
      rows = newRows;
      width = newWidth;
    }
    if (height != newHeight) {
      const newRows = [];
      for (let row2 = 0, i2 = 0; row2 < newHeight; row2++, i2++) {
        const cells2 = [], source2 = rows[i2 % height];
        for (let j = 0; j < source2.childCount; j++) {
          let cell2 = source2.child(j);
          if (row2 + cell2.attrs.rowspan > newHeight)
            cell2 = cell2.type.create(
              {
                ...cell2.attrs,
                rowspan: Math.max(1, newHeight - cell2.attrs.rowspan)
              },
              cell2.content
            );
          cells2.push(cell2);
        }
        newRows.push(Fragment.from(cells2));
      }
      rows = newRows;
      height = newHeight;
    }
    return { width, height, rows };
  }
  function growTable(tr2, map2, table2, start, width, height, mapFrom) {
    const schema = tr2.doc.type.schema;
    const types2 = tableNodeTypes(schema);
    let empty2;
    let emptyHead;
    if (width > map2.width) {
      for (let row2 = 0, rowEnd = 0; row2 < map2.height; row2++) {
        const rowNode = table2.child(row2);
        rowEnd += rowNode.nodeSize;
        const cells2 = [];
        let add;
        if (rowNode.lastChild == null || rowNode.lastChild.type == types2.cell)
          add = empty2 || (empty2 = types2.cell.createAndFill());
        else
          add = emptyHead || (emptyHead = types2.header_cell.createAndFill());
        for (let i2 = map2.width; i2 < width; i2++)
          cells2.push(add);
        tr2.insert(tr2.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells2);
      }
    }
    if (height > map2.height) {
      const cells2 = [];
      for (let i2 = 0, start2 = (map2.height - 1) * map2.width; i2 < Math.max(map2.width, width); i2++) {
        const header = i2 >= map2.width ? false : table2.nodeAt(map2.map[start2 + i2]).type == types2.header_cell;
        cells2.push(
          header ? emptyHead || (emptyHead = types2.header_cell.createAndFill()) : empty2 || (empty2 = types2.cell.createAndFill())
        );
      }
      const emptyRow = types2.row.create(null, Fragment.from(cells2)), rows = [];
      for (let i2 = map2.height; i2 < height; i2++)
        rows.push(emptyRow);
      tr2.insert(tr2.mapping.slice(mapFrom).map(start + table2.nodeSize - 2), rows);
    }
    return !!(empty2 || emptyHead);
  }
  function isolateHorizontal(tr2, map2, table2, start, left, right, top, mapFrom) {
    if (top == 0 || top == map2.height)
      return false;
    let found2 = false;
    for (let col = left; col < right; col++) {
      const index2 = top * map2.width + col, pos = map2.map[index2];
      if (map2.map[index2 - map2.width] == pos) {
        found2 = true;
        const cell2 = table2.nodeAt(pos);
        const { top: cellTop, left: cellLeft } = map2.findCell(pos);
        tr2.setNodeMarkup(tr2.mapping.slice(mapFrom).map(pos + start), null, {
          ...cell2.attrs,
          rowspan: top - cellTop
        });
        tr2.insert(
          tr2.mapping.slice(mapFrom).map(map2.positionAt(top, cellLeft, table2)),
          cell2.type.createAndFill({
            ...cell2.attrs,
            rowspan: cellTop + cell2.attrs.rowspan - top
          })
        );
        col += cell2.attrs.colspan - 1;
      }
    }
    return found2;
  }
  function isolateVertical(tr2, map2, table2, start, top, bottom, left, mapFrom) {
    if (left == 0 || left == map2.width)
      return false;
    let found2 = false;
    for (let row2 = top; row2 < bottom; row2++) {
      const index2 = row2 * map2.width + left, pos = map2.map[index2];
      if (map2.map[index2 - 1] == pos) {
        found2 = true;
        const cell2 = table2.nodeAt(pos);
        const cellLeft = map2.colCount(pos);
        const updatePos = tr2.mapping.slice(mapFrom).map(pos + start);
        tr2.setNodeMarkup(
          updatePos,
          null,
          removeColSpan(
            cell2.attrs,
            left - cellLeft,
            cell2.attrs.colspan - (left - cellLeft)
          )
        );
        tr2.insert(
          updatePos + cell2.nodeSize,
          cell2.type.createAndFill(
            removeColSpan(cell2.attrs, 0, left - cellLeft)
          )
        );
        row2 += cell2.attrs.rowspan - 1;
      }
    }
    return found2;
  }
  function insertCells(state, dispatch, tableStart, rect, cells2) {
    let table2 = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;
    if (!table2) {
      throw new Error("No table found");
    }
    let map2 = TableMap.get(table2);
    const { top, left } = rect;
    const right = left + cells2.width, bottom = top + cells2.height;
    const tr2 = state.tr;
    let mapFrom = 0;
    function recomp() {
      table2 = tableStart ? tr2.doc.nodeAt(tableStart - 1) : tr2.doc;
      if (!table2) {
        throw new Error("No table found");
      }
      map2 = TableMap.get(table2);
      mapFrom = tr2.mapping.maps.length;
    }
    if (growTable(tr2, map2, table2, tableStart, right, bottom, mapFrom))
      recomp();
    if (isolateHorizontal(tr2, map2, table2, tableStart, left, right, top, mapFrom))
      recomp();
    if (isolateHorizontal(tr2, map2, table2, tableStart, left, right, bottom, mapFrom))
      recomp();
    if (isolateVertical(tr2, map2, table2, tableStart, top, bottom, left, mapFrom))
      recomp();
    if (isolateVertical(tr2, map2, table2, tableStart, top, bottom, right, mapFrom))
      recomp();
    for (let row2 = top; row2 < bottom; row2++) {
      const from2 = map2.positionAt(row2, left, table2), to = map2.positionAt(row2, right, table2);
      tr2.replace(
        tr2.mapping.slice(mapFrom).map(from2 + tableStart),
        tr2.mapping.slice(mapFrom).map(to + tableStart),
        new Slice(cells2.rows[row2 - top], 0, 0)
      );
    }
    recomp();
    tr2.setSelection(
      new CellSelection(
        tr2.doc.resolve(tableStart + map2.positionAt(top, left, table2)),
        tr2.doc.resolve(tableStart + map2.positionAt(bottom - 1, right - 1, table2))
      )
    );
    dispatch(tr2);
  }
  var handleKeyDown$1 = keydownHandler({
    ArrowLeft: arrow$1("horiz", -1),
    ArrowRight: arrow$1("horiz", 1),
    ArrowUp: arrow$1("vert", -1),
    ArrowDown: arrow$1("vert", 1),
    "Shift-ArrowLeft": shiftArrow("horiz", -1),
    "Shift-ArrowRight": shiftArrow("horiz", 1),
    "Shift-ArrowUp": shiftArrow("vert", -1),
    "Shift-ArrowDown": shiftArrow("vert", 1),
    Backspace: deleteCellSelection,
    "Mod-Backspace": deleteCellSelection,
    Delete: deleteCellSelection,
    "Mod-Delete": deleteCellSelection
  });
  function maybeSetSelection(state, dispatch, selection) {
    if (selection.eq(state.selection))
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(selection).scrollIntoView());
    return true;
  }
  function arrow$1(axis, dir) {
    return (state, dispatch, view) => {
      if (!view)
        return false;
      const sel = state.selection;
      if (sel instanceof CellSelection) {
        return maybeSetSelection(
          state,
          dispatch,
          Selection.near(sel.$headCell, dir)
        );
      }
      if (axis != "horiz" && !sel.empty)
        return false;
      const end = atEndOfCell(view, axis, dir);
      if (end == null)
        return false;
      if (axis == "horiz") {
        return maybeSetSelection(
          state,
          dispatch,
          Selection.near(state.doc.resolve(sel.head + dir), dir)
        );
      } else {
        const $cell = state.doc.resolve(end);
        const $next = nextCell($cell, axis, dir);
        let newSel;
        if ($next)
          newSel = Selection.near($next, 1);
        else if (dir < 0)
          newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);
        else
          newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);
        return maybeSetSelection(state, dispatch, newSel);
      }
    };
  }
  function shiftArrow(axis, dir) {
    return (state, dispatch, view) => {
      if (!view)
        return false;
      const sel = state.selection;
      let cellSel;
      if (sel instanceof CellSelection) {
        cellSel = sel;
      } else {
        const end = atEndOfCell(view, axis, dir);
        if (end == null)
          return false;
        cellSel = new CellSelection(state.doc.resolve(end));
      }
      const $head = nextCell(cellSel.$headCell, axis, dir);
      if (!$head)
        return false;
      return maybeSetSelection(
        state,
        dispatch,
        new CellSelection(cellSel.$anchorCell, $head)
      );
    };
  }
  function deleteCellSelection(state, dispatch) {
    const sel = state.selection;
    if (!(sel instanceof CellSelection))
      return false;
    if (dispatch) {
      const tr2 = state.tr;
      const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
      sel.forEachCell((cell2, pos) => {
        if (!cell2.content.eq(baseContent))
          tr2.replace(
            tr2.mapping.map(pos + 1),
            tr2.mapping.map(pos + cell2.nodeSize - 1),
            new Slice(baseContent, 0, 0)
          );
      });
      if (tr2.docChanged)
        dispatch(tr2);
    }
    return true;
  }
  function handleTripleClick(view, pos) {
    const doc2 = view.state.doc, $cell = cellAround(doc2.resolve(pos));
    if (!$cell)
      return false;
    view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
    return true;
  }
  function handlePaste(view, _, slice) {
    if (!isInTable(view.state))
      return false;
    let cells2 = pastedCells(slice);
    const sel = view.state.selection;
    if (sel instanceof CellSelection) {
      if (!cells2)
        cells2 = {
          width: 1,
          height: 1,
          rows: [
            Fragment.from(
              fitSlice(tableNodeTypes(view.state.schema).cell, slice)
            )
          ]
        };
      const table2 = sel.$anchorCell.node(-1);
      const start = sel.$anchorCell.start(-1);
      const rect = TableMap.get(table2).rectBetween(
        sel.$anchorCell.pos - start,
        sel.$headCell.pos - start
      );
      cells2 = clipCells(cells2, rect.right - rect.left, rect.bottom - rect.top);
      insertCells(view.state, view.dispatch, start, rect, cells2);
      return true;
    } else if (cells2) {
      const $cell = selectionCell(view.state);
      const start = $cell.start(-1);
      insertCells(
        view.state,
        view.dispatch,
        start,
        TableMap.get($cell.node(-1)).findCell($cell.pos - start),
        cells2
      );
      return true;
    } else {
      return false;
    }
  }
  function handleMouseDown(view, startEvent) {
    var _a;
    if (startEvent.ctrlKey || startEvent.metaKey)
      return;
    const startDOMCell = domInCell(view, startEvent.target);
    let $anchor;
    if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
      setCellSelection(view.state.selection.$anchorCell, startEvent);
      startEvent.preventDefault();
    } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {
      setCellSelection($anchor, startEvent);
      startEvent.preventDefault();
    } else if (!startDOMCell) {
      return;
    }
    function setCellSelection($anchor2, event) {
      let $head = cellUnderMouse(view, event);
      const starting = tableEditingKey.getState(view.state) == null;
      if (!$head || !inSameTable($anchor2, $head)) {
        if (starting)
          $head = $anchor2;
        else
          return;
      }
      const selection = new CellSelection($anchor2, $head);
      if (starting || !view.state.selection.eq(selection)) {
        const tr2 = view.state.tr.setSelection(selection);
        if (starting)
          tr2.setMeta(tableEditingKey, $anchor2.pos);
        view.dispatch(tr2);
      }
    }
    function stop() {
      view.root.removeEventListener("mouseup", stop);
      view.root.removeEventListener("dragstart", stop);
      view.root.removeEventListener("mousemove", move);
      if (tableEditingKey.getState(view.state) != null)
        view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));
    }
    function move(_event) {
      const event = _event;
      const anchor = tableEditingKey.getState(view.state);
      let $anchor2;
      if (anchor != null) {
        $anchor2 = view.state.doc.resolve(anchor);
      } else if (domInCell(view, event.target) != startDOMCell) {
        $anchor2 = cellUnderMouse(view, startEvent);
        if (!$anchor2)
          return stop();
      }
      if ($anchor2)
        setCellSelection($anchor2, event);
    }
    view.root.addEventListener("mouseup", stop);
    view.root.addEventListener("dragstart", stop);
    view.root.addEventListener("mousemove", move);
  }
  function atEndOfCell(view, axis, dir) {
    if (!(view.state.selection instanceof TextSelection))
      return null;
    const { $head } = view.state.selection;
    for (let d = $head.depth - 1; d >= 0; d--) {
      const parent = $head.node(d), index2 = dir < 0 ? $head.index(d) : $head.indexAfter(d);
      if (index2 != (dir < 0 ? 0 : parent.childCount))
        return null;
      if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
        const cellPos = $head.before(d);
        const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
        return view.endOfTextblock(dirStr) ? cellPos : null;
      }
    }
    return null;
  }
  function domInCell(view, dom) {
    for (; dom && dom != view.dom; dom = dom.parentNode) {
      if (dom.nodeName == "TD" || dom.nodeName == "TH") {
        return dom;
      }
    }
    return null;
  }
  function cellUnderMouse(view, event) {
    const mousePos = view.posAtCoords({
      left: event.clientX,
      top: event.clientY
    });
    if (!mousePos)
      return null;
    return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;
  }
  var TableView = class {
    constructor(node2, cellMinWidth) {
      this.node = node2;
      this.cellMinWidth = cellMinWidth;
      this.dom = document.createElement("div");
      this.dom.className = "tableWrapper";
      this.table = this.dom.appendChild(document.createElement("table"));
      this.colgroup = this.table.appendChild(document.createElement("colgroup"));
      updateColumnsOnResize(node2, this.colgroup, this.table, cellMinWidth);
      this.contentDOM = this.table.appendChild(document.createElement("tbody"));
    }
    update(node2) {
      if (node2.type != this.node.type)
        return false;
      this.node = node2;
      updateColumnsOnResize(node2, this.colgroup, this.table, this.cellMinWidth);
      return true;
    }
    ignoreMutation(record) {
      return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target));
    }
  };
  function updateColumnsOnResize(node2, colgroup2, table2, cellMinWidth, overrideCol, overrideValue) {
    var _a;
    let totalWidth = 0;
    let fixedWidth = true;
    let nextDOM = colgroup2.firstChild;
    const row2 = node2.firstChild;
    if (!row2)
      return;
    for (let i2 = 0, col = 0; i2 < row2.childCount; i2++) {
      const { colspan, colwidth } = row2.child(i2).attrs;
      for (let j = 0; j < colspan; j++, col++) {
        const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];
        const cssWidth = hasWidth ? hasWidth + "px" : "";
        totalWidth += hasWidth || cellMinWidth;
        if (!hasWidth)
          fixedWidth = false;
        if (!nextDOM) {
          colgroup2.appendChild(document.createElement("col")).style.width = cssWidth;
        } else {
          if (nextDOM.style.width != cssWidth)
            nextDOM.style.width = cssWidth;
          nextDOM = nextDOM.nextSibling;
        }
      }
    }
    while (nextDOM) {
      const after = nextDOM.nextSibling;
      (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);
      nextDOM = after;
    }
    if (fixedWidth) {
      table2.style.width = totalWidth + "px";
      table2.style.minWidth = "";
    } else {
      table2.style.width = "";
      table2.style.minWidth = totalWidth + "px";
    }
  }
  var columnResizingPluginKey = new PluginKey(
    "tableColumnResizing"
  );
  function columnResizing({
    handleWidth = 5,
    cellMinWidth = 25,
    View = TableView,
    lastColumnResizable = true
  } = {}) {
    const plugin = new Plugin({
      key: columnResizingPluginKey,
      state: {
        init(_, state) {
          plugin.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = (node2, view) => new View(node2, cellMinWidth, view);
          return new ResizeState(-1, false);
        },
        apply(tr2, prev) {
          return prev.apply(tr2);
        }
      },
      props: {
        attributes: (state) => {
          const pluginState = columnResizingPluginKey.getState(state);
          return pluginState && pluginState.activeHandle > -1 ? { class: "resize-cursor" } : {};
        },
        handleDOMEvents: {
          mousemove: (view, event) => {
            handleMouseMove(
              view,
              event,
              handleWidth,
              cellMinWidth,
              lastColumnResizable
            );
          },
          mouseleave: (view) => {
            handleMouseLeave(view);
          },
          mousedown: (view, event) => {
            handleMouseDown2(view, event, cellMinWidth);
          }
        },
        decorations: (state) => {
          const pluginState = columnResizingPluginKey.getState(state);
          if (pluginState && pluginState.activeHandle > -1) {
            return handleDecorations(state, pluginState.activeHandle);
          }
        },
        nodeViews: {}
      }
    });
    return plugin;
  }
  var ResizeState = class _ResizeState {
    constructor(activeHandle, dragging) {
      this.activeHandle = activeHandle;
      this.dragging = dragging;
    }
    apply(tr2) {
      const state = this;
      const action = tr2.getMeta(columnResizingPluginKey);
      if (action && action.setHandle != null)
        return new _ResizeState(action.setHandle, false);
      if (action && action.setDragging !== void 0)
        return new _ResizeState(state.activeHandle, action.setDragging);
      if (state.activeHandle > -1 && tr2.docChanged) {
        let handle2 = tr2.mapping.map(state.activeHandle, -1);
        if (!pointsAtCell(tr2.doc.resolve(handle2))) {
          handle2 = -1;
        }
        return new _ResizeState(handle2, state.dragging);
      }
      return state;
    }
  };
  function handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {
    const pluginState = columnResizingPluginKey.getState(view.state);
    if (!pluginState)
      return;
    if (!pluginState.dragging) {
      const target = domCellAround$1(event.target);
      let cell2 = -1;
      if (target) {
        const { left, right } = target.getBoundingClientRect();
        if (event.clientX - left <= handleWidth)
          cell2 = edgeCell(view, event, "left", handleWidth);
        else if (right - event.clientX <= handleWidth)
          cell2 = edgeCell(view, event, "right", handleWidth);
      }
      if (cell2 != pluginState.activeHandle) {
        if (!lastColumnResizable && cell2 !== -1) {
          const $cell = view.state.doc.resolve(cell2);
          const table2 = $cell.node(-1);
          const map2 = TableMap.get(table2);
          const tableStart = $cell.start(-1);
          const col = map2.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;
          if (col == map2.width - 1) {
            return;
          }
        }
        updateHandle(view, cell2);
      }
    }
  }
  function handleMouseLeave(view) {
    const pluginState = columnResizingPluginKey.getState(view.state);
    if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)
      updateHandle(view, -1);
  }
  function handleMouseDown2(view, event, cellMinWidth) {
    var _a;
    const win = (_a = view.dom.ownerDocument.defaultView) != null ? _a : window;
    const pluginState = columnResizingPluginKey.getState(view.state);
    if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)
      return false;
    const cell2 = view.state.doc.nodeAt(pluginState.activeHandle);
    const width = currentColWidth(view, pluginState.activeHandle, cell2.attrs);
    view.dispatch(
      view.state.tr.setMeta(columnResizingPluginKey, {
        setDragging: { startX: event.clientX, startWidth: width }
      })
    );
    function finish(event2) {
      win.removeEventListener("mouseup", finish);
      win.removeEventListener("mousemove", move);
      const pluginState2 = columnResizingPluginKey.getState(view.state);
      if (pluginState2 == null ? void 0 : pluginState2.dragging) {
        updateColumnWidth(
          view,
          pluginState2.activeHandle,
          draggedWidth(pluginState2.dragging, event2, cellMinWidth)
        );
        view.dispatch(
          view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })
        );
      }
    }
    function move(event2) {
      if (!event2.which)
        return finish(event2);
      const pluginState2 = columnResizingPluginKey.getState(view.state);
      if (!pluginState2)
        return;
      if (pluginState2.dragging) {
        const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);
        displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);
      }
    }
    win.addEventListener("mouseup", finish);
    win.addEventListener("mousemove", move);
    event.preventDefault();
    return true;
  }
  function currentColWidth(view, cellPos, { colspan, colwidth }) {
    const width = colwidth && colwidth[colwidth.length - 1];
    if (width)
      return width;
    const dom = view.domAtPos(cellPos);
    const node2 = dom.node.childNodes[dom.offset];
    let domWidth = node2.offsetWidth, parts = colspan;
    if (colwidth) {
      for (let i2 = 0; i2 < colspan; i2++)
        if (colwidth[i2]) {
          domWidth -= colwidth[i2];
          parts--;
        }
    }
    return domWidth / parts;
  }
  function domCellAround$1(target) {
    while (target && target.nodeName != "TD" && target.nodeName != "TH")
      target = target.classList && target.classList.contains("ProseMirror") ? null : target.parentNode;
    return target;
  }
  function edgeCell(view, event, side, handleWidth) {
    const offset = side == "right" ? -handleWidth : handleWidth;
    const found2 = view.posAtCoords({
      left: event.clientX + offset,
      top: event.clientY
    });
    if (!found2)
      return -1;
    const { pos } = found2;
    const $cell = cellAround(view.state.doc.resolve(pos));
    if (!$cell)
      return -1;
    if (side == "right")
      return $cell.pos;
    const map2 = TableMap.get($cell.node(-1)), start = $cell.start(-1);
    const index2 = map2.map.indexOf($cell.pos - start);
    return index2 % map2.width == 0 ? -1 : start + map2.map[index2 - 1];
  }
  function draggedWidth(dragging, event, cellMinWidth) {
    const offset = event.clientX - dragging.startX;
    return Math.max(cellMinWidth, dragging.startWidth + offset);
  }
  function updateHandle(view, value) {
    view.dispatch(
      view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })
    );
  }
  function updateColumnWidth(view, cell2, width) {
    const $cell = view.state.doc.resolve(cell2);
    const table2 = $cell.node(-1), map2 = TableMap.get(table2), start = $cell.start(-1);
    const col = map2.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
    const tr2 = view.state.tr;
    for (let row2 = 0; row2 < map2.height; row2++) {
      const mapIndex = row2 * map2.width + col;
      if (row2 && map2.map[mapIndex] == map2.map[mapIndex - map2.width])
        continue;
      const pos = map2.map[mapIndex];
      const attrs = table2.nodeAt(pos).attrs;
      const index2 = attrs.colspan == 1 ? 0 : col - map2.colCount(pos);
      if (attrs.colwidth && attrs.colwidth[index2] == width)
        continue;
      const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
      colwidth[index2] = width;
      tr2.setNodeMarkup(start + pos, null, { ...attrs, colwidth });
    }
    if (tr2.docChanged)
      view.dispatch(tr2);
  }
  function displayColumnWidth(view, cell2, width, cellMinWidth) {
    const $cell = view.state.doc.resolve(cell2);
    const table2 = $cell.node(-1), start = $cell.start(-1);
    const col = TableMap.get(table2).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
    let dom = view.domAtPos($cell.start(-1)).node;
    while (dom && dom.nodeName != "TABLE") {
      dom = dom.parentNode;
    }
    if (!dom)
      return;
    updateColumnsOnResize(
      table2,
      dom.firstChild,
      dom,
      cellMinWidth,
      col,
      width
    );
  }
  function zeroes(n) {
    return Array(n).fill(0);
  }
  function handleDecorations(state, cell2) {
    const decorations = [];
    const $cell = state.doc.resolve(cell2);
    const table2 = $cell.node(-1);
    if (!table2) {
      return DecorationSet.empty;
    }
    const map2 = TableMap.get(table2);
    const start = $cell.start(-1);
    const col = map2.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;
    for (let row2 = 0; row2 < map2.height; row2++) {
      const index2 = col + row2 * map2.width - 1;
      if ((col == map2.width || map2.map[index2] != map2.map[index2 + 1]) && (row2 == 0 || map2.map[index2] != map2.map[index2 - map2.width])) {
        const cellPos = map2.map[index2];
        const pos = start + cellPos + table2.nodeAt(cellPos).nodeSize - 1;
        const dom = document.createElement("div");
        dom.className = "column-resize-handle";
        decorations.push(Decoration.widget(pos, dom));
      }
    }
    return DecorationSet.create(state.doc, decorations);
  }
  function selectedRect(state) {
    const sel = state.selection;
    const $pos = selectionCell(state);
    const table2 = $pos.node(-1);
    const tableStart = $pos.start(-1);
    const map2 = TableMap.get(table2);
    const rect = sel instanceof CellSelection ? map2.rectBetween(
      sel.$anchorCell.pos - tableStart,
      sel.$headCell.pos - tableStart
    ) : map2.findCell($pos.pos - tableStart);
    return { ...rect, tableStart, map: map2, table: table2 };
  }
  function rowIsHeader(map2, table2, row2) {
    var _a;
    const headerCell = tableNodeTypes(table2.type.schema).header_cell;
    for (let col = 0; col < map2.width; col++)
      if (((_a = table2.nodeAt(map2.map[col + row2 * map2.width])) == null ? void 0 : _a.type) != headerCell)
        return false;
    return true;
  }
  function addRow(tr2, { map: map2, tableStart, table: table2 }, row2) {
    var _a;
    let rowPos = tableStart;
    for (let i2 = 0; i2 < row2; i2++)
      rowPos += table2.child(i2).nodeSize;
    const cells2 = [];
    let refRow = row2 > 0 ? -1 : 0;
    if (rowIsHeader(map2, table2, row2 + refRow))
      refRow = row2 == 0 || row2 == map2.height ? null : 0;
    for (let col = 0, index2 = map2.width * row2; col < map2.width; col++, index2++) {
      if (row2 > 0 && row2 < map2.height && map2.map[index2] == map2.map[index2 - map2.width]) {
        const pos = map2.map[index2];
        const attrs = table2.nodeAt(pos).attrs;
        tr2.setNodeMarkup(tableStart + pos, null, {
          ...attrs,
          rowspan: attrs.rowspan + 1
        });
        col += attrs.colspan - 1;
      } else {
        const type = refRow == null ? tableNodeTypes(table2.type.schema).cell : (_a = table2.nodeAt(map2.map[index2 + refRow * map2.width])) == null ? void 0 : _a.type;
        const node2 = type == null ? void 0 : type.createAndFill();
        if (node2)
          cells2.push(node2);
      }
    }
    tr2.insert(rowPos, tableNodeTypes(table2.type.schema).row.create(null, cells2));
    return tr2;
  }
  function addRowBefore(state, dispatch) {
    if (!isInTable(state))
      return false;
    if (dispatch) {
      const rect = selectedRect(state);
      dispatch(addRow(state.tr, rect, rect.top));
    }
    return true;
  }
  function addRowAfter(state, dispatch) {
    if (!isInTable(state))
      return false;
    if (dispatch) {
      const rect = selectedRect(state);
      dispatch(addRow(state.tr, rect, rect.bottom));
    }
    return true;
  }
  function deprecated_toggleHeader(type) {
    return function(state, dispatch) {
      if (!isInTable(state))
        return false;
      if (dispatch) {
        const types2 = tableNodeTypes(state.schema);
        const rect = selectedRect(state), tr2 = state.tr;
        const cells2 = rect.map.cellsInRect(
          type == "column" ? {
            left: rect.left,
            top: 0,
            right: rect.right,
            bottom: rect.map.height
          } : type == "row" ? {
            left: 0,
            top: rect.top,
            right: rect.map.width,
            bottom: rect.bottom
          } : rect
        );
        const nodes = cells2.map((pos) => rect.table.nodeAt(pos));
        for (let i2 = 0; i2 < cells2.length; i2++)
          if (nodes[i2].type == types2.header_cell)
            tr2.setNodeMarkup(
              rect.tableStart + cells2[i2],
              types2.cell,
              nodes[i2].attrs
            );
        if (tr2.steps.length == 0)
          for (let i2 = 0; i2 < cells2.length; i2++)
            tr2.setNodeMarkup(
              rect.tableStart + cells2[i2],
              types2.header_cell,
              nodes[i2].attrs
            );
        dispatch(tr2);
      }
      return true;
    };
  }
  function isHeaderEnabledByType(type, rect, types2) {
    const cellPositions = rect.map.cellsInRect({
      left: 0,
      top: 0,
      right: type == "row" ? rect.map.width : 1,
      bottom: type == "column" ? rect.map.height : 1
    });
    for (let i2 = 0; i2 < cellPositions.length; i2++) {
      const cell2 = rect.table.nodeAt(cellPositions[i2]);
      if (cell2 && cell2.type !== types2.header_cell) {
        return false;
      }
    }
    return true;
  }
  function toggleHeader(type, options) {
    options = options || { useDeprecatedLogic: false };
    if (options.useDeprecatedLogic)
      return deprecated_toggleHeader(type);
    return function(state, dispatch) {
      if (!isInTable(state))
        return false;
      if (dispatch) {
        const types2 = tableNodeTypes(state.schema);
        const rect = selectedRect(state), tr2 = state.tr;
        const isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types2);
        const isHeaderColumnEnabled = isHeaderEnabledByType(
          "column",
          rect,
          types2
        );
        const isHeaderEnabled = type === "column" ? isHeaderRowEnabled : type === "row" ? isHeaderColumnEnabled : false;
        const selectionStartsAt = isHeaderEnabled ? 1 : 0;
        const cellsRect = type == "column" ? {
          left: 0,
          top: selectionStartsAt,
          right: 1,
          bottom: rect.map.height
        } : type == "row" ? {
          left: selectionStartsAt,
          top: 0,
          right: rect.map.width,
          bottom: 1
        } : rect;
        const newType = type == "column" ? isHeaderColumnEnabled ? types2.cell : types2.header_cell : type == "row" ? isHeaderRowEnabled ? types2.cell : types2.header_cell : types2.cell;
        rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {
          const cellPos = relativeCellPos + rect.tableStart;
          const cell2 = tr2.doc.nodeAt(cellPos);
          if (cell2) {
            tr2.setNodeMarkup(cellPos, newType, cell2.attrs);
          }
        });
        dispatch(tr2);
      }
      return true;
    };
  }
  toggleHeader("row", {
    useDeprecatedLogic: true
  });
  toggleHeader("column", {
    useDeprecatedLogic: true
  });
  toggleHeader("cell", {
    useDeprecatedLogic: true
  });
  function findNextCell($cell, dir) {
    if (dir < 0) {
      const before = $cell.nodeBefore;
      if (before)
        return $cell.pos - before.nodeSize;
      for (let row2 = $cell.index(-1) - 1, rowEnd = $cell.before(); row2 >= 0; row2--) {
        const rowNode = $cell.node(-1).child(row2);
        const lastChild = rowNode.lastChild;
        if (lastChild) {
          return rowEnd - 1 - lastChild.nodeSize;
        }
        rowEnd -= rowNode.nodeSize;
      }
    } else {
      if ($cell.index() < $cell.parent.childCount - 1) {
        return $cell.pos + $cell.nodeAfter.nodeSize;
      }
      const table2 = $cell.node(-1);
      for (let row2 = $cell.indexAfter(-1), rowStart = $cell.after(); row2 < table2.childCount; row2++) {
        const rowNode = table2.child(row2);
        if (rowNode.childCount)
          return rowStart + 1;
        rowStart += rowNode.nodeSize;
      }
    }
    return null;
  }
  function goToNextCell(direction) {
    return function(state, dispatch) {
      if (!isInTable(state))
        return false;
      const cell2 = findNextCell(selectionCell(state), direction);
      if (cell2 == null)
        return false;
      if (dispatch) {
        const $cell = state.doc.resolve(cell2);
        dispatch(
          state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView()
        );
      }
      return true;
    };
  }
  function deleteTable(state, dispatch) {
    const $pos = state.selection.$anchor;
    for (let d = $pos.depth; d > 0; d--) {
      const node2 = $pos.node(d);
      if (node2.type.spec.tableRole == "table") {
        if (dispatch)
          dispatch(
            state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()
          );
        return true;
      }
    }
    return false;
  }
  function tableEditing({
    allowTableNodeSelection = false
  } = {}) {
    return new Plugin({
      key: tableEditingKey,
      // This piece of state is used to remember when a mouse-drag
      // cell-selection is happening, so that it can continue even as
      // transactions (which might move its anchor cell) come in.
      state: {
        init() {
          return null;
        },
        apply(tr2, cur) {
          const set = tr2.getMeta(tableEditingKey);
          if (set != null)
            return set == -1 ? null : set;
          if (cur == null || !tr2.docChanged)
            return cur;
          const { deleted, pos } = tr2.mapping.mapResult(cur);
          return deleted ? null : pos;
        }
      },
      props: {
        decorations: drawCellSelection,
        handleDOMEvents: {
          mousedown: handleMouseDown
        },
        createSelectionBetween(view) {
          return tableEditingKey.getState(view.state) != null ? view.state.selection : null;
        },
        handleTripleClick,
        handleKeyDown: handleKeyDown$1,
        handlePaste
      },
      appendTransaction(_, oldState, state) {
        return normalizeSelection(
          state,
          fixTables(state, oldState),
          allowTableNodeSelection
        );
      }
    });
  }
  const TableExtension = Extension.create({
    name: "BlockNoteTableExtension",
    addProseMirrorPlugins: () => {
      return [
        columnResizing({
          cellMinWidth: 100
        }),
        tableEditing()
      ];
    },
    addKeyboardShortcuts() {
      return {
        // Enter: () => {
        //   const currentEl = this.editor.view.domAtPos(
        //     this.editor.state.selection.from
        //   ).node as Element;
        //   if (currentEl.closest("table")) {
        //     this.editor.commands.setHardBreak();
        //     return true;
        //   }
        //   return false;
        // },
        // Ensures that backspace won't delete the table if the text cursor is at
        // the start of a cell and the selection is empty.
        Backspace: () => {
          return this.editor.commands.first(({ commands: commands2 }) => [
            // Deletes the selection if it's not empty.
            () => commands2.deleteSelection(),
            // Undoes an input rule if one was triggered in the last editor state change.
            () => commands2.undoInputRule(),
            // Reverts block content type to a paragraph if the selection is at the start of the block.
            () => commands2.command(({ state }) => {
              const { contentType } = getBlockInfoFromPos(
                state.doc,
                state.selection.from
              );
              const selectionAtBlockStart = state.selection.$anchor.parentOffset === 0;
              const isParagraph = contentType.name === "paragraph";
              if (selectionAtBlockStart && !isParagraph) {
                return commands2.BNUpdateBlock(state.selection.from, {
                  type: "paragraph",
                  props: {}
                });
              }
              return false;
            }),
            // Removes a level of nesting if the block is indented if the selection is at the start of the block.
            () => commands2.command(({ state }) => {
              const selectionAtBlockStart = state.selection.$anchor.parentOffset === 0;
              if (selectionAtBlockStart) {
                return commands2.liftListItem("blockContainer");
              }
              return false;
            }),
            // Merges block with the previous one if it isn't indented, isn't the first block in the doc, and the selection
            // is at the start of the block.
            () => commands2.command(({ state }) => {
              const { depth, startPos } = getBlockInfoFromPos(
                state.doc,
                state.selection.from
              );
              const selectionAtBlockStart = state.selection.$anchor.parentOffset === 0;
              const selectionEmpty = state.selection.anchor === state.selection.head;
              const blockAtDocStart = startPos === 2;
              const posBetweenBlocks = startPos - 1;
              if (!blockAtDocStart && selectionAtBlockStart && selectionEmpty && depth > 1) {
                return commands2.BNMergeBlocks(posBetweenBlocks);
              }
              return false;
            })
          ]);
        }
      };
    },
    extendNodeSchema(extension2) {
      const context = {
        name: extension2.name,
        options: extension2.options,
        storage: extension2.storage
      };
      return {
        tableRole: callOrReturn(
          getExtensionField(extension2, "tableRole", context)
        )
      };
    }
  });
  const tablePropSchema = {
    ...defaultProps
  };
  const TableBlockContent = createStronglyTypedTiptapNode({
    name: "table",
    content: "tableRow+",
    group: "blockContent",
    tableRole: "table",
    isolating: true,
    parseHTML() {
      return [{ tag: "table" }];
    },
    renderHTML({ HTMLAttributes }) {
      var _a, _b;
      return createDefaultBlockDOMOutputSpec(
        this.name,
        "table",
        {
          ...((_a = this.options.domAttributes) == null ? void 0 : _a.blockContent) || {},
          ...HTMLAttributes
        },
        ((_b = this.options.domAttributes) == null ? void 0 : _b.inlineContent) || {}
      );
    },
    addCommands() {
      return {
        goToNextCell: () => ({ state, dispatch }) => {
          return goToNextCell(1)(state, dispatch);
        },
        goToPreviousCell: () => ({ state, dispatch }) => {
          return goToNextCell(-1)(state, dispatch);
        },
        addRowBefore: () => ({ state, dispatch }) => {
          return addRowBefore(state, dispatch);
        },
        addRowAfter: () => ({ state, dispatch }) => {
          return addRowAfter(state, dispatch);
        },
        deleteTable: () => ({ state, dispatch }) => {
          return deleteTable(state, dispatch);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
        Backspace: deleteTableWhenAllCellsSelected,
        "Mod-Backspace": deleteTableWhenAllCellsSelected,
        Delete: deleteTableWhenAllCellsSelected,
        "Mod-Delete": deleteTableWhenAllCellsSelected
      };
    }
  });
  const TableParagraph = Node.create({
    name: "tableParagraph",
    group: "tableContent",
    content: "blockContainer+",
    parseHTML() {
      return [{ tag: "div[data-node-type=" + this.name + "]" }];
    },
    renderHTML({ HTMLAttributes }) {
      var _a;
      const blockGroupHTMLAttributes = {
        ...((_a = this.options.domAttributes) == null ? void 0 : _a.blockGroup) || {},
        ...HTMLAttributes
      };
      const blockGroup = document.createElement("div");
      blockGroup.className = mergeCSSClasses(
        "bn-block-table-paragraph",
        blockGroupHTMLAttributes.class
      );
      blockGroup.setAttribute("data-node-type", "tableParagraph");
      for (const [attribute, value] of Object.entries(blockGroupHTMLAttributes)) {
        if (attribute !== "class") {
          blockGroup.setAttribute(attribute, value);
        }
      }
      return {
        dom: blockGroup,
        contentDOM: blockGroup
      };
    }
  });
  const Table = createBlockSpecFromStronglyTypedTiptapNode(
    TableBlockContent,
    tablePropSchema,
    [
      TableExtension,
      TableParagraph,
      TableHeader.extend({
        content: "tableContent"
      }),
      TableCell.extend({
        content: "tableContent"
      }),
      TableRow
    ]
  );
  function isCellSelection(value) {
    return value instanceof CellSelection;
  }
  const deleteTableWhenAllCellsSelected = ({
    editor: editor2
  }) => {
    const { selection } = editor2.state;
    if (!isCellSelection(selection)) {
      return false;
    }
    let cellCount = 0;
    const table2 = findParentNodeClosestToPos(
      selection.ranges[0].$from,
      (node2) => {
        return node2.type.name === "table";
      }
    );
    table2 == null ? void 0 : table2.node.descendants((node2) => {
      if (["tableCell", "tableHeader"].includes(node2.type.name)) {
        cellCount += 1;
      }
    });
    const allCellsSelected = cellCount === selection.ranges.length;
    if (!allCellsSelected) {
      return false;
    }
    editor2.commands.deleteTable();
    return true;
  };
  const defaultBlockSpecs = {
    paragraph: Paragraph,
    heading: Heading,
    bulletListItem: BulletListItem,
    numberedListItem: NumberedListItem,
    image: Image,
    table: Table
  };
  const defaultBlockSchema = getBlockSchemaFromSpecs(defaultBlockSpecs);
  const defaultStyleSpecs = {
    bold: createStyleSpecFromTipTapMark(Bold, "boolean"),
    italic: createStyleSpecFromTipTapMark(Italic, "boolean"),
    underline: createStyleSpecFromTipTapMark(Underline, "boolean"),
    strike: createStyleSpecFromTipTapMark(Strike, "boolean"),
    code: createStyleSpecFromTipTapMark(Code, "boolean"),
    textColor: TextColor,
    backgroundColor: BackgroundColor
  };
  const defaultStyleSchema = getStyleSchemaFromSpecs(defaultStyleSpecs);
  const defaultInlineContentSpecs = {
    text: { config: "text", implementation: {} },
    link: { config: "link", implementation: {} }
  };
  const defaultInlineContentSchema = getInlineContentSchemaFromSpecs(
    defaultInlineContentSpecs
  );
  function getNodeById(id, doc2) {
    let targetNode = void 0;
    let posBeforeNode = void 0;
    doc2.firstChild.descendants((node2, pos) => {
      if (targetNode) {
        return false;
      }
      if (node2.type.name !== "blockContainer" || node2.attrs.id !== id) {
        return true;
      }
      targetNode = node2;
      posBeforeNode = pos + 1;
      return false;
    });
    if (targetNode === void 0 || posBeforeNode === void 0) {
      throw Error("Could not find block in the editor with matching ID.");
    }
    return {
      node: targetNode,
      posBeforeNode
    };
  }
  function insertBlocks(blocksToInsert, referenceBlock, placement = "before", editor2) {
    const ttEditor = editor2._tiptapEditor;
    const id = typeof referenceBlock === "string" ? referenceBlock : referenceBlock.id;
    const nodesToInsert = [];
    for (const blockSpec of blocksToInsert) {
      nodesToInsert.push(
        blockToNode(blockSpec, ttEditor.schema, editor2.styleSchema)
      );
    }
    const { node: node2, posBeforeNode } = getNodeById(id, ttEditor.state.doc);
    if (placement === "before") {
      ttEditor.view.dispatch(
        ttEditor.state.tr.insert(posBeforeNode, nodesToInsert)
      );
    }
    if (placement === "after") {
      ttEditor.view.dispatch(
        ttEditor.state.tr.insert(posBeforeNode + node2.nodeSize, nodesToInsert)
      );
    }
    if (placement === "nested") {
      if (node2.childCount < 2) {
        const blockGroupNode = ttEditor.state.schema.nodes["blockGroup"].create(
          {},
          nodesToInsert
        );
        ttEditor.view.dispatch(
          ttEditor.state.tr.insert(
            posBeforeNode + node2.firstChild.nodeSize + 1,
            blockGroupNode
          )
        );
      }
    }
    const insertedBlocks = [];
    for (const node22 of nodesToInsert) {
      insertedBlocks.push(
        nodeToBlock(
          node22,
          editor2.blockSchema,
          editor2.inlineContentSchema,
          editor2.styleSchema,
          editor2.blockCache
        )
      );
    }
    return insertedBlocks;
  }
  function updateBlock(blockToUpdate, update, editor2) {
    const ttEditor = editor2._tiptapEditor;
    const id = typeof blockToUpdate === "string" ? blockToUpdate : blockToUpdate.id;
    const { posBeforeNode } = getNodeById(id, ttEditor.state.doc);
    ttEditor.commands.BNUpdateBlock(posBeforeNode + 1, update);
    const blockContainerNode = ttEditor.state.doc.resolve(posBeforeNode + 1).node();
    return nodeToBlock(
      blockContainerNode,
      editor2.blockSchema,
      editor2.inlineContentSchema,
      editor2.styleSchema,
      editor2.blockCache
    );
  }
  function removeBlocksWithCallback(blocksToRemove, editor2, callback) {
    const ttEditor = editor2._tiptapEditor;
    const tr2 = ttEditor.state.tr;
    const idsOfBlocksToRemove = new Set(
      blocksToRemove.map(
        (block2) => typeof block2 === "string" ? block2 : block2.id
      )
    );
    const removedBlocks = [];
    let removedSize = 0;
    ttEditor.state.doc.descendants((node2, pos) => {
      if (idsOfBlocksToRemove.size === 0) {
        return false;
      }
      if (node2.type.name !== "blockContainer" || !idsOfBlocksToRemove.has(node2.attrs.id)) {
        return true;
      }
      removedBlocks.push(
        nodeToBlock(
          node2,
          editor2.blockSchema,
          editor2.inlineContentSchema,
          editor2.styleSchema,
          editor2.blockCache
        )
      );
      idsOfBlocksToRemove.delete(node2.attrs.id);
      removedSize = (callback == null ? void 0 : callback(node2, pos, tr2, removedSize)) || removedSize;
      const oldDocSize = tr2.doc.nodeSize;
      tr2.delete(pos - removedSize - 1, pos - removedSize + node2.nodeSize + 1);
      const newDocSize = tr2.doc.nodeSize;
      removedSize += oldDocSize - newDocSize;
      return false;
    });
    if (idsOfBlocksToRemove.size > 0) {
      const notFoundIds = [...idsOfBlocksToRemove].join("\n");
      throw Error(
        "Blocks with the following IDs could not be found in the editor: " + notFoundIds
      );
    }
    ttEditor.view.dispatch(tr2);
    return removedBlocks;
  }
  function removeBlocks(blocksToRemove, editor2) {
    return removeBlocksWithCallback(blocksToRemove, editor2);
  }
  function replaceBlocks(blocksToRemove, blocksToInsert, editor2) {
    const ttEditor = editor2._tiptapEditor;
    const nodesToInsert = [];
    for (const block2 of blocksToInsert) {
      nodesToInsert.push(blockToNode(block2, ttEditor.schema, editor2.styleSchema));
    }
    const idOfFirstBlock = typeof blocksToRemove[0] === "string" ? blocksToRemove[0] : blocksToRemove[0].id;
    const removedBlocks = removeBlocksWithCallback(
      blocksToRemove,
      editor2,
      (node2, pos, tr2, removedSize) => {
        if (node2.attrs.id === idOfFirstBlock) {
          const oldDocSize = tr2.doc.nodeSize;
          tr2.insert(pos, nodesToInsert);
          const newDocSize = tr2.doc.nodeSize;
          return removedSize + oldDocSize - newDocSize;
        }
        return removedSize;
      }
    );
    const insertedBlocks = [];
    for (const node2 of nodesToInsert) {
      insertedBlocks.push(
        nodeToBlock(
          node2,
          editor2.blockSchema,
          editor2.inlineContentSchema,
          editor2.styleSchema,
          editor2.blockCache
        )
      );
    }
    return { insertedBlocks, removedBlocks };
  }
  const isElement = (
    /**
     * @type {(
     *   (() => false) &
     *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &
     *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)
     * )}
     */
    /**
     * @param {unknown} [node]
     * @param {Test | undefined} [test]
     * @param {number | null | undefined} [index]
     * @param {Parent | null | undefined} [parent]
     * @param {unknown} [context]
     * @returns {boolean}
     */
    // eslint-disable-next-line max-params
    function(node2, test, index2, parent, context) {
      const check = convertElement$1(test);
      if (index2 !== void 0 && index2 !== null && (typeof index2 !== "number" || index2 < 0 || index2 === Number.POSITIVE_INFINITY)) {
        throw new Error("Expected positive finite index for child node");
      }
      if (parent !== void 0 && parent !== null && (!parent.type || !parent.children)) {
        throw new Error("Expected parent node");
      }
      if (!node2 || !node2.type || typeof node2.type !== "string") {
        return false;
      }
      if ((parent === void 0 || parent === null) !== (index2 === void 0 || index2 === null)) {
        throw new Error("Expected both parent and index");
      }
      return check.call(context, node2, index2, parent);
    }
  );
  const convertElement$1 = (
    /**
     * @type {(
     *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &
     *   ((test?: Test) => AssertAnything)
     * )}
     */
    /**
     * @param {Test | null | undefined} [test]
     * @returns {AssertAnything}
     */
    function(test) {
      if (test === void 0 || test === null) {
        return element$1;
      }
      if (typeof test === "string") {
        return tagNameFactory$1(test);
      }
      if (typeof test === "object") {
        return anyFactory$4(test);
      }
      if (typeof test === "function") {
        return castFactory$4(test);
      }
      throw new Error("Expected function, string, or array as test");
    }
  );
  function anyFactory$4(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convertElement$1(tests[index2]);
    }
    return castFactory$4(any2);
    function any2(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].call(this, ...parameters)) {
          return true;
        }
      }
      return false;
    }
  }
  function tagNameFactory$1(check) {
    return tagName;
    function tagName(node2) {
      return element$1(node2) && node2.tagName === check;
    }
  }
  function castFactory$4(check) {
    return assertion;
    function assertion(node2, ...parameters) {
      return element$1(node2) && Boolean(check.call(this, node2, ...parameters));
    }
  }
  function element$1(node2) {
    return Boolean(
      node2 && typeof node2 === "object" && // @ts-expect-error Looks like a node.
      node2.type === "element" && // @ts-expect-error Looks like an element.
      typeof node2.tagName === "string"
    );
  }
  const embedded = convertElement$1([
    "audio",
    "canvas",
    "embed",
    "iframe",
    "img",
    "math",
    "object",
    "picture",
    "svg",
    "video"
  ]);
  const convert$2 = (
    /**
     * @type {(
     *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
     *   ((test?: Test) => AssertAnything)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */
    function(test) {
      if (test === void 0 || test === null) {
        return ok$2;
      }
      if (typeof test === "string") {
        return typeFactory$2(test);
      }
      if (typeof test === "object") {
        return Array.isArray(test) ? anyFactory$3(test) : propsFactory$2(test);
      }
      if (typeof test === "function") {
        return castFactory$3(test);
      }
      throw new Error("Expected function, string, or object as test");
    }
  );
  function anyFactory$3(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convert$2(tests[index2]);
    }
    return castFactory$3(any2);
    function any2(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].call(this, ...parameters))
          return true;
      }
      return false;
    }
  }
  function propsFactory$2(check) {
    return castFactory$3(all2);
    function all2(node2) {
      let key2;
      for (key2 in check) {
        if (node2[key2] !== check[key2])
          return false;
      }
      return true;
    }
  }
  function typeFactory$2(check) {
    return castFactory$3(type);
    function type(node2) {
      return node2 && node2.type === check;
    }
  }
  function castFactory$3(check) {
    return assertion;
    function assertion(node2, ...parameters) {
      return Boolean(
        node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
        Boolean(check.call(this, node2, ...parameters))
      );
    }
  }
  function ok$2() {
    return true;
  }
  function whitespace$1(thing) {
    const value = (
      // @ts-expect-error looks like a node.
      thing && typeof thing === "object" && thing.type === "text" ? (
        // @ts-expect-error looks like a text.
        thing.value || ""
      ) : thing
    );
    return typeof value === "string" && value.replace(/[ \t\n\f\r]/g, "") === "";
  }
  const blocks = [
    "address",
    // Flow content.
    "article",
    // Sections and headings.
    "aside",
    // Sections and headings.
    "blockquote",
    // Flow content.
    "body",
    // Page.
    "br",
    // Contribute whitespace intrinsically.
    "caption",
    // Similar to block.
    "center",
    // Flow content, legacy.
    "col",
    // Similar to block.
    "colgroup",
    // Similar to block.
    "dd",
    // Lists.
    "dialog",
    // Flow content.
    "dir",
    // Lists, legacy.
    "div",
    // Flow content.
    "dl",
    // Lists.
    "dt",
    // Lists.
    "figcaption",
    // Flow content.
    "figure",
    // Flow content.
    "footer",
    // Flow content.
    "form",
    // Flow content.
    "h1",
    // Sections and headings.
    "h2",
    // Sections and headings.
    "h3",
    // Sections and headings.
    "h4",
    // Sections and headings.
    "h5",
    // Sections and headings.
    "h6",
    // Sections and headings.
    "head",
    // Page.
    "header",
    // Flow content.
    "hgroup",
    // Sections and headings.
    "hr",
    // Flow content.
    "html",
    // Page.
    "legend",
    // Flow content.
    "li",
    // Block-like.
    "li",
    // Similar to block.
    "listing",
    // Flow content, legacy
    "main",
    // Flow content.
    "menu",
    // Lists.
    "nav",
    // Sections and headings.
    "ol",
    // Lists.
    "optgroup",
    // Similar to block.
    "option",
    // Similar to block.
    "p",
    // Flow content.
    "plaintext",
    // Flow content, legacy
    "pre",
    // Flow content.
    "section",
    // Sections and headings.
    "summary",
    // Similar to block.
    "table",
    // Similar to block.
    "tbody",
    // Similar to block.
    "td",
    // Block-like.
    "td",
    // Similar to block.
    "tfoot",
    // Similar to block.
    "th",
    // Block-like.
    "th",
    // Similar to block.
    "thead",
    // Similar to block.
    "tr",
    // Similar to block.
    "ul",
    // Lists.
    "wbr",
    // Contribute whitespace intrinsically.
    "xmp"
    // Flow content, legacy
  ];
  const content$1 = [
    // Form.
    "button",
    "input",
    "select",
    "textarea"
  ];
  const skippable$1 = [
    "area",
    "base",
    "basefont",
    "dialog",
    "datalist",
    "head",
    "link",
    "meta",
    "noembed",
    "noframes",
    "param",
    "rp",
    "script",
    "source",
    "style",
    "template",
    "track",
    "title"
  ];
  const ignorableNode = convert$2(["doctype", "comment"]);
  function rehypeMinifyWhitespace(options = {}) {
    const collapse = collapseFactory(
      options.newlines ? replaceNewlines : replaceWhitespace
    );
    return (tree) => {
      minify(tree, { collapse, whitespace: "normal" });
    };
  }
  function minify(node2, context) {
    if ("children" in node2) {
      const settings = Object.assign({}, context);
      if (node2.type === "root" || blocklike(node2)) {
        settings.before = true;
        settings.after = true;
      }
      settings.whitespace = inferWhiteSpace(node2, context);
      return all$1(node2, settings);
    }
    if (node2.type === "text") {
      if (context.whitespace === "normal") {
        return minifyText(node2, context);
      }
      if (context.whitespace === "nowrap") {
        node2.value = context.collapse(node2.value);
      }
    }
    return { remove: false, ignore: ignorableNode(node2), stripAtStart: false };
  }
  function minifyText(node2, context) {
    const value = context.collapse(node2.value);
    const result = { remove: false, ignore: false, stripAtStart: false };
    let start = 0;
    let end = value.length;
    if (context.before && removable(value.charAt(0))) {
      start++;
    }
    if (start !== end && removable(value.charAt(end - 1))) {
      if (context.after) {
        end--;
      } else {
        result.stripAtStart = true;
      }
    }
    if (start === end) {
      result.remove = true;
    } else {
      node2.value = value.slice(start, end);
    }
    return result;
  }
  function all$1(parent, context) {
    let before = context.before;
    const after = context.after;
    const children = parent.children;
    let length2 = children.length;
    let index2 = -1;
    while (++index2 < length2) {
      const result = minify(
        children[index2],
        Object.assign({}, context, {
          before,
          after: collapsableAfter(children, index2, after)
        })
      );
      if (result.remove) {
        children.splice(index2, 1);
        index2--;
        length2--;
      } else if (!result.ignore) {
        before = result.stripAtStart;
      }
      if (content(children[index2])) {
        before = false;
      }
    }
    return { remove: false, ignore: false, stripAtStart: Boolean(before || after) };
  }
  function collapsableAfter(nodes, index2, after) {
    while (++index2 < nodes.length) {
      const node2 = nodes[index2];
      let result = inferBoundary(node2);
      if (result === void 0 && "children" in node2 && !skippable(node2)) {
        result = collapsableAfter(node2.children, -1);
      }
      if (typeof result === "boolean") {
        return result;
      }
    }
    return after;
  }
  function inferBoundary(node2) {
    if (node2.type === "element") {
      if (content(node2)) {
        return false;
      }
      if (blocklike(node2)) {
        return true;
      }
    } else if (node2.type === "text") {
      if (!whitespace$1(node2)) {
        return false;
      }
    } else if (!ignorableNode(node2)) {
      return false;
    }
  }
  function content(node2) {
    return embedded(node2) || isElement(node2, content$1);
  }
  function blocklike(node2) {
    return isElement(node2, blocks);
  }
  function skippable(node2) {
    return Boolean(
      "properties" in node2 && node2.properties && node2.properties.hidden
    ) || ignorableNode(node2) || isElement(node2, skippable$1);
  }
  function removable(character) {
    return character === " " || character === "\n";
  }
  function replaceNewlines(value) {
    const match = /\r?\n|\r/.exec(value);
    return match ? match[0] : " ";
  }
  function replaceWhitespace() {
    return " ";
  }
  function collapseFactory(replace2) {
    return collapse;
    function collapse(value) {
      return String(value).replace(/[\t\n\v\f\r ]+/g, replace2);
    }
  }
  function inferWhiteSpace(node2, context) {
    if ("tagName" in node2 && node2.properties) {
      switch (node2.tagName) {
        case "listing":
        case "plaintext":
        case "script":
        case "style":
        case "xmp":
          return "pre";
        case "nobr":
          return "nowrap";
        case "pre":
          return node2.properties.wrap ? "pre-wrap" : "pre";
        case "td":
        case "th":
          return node2.properties.noWrap ? "nowrap" : context.whitespace;
        case "textarea":
          return "pre-wrap";
      }
    }
    return context.whitespace;
  }
  function all(h2, parent) {
    const nodes = parent.children || [];
    const values = [];
    let index2 = -1;
    while (++index2 < nodes.length) {
      const result = one(h2, nodes[index2], parent);
      if (Array.isArray(result)) {
        values.push(...result);
      } else if (result) {
        values.push(result);
      }
    }
    let start = 0;
    let end = values.length;
    while (start < end && values[start].type === "break") {
      start++;
    }
    while (end > start && values[end - 1].type === "break") {
      end--;
    }
    return start === 0 && end === values.length ? values : values.slice(start, end);
  }
  const own$1 = {}.hasOwnProperty;
  function wrapText(h2, value) {
    return h2.wrapText ? value : value.replace(/\r?\n|\r/g, " ");
  }
  function one(h2, node2, parent) {
    let fn;
    if (node2.type === "element") {
      if (node2.properties && node2.properties.dataMdast === "ignore") {
        return;
      }
      if (own$1.call(h2.handlers, node2.tagName)) {
        fn = h2.handlers[node2.tagName];
      }
    } else if (own$1.call(h2.handlers, node2.type)) {
      fn = h2.handlers[node2.type];
    }
    if (typeof fn === "function") {
      return fn(h2, node2, parent);
    }
    return unknown$1(h2, node2);
  }
  function unknown$1(h2, node2) {
    if (typeof node2.value === "string") {
      return h2(node2, "text", wrapText(h2, node2.value));
    }
    return all(h2, node2);
  }
  const own = {}.hasOwnProperty;
  function hasProperty$1(node2, field) {
    const value = typeof field === "string" && isNode$1(node2) && node2.type === "element" && node2.properties && own.call(node2.properties, field) && node2.properties[field];
    return value !== null && value !== void 0 && value !== false;
  }
  function isNode$1(value) {
    return Boolean(value && typeof value === "object" && "type" in value);
  }
  const list$2 = /* @__PURE__ */ new Set(["pingback", "prefetch", "stylesheet"]);
  function isBodyOkLink(node2) {
    if (!isElement(node2, "link")) {
      return false;
    }
    if (hasProperty$1(node2, "itemProp")) {
      return true;
    }
    const props = node2.properties || {};
    const rel = props.rel || [];
    let index2 = -1;
    if (!Array.isArray(rel) || rel.length === 0) {
      return false;
    }
    while (++index2 < rel.length) {
      if (!list$2.has(String(rel[index2]))) {
        return false;
      }
    }
    return true;
  }
  const basic = convertElement$1([
    "a",
    "abbr",
    // `area` is in fact only phrasing if it is inside a `map` element.
    // However, since `area`s are required to be inside a `map` element, and it’s
    // a rather involved check, it’s ignored here for now.
    "area",
    "b",
    "bdi",
    "bdo",
    "br",
    "button",
    "cite",
    "code",
    "data",
    "datalist",
    "del",
    "dfn",
    "em",
    "i",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "map",
    "mark",
    "meter",
    "noscript",
    "output",
    "progress",
    "q",
    "ruby",
    "s",
    "samp",
    "script",
    "select",
    "small",
    "span",
    "strong",
    "sub",
    "sup",
    "template",
    "textarea",
    "time",
    "u",
    "var",
    "wbr"
  ]);
  const meta = convertElement$1("meta");
  function phrasing$2(value) {
    return Boolean(
      node(value) && (value.type === "text" || basic(value) || embedded(value) || isBodyOkLink(value) || meta(value) && hasProperty$1(value, "itemProp"))
    );
  }
  function node(value) {
    return value && typeof value === "object" && "type" in value;
  }
  const convert$1 = (
    /**
     * @type {(
     *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
     *   ((test?: Test) => AssertAnything)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */
    function(test) {
      if (test === void 0 || test === null) {
        return ok$1;
      }
      if (typeof test === "string") {
        return typeFactory$1(test);
      }
      if (typeof test === "object") {
        return Array.isArray(test) ? anyFactory$2(test) : propsFactory$1(test);
      }
      if (typeof test === "function") {
        return castFactory$2(test);
      }
      throw new Error("Expected function, string, or object as test");
    }
  );
  function anyFactory$2(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convert$1(tests[index2]);
    }
    return castFactory$2(any2);
    function any2(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].call(this, ...parameters))
          return true;
      }
      return false;
    }
  }
  function propsFactory$1(check) {
    return castFactory$2(all2);
    function all2(node2) {
      let key2;
      for (key2 in check) {
        if (node2[key2] !== check[key2])
          return false;
      }
      return true;
    }
  }
  function typeFactory$1(check) {
    return castFactory$2(type);
    function type(node2) {
      return node2 && node2.type === check;
    }
  }
  function castFactory$2(check) {
    return assertion;
    function assertion(node2, ...parameters) {
      return Boolean(
        node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
        Boolean(check.call(this, node2, ...parameters))
      );
    }
  }
  function ok$1() {
    return true;
  }
  const phrasing$1 = (
    /** @type {AssertPredicatePhrasing} */
    convert$1([
      "break",
      "delete",
      "emphasis",
      "footnote",
      "footnoteReference",
      "image",
      "imageReference",
      "inlineCode",
      "link",
      "linkReference",
      "strong",
      "text"
    ])
  );
  function wrap(nodes) {
    return runs(nodes, onphrasing);
    function onphrasing(nodes2) {
      const head2 = nodes2[0];
      if (nodes2.length === 1 && head2.type === "text" && (head2.value === " " || head2.value === "\n")) {
        return [];
      }
      return { type: "paragraph", children: nodes2 };
    }
  }
  function wrapNeeded(nodes) {
    let index2 = -1;
    let node2;
    while (++index2 < nodes.length) {
      node2 = nodes[index2];
      if (!phrasing(node2) || "children" in node2 && wrapNeeded(node2.children)) {
        return true;
      }
    }
    return false;
  }
  function runs(nodes, onphrasing, onnonphrasing) {
    const nonphrasing = onnonphrasing || identity;
    const flattened = flatten(nodes);
    let result = [];
    let index2 = -1;
    let queue;
    let node2;
    while (++index2 < flattened.length) {
      node2 = flattened[index2];
      if (phrasing(node2)) {
        if (!queue)
          queue = [];
        queue.push(node2);
      } else {
        if (queue) {
          result = result.concat(onphrasing(queue));
          queue = void 0;
        }
        result = result.concat(nonphrasing(node2));
      }
    }
    if (queue) {
      result = result.concat(onphrasing(queue));
    }
    return result;
  }
  function flatten(nodes) {
    let flattened = [];
    let index2 = -1;
    let node2;
    while (++index2 < nodes.length) {
      node2 = nodes[index2];
      if ((node2.type === "delete" || node2.type === "link") && wrapNeeded(node2.children)) {
        flattened = flattened.concat(split(node2));
      } else {
        flattened.push(node2);
      }
    }
    return flattened;
  }
  function split(node2) {
    return runs(node2.children, onphrasing, onnonphrasing);
    function onnonphrasing(child) {
      if ("children" in child && "children" in node2) {
        const { children, ...rest } = node2;
        return {
          ...child,
          // @ts-expect-error: assume matching parent & child.
          children: [{ ...extend$1(true, {}, rest), children: child.children }]
        };
      }
      return { ...child };
    }
    function onphrasing(nodes) {
      const { children, ...rest } = node2;
      return { ...extend$1(true, {}, rest), children: nodes };
    }
  }
  function phrasing(node2) {
    return node2.data && node2.data.hName ? phrasing$2({
      type: "element",
      tagName: node2.data.hName,
      properties: {},
      children: []
    }) : phrasing$1(node2);
  }
  function identity(n) {
    return n;
  }
  function wrapChildren(h2, node2) {
    return wrap(all(h2, node2));
  }
  function resolve(h2, url) {
    if (url === null || url === void 0) {
      return "";
    }
    if (h2.frozenBaseUrl) {
      return String(new URL(url, h2.frozenBaseUrl));
    }
    return url;
  }
  function a(h2, node2) {
    const props = node2.properties;
    return h2(
      node2,
      "link",
      {
        title: props.title || null,
        url: resolve(h2, String(props.href || "") || null)
      },
      all(h2, node2)
    );
  }
  function base(h2, node2) {
    if (!h2.baseFound) {
      h2.frozenBaseUrl = String(node2.properties && node2.properties.href || "") || null;
      h2.baseFound = true;
    }
  }
  function blockquote$1(h2, node2) {
    return h2(node2, "blockquote", wrapChildren(h2, node2));
  }
  function br$1(h2, node2) {
    return h2.wrapText ? h2(node2, "break") : h2(node2, "text", " ");
  }
  const convertElement = (
    /**
     * @type {(
     *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &
     *   ((test?: Test) => AssertAnything)
     * )}
     */
    /**
     * @param {Test | null | undefined} [test]
     * @returns {AssertAnything}
     */
    function(test) {
      if (test === void 0 || test === null) {
        return element;
      }
      if (typeof test === "string") {
        return tagNameFactory(test);
      }
      if (typeof test === "object") {
        return anyFactory$1(test);
      }
      if (typeof test === "function") {
        return castFactory$1(test);
      }
      throw new Error("Expected function, string, or array as test");
    }
  );
  function anyFactory$1(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convertElement(tests[index2]);
    }
    return castFactory$1(any2);
    function any2(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].call(this, ...parameters)) {
          return true;
        }
      }
      return false;
    }
  }
  function tagNameFactory(check) {
    return tagName;
    function tagName(node2) {
      return element(node2) && node2.tagName === check;
    }
  }
  function castFactory$1(check) {
    return assertion;
    function assertion(node2, ...parameters) {
      return element(node2) && Boolean(check.call(this, node2, ...parameters));
    }
  }
  function element(node2) {
    return Boolean(
      node2 && typeof node2 === "object" && // @ts-expect-error Looks like a node.
      node2.type === "element" && // @ts-expect-error Looks like an element.
      typeof node2.tagName === "string"
    );
  }
  const convert = (
    /**
     * @type {(
     *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
     *   ((test?: Test) => AssertAnything)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */
    function(test) {
      if (test === void 0 || test === null) {
        return ok;
      }
      if (typeof test === "string") {
        return typeFactory(test);
      }
      if (typeof test === "object") {
        return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
      }
      if (typeof test === "function") {
        return castFactory(test);
      }
      throw new Error("Expected function, string, or object as test");
    }
  );
  function anyFactory(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convert(tests[index2]);
    }
    return castFactory(any2);
    function any2(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].call(this, ...parameters))
          return true;
      }
      return false;
    }
  }
  function propsFactory(check) {
    return castFactory(all2);
    function all2(node2) {
      let key2;
      for (key2 in check) {
        if (node2[key2] !== check[key2])
          return false;
      }
      return true;
    }
  }
  function typeFactory(check) {
    return castFactory(type);
    function type(node2) {
      return node2 && node2.type === check;
    }
  }
  function castFactory(check) {
    return assertion;
    function assertion(node2, ...parameters) {
      return Boolean(
        node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
        Boolean(check.call(this, node2, ...parameters))
      );
    }
  }
  function ok() {
    return true;
  }
  const findAfter = (
    /**
     * @type {(
     *  (<T extends Node>(node: Parent, index: Node | number, test: import('unist-util-is').PredicateTest<T>) => T | null) &
     *  ((node: Parent, index: Node | number, test?: Test) => Node | null)
     * )}
     */
    /**
     * @param {Parent} parent
     * @param {Node | number} index
     * @param {Test} [test]
     * @returns {Node | null}
     */
    function(parent, index2, test) {
      const is = convert(test);
      if (!parent || !parent.type || !parent.children) {
        throw new Error("Expected parent node");
      }
      if (typeof index2 === "number") {
        if (index2 < 0 || index2 === Number.POSITIVE_INFINITY) {
          throw new Error("Expected positive finite number as index");
        }
      } else {
        index2 = parent.children.indexOf(index2);
        if (index2 < 0) {
          throw new Error("Expected child node or index");
        }
      }
      while (++index2 < parent.children.length) {
        if (is(parent.children[index2], index2, parent)) {
          return parent.children[index2];
        }
      }
      return null;
    }
  );
  const searchLineFeeds = /\n/g;
  const searchTabOrSpaces = /[\t ]+/g;
  const br = convertElement("br");
  const p$2 = convertElement("p");
  const cell$1 = convertElement(["th", "td"]);
  const row = convertElement("tr");
  const notRendered = convertElement([
    // List from: <https://html.spec.whatwg.org/#hidden-elements>
    "datalist",
    "head",
    "noembed",
    "noframes",
    "noscript",
    // Act as if we support scripting.
    "rp",
    "script",
    "style",
    "template",
    "title",
    // Hidden attribute.
    hidden,
    // From: <https://html.spec.whatwg.org/#flow-content-3>
    closedDialog
  ]);
  const blockOrCaption = convertElement([
    "address",
    // Flow content
    "article",
    // Sections and headings
    "aside",
    // Sections and headings
    "blockquote",
    // Flow content
    "body",
    // Page
    "caption",
    // `table-caption`
    "center",
    // Flow content (legacy)
    "dd",
    // Lists
    "dialog",
    // Flow content
    "dir",
    // Lists (legacy)
    "dl",
    // Lists
    "dt",
    // Lists
    "div",
    // Flow content
    "figure",
    // Flow content
    "figcaption",
    // Flow content
    "footer",
    // Flow content
    "form,",
    // Flow content
    "h1",
    // Sections and headings
    "h2",
    // Sections and headings
    "h3",
    // Sections and headings
    "h4",
    // Sections and headings
    "h5",
    // Sections and headings
    "h6",
    // Sections and headings
    "header",
    // Flow content
    "hgroup",
    // Sections and headings
    "hr",
    // Flow content
    "html",
    // Page
    "legend",
    // Flow content
    "listing",
    // Flow content (legacy)
    "main",
    // Flow content
    "menu",
    // Lists
    "nav",
    // Sections and headings
    "ol",
    // Lists
    "p",
    // Flow content
    "plaintext",
    // Flow content (legacy)
    "pre",
    // Flow content
    "section",
    // Sections and headings
    "ul",
    // Lists
    "xmp"
    // Flow content (legacy)
  ]);
  function toText(tree, options = {}) {
    const children = "children" in tree ? tree.children : [];
    const block2 = blockOrCaption(tree);
    const whitespace2 = inferWhitespace(tree, {
      whitespace: options.whitespace || "normal",
      breakBefore: false,
      breakAfter: false
    });
    const results = [];
    if (tree.type === "text" || tree.type === "comment") {
      results.push(
        ...collectText(tree, {
          whitespace: whitespace2,
          breakBefore: true,
          breakAfter: true
        })
      );
    }
    let index2 = -1;
    while (++index2 < children.length) {
      results.push(
        ...innerTextCollection(children[index2], tree, {
          whitespace: whitespace2,
          breakBefore: index2 ? void 0 : block2,
          breakAfter: index2 < children.length - 1 ? br(children[index2 + 1]) : block2
        })
      );
    }
    const result = [];
    let count;
    index2 = -1;
    while (++index2 < results.length) {
      const value = results[index2];
      if (typeof value === "number") {
        if (count !== void 0 && value > count)
          count = value;
      } else if (value) {
        if (count !== void 0 && count > -1) {
          result.push("\n".repeat(count) || " ");
        }
        count = -1;
        result.push(value);
      }
    }
    return result.join("");
  }
  function innerTextCollection(node2, parent, info) {
    if (node2.type === "element") {
      return collectElement(node2, parent, info);
    }
    if (node2.type === "text") {
      return info.whitespace === "normal" ? collectText(node2, info) : collectPreText(node2);
    }
    return [];
  }
  function collectElement(node2, parent, info) {
    const whitespace2 = inferWhitespace(node2, info);
    const children = node2.children || [];
    let index2 = -1;
    let items = [];
    if (notRendered(node2)) {
      return items;
    }
    let prefix2;
    let suffix;
    if (br(node2)) {
      suffix = "\n";
    } else if (row(node2) && findAfter(parent, node2, row)) {
      suffix = "\n";
    } else if (p$2(node2)) {
      prefix2 = 2;
      suffix = 2;
    } else if (blockOrCaption(node2)) {
      prefix2 = 1;
      suffix = 1;
    }
    while (++index2 < children.length) {
      items = items.concat(
        innerTextCollection(children[index2], node2, {
          whitespace: whitespace2,
          breakBefore: index2 ? void 0 : prefix2,
          breakAfter: index2 < children.length - 1 ? br(children[index2 + 1]) : suffix
        })
      );
    }
    if (cell$1(node2) && findAfter(parent, node2, cell$1)) {
      items.push("	");
    }
    if (prefix2)
      items.unshift(prefix2);
    if (suffix)
      items.push(suffix);
    return items;
  }
  function collectText(node2, info) {
    const value = String(node2.value);
    const lines = [];
    const result = [];
    let start = 0;
    while (start <= value.length) {
      searchLineFeeds.lastIndex = start;
      const match = searchLineFeeds.exec(value);
      const end = match && "index" in match ? match.index : value.length;
      lines.push(
        // Any sequence of collapsible spaces and tabs immediately preceding or
        // following a segment break is removed.
        trimAndCollapseSpacesAndTabs(
          // […] ignoring bidi formatting characters (characters with the
          // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if
          // they were not there.
          value.slice(start, end).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""),
          start === 0 ? info.breakBefore : true,
          end === value.length ? info.breakAfter : true
        )
      );
      start = end + 1;
    }
    let index2 = -1;
    let join2;
    while (++index2 < lines.length) {
      if (lines[index2].charCodeAt(lines[index2].length - 1) === 8203 || index2 < lines.length - 1 && lines[index2 + 1].charCodeAt(0) === 8203) {
        result.push(lines[index2]);
        join2 = void 0;
      } else if (lines[index2]) {
        if (typeof join2 === "number")
          result.push(join2);
        result.push(lines[index2]);
        join2 = 0;
      } else if (index2 === 0 || index2 === lines.length - 1) {
        result.push(0);
      }
    }
    return result;
  }
  function collectPreText(node2) {
    return [String(node2.value)];
  }
  function trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {
    const result = [];
    let start = 0;
    let end;
    while (start < value.length) {
      searchTabOrSpaces.lastIndex = start;
      const match = searchTabOrSpaces.exec(value);
      end = match ? match.index : value.length;
      if (!start && !end && match && !breakBefore) {
        result.push("");
      }
      if (start !== end) {
        result.push(value.slice(start, end));
      }
      start = match ? end + match[0].length : end;
    }
    if (start !== end && !breakAfter) {
      result.push("");
    }
    return result.join(" ");
  }
  function inferWhitespace(node2, info) {
    if (node2.type === "element") {
      const props = node2.properties || {};
      switch (node2.tagName) {
        case "listing":
        case "plaintext":
        case "xmp": {
          return "pre";
        }
        case "nobr": {
          return "nowrap";
        }
        case "pre": {
          return props.wrap ? "pre-wrap" : "pre";
        }
        case "td":
        case "th": {
          return props.noWrap ? "nowrap" : info.whitespace;
        }
        case "textarea": {
          return "pre-wrap";
        }
      }
    }
    return info.whitespace;
  }
  function hidden(node2) {
    return Boolean((node2.properties || {}).hidden);
  }
  function closedDialog(node2) {
    return node2.tagName === "dialog" && !(node2.properties || {}).open;
  }
  function trimTrailingLines(value) {
    const input2 = String(value);
    let end = input2.length;
    while (end > 0) {
      const code2 = input2.codePointAt(end - 1);
      if (code2 !== void 0 && (code2 === 10 || code2 === 13)) {
        end--;
      } else {
        break;
      }
    }
    return input2.slice(0, end);
  }
  const prefix = "language-";
  const pre = convertElement$1("pre");
  const isCode = convertElement$1("code");
  function code$1(h2, node2) {
    const children = node2.children;
    let index2 = -1;
    let classList;
    let lang;
    if (pre(node2)) {
      while (++index2 < children.length) {
        const child = children[index2];
        if (isCode(child) && child.properties && child.properties.className && Array.isArray(child.properties.className)) {
          classList = child.properties.className;
          break;
        }
      }
    }
    if (classList) {
      index2 = -1;
      while (++index2 < classList.length) {
        if (String(classList[index2]).slice(0, prefix.length) === prefix) {
          lang = String(classList[index2]).slice(prefix.length);
          break;
        }
      }
    }
    return h2(
      node2,
      "code",
      { lang: lang || null, meta: null },
      trimTrailingLines(wrapText(h2, toText(node2)))
    );
  }
  function comment(h2, node2) {
    return h2(node2, "html", "<!--" + wrapText(h2, node2.value) + "-->");
  }
  function del(h2, node2) {
    return h2(node2, "delete", all(h2, node2));
  }
  function listItemsSpread(children) {
    let index2 = -1;
    if (children.length > 1) {
      while (++index2 < children.length) {
        if (children[index2].spread) {
          return true;
        }
      }
    }
    return false;
  }
  function wrapListItems(h2, node2) {
    const children = all(h2, node2);
    let index2 = -1;
    while (++index2 < children.length) {
      const child = children[index2];
      if (child.type !== "listItem") {
        children[index2] = {
          type: "listItem",
          spread: false,
          checked: null,
          // @ts-expect-error Assume `children[index]` is block content.
          children: [child]
        };
      }
    }
    return children;
  }
  const div = convertElement$1("div");
  const dt = convertElement$1("dt");
  const dd = convertElement$1("dd");
  function dl(h2, node2) {
    const children = node2.children;
    let index2 = -1;
    let clean2 = [];
    const groups = [];
    let group = { titles: [], definitions: [] };
    let child;
    let result;
    while (++index2 < children.length) {
      child = children[index2];
      clean2 = clean2.concat(div(child) ? child.children : child);
    }
    index2 = -1;
    while (++index2 < clean2.length) {
      child = clean2[index2];
      if (dt(child)) {
        if (dd(clean2[index2 - 1])) {
          groups.push(group);
          group = { titles: [], definitions: [] };
        }
        group.titles.push(child);
      } else {
        group.definitions.push(child);
      }
    }
    groups.push(group);
    index2 = -1;
    const content2 = [];
    while (++index2 < groups.length) {
      result = [
        ...handle$1(h2, groups[index2].titles),
        ...handle$1(h2, groups[index2].definitions)
      ];
      if (result.length > 0) {
        content2.push({
          type: "listItem",
          spread: result.length > 1,
          checked: null,
          children: result
        });
      }
    }
    if (content2.length > 0) {
      return h2(
        node2,
        "list",
        { ordered: false, start: null, spread: listItemsSpread(content2) },
        content2
      );
    }
  }
  function handle$1(h2, children) {
    const nodes = wrapListItems(h2, { type: "element", tagName: "x", children });
    if (nodes.length === 0) {
      return [];
    }
    if (nodes.length === 1) {
      return nodes[0].children;
    }
    return [
      {
        type: "list",
        ordered: false,
        start: null,
        spread: listItemsSpread(nodes),
        children: nodes
      }
    ];
  }
  function em(h2, node2) {
    return h2(node2, "emphasis", all(h2, node2));
  }
  function heading$1(h2, node2) {
    const depth = Number(node2.tagName.charAt(1)) || 1;
    const wrap2 = h2.wrapText;
    h2.wrapText = false;
    const result = h2(node2, "heading", { depth }, all(h2, node2));
    h2.wrapText = wrap2;
    return result;
  }
  function hr(h2, node2) {
    return h2(node2, "thematicBreak");
  }
  function iframe(h2, node2) {
    const props = node2.properties;
    const src = String(props.src || "");
    const title = String(props.title || "");
    if (src && title) {
      return {
        type: "link",
        title: null,
        url: resolve(h2, src),
        children: [{ type: "text", value: wrapText(h2, title) }]
      };
    }
  }
  function img(h2, node2) {
    const props = node2.properties;
    return h2(node2, "image", {
      url: resolve(h2, String(props.src || "") || null),
      title: props.title || null,
      alt: props.alt || ""
    });
  }
  function inlineCode(h2, node2) {
    return h2(node2, "inlineCode", wrapText(h2, toText(node2)));
  }
  const option = convertElement$1("option");
  function findSelectedOptions(h2, node2, properties) {
    const props = properties || node2.properties;
    let options = findOptions(node2);
    const size = Math.min(Number.parseInt(String(props.size), 10), 0) || (props.multiple ? 4 : 1);
    let index2 = -1;
    const selectedOptions = [];
    const values = [];
    while (++index2 < options.length) {
      if (hasProperty$1(options[index2], "selected")) {
        selectedOptions.push(options[index2]);
      }
    }
    const list2 = selectedOptions.length > 0 ? selectedOptions : options;
    options = list2.slice(0, size);
    index2 = -1;
    while (++index2 < options.length) {
      const option2 = options[index2];
      const content2 = wrapText(h2, toText(option2));
      const props2 = option2.properties;
      const label = content2 || String(props2.label || "");
      const value = String(props2.value || "") || content2;
      values.push([value, label === value ? null : label]);
    }
    return values;
  }
  function findOptions(node2) {
    const children = node2.children;
    let index2 = -1;
    let results = [];
    let child;
    while (++index2 < children.length) {
      child = children[index2];
      if (Array.isArray(child.children)) {
        results = results.concat(findOptions(child));
      }
      if (option(child) && !hasProperty$1(child, "disabled")) {
        results.push(child);
      }
    }
    return results;
  }
  const datalist = convertElement$1("datalist");
  function input$1(h2, node2) {
    const props = node2.properties;
    let value = String(props.value || props.placeholder || "");
    const results = [];
    const texts = [];
    let values = [];
    let index2 = -1;
    let list2;
    if (props.disabled || props.type === "hidden" || props.type === "file") {
      return;
    }
    if (props.type === "checkbox" || props.type === "radio") {
      return h2(
        node2,
        "text",
        wrapText(h2, h2[props.checked ? "checked" : "unchecked"])
      );
    }
    if (props.type === "image") {
      return props.alt || value ? h2(node2, "image", {
        url: resolve(h2, String(props.src || "") || null),
        title: wrapText(h2, String(props.title || "")) || null,
        alt: wrapText(h2, String(props.alt || value))
      }) : [];
    }
    if (value) {
      values = [[value, null]];
    } else if (
      // `list` is not supported on these types:
      props.type !== "password" && props.type !== "file" && props.type !== "submit" && props.type !== "reset" && props.type !== "button" && props.list
    ) {
      list2 = String(props.list).toUpperCase();
      if (own$1.call(h2.nodeById, list2) && datalist(h2.nodeById[list2])) {
        values = findSelectedOptions(h2, h2.nodeById[list2], props);
      }
    }
    if (values.length === 0) {
      return;
    }
    if (props.type === "password") {
      values[0] = ["•".repeat(values[0][0].length), null];
    }
    if (props.type === "url" || props.type === "email") {
      while (++index2 < values.length) {
        value = resolve(h2, values[index2][0]);
        results.push(
          h2(
            node2,
            "link",
            {
              title: null,
              url: wrapText(h2, props.type === "email" ? "mailto:" + value : value)
            },
            [{ type: "text", value: wrapText(h2, values[index2][1] || value) }]
          )
        );
        if (index2 !== values.length - 1) {
          results.push({ type: "text", value: ", " });
        }
      }
      return results;
    }
    while (++index2 < values.length) {
      texts.push(
        values[index2][1] ? values[index2][1] + " (" + values[index2][0] + ")" : values[index2][0]
      );
    }
    return h2(node2, "text", wrapText(h2, texts.join(", ")));
  }
  const p$1 = convertElement$1("p");
  const input = convertElement$1("input");
  function li(h2, node2) {
    const head2 = node2.children[0];
    let checked = null;
    let checkbox;
    let clone;
    if (p$1(head2)) {
      checkbox = head2.children[0];
      if (input(checkbox) && checkbox.properties && (checkbox.properties.type === "checkbox" || checkbox.properties.type === "radio")) {
        checked = Boolean(checkbox.properties.checked);
        clone = {
          ...node2,
          children: [
            { ...head2, children: head2.children.slice(1) },
            ...node2.children.slice(1)
          ]
        };
      }
    }
    const content2 = wrapChildren(h2, clone || node2);
    return h2(node2, "listItem", { spread: content2.length > 1, checked }, content2);
  }
  const ol = convertElement$1("ol");
  function list$1(h2, node2) {
    const ordered = ol(node2);
    const children = wrapListItems(h2, node2);
    let start = null;
    if (ordered) {
      start = hasProperty$1(node2, "start") ? (
        // @ts-expect-error: `props` exist.
        Number.parseInt(String(node2.properties.start), 10)
      ) : 1;
    }
    return h2(
      node2,
      "list",
      { ordered, start, spread: listItemsSpread(children) },
      children
    );
  }
  const source = convertElement$1("source");
  const video = convertElement$1("video");
  function media(h2, node2) {
    let nodes = all(h2, node2);
    const properties = node2.properties;
    const poster = video(node2) && String(properties.poster || "");
    let src = String(properties.src || "");
    let index2 = -1;
    let linkInFallbackContent = false;
    let child;
    visit({ type: "root", children: nodes }, "link", findLink);
    if (linkInFallbackContent || wrapNeeded(nodes)) {
      return nodes;
    }
    while (!src && ++index2 < node2.children.length) {
      child = node2.children[index2];
      if (source(child)) {
        src = String(child.properties.src || "");
      }
    }
    if (poster) {
      nodes = [
        {
          type: "image",
          title: null,
          url: resolve(h2, poster),
          alt: toString({ children: nodes })
        }
      ];
    }
    return {
      type: "link",
      // @ts-expect-error Types are broken.
      title: node2.properties.title || null,
      url: resolve(h2, src),
      // @ts-expect-error Assume phrasing content.
      children: nodes
    };
    function findLink() {
      linkInFallbackContent = true;
      return EXIT;
    }
  }
  function p(h2, node2) {
    const nodes = all(h2, node2);
    if (nodes.length > 0) {
      return h2(node2, "paragraph", nodes);
    }
  }
  function q(h2, node2) {
    const expected = h2.quotes[h2.qNesting % h2.quotes.length];
    h2.qNesting++;
    const contents = all(h2, node2);
    h2.qNesting--;
    contents.unshift({ type: "text", value: expected.charAt(0) });
    contents.push({
      type: "text",
      value: expected.length > 1 ? expected.charAt(1) : expected
    });
    return contents;
  }
  function root$1(h2, node2) {
    let children = all(h2, node2);
    if (h2.document || wrapNeeded(children)) {
      children = wrap(children);
    }
    return h2(node2, "root", children);
  }
  function select(h2, node2) {
    const values = findSelectedOptions(h2, node2);
    let index2 = -1;
    const results = [];
    let value;
    while (++index2 < values.length) {
      value = values[index2];
      results.push(value[1] ? value[1] + " (" + value[0] + ")" : value[0]);
    }
    if (results.length > 0) {
      return h2(node2, "text", wrapText(h2, results.join(", ")));
    }
  }
  function strong$1(h2, node2) {
    return h2(node2, "strong", all(h2, node2));
  }
  function tableCell(h2, node2) {
    const wrap2 = h2.wrapText;
    h2.wrapText = false;
    const result = h2(node2, "tableCell", all(h2, node2));
    if (node2.properties && (node2.properties.rowSpan || node2.properties.colSpan)) {
      const data = result.data || (result.data = {});
      if (node2.properties.rowSpan)
        data.rowSpan = node2.properties.rowSpan;
      if (node2.properties.colSpan)
        data.colSpan = node2.properties.colSpan;
    }
    h2.wrapText = wrap2;
    return result;
  }
  function tableRow(h2, node2) {
    return h2(node2, "tableRow", all(h2, node2));
  }
  const thead = convertElement$1("thead");
  const tr$1 = convertElement$1("tr");
  const cell = convertElement$1(["th", "td"]);
  function table(h2, node2) {
    if (h2.inTable) {
      return h2(node2, "text", wrapText(h2, toText(node2)));
    }
    h2.inTable = true;
    const { headless, align } = inspect(node2);
    const rows = toRows(all(h2, node2), headless);
    let columns = 1;
    let rowIndex = -1;
    while (++rowIndex < rows.length) {
      const cells2 = rows[rowIndex].children;
      let cellIndex = -1;
      while (++cellIndex < cells2.length) {
        const cell2 = cells2[cellIndex];
        if (cell2.data) {
          const colSpan = Number.parseInt(String(cell2.data.colSpan), 10) || 1;
          const rowSpan = Number.parseInt(String(cell2.data.rowSpan), 10) || 1;
          if (colSpan > 1 || rowSpan > 1) {
            let otherRowIndex = rowIndex - 1;
            while (++otherRowIndex < rowIndex + rowSpan) {
              let colIndex = cellIndex - 1;
              while (++colIndex < cellIndex + colSpan) {
                if (!rows[otherRowIndex]) {
                  break;
                }
                const newCells = [];
                if (otherRowIndex !== rowIndex || colIndex !== cellIndex) {
                  newCells.push({ type: "tableCell", children: [] });
                }
                rows[otherRowIndex].children.splice(colIndex, 0, ...newCells);
              }
            }
          }
          if ("colSpan" in cell2.data)
            delete cell2.data.colSpan;
          if ("rowSpan" in cell2.data)
            delete cell2.data.rowSpan;
          if (Object.keys(cell2.data).length === 0)
            delete cell2.data;
        }
      }
      if (cells2.length > columns)
        columns = cells2.length;
    }
    rowIndex = -1;
    while (++rowIndex < rows.length) {
      const cells2 = rows[rowIndex].children;
      let cellIndex = cells2.length - 1;
      while (++cellIndex < columns) {
        cells2.push({ type: "tableCell", children: [] });
      }
    }
    let alignIndex = align.length - 1;
    while (++alignIndex < columns) {
      align.push(null);
    }
    h2.inTable = false;
    return h2(node2, "table", { align }, rows);
  }
  function inspect(node2) {
    let headless = true;
    let rowIndex = 0;
    let cellIndex = 0;
    const align = [null];
    visit(node2, "element", (child) => {
      if (child.tagName === "table" && node2 !== child) {
        return SKIP;
      }
      if (cell(child) && child.properties) {
        if (!align[cellIndex]) {
          align[cellIndex] = String(child.properties.align || "") || null;
        }
        if (headless && rowIndex < 2 && child.tagName === "th") {
          headless = false;
        }
        cellIndex++;
      } else if (thead(child)) {
        headless = false;
      } else if (tr$1(child)) {
        rowIndex++;
        cellIndex = 0;
      }
    });
    return { align, headless };
  }
  function toRows(children, headless) {
    let index2 = -1;
    const nodes = [];
    let queue;
    if (headless) {
      nodes.push({ type: "tableRow", children: [] });
    }
    while (++index2 < children.length) {
      const node2 = children[index2];
      if (node2.type === "tableRow") {
        if (queue) {
          node2.children.unshift(...queue);
          queue = void 0;
        }
        nodes.push(node2);
      } else {
        if (!queue)
          queue = [];
        queue.push(node2);
      }
    }
    if (queue) {
      nodes[nodes.length - 1].children.push(...queue);
    }
    index2 = -1;
    while (++index2 < nodes.length) {
      nodes[index2].children = toCells(nodes[index2].children);
    }
    return nodes;
  }
  function toCells(children) {
    const nodes = [];
    let index2 = -1;
    let node2;
    let queue;
    while (++index2 < children.length) {
      node2 = children[index2];
      if (node2.type === "tableCell") {
        if (queue) {
          node2.children.unshift(...queue);
          queue = void 0;
        }
        nodes.push(node2);
      } else {
        if (!queue)
          queue = [];
        queue.push(node2);
      }
    }
    if (queue) {
      node2 = nodes[nodes.length - 1];
      if (!node2) {
        node2 = { type: "tableCell", children: [] };
        nodes.push(node2);
      }
      node2.children.push(...queue);
    }
    return nodes;
  }
  function text$1(h2, node2) {
    return h2(node2, "text", wrapText(h2, node2.value));
  }
  function textarea(h2, node2) {
    return h2(node2, "text", wrapText(h2, toText(node2)));
  }
  function wbr(h2, node2) {
    return h2(node2, "text", "​");
  }
  const handlers = {
    root: root$1,
    text: text$1,
    comment,
    doctype: ignore,
    applet: ignore,
    area: ignore,
    basefont: ignore,
    bgsound: ignore,
    caption: ignore,
    col: ignore,
    colgroup: ignore,
    command: ignore,
    content: ignore,
    datalist: ignore,
    dialog: ignore,
    element: ignore,
    embed: ignore,
    frame: ignore,
    frameset: ignore,
    isindex: ignore,
    keygen: ignore,
    link: ignore,
    math: ignore,
    menu: ignore,
    menuitem: ignore,
    meta: ignore,
    nextid: ignore,
    noembed: ignore,
    noframes: ignore,
    optgroup: ignore,
    option: ignore,
    param: ignore,
    script: ignore,
    shadow: ignore,
    source: ignore,
    spacer: ignore,
    style: ignore,
    svg: ignore,
    template: ignore,
    title: ignore,
    track: ignore,
    abbr: all,
    acronym: all,
    bdi: all,
    bdo: all,
    big: all,
    blink: all,
    button: all,
    canvas: all,
    cite: all,
    data: all,
    details: all,
    dfn: all,
    font: all,
    ins: all,
    label: all,
    map: all,
    marquee: all,
    meter: all,
    nobr: all,
    noscript: all,
    object: all,
    output: all,
    progress: all,
    rb: all,
    rbc: all,
    rp: all,
    rt: all,
    rtc: all,
    ruby: all,
    slot: all,
    small: all,
    span: all,
    sup: all,
    sub: all,
    tbody: all,
    tfoot: all,
    thead: all,
    time: all,
    address: wrapChildren,
    article: wrapChildren,
    aside: wrapChildren,
    body: wrapChildren,
    center: wrapChildren,
    div: wrapChildren,
    fieldset: wrapChildren,
    figcaption: wrapChildren,
    figure: wrapChildren,
    form: wrapChildren,
    footer: wrapChildren,
    header: wrapChildren,
    hgroup: wrapChildren,
    html: wrapChildren,
    legend: wrapChildren,
    main: wrapChildren,
    multicol: wrapChildren,
    nav: wrapChildren,
    picture: wrapChildren,
    section: wrapChildren,
    a,
    audio: media,
    b: strong$1,
    base,
    blockquote: blockquote$1,
    br: br$1,
    code: inlineCode,
    dir: list$1,
    dl,
    dt: li,
    dd: li,
    del,
    em,
    h1: heading$1,
    h2: heading$1,
    h3: heading$1,
    h4: heading$1,
    h5: heading$1,
    h6: heading$1,
    hr,
    i: em,
    iframe,
    img,
    image: img,
    input: input$1,
    kbd: inlineCode,
    li,
    listing: code$1,
    mark: em,
    ol: list$1,
    p,
    plaintext: code$1,
    pre: code$1,
    q,
    s: del,
    samp: inlineCode,
    select,
    strike: del,
    strong: strong$1,
    summary: p,
    table,
    td: tableCell,
    textarea,
    th: tableCell,
    tr: tableRow,
    tt: inlineCode,
    u: em,
    ul: list$1,
    var: inlineCode,
    video: media,
    wbr,
    xmp: code$1
  };
  function ignore() {
  }
  const block = convert$2(["heading", "paragraph", "root"]);
  function toMdast(tree, options = {}) {
    const byId = {};
    let mdast;
    const h2 = Object.assign(
      /**
       * @type {HWithProps & HWithoutProps}
       */
      /**
       * @param {Node} node
       * @param {string} type
       * @param {Properties|string|Array<Node>} [props]
       * @param {string|Array<Node>} [children]
       */
      (node2, type, props, children) => {
        let properties;
        if (typeof props === "string" || Array.isArray(props)) {
          children = props;
          properties = {};
        } else {
          properties = props;
        }
        const result2 = { type, ...properties };
        if (typeof children === "string") {
          result2.value = children;
        } else if (children) {
          result2.children = children;
        }
        if (node2.position) {
          result2.position = node2.position;
        }
        return result2;
      },
      {
        nodeById: byId,
        baseFound: false,
        inTable: false,
        wrapText: true,
        /** @type {string|null} */
        frozenBaseUrl: null,
        qNesting: 0,
        handlers: options.handlers ? { ...handlers, ...options.handlers } : handlers,
        document: options.document,
        checked: options.checked || "[x]",
        unchecked: options.unchecked || "[ ]",
        quotes: options.quotes || ['"']
      }
    );
    visit(tree, "element", (node2) => {
      const id = node2.properties && "id" in node2.properties && String(node2.properties.id).toUpperCase();
      if (id && !own$1.call(byId, id)) {
        byId[id] = node2;
      }
    });
    rehypeMinifyWhitespace({ newlines: options.newlines === true })(tree);
    const result = one(h2, tree, void 0);
    if (!result) {
      mdast = { type: "root", children: [] };
    } else if (Array.isArray(result)) {
      mdast = { type: "root", children: result };
    } else {
      mdast = result;
    }
    visit(mdast, "text", ontext);
    return mdast;
    function ontext(node2, index2, parent) {
      if (index2 === null || !parent) {
        return;
      }
      const previous2 = parent.children[index2 - 1];
      if (previous2 && previous2.type === node2.type) {
        previous2.value += node2.value;
        parent.children.splice(index2, 1);
        if (previous2.position && node2.position) {
          previous2.position.end = node2.position.end;
        }
        return index2 - 1;
      }
      node2.value = node2.value.replace(/[\t ]*(\r?\n|\r)[\t ]*/, "$1");
      if (parent && block(parent)) {
        if (!index2) {
          node2.value = node2.value.replace(/^[\t ]+/, "");
        }
        if (index2 === parent.children.length - 1) {
          node2.value = node2.value.replace(/[\t ]+$/, "");
        }
      }
      if (!node2.value) {
        parent.children.splice(index2, 1);
        return index2;
      }
    }
  }
  const rehypeRemark = (
    /**
     * @type {(import('unified').Plugin<[Processor, Options?], HastRoot> & import('unified').Plugin<[Options?]|void[], HastRoot, MdastRoot>)}
     */
    /**
     * @param {Processor|Options} [destination]
     * @param {Options} [options]
     */
    function(destination, options) {
      let settings;
      let processor;
      if (typeof destination === "function") {
        processor = destination;
        settings = options || {};
      } else {
        settings = destination || {};
      }
      if (settings.document === void 0 || settings.document === null) {
        settings = Object.assign({}, settings, { document: true });
      }
      return processor ? bridge(processor, settings) : mutate(settings);
    }
  );
  const rehypeRemark$1 = rehypeRemark;
  function bridge(destination, options) {
    return (node2, file, next) => {
      destination.run(toMdast(node2, options), file, (error) => {
        next(error);
      });
    };
  }
  function mutate(options = {}) {
    return (node2) => {
      const result = (
        /** @type {MdastRoot} */
        toMdast(node2, options)
      );
      return result;
    };
  }
  function configure(base2, extension2) {
    let index2 = -1;
    let key2;
    if (extension2.extensions) {
      while (++index2 < extension2.extensions.length) {
        configure(base2, extension2.extensions[index2]);
      }
    }
    for (key2 in extension2) {
      if (key2 === "extensions")
        ;
      else if (key2 === "unsafe" || key2 === "join") {
        base2[key2] = [...base2[key2] || [], ...extension2[key2] || []];
      } else if (key2 === "handlers") {
        base2[key2] = Object.assign(base2[key2], extension2[key2] || {});
      } else {
        base2.options[key2] = extension2[key2];
      }
    }
    return base2;
  }
  function blockquote(node2, _, state, info) {
    const exit2 = state.enter("blockquote");
    const tracker = state.createTracker(info);
    tracker.move("> ");
    tracker.shift(2);
    const value = state.indentLines(
      state.containerFlow(node2, tracker.current()),
      map$2
    );
    exit2();
    return value;
  }
  function map$2(line, _, blank) {
    return ">" + (blank ? "" : " ") + line;
  }
  function hardBreak(_, _1, state, info) {
    let index2 = -1;
    while (++index2 < state.unsafe.length) {
      if (state.unsafe[index2].character === "\n" && patternInScope(state.stack, state.unsafe[index2])) {
        return /[ \t]/.test(info.before) ? "" : " ";
      }
    }
    return "\\\n";
  }
  function longestStreak(value, substring) {
    const source2 = String(value);
    let index2 = source2.indexOf(substring);
    let expected = index2;
    let count = 0;
    let max2 = 0;
    if (typeof substring !== "string") {
      throw new TypeError("Expected substring");
    }
    while (index2 !== -1) {
      if (index2 === expected) {
        if (++count > max2) {
          max2 = count;
        }
      } else {
        count = 1;
      }
      expected = index2 + substring.length;
      index2 = source2.indexOf(substring, expected);
    }
    return max2;
  }
  function formatCodeAsIndented(node2, state) {
    return Boolean(
      !state.options.fences && node2.value && // If there’s no info…
      !node2.lang && // And there’s a non-whitespace character…
      /[^ \r\n]/.test(node2.value) && // And the value doesn’t start or end in a blank…
      !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
    );
  }
  function checkFence(state) {
    const marker = state.options.fence || "`";
    if (marker !== "`" && marker !== "~") {
      throw new Error(
        "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
      );
    }
    return marker;
  }
  function code(node2, _, state, info) {
    const marker = checkFence(state);
    const raw2 = node2.value || "";
    const suffix = marker === "`" ? "GraveAccent" : "Tilde";
    if (formatCodeAsIndented(node2, state)) {
      const exit3 = state.enter("codeIndented");
      const value2 = state.indentLines(raw2, map$1);
      exit3();
      return value2;
    }
    const tracker = state.createTracker(info);
    const sequence = marker.repeat(Math.max(longestStreak(raw2, marker) + 1, 3));
    const exit2 = state.enter("codeFenced");
    let value = tracker.move(sequence);
    if (node2.lang) {
      const subexit = state.enter(`codeFencedLang${suffix}`);
      value += tracker.move(
        state.safe(node2.lang, {
          before: value,
          after: " ",
          encode: ["`"],
          ...tracker.current()
        })
      );
      subexit();
    }
    if (node2.lang && node2.meta) {
      const subexit = state.enter(`codeFencedMeta${suffix}`);
      value += tracker.move(" ");
      value += tracker.move(
        state.safe(node2.meta, {
          before: value,
          after: "\n",
          encode: ["`"],
          ...tracker.current()
        })
      );
      subexit();
    }
    value += tracker.move("\n");
    if (raw2) {
      value += tracker.move(raw2 + "\n");
    }
    value += tracker.move(sequence);
    exit2();
    return value;
  }
  function map$1(line, _, blank) {
    return (blank ? "" : "    ") + line;
  }
  function checkQuote(state) {
    const marker = state.options.quote || '"';
    if (marker !== '"' && marker !== "'") {
      throw new Error(
        "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
      );
    }
    return marker;
  }
  function definition(node2, _, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const exit2 = state.enter("definition");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("[");
    value += tracker.move(
      state.safe(state.associationId(node2), {
        before: value,
        after: "]",
        ...tracker.current()
      })
    );
    value += tracker.move("]: ");
    subexit();
    if (
      // If there’s no url, or…
      !node2.url || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node2.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value += tracker.move("<");
      value += tracker.move(
        state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
      );
      value += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value += tracker.move(
        state.safe(node2.url, {
          before: value,
          after: node2.title ? " " : "\n",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node2.title) {
      subexit = state.enter(`title${suffix}`);
      value += tracker.move(" " + quote);
      value += tracker.move(
        state.safe(node2.title, {
          before: value,
          after: quote,
          ...tracker.current()
        })
      );
      value += tracker.move(quote);
      subexit();
    }
    exit2();
    return value;
  }
  function checkEmphasis(state) {
    const marker = state.options.emphasis || "*";
    if (marker !== "*" && marker !== "_") {
      throw new Error(
        "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
      );
    }
    return marker;
  }
  emphasis.peek = emphasisPeek;
  function emphasis(node2, _, state, info) {
    const marker = checkEmphasis(state);
    const exit2 = state.enter("emphasis");
    const tracker = state.createTracker(info);
    let value = tracker.move(marker);
    value += tracker.move(
      state.containerPhrasing(node2, {
        before: value,
        after: marker,
        ...tracker.current()
      })
    );
    value += tracker.move(marker);
    exit2();
    return value;
  }
  function emphasisPeek(_, _1, state) {
    return state.options.emphasis || "*";
  }
  function formatHeadingAsSetext(node2, state) {
    let literalWithBreak = false;
    visit(node2, (node3) => {
      if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
        literalWithBreak = true;
        return EXIT;
      }
    });
    return Boolean(
      (!node2.depth || node2.depth < 3) && toString(node2) && (state.options.setext || literalWithBreak)
    );
  }
  function heading(node2, _, state, info) {
    const rank = Math.max(Math.min(6, node2.depth || 1), 1);
    const tracker = state.createTracker(info);
    if (formatHeadingAsSetext(node2, state)) {
      const exit3 = state.enter("headingSetext");
      const subexit2 = state.enter("phrasing");
      const value2 = state.containerPhrasing(node2, {
        ...tracker.current(),
        before: "\n",
        after: "\n"
      });
      subexit2();
      exit3();
      return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
        // The whole size…
        value2.length - // Minus the position of the character after the last EOL (or
        // 0 if there is none)…
        (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
      );
    }
    const sequence = "#".repeat(rank);
    const exit2 = state.enter("headingAtx");
    const subexit = state.enter("phrasing");
    tracker.move(sequence + " ");
    let value = state.containerPhrasing(node2, {
      before: "# ",
      after: "\n",
      ...tracker.current()
    });
    if (/^[\t ]/.test(value)) {
      value = "&#x" + value.charCodeAt(0).toString(16).toUpperCase() + ";" + value.slice(1);
    }
    value = value ? sequence + " " + value : sequence;
    if (state.options.closeAtx) {
      value += " " + sequence;
    }
    subexit();
    exit2();
    return value;
  }
  html.peek = htmlPeek;
  function html(node2) {
    return node2.value || "";
  }
  function htmlPeek() {
    return "<";
  }
  image.peek = imagePeek;
  function image(node2, _, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const exit2 = state.enter("image");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("![");
    value += tracker.move(
      state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
    );
    value += tracker.move("](");
    subexit();
    if (
      // If there’s no url but there is a title…
      !node2.url && node2.title || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node2.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value += tracker.move("<");
      value += tracker.move(
        state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
      );
      value += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value += tracker.move(
        state.safe(node2.url, {
          before: value,
          after: node2.title ? " " : ")",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node2.title) {
      subexit = state.enter(`title${suffix}`);
      value += tracker.move(" " + quote);
      value += tracker.move(
        state.safe(node2.title, {
          before: value,
          after: quote,
          ...tracker.current()
        })
      );
      value += tracker.move(quote);
      subexit();
    }
    value += tracker.move(")");
    exit2();
    return value;
  }
  function imagePeek() {
    return "!";
  }
  imageReference.peek = imageReferencePeek;
  function imageReference(node2, _, state, info) {
    const type = node2.referenceType;
    const exit2 = state.enter("imageReference");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("![");
    const alt = state.safe(node2.alt, {
      before: value,
      after: "]",
      ...tracker.current()
    });
    value += tracker.move(alt + "][");
    subexit();
    const stack = state.stack;
    state.stack = [];
    subexit = state.enter("reference");
    const reference = state.safe(state.associationId(node2), {
      before: value,
      after: "]",
      ...tracker.current()
    });
    subexit();
    state.stack = stack;
    exit2();
    if (type === "full" || !alt || alt !== reference) {
      value += tracker.move(reference + "]");
    } else if (type === "shortcut") {
      value = value.slice(0, -1);
    } else {
      value += tracker.move("]");
    }
    return value;
  }
  function imageReferencePeek() {
    return "!";
  }
  function formatLinkAsAutolink(node2, state) {
    const raw2 = toString(node2);
    return Boolean(
      !state.options.resourceLink && // If there’s a url…
      node2.url && // And there’s a no title…
      !node2.title && // And the content of `node` is a single text node…
      node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the content…
      (raw2 === node2.url || "mailto:" + raw2 === node2.url) && // And that starts w/ a protocol…
      /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesn’t contain ASCII control codes (character escapes and
      // references don’t work), space, or angle brackets…
      !/[\0- <>\u007F]/.test(node2.url)
    );
  }
  link.peek = linkPeek;
  function link(node2, _, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const tracker = state.createTracker(info);
    let exit2;
    let subexit;
    if (formatLinkAsAutolink(node2, state)) {
      const stack = state.stack;
      state.stack = [];
      exit2 = state.enter("autolink");
      let value2 = tracker.move("<");
      value2 += tracker.move(
        state.containerPhrasing(node2, {
          before: value2,
          after: ">",
          ...tracker.current()
        })
      );
      value2 += tracker.move(">");
      exit2();
      state.stack = stack;
      return value2;
    }
    exit2 = state.enter("link");
    subexit = state.enter("label");
    let value = tracker.move("[");
    value += tracker.move(
      state.containerPhrasing(node2, {
        before: value,
        after: "](",
        ...tracker.current()
      })
    );
    value += tracker.move("](");
    subexit();
    if (
      // If there’s no url but there is a title…
      !node2.url && node2.title || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node2.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value += tracker.move("<");
      value += tracker.move(
        state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
      );
      value += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value += tracker.move(
        state.safe(node2.url, {
          before: value,
          after: node2.title ? " " : ")",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node2.title) {
      subexit = state.enter(`title${suffix}`);
      value += tracker.move(" " + quote);
      value += tracker.move(
        state.safe(node2.title, {
          before: value,
          after: quote,
          ...tracker.current()
        })
      );
      value += tracker.move(quote);
      subexit();
    }
    value += tracker.move(")");
    exit2();
    return value;
  }
  function linkPeek(node2, _, state) {
    return formatLinkAsAutolink(node2, state) ? "<" : "[";
  }
  linkReference.peek = linkReferencePeek;
  function linkReference(node2, _, state, info) {
    const type = node2.referenceType;
    const exit2 = state.enter("linkReference");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("[");
    const text2 = state.containerPhrasing(node2, {
      before: value,
      after: "]",
      ...tracker.current()
    });
    value += tracker.move(text2 + "][");
    subexit();
    const stack = state.stack;
    state.stack = [];
    subexit = state.enter("reference");
    const reference = state.safe(state.associationId(node2), {
      before: value,
      after: "]",
      ...tracker.current()
    });
    subexit();
    state.stack = stack;
    exit2();
    if (type === "full" || !text2 || text2 !== reference) {
      value += tracker.move(reference + "]");
    } else if (type === "shortcut") {
      value = value.slice(0, -1);
    } else {
      value += tracker.move("]");
    }
    return value;
  }
  function linkReferencePeek() {
    return "[";
  }
  function checkBulletOther(state) {
    const bullet = checkBullet(state);
    const bulletOther = state.options.bulletOther;
    if (!bulletOther) {
      return bullet === "*" ? "-" : "*";
    }
    if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
      throw new Error(
        "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
      );
    }
    if (bulletOther === bullet) {
      throw new Error(
        "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
      );
    }
    return bulletOther;
  }
  function checkBulletOrdered(state) {
    const marker = state.options.bulletOrdered || ".";
    if (marker !== "." && marker !== ")") {
      throw new Error(
        "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
      );
    }
    return marker;
  }
  function checkBulletOrderedOther(state) {
    const bulletOrdered = checkBulletOrdered(state);
    const bulletOrderedOther = state.options.bulletOrderedOther;
    if (!bulletOrderedOther) {
      return bulletOrdered === "." ? ")" : ".";
    }
    if (bulletOrderedOther !== "." && bulletOrderedOther !== ")") {
      throw new Error(
        "Cannot serialize items with `" + bulletOrderedOther + "` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`"
      );
    }
    if (bulletOrderedOther === bulletOrdered) {
      throw new Error(
        "Expected `bulletOrdered` (`" + bulletOrdered + "`) and `bulletOrderedOther` (`" + bulletOrderedOther + "`) to be different"
      );
    }
    return bulletOrderedOther;
  }
  function checkRule(state) {
    const marker = state.options.rule || "*";
    if (marker !== "*" && marker !== "-" && marker !== "_") {
      throw new Error(
        "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
      );
    }
    return marker;
  }
  function list(node2, parent, state, info) {
    const exit2 = state.enter("list");
    const bulletCurrent = state.bulletCurrent;
    let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
    const bulletOther = node2.ordered ? checkBulletOrderedOther(state) : checkBulletOther(state);
    const bulletLastUsed = state.bulletLastUsed;
    let useDifferentMarker = false;
    if (parent && // Explicit `other` set.
    (node2.ordered ? state.options.bulletOrderedOther : state.options.bulletOther) && bulletLastUsed && bullet === bulletLastUsed) {
      useDifferentMarker = true;
    }
    if (!node2.ordered) {
      const firstListItem = node2.children ? node2.children[0] : void 0;
      if (
        // Bullet could be used as a thematic break marker:
        (bullet === "*" || bullet === "-") && // Empty first list item:
        firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
        state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
        state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
      ) {
        useDifferentMarker = true;
      }
      if (checkRule(state) === bullet && firstListItem) {
        let index2 = -1;
        while (++index2 < node2.children.length) {
          const item = node2.children[index2];
          if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
            useDifferentMarker = true;
            break;
          }
        }
      }
    }
    if (useDifferentMarker) {
      bullet = bulletOther;
    }
    state.bulletCurrent = bullet;
    const value = state.containerFlow(node2, info);
    state.bulletLastUsed = bullet;
    state.bulletCurrent = bulletCurrent;
    exit2();
    return value;
  }
  function paragraph(node2, _, state, info) {
    const exit2 = state.enter("paragraph");
    const subexit = state.enter("phrasing");
    const value = state.containerPhrasing(node2, info);
    subexit();
    exit2();
    return value;
  }
  function root(node2, _, state, info) {
    const hasPhrasing = node2.children.some((d) => phrasing$1(d));
    const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow;
    return fn.call(state, node2, info);
  }
  function checkStrong(state) {
    const marker = state.options.strong || "*";
    if (marker !== "*" && marker !== "_") {
      throw new Error(
        "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
      );
    }
    return marker;
  }
  strong.peek = strongPeek;
  function strong(node2, _, state, info) {
    const marker = checkStrong(state);
    const exit2 = state.enter("strong");
    const tracker = state.createTracker(info);
    let value = tracker.move(marker + marker);
    value += tracker.move(
      state.containerPhrasing(node2, {
        before: value,
        after: marker,
        ...tracker.current()
      })
    );
    value += tracker.move(marker + marker);
    exit2();
    return value;
  }
  function strongPeek(_, _1, state) {
    return state.options.strong || "*";
  }
  function text(node2, _, state, info) {
    return state.safe(node2.value, info);
  }
  function checkRuleRepetition(state) {
    const repetition = state.options.ruleRepetition || 3;
    if (repetition < 3) {
      throw new Error(
        "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
      );
    }
    return repetition;
  }
  function thematicBreak(_, _1, state) {
    const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
    return state.options.ruleSpaces ? value.slice(0, -1) : value;
  }
  const handle = {
    blockquote,
    break: hardBreak,
    code,
    definition,
    emphasis,
    hardBreak,
    heading,
    html,
    image,
    imageReference,
    inlineCode: inlineCode$2,
    link,
    linkReference,
    list,
    listItem: listItem$1,
    paragraph,
    root,
    strong,
    text,
    thematicBreak
  };
  const join = [joinDefaults];
  function joinDefaults(left, right, parent, state) {
    if (right.type === "code" && formatCodeAsIndented(right, state) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, state))) {
      return false;
    }
    if (left.type === "list" && left.type === right.type && Boolean(left.ordered) === Boolean(right.ordered) && !(left.ordered ? state.options.bulletOrderedOther : state.options.bulletOther)) {
      return false;
    }
    if ("spread" in parent && typeof parent.spread === "boolean") {
      if (left.type === "paragraph" && // Two paragraphs.
      (left.type === right.type || right.type === "definition" || // Paragraph followed by a setext heading.
      right.type === "heading" && formatHeadingAsSetext(right, state))) {
        return;
      }
      return parent.spread ? 1 : 0;
    }
  }
  const fullPhrasingSpans = [
    "autolink",
    "destinationLiteral",
    "destinationRaw",
    "reference",
    "titleQuote",
    "titleApostrophe"
  ];
  const unsafe = [
    { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
    {
      character: "	",
      inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
    },
    {
      character: "\r",
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedLangTilde",
        "codeFencedMetaGraveAccent",
        "codeFencedMetaTilde",
        "destinationLiteral",
        "headingAtx"
      ]
    },
    {
      character: "\n",
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedLangTilde",
        "codeFencedMetaGraveAccent",
        "codeFencedMetaTilde",
        "destinationLiteral",
        "headingAtx"
      ]
    },
    { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
    { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
    {
      character: " ",
      inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
    },
    // An exclamation mark can start an image, if it is followed by a link or
    // a link reference.
    {
      character: "!",
      after: "\\[",
      inConstruct: "phrasing",
      notInConstruct: fullPhrasingSpans
    },
    // A quote can break out of a title.
    { character: '"', inConstruct: "titleQuote" },
    // A number sign could start an ATX heading if it starts a line.
    { atBreak: true, character: "#" },
    { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
    // Dollar sign and percentage are not used in markdown.
    // An ampersand could start a character reference.
    { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
    // An apostrophe can break out of a title.
    { character: "'", inConstruct: "titleApostrophe" },
    // A left paren could break out of a destination raw.
    { character: "(", inConstruct: "destinationRaw" },
    // A left paren followed by `]` could make something into a link or image.
    {
      before: "\\]",
      character: "(",
      inConstruct: "phrasing",
      notInConstruct: fullPhrasingSpans
    },
    // A right paren could start a list item or break out of a destination
    // raw.
    { atBreak: true, before: "\\d+", character: ")" },
    { character: ")", inConstruct: "destinationRaw" },
    // An asterisk can start thematic breaks, list items, emphasis, strong.
    { atBreak: true, character: "*", after: "(?:[ 	\r\n*])" },
    { character: "*", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
    // A plus sign could start a list item.
    { atBreak: true, character: "+", after: "(?:[ 	\r\n])" },
    // A dash can start thematic breaks, list items, and setext heading
    // underlines.
    { atBreak: true, character: "-", after: "(?:[ 	\r\n-])" },
    // A dot could start a list item.
    { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
    // Slash, colon, and semicolon are not used in markdown for constructs.
    // A less than can start html (flow or text) or an autolink.
    // HTML could start with an exclamation mark (declaration, cdata, comment),
    // slash (closing tag), question mark (instruction), or a letter (tag).
    // An autolink also starts with a letter.
    // Finally, it could break out of a destination literal.
    { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
    {
      character: "<",
      after: "[!/?A-Za-z]",
      inConstruct: "phrasing",
      notInConstruct: fullPhrasingSpans
    },
    { character: "<", inConstruct: "destinationLiteral" },
    // An equals to can start setext heading underlines.
    { atBreak: true, character: "=" },
    // A greater than can start block quotes and it can break out of a
    // destination literal.
    { atBreak: true, character: ">" },
    { character: ">", inConstruct: "destinationLiteral" },
    // Question mark and at sign are not used in markdown for constructs.
    // A left bracket can start definitions, references, labels,
    { atBreak: true, character: "[" },
    { character: "[", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
    { character: "[", inConstruct: ["label", "reference"] },
    // A backslash can start an escape (when followed by punctuation) or a
    // hard break (when followed by an eol).
    // Note: typical escapes are handled in `safe`!
    { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
    // A right bracket can exit labels.
    { character: "]", inConstruct: ["label", "reference"] },
    // Caret is not used in markdown for constructs.
    // An underscore can start emphasis, strong, or a thematic break.
    { atBreak: true, character: "_" },
    { character: "_", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
    // A grave accent can start code (fenced or text), or it can break out of
    // a grave accent code fence.
    { atBreak: true, character: "`" },
    {
      character: "`",
      inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
    },
    { character: "`", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
    // Left brace, vertical bar, right brace are not used in markdown for
    // constructs.
    // A tilde can start code (fenced).
    { atBreak: true, character: "~" }
  ];
  function toMarkdown(tree, options = {}) {
    const state = {
      enter: enter2,
      indentLines,
      associationId: association,
      containerPhrasing: containerPhrasingBound,
      containerFlow: containerFlowBound,
      createTracker: track,
      safe: safeBound,
      stack: [],
      unsafe: [],
      join: [],
      // @ts-expect-error: we’ll fill it next.
      handlers: {},
      options: {},
      indexStack: [],
      // @ts-expect-error: we’ll add `handle` later.
      handle: void 0
    };
    configure(state, { unsafe, join, handlers: handle });
    configure(state, options);
    if (state.options.tightDefinitions) {
      configure(state, { join: [joinDefinition] });
    }
    state.handle = zwitch("type", {
      invalid,
      unknown,
      handlers: state.handlers
    });
    let result = state.handle(tree, void 0, state, {
      before: "\n",
      after: "\n",
      now: { line: 1, column: 1 },
      lineShift: 0
    });
    if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {
      result += "\n";
    }
    return result;
    function enter2(name) {
      state.stack.push(name);
      return exit2;
      function exit2() {
        state.stack.pop();
      }
    }
  }
  function invalid(value) {
    throw new Error("Cannot handle value `" + value + "`, expected node");
  }
  function unknown(node2) {
    throw new Error("Cannot handle unknown node `" + node2.type + "`");
  }
  function joinDefinition(left, right) {
    if (left.type === "definition" && left.type === right.type) {
      return 0;
    }
  }
  function containerPhrasingBound(parent, info) {
    return containerPhrasing(parent, this, info);
  }
  function containerFlowBound(parent, info) {
    return containerFlow(parent, this, info);
  }
  function safeBound(value, config) {
    return safe(this, value, config);
  }
  function remarkStringify(options) {
    const compiler2 = (tree) => {
      const settings = (
        /** @type {Options} */
        this.data("settings")
      );
      return toMarkdown(
        tree,
        Object.assign({}, settings, options, {
          // Note: this option is not in the readme.
          // The goal is for it to be set by plugins on `data` instead of being
          // passed by users.
          extensions: (
            /** @type {ToMarkdownOptions['extensions']} */
            this.data("toMarkdownExtensions") || []
          )
        })
      );
    };
    Object.assign(this, { Compiler: compiler2 });
  }
  function removeUnderlines() {
    const removeUnderlinesHelper = (tree) => {
      let numChildElements = tree.children.length;
      for (let i2 = 0; i2 < numChildElements; i2++) {
        const node2 = tree.children[i2];
        if (node2.type === "element") {
          removeUnderlinesHelper(node2);
          if (node2.tagName === "u") {
            if (node2.children.length > 0) {
              tree.children.splice(i2, 1, ...node2.children);
              const numElementsAdded = node2.children.length - 1;
              numChildElements += numElementsAdded;
              i2 += numElementsAdded;
            } else {
              tree.children.splice(i2, 1);
              numChildElements--;
              i2--;
            }
          } else if (node2.tagName === "br") {
            tree.children.splice(i2, 1, { type: "text", value: "<br>" });
            numChildElements--;
            i2--;
          }
        }
      }
    };
    return removeUnderlinesHelper;
  }
  function cleanHTMLToMarkdown(cleanHTMLString) {
    const markdownString = unified().use(rehypeParse, { fragment: true }).use(removeUnderlines).use(rehypeRemark$1, {
      newlines: true,
      handlers: {
        span: (state, node2) => {
          const result = {
            type: "html",
            value: toHtml(node2)
          };
          state(node2, result);
          return result;
        }
      }
    }).use(remarkGfm).use(remarkStringify).processSync(cleanHTMLString);
    if (markdownString.value) {
      markdownString.value = markdownString.value.replace(
        /\\<br>/g,
        "\n"
      );
    }
    return markdownString.value;
  }
  function blocksToMarkdown(blocks2, schema, editor2) {
    const exporter = createExternalHTMLExporter(schema, editor2);
    const externalHTML = exporter.exportBlocks(blocks2);
    return cleanHTMLToMarkdown(externalHTML);
  }
  class FormattingToolbarView {
    constructor(editor2, pmView, updateFormattingToolbar) {
      __publicField(this, "formattingToolbarState");
      __publicField(this, "updateFormattingToolbar");
      __publicField(this, "preventHide", false);
      __publicField(this, "preventShow", false);
      __publicField(this, "prevWasEditable", null);
      __publicField(this, "shouldShow", ({ state }) => {
        return !state.selection.empty && !isNodeSelection(state.selection);
      });
      __publicField(this, "viewMousedownHandler", () => {
        this.preventShow = true;
      });
      __publicField(this, "viewMouseupHandler", () => {
        this.preventShow = false;
        setTimeout(() => this.update(this.pmView));
      });
      // For dragging the whole editor.
      __publicField(this, "dragHandler", () => {
        var _a;
        if ((_a = this.formattingToolbarState) == null ? void 0 : _a.show) {
          this.formattingToolbarState.show = false;
          this.updateFormattingToolbar();
        }
      });
      __publicField(this, "focusHandler", () => {
        setTimeout(() => this.update(this.pmView));
      });
      __publicField(this, "blurHandler", (event) => {
        var _a;
        if (this.preventHide) {
          this.preventHide = false;
          return;
        }
        const editorWrapper = this.pmView.dom.parentElement;
        if (
          // An element is clicked.
          event && event.relatedTarget && // Element is inside the editor.
          (editorWrapper === event.relatedTarget || editorWrapper.contains(event.relatedTarget))
        ) {
          return;
        }
        if ((_a = this.formattingToolbarState) == null ? void 0 : _a.show) {
          this.formattingToolbarState.show = false;
          this.updateFormattingToolbar();
        }
      });
      __publicField(this, "scrollHandler", () => {
        var _a;
        if ((_a = this.formattingToolbarState) == null ? void 0 : _a.show) {
          this.formattingToolbarState.referencePos = this.getSelectionBoundingBox();
          this.updateFormattingToolbar();
        }
      });
      this.editor = editor2;
      this.pmView = pmView;
      this.updateFormattingToolbar = () => {
        if (!this.formattingToolbarState) {
          throw new Error(
            "Attempting to update uninitialized formatting toolbar"
          );
        }
        updateFormattingToolbar(this.formattingToolbarState);
      };
      pmView.dom.addEventListener("mousedown", this.viewMousedownHandler);
      pmView.dom.addEventListener("mouseup", this.viewMouseupHandler);
      pmView.dom.addEventListener("dragstart", this.dragHandler);
      pmView.dom.addEventListener("dragover", this.dragHandler);
      pmView.dom.addEventListener("focus", this.focusHandler);
      pmView.dom.addEventListener("blur", this.blurHandler);
      document.addEventListener("scroll", this.scrollHandler);
    }
    update(view, oldState) {
      var _a, _b;
      const { state, composing } = view;
      const { doc: doc2, selection } = state;
      const isSame = oldState && oldState.doc.eq(doc2) && oldState.selection.eq(selection);
      if ((this.prevWasEditable === null || this.prevWasEditable === this.editor.isEditable) && (composing || isSame)) {
        return;
      }
      this.prevWasEditable = this.editor.isEditable;
      const { ranges } = selection;
      const from2 = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      const shouldShow = (_a = this.shouldShow) == null ? void 0 : _a.call(this, {
        view,
        state,
        from: from2,
        to
      });
      if (this.editor.isEditable && !this.preventShow && (shouldShow || this.preventHide)) {
        this.formattingToolbarState = {
          show: true,
          referencePos: this.getSelectionBoundingBox()
        };
        this.updateFormattingToolbar();
        return;
      }
      if (((_b = this.formattingToolbarState) == null ? void 0 : _b.show) && !this.preventHide && (!shouldShow || this.preventShow || !this.editor.isEditable)) {
        this.formattingToolbarState.show = false;
        this.updateFormattingToolbar();
        return;
      }
    }
    destroy() {
      this.pmView.dom.removeEventListener("mousedown", this.viewMousedownHandler);
      this.pmView.dom.removeEventListener("mouseup", this.viewMouseupHandler);
      this.pmView.dom.removeEventListener("dragstart", this.dragHandler);
      this.pmView.dom.removeEventListener("dragover", this.dragHandler);
      this.pmView.dom.removeEventListener("focus", this.focusHandler);
      this.pmView.dom.removeEventListener("blur", this.blurHandler);
      document.removeEventListener("scroll", this.scrollHandler);
    }
    getSelectionBoundingBox() {
      const { state } = this.pmView;
      const { selection } = state;
      const { ranges } = selection;
      const from2 = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      if (isNodeSelection(selection)) {
        const node2 = this.pmView.nodeDOM(from2);
        if (node2) {
          return node2.getBoundingClientRect();
        }
      }
      return posToDOMRect(this.pmView, from2, to);
    }
  }
  const formattingToolbarPluginKey = new PluginKey(
    "FormattingToolbarPlugin"
  );
  class FormattingToolbarProsemirrorPlugin extends EventEmitter {
    constructor(editor2) {
      super();
      __publicField(this, "view");
      __publicField(this, "plugin");
      this.plugin = new Plugin({
        key: formattingToolbarPluginKey,
        view: (editorView) => {
          this.view = new FormattingToolbarView(editor2, editorView, (state) => {
            this.emit("update", state);
          });
          return this.view;
        }
      });
    }
    onUpdate(callback) {
      return this.on("update", callback);
    }
  }
  class HyperlinkToolbarView {
    constructor(editor2, pmView, updateHyperlinkToolbar) {
      __publicField(this, "hyperlinkToolbarState");
      __publicField(this, "updateHyperlinkToolbar");
      __publicField(this, "menuUpdateTimer");
      __publicField(this, "startMenuUpdateTimer");
      __publicField(this, "stopMenuUpdateTimer");
      __publicField(this, "mouseHoveredHyperlinkMark");
      __publicField(this, "mouseHoveredHyperlinkMarkRange");
      __publicField(this, "keyboardHoveredHyperlinkMark");
      __publicField(this, "keyboardHoveredHyperlinkMarkRange");
      __publicField(this, "hyperlinkMark");
      __publicField(this, "hyperlinkMarkRange");
      __publicField(this, "mouseOverHandler", (event) => {
        this.mouseHoveredHyperlinkMark = void 0;
        this.mouseHoveredHyperlinkMarkRange = void 0;
        this.stopMenuUpdateTimer();
        if (event.target instanceof HTMLAnchorElement && event.target.nodeName === "A") {
          const hoveredHyperlinkElement = event.target;
          const posInHoveredHyperlinkMark = this.pmView.posAtDOM(hoveredHyperlinkElement, 0) + 1;
          const resolvedPosInHoveredHyperlinkMark = this.pmView.state.doc.resolve(
            posInHoveredHyperlinkMark
          );
          const marksAtPos = resolvedPosInHoveredHyperlinkMark.marks();
          for (const mark2 of marksAtPos) {
            if (mark2.type.name === this.pmView.state.schema.mark("link").type.name) {
              this.mouseHoveredHyperlinkMark = mark2;
              this.mouseHoveredHyperlinkMarkRange = getMarkRange(
                resolvedPosInHoveredHyperlinkMark,
                mark2.type,
                mark2.attrs
              ) || void 0;
              break;
            }
          }
        }
        this.startMenuUpdateTimer();
        return false;
      });
      __publicField(this, "clickHandler", (event) => {
        var _a;
        const editorWrapper = this.pmView.dom.parentElement;
        if (
          // Toolbar is open.
          this.hyperlinkMark && // An element is clicked.
          event && event.target && // The clicked element is not the editor.
          !(editorWrapper === event.target || editorWrapper.contains(event.target))
        ) {
          if ((_a = this.hyperlinkToolbarState) == null ? void 0 : _a.show) {
            this.hyperlinkToolbarState.show = false;
            this.updateHyperlinkToolbar();
          }
        }
      });
      __publicField(this, "scrollHandler", () => {
        var _a;
        if (this.hyperlinkMark !== void 0) {
          if ((_a = this.hyperlinkToolbarState) == null ? void 0 : _a.show) {
            this.hyperlinkToolbarState.referencePos = posToDOMRect(
              this.pmView,
              this.hyperlinkMarkRange.from,
              this.hyperlinkMarkRange.to
            );
            this.updateHyperlinkToolbar();
          }
        }
      });
      this.editor = editor2;
      this.pmView = pmView;
      this.updateHyperlinkToolbar = () => {
        if (!this.hyperlinkToolbarState) {
          throw new Error("Attempting to update uninitialized hyperlink toolbar");
        }
        updateHyperlinkToolbar(this.hyperlinkToolbarState);
      };
      this.startMenuUpdateTimer = () => {
        this.menuUpdateTimer = setTimeout(() => {
          this.update();
        }, 250);
      };
      this.stopMenuUpdateTimer = () => {
        if (this.menuUpdateTimer) {
          clearTimeout(this.menuUpdateTimer);
          this.menuUpdateTimer = void 0;
        }
        return false;
      };
      this.pmView.dom.addEventListener("mouseover", this.mouseOverHandler);
      document.addEventListener("click", this.clickHandler, true);
      document.addEventListener("scroll", this.scrollHandler);
    }
    editHyperlink(url, text2) {
      var _a;
      const tr2 = this.pmView.state.tr.insertText(
        text2,
        this.hyperlinkMarkRange.from,
        this.hyperlinkMarkRange.to
      );
      tr2.addMark(
        this.hyperlinkMarkRange.from,
        this.hyperlinkMarkRange.from + text2.length,
        this.pmView.state.schema.mark("link", { href: url })
      );
      this.pmView.dispatch(tr2);
      this.pmView.focus();
      if ((_a = this.hyperlinkToolbarState) == null ? void 0 : _a.show) {
        this.hyperlinkToolbarState.show = false;
        this.updateHyperlinkToolbar();
      }
    }
    deleteHyperlink() {
      var _a;
      this.pmView.dispatch(
        this.pmView.state.tr.removeMark(
          this.hyperlinkMarkRange.from,
          this.hyperlinkMarkRange.to,
          this.hyperlinkMark.type
        ).setMeta("preventAutolink", true)
      );
      this.pmView.focus();
      if ((_a = this.hyperlinkToolbarState) == null ? void 0 : _a.show) {
        this.hyperlinkToolbarState.show = false;
        this.updateHyperlinkToolbar();
      }
    }
    update() {
      var _a;
      if (!this.pmView.hasFocus()) {
        return;
      }
      const prevHyperlinkMark = this.hyperlinkMark;
      this.hyperlinkMark = void 0;
      this.hyperlinkMarkRange = void 0;
      this.keyboardHoveredHyperlinkMark = void 0;
      this.keyboardHoveredHyperlinkMarkRange = void 0;
      if (this.pmView.state.selection.empty) {
        const marksAtPos = this.pmView.state.selection.$from.marks();
        for (const mark2 of marksAtPos) {
          if (mark2.type.name === this.pmView.state.schema.mark("link").type.name) {
            this.keyboardHoveredHyperlinkMark = mark2;
            this.keyboardHoveredHyperlinkMarkRange = getMarkRange(
              this.pmView.state.selection.$from,
              mark2.type,
              mark2.attrs
            ) || void 0;
            break;
          }
        }
      }
      if (this.mouseHoveredHyperlinkMark) {
        this.hyperlinkMark = this.mouseHoveredHyperlinkMark;
        this.hyperlinkMarkRange = this.mouseHoveredHyperlinkMarkRange;
      }
      if (this.keyboardHoveredHyperlinkMark) {
        this.hyperlinkMark = this.keyboardHoveredHyperlinkMark;
        this.hyperlinkMarkRange = this.keyboardHoveredHyperlinkMarkRange;
      }
      if (this.hyperlinkMark && this.editor.isEditable) {
        this.hyperlinkToolbarState = {
          show: true,
          referencePos: posToDOMRect(
            this.pmView,
            this.hyperlinkMarkRange.from,
            this.hyperlinkMarkRange.to
          ),
          url: this.hyperlinkMark.attrs.href,
          text: this.pmView.state.doc.textBetween(
            this.hyperlinkMarkRange.from,
            this.hyperlinkMarkRange.to
          )
        };
        this.updateHyperlinkToolbar();
        return;
      }
      if (((_a = this.hyperlinkToolbarState) == null ? void 0 : _a.show) && prevHyperlinkMark && (!this.hyperlinkMark || !this.editor.isEditable)) {
        this.hyperlinkToolbarState.show = false;
        this.updateHyperlinkToolbar();
        return;
      }
    }
    destroy() {
      this.pmView.dom.removeEventListener("mouseover", this.mouseOverHandler);
      document.removeEventListener("scroll", this.scrollHandler);
      document.removeEventListener("click", this.clickHandler, true);
    }
  }
  const hyperlinkToolbarPluginKey = new PluginKey(
    "HyperlinkToolbarPlugin"
  );
  class HyperlinkToolbarProsemirrorPlugin extends EventEmitter {
    constructor(editor2) {
      super();
      __publicField(this, "view");
      __publicField(this, "plugin");
      /**
       * Edit the currently hovered hyperlink.
       */
      __publicField(this, "editHyperlink", (url, text2) => {
        this.view.editHyperlink(url, text2);
      });
      /**
       * Delete the currently hovered hyperlink.
       */
      __publicField(this, "deleteHyperlink", () => {
        this.view.deleteHyperlink();
      });
      /**
       * When hovering on/off hyperlinks using the mouse cursor, the hyperlink
       * toolbar will open & close with a delay.
       *
       * This function starts the delay timer, and should be used for when the mouse cursor enters the hyperlink toolbar.
       */
      __publicField(this, "startHideTimer", () => {
        this.view.startMenuUpdateTimer();
      });
      /**
       * When hovering on/off hyperlinks using the mouse cursor, the hyperlink
       * toolbar will open & close with a delay.
       *
       * This function stops the delay timer, and should be used for when the mouse cursor exits the hyperlink toolbar.
       */
      __publicField(this, "stopHideTimer", () => {
        this.view.stopMenuUpdateTimer();
      });
      this.plugin = new Plugin({
        key: hyperlinkToolbarPluginKey,
        view: (editorView) => {
          this.view = new HyperlinkToolbarView(editor2, editorView, (state) => {
            this.emit("update", state);
          });
          return this.view;
        }
      });
    }
    onUpdate(callback) {
      return this.on("update", callback);
    }
  }
  const findBlock = findParentNode((node2) => node2.type.name === "blockContainer");
  class SuggestionsMenuView {
    constructor(editor2, pluginKey, updateSuggestionsMenu = () => {
    }) {
      __publicField(this, "suggestionsMenuState");
      __publicField(this, "updateSuggestionsMenu");
      __publicField(this, "pluginState");
      __publicField(this, "handleScroll", () => {
        var _a;
        if ((_a = this.suggestionsMenuState) == null ? void 0 : _a.show) {
          const decorationNode = document.querySelector(
            `[data-decoration-id="${this.pluginState.decorationId}"]`
          );
          this.suggestionsMenuState.referencePos = decorationNode.getBoundingClientRect();
          this.updateSuggestionsMenu();
        }
      });
      this.editor = editor2;
      this.pluginKey = pluginKey;
      this.pluginState = getDefaultPluginState();
      this.updateSuggestionsMenu = () => {
        if (!this.suggestionsMenuState) {
          throw new Error("Attempting to update uninitialized suggestions menu");
        }
        updateSuggestionsMenu(this.suggestionsMenuState);
      };
      document.addEventListener("scroll", this.handleScroll);
    }
    update(view, prevState) {
      const prev = this.pluginKey.getState(prevState);
      const next = this.pluginKey.getState(view.state);
      const started = !prev.active && next.active;
      const stopped = prev.active && !next.active;
      const changed = prev.active && next.active;
      if (!started && !changed && !stopped) {
        return;
      }
      this.pluginState = stopped ? prev : next;
      if (stopped || !this.editor.isEditable) {
        this.suggestionsMenuState.show = false;
        this.updateSuggestionsMenu();
        return;
      }
      const decorationNode = document.querySelector(
        `[data-decoration-id="${this.pluginState.decorationId}"]`
      );
      if (this.editor.isEditable) {
        this.suggestionsMenuState = {
          show: true,
          referencePos: decorationNode.getBoundingClientRect(),
          filteredItems: this.pluginState.items,
          keyboardHoveredItemIndex: this.pluginState.keyboardHoveredItemIndex
        };
        this.updateSuggestionsMenu();
      }
    }
    destroy() {
      document.removeEventListener("scroll", this.handleScroll);
    }
  }
  function getDefaultPluginState() {
    return {
      active: false,
      triggerCharacter: void 0,
      queryStartPos: void 0,
      items: [],
      keyboardHoveredItemIndex: void 0,
      notFoundCount: 0,
      decorationId: void 0
    };
  }
  const setupSuggestionsMenu = (editor2, updateSuggestionsMenu, pluginKey, defaultTriggerCharacter, items = () => [], onSelectItem = () => {
  }) => {
    if (defaultTriggerCharacter.length !== 1) {
      throw new Error("'char' should be a single character");
    }
    let suggestionsPluginView;
    const deactivate = (view) => {
      view.dispatch(view.state.tr.setMeta(pluginKey, { deactivate: true }));
    };
    return {
      plugin: new Plugin({
        key: pluginKey,
        view: () => {
          suggestionsPluginView = new SuggestionsMenuView(
            editor2,
            pluginKey,
            updateSuggestionsMenu
          );
          return suggestionsPluginView;
        },
        state: {
          // Initialize the plugin's internal state.
          init() {
            return getDefaultPluginState();
          },
          // Apply changes to the plugin state from an editor transaction.
          apply(transaction, prev, oldState, newState) {
            var _a, _b, _c, _d;
            if (transaction.getMeta("orderedListIndexing") !== void 0) {
              return prev;
            }
            if ((_a = transaction.getMeta(pluginKey)) == null ? void 0 : _a.activate) {
              return {
                active: true,
                triggerCharacter: ((_b = transaction.getMeta(pluginKey)) == null ? void 0 : _b.triggerCharacter) || "",
                queryStartPos: newState.selection.from,
                items: items(""),
                keyboardHoveredItemIndex: 0,
                // TODO: Maybe should be 1 if the menu has no possible items? Probably redundant since a menu with no items
                //  is useless in practice.
                notFoundCount: 0,
                decorationId: `id_${Math.floor(Math.random() * 4294967295)}`
              };
            }
            if (!prev.active) {
              return prev;
            }
            const next = { ...prev };
            next.items = items(
              newState.doc.textBetween(
                prev.queryStartPos,
                newState.selection.from
              )
            );
            next.notFoundCount = 0;
            if (next.items.length === 0) {
              next.notFoundCount = Math.max(
                0,
                prev.notFoundCount + (newState.selection.from - oldState.selection.from)
              );
            }
            if (
              // Highlighting text should hide the menu.
              newState.selection.from !== newState.selection.to || // Transactions with plugin metadata {deactivate: true} should hide the menu.
              ((_c = transaction.getMeta(pluginKey)) == null ? void 0 : _c.deactivate) || // Certain mouse events should hide the menu.
              // TODO: Change to global mousedown listener.
              transaction.getMeta("focus") || transaction.getMeta("blur") || transaction.getMeta("pointer") || // Moving the caret before the character which triggered the menu should hide it.
              prev.active && newState.selection.from < prev.queryStartPos || // Entering more than 3 characters, after the last query that matched with at least 1 menu item, should hide
              // the menu.
              next.notFoundCount > 3
            ) {
              return getDefaultPluginState();
            }
            if (((_d = transaction.getMeta(pluginKey)) == null ? void 0 : _d.selectedItemIndexChanged) !== void 0) {
              let newIndex = transaction.getMeta(pluginKey).selectedItemIndexChanged;
              if (newIndex < 0) {
                newIndex = prev.items.length - 1;
              } else if (newIndex >= prev.items.length) {
                newIndex = 0;
              }
              next.keyboardHoveredItemIndex = newIndex;
            } else if (oldState.selection.from !== newState.selection.from) {
              next.keyboardHoveredItemIndex = 0;
            }
            return next;
          }
        },
        props: {
          handleKeyDown(view, event) {
            const menuIsActive = this.getState(view.state).active;
            if (event.key === defaultTriggerCharacter && !menuIsActive) {
              view.dispatch(
                view.state.tr.insertText(defaultTriggerCharacter).scrollIntoView().setMeta(pluginKey, {
                  activate: true,
                  triggerCharacter: defaultTriggerCharacter
                })
              );
              return true;
            }
            if (!menuIsActive) {
              return false;
            }
            const {
              triggerCharacter,
              queryStartPos,
              items: items2,
              keyboardHoveredItemIndex
            } = pluginKey.getState(view.state);
            if (event.key === "ArrowUp") {
              view.dispatch(
                view.state.tr.setMeta(pluginKey, {
                  selectedItemIndexChanged: keyboardHoveredItemIndex - 1
                })
              );
              return true;
            }
            if (event.key === "ArrowDown") {
              view.dispatch(
                view.state.tr.setMeta(pluginKey, {
                  selectedItemIndexChanged: keyboardHoveredItemIndex + 1
                })
              );
              return true;
            }
            if (event.key === "Enter") {
              if (items2.length === 0) {
                return true;
              }
              deactivate(view);
              editor2._tiptapEditor.chain().focus().deleteRange({
                from: queryStartPos - triggerCharacter.length,
                to: editor2._tiptapEditor.state.selection.from
              }).run();
              onSelectItem({
                item: items2[keyboardHoveredItemIndex],
                editor: editor2
              });
              return true;
            }
            if (event.key === "Escape") {
              deactivate(view);
              return true;
            }
            return false;
          },
          // Setup decorator on the currently active suggestion.
          decorations(state) {
            const { active, decorationId, queryStartPos, triggerCharacter } = this.getState(state);
            if (!active) {
              return null;
            }
            if (triggerCharacter === "") {
              const blockNode = findBlock(state.selection);
              if (blockNode) {
                return DecorationSet.create(state.doc, [
                  Decoration.node(
                    blockNode.pos,
                    blockNode.pos + blockNode.node.nodeSize,
                    {
                      nodeName: "span",
                      class: "bn-suggestion-decorator",
                      "data-decoration-id": decorationId
                    }
                  )
                ]);
              }
            }
            return DecorationSet.create(state.doc, [
              Decoration.inline(
                queryStartPos - triggerCharacter.length,
                queryStartPos,
                {
                  nodeName: "span",
                  class: "bn-suggestion-decorator",
                  "data-decoration-id": decorationId
                }
              )
            ]);
          }
        }
      }),
      itemCallback: (item) => {
        deactivate(editor2._tiptapEditor.view);
        editor2._tiptapEditor.chain().focus().deleteRange({
          from: suggestionsPluginView.pluginState.queryStartPos - suggestionsPluginView.pluginState.triggerCharacter.length,
          to: editor2._tiptapEditor.state.selection.from
        }).run();
        onSelectItem({
          item,
          editor: editor2
        });
      }
    };
  };
  const slashMenuPluginKey = new PluginKey("SlashMenuPlugin");
  class SlashMenuProsemirrorPlugin extends EventEmitter {
    constructor(editor2, items) {
      super();
      __publicField(this, "plugin");
      __publicField(this, "itemCallback");
      const suggestions = setupSuggestionsMenu(
        editor2,
        (state) => {
          this.emit("update", state);
        },
        slashMenuPluginKey,
        "/",
        (query) => items.filter(
          ({ name, aliases }) => name.toLowerCase().startsWith(query.toLowerCase()) || aliases && aliases.filter(
            (alias) => alias.toLowerCase().startsWith(query.toLowerCase())
          ).length !== 0
        ),
        ({ item, editor: editor22 }) => item.execute(editor22)
      );
      this.plugin = suggestions.plugin;
      this.itemCallback = suggestions.itemCallback;
    }
    onUpdate(callback) {
      return this.on("update", callback);
    }
  }
  class MultipleNodeSelection extends Selection {
    constructor($anchor, $head) {
      super($anchor, $head);
      __publicField(this, "nodes");
      const parentNode2 = $anchor.node();
      this.nodes = [];
      $anchor.doc.nodesBetween($anchor.pos, $head.pos, (node2, _pos, parent) => {
        if (parent !== null && parent.eq(parentNode2)) {
          this.nodes.push(node2);
          return false;
        }
        return;
      });
    }
    static create(doc2, from2, to = from2) {
      return new MultipleNodeSelection(doc2.resolve(from2), doc2.resolve(to));
    }
    content() {
      return new Slice(Fragment.from(this.nodes), 0, 0);
    }
    eq(selection) {
      if (!(selection instanceof MultipleNodeSelection)) {
        return false;
      }
      if (this.nodes.length !== selection.nodes.length) {
        return false;
      }
      if (this.from !== selection.from || this.to !== selection.to) {
        return false;
      }
      for (let i2 = 0; i2 < this.nodes.length; i2++) {
        if (!this.nodes[i2].eq(selection.nodes[i2])) {
          return false;
        }
      }
      return true;
    }
    map(doc2, mapping) {
      const fromResult = mapping.mapResult(this.from);
      const toResult2 = mapping.mapResult(this.to);
      if (toResult2.deleted) {
        return Selection.near(doc2.resolve(fromResult.pos));
      }
      if (fromResult.deleted) {
        return Selection.near(doc2.resolve(toResult2.pos));
      }
      return new MultipleNodeSelection(
        doc2.resolve(fromResult.pos),
        doc2.resolve(toResult2.pos)
      );
    }
    toJSON() {
      return { type: "node", anchor: this.anchor, head: this.head };
    }
  }
  let dragImageElement$1;
  function getDraggableBlockFromCoords(coords, view) {
    var _a;
    if (!view.dom.isConnected) {
      return void 0;
    }
    const pos = view.posAtCoords(coords);
    if (!pos) {
      return void 0;
    }
    let node2 = view.domAtPos(pos.pos).node;
    if (node2 === view.dom) {
      return void 0;
    }
    while (node2 && node2.parentNode && node2.parentNode !== view.dom && !((_a = node2.hasAttribute) == null ? void 0 : _a.call(node2, "data-id"))) {
      node2 = node2.parentNode;
    }
    if (!node2) {
      return void 0;
    }
    return { node: node2, id: node2.getAttribute("data-id") };
  }
  function blockPositionFromCoords(coords, view) {
    const block2 = getDraggableBlockFromCoords(coords, view);
    if (block2 && block2.node.nodeType === 1) {
      const docView = view.docView;
      const desc = docView.nearestDesc(block2.node, true);
      if (!desc || desc === docView) {
        return null;
      }
      return desc.posBefore;
    }
    return null;
  }
  function blockPositionsFromSelection(selection, doc2) {
    let beforeFirstBlockPos;
    let afterLastBlockPos;
    const selectionStartInBlockContent = doc2.resolve(selection.from).node().type.spec.group === "blockContent";
    const selectionEndInBlockContent = doc2.resolve(selection.to).node().type.spec.group === "blockContent";
    const minDepth = Math.min(selection.$anchor.depth, selection.$head.depth);
    if (selectionStartInBlockContent && selectionEndInBlockContent) {
      const startFirstBlockPos = selection.$from.start(minDepth - 1);
      const endLastBlockPos = selection.$to.end(minDepth - 1);
      beforeFirstBlockPos = doc2.resolve(startFirstBlockPos - 1).pos;
      afterLastBlockPos = doc2.resolve(endLastBlockPos + 1).pos;
    } else {
      beforeFirstBlockPos = selection.from;
      afterLastBlockPos = selection.to;
    }
    return { from: beforeFirstBlockPos, to: afterLastBlockPos };
  }
  function setDragImage(view, from2, to = from2) {
    if (from2 === to) {
      to += view.state.doc.resolve(from2 + 1).node().nodeSize;
    }
    const parentClone = view.domAtPos(from2).node.cloneNode(true);
    const parent = view.domAtPos(from2).node;
    const getElementIndex = (parentElement, targetElement) => Array.prototype.indexOf.call(parentElement.children, targetElement);
    const firstSelectedBlockIndex = getElementIndex(
      parent,
      // Expects from position to be just before the first selected block.
      view.domAtPos(from2 + 1).node.parentElement
    );
    const lastSelectedBlockIndex = getElementIndex(
      parent,
      // Expects to position to be just after the last selected block.
      view.domAtPos(to - 1).node.parentElement
    );
    for (let i2 = parent.childElementCount - 1; i2 >= 0; i2--) {
      if (i2 > lastSelectedBlockIndex || i2 < firstSelectedBlockIndex) {
        parentClone.removeChild(parentClone.children[i2]);
      }
    }
    unsetDragImage();
    dragImageElement$1 = parentClone;
    const classes = view.dom.className.split(" ");
    const inheritedClasses = classes.filter(
      (className) => className !== "ProseMirror" && className !== "bn-root" && className !== "bn-editor"
    ).join(" ");
    dragImageElement$1.className = dragImageElement$1.className + " bn-drag-preview " + inheritedClasses;
    document.body.appendChild(dragImageElement$1);
  }
  function unsetDragImage() {
    if (dragImageElement$1 !== void 0) {
      document.body.removeChild(dragImageElement$1);
      dragImageElement$1 = void 0;
    }
  }
  function dragStart(e, editor2) {
    if (!e.dataTransfer) {
      return;
    }
    const view = editor2.prosemirrorView;
    const editorBoundingBox = view.dom.getBoundingClientRect();
    const coords = {
      left: editorBoundingBox.left + editorBoundingBox.width / 2,
      // take middle of editor
      top: e.clientY
    };
    const pos = blockPositionFromCoords(coords, view);
    if (pos != null) {
      const selection = view.state.selection;
      const doc2 = view.state.doc;
      const { from: from2, to } = blockPositionsFromSelection(selection, doc2);
      const draggedBlockInSelection = from2 <= pos && pos < to;
      const multipleBlocksSelected = selection.$anchor.node() !== selection.$head.node() || selection instanceof MultipleNodeSelection;
      if (draggedBlockInSelection && multipleBlocksSelected) {
        view.dispatch(
          view.state.tr.setSelection(MultipleNodeSelection.create(doc2, from2, to))
        );
        setDragImage(view, from2, to);
      } else {
        view.dispatch(
          view.state.tr.setSelection(NodeSelection.create(view.state.doc, pos))
        );
        setDragImage(view, pos);
      }
      const selectedSlice = view.state.selection.content();
      const schema = editor2._tiptapEditor.schema;
      const internalHTMLSerializer = createInternalHTMLSerializer(schema, editor2);
      const internalHTML = internalHTMLSerializer.serializeProseMirrorFragment(
        selectedSlice.content
      );
      const externalHTMLExporter = createExternalHTMLExporter(schema, editor2);
      const externalHTML = externalHTMLExporter.exportProseMirrorFragment(
        selectedSlice.content
      );
      const plainText = cleanHTMLToMarkdown(externalHTML);
      e.dataTransfer.clearData();
      e.dataTransfer.setData("blocknote/html", internalHTML);
      e.dataTransfer.setData("text/html", externalHTML);
      e.dataTransfer.setData("text/plain", plainText);
      e.dataTransfer.effectAllowed = "move";
      e.dataTransfer.setDragImage(dragImageElement$1, 0, 0);
      view.dragging = { slice: selectedSlice, move: true };
    }
  }
  class SideMenuView {
    constructor(editor2, pmView, updateSideMenu) {
      __publicField(this, "sideMenuState");
      // When true, the drag handle with be anchored at the same level as root elements
      // When false, the drag handle with be just to the left of the element
      // TODO: Is there any case where we want this to be false?
      __publicField(this, "horizontalPosAnchoredAtRoot");
      __publicField(this, "horizontalPosAnchor");
      __publicField(this, "hoveredBlock");
      // Used to check if currently dragged content comes from this editor instance.
      __publicField(this, "isDragging", false);
      __publicField(this, "menuFrozen", false);
      /**
       * Sets isDragging when dragging text.
       */
      __publicField(this, "onDragStart", () => {
        this.isDragging = true;
      });
      /**
       * If the event is outside the editor contents,
       * we dispatch a fake event, so that we can still drop the content
       * when dragging / dropping to the side of the editor
       */
      __publicField(this, "onDrop", (event) => {
        this.editor._tiptapEditor.commands.blur();
        if (event.synthetic || !this.isDragging) {
          return;
        }
        const pos = this.pmView.posAtCoords({
          left: event.clientX,
          top: event.clientY
        });
        this.isDragging = false;
        if (!pos || pos.inside === -1) {
          const evt = new Event("drop", event);
          const editorBoundingBox = this.pmView.dom.firstChild.getBoundingClientRect();
          evt.clientX = editorBoundingBox.left + editorBoundingBox.width / 2;
          evt.clientY = event.clientY;
          evt.dataTransfer = event.dataTransfer;
          evt.preventDefault = () => event.preventDefault();
          evt.synthetic = true;
          this.pmView.dom.dispatchEvent(evt);
        }
      });
      /**
       * If the event is outside the editor contents,
       * we dispatch a fake event, so that we can still drop the content
       * when dragging / dropping to the side of the editor
       */
      __publicField(this, "onDragOver", (event) => {
        if (event.synthetic || !this.isDragging) {
          return;
        }
        const pos = this.pmView.posAtCoords({
          left: event.clientX,
          top: event.clientY
        });
        if (!pos || pos.inside === -1) {
          const evt = new Event("dragover", event);
          const editorBoundingBox = this.pmView.dom.firstChild.getBoundingClientRect();
          evt.clientX = editorBoundingBox.left + editorBoundingBox.width / 2;
          evt.clientY = event.clientY;
          evt.dataTransfer = event.dataTransfer;
          evt.preventDefault = () => event.preventDefault();
          evt.synthetic = true;
          this.pmView.dom.dispatchEvent(evt);
        }
      });
      __publicField(this, "onKeyDown", (_event) => {
        var _a;
        if ((_a = this.sideMenuState) == null ? void 0 : _a.show) {
          this.sideMenuState.show = false;
          this.updateSideMenu(this.sideMenuState);
        }
        this.menuFrozen = false;
      });
      __publicField(this, "onMouseDown", (_event) => {
        if (this.sideMenuState && !this.sideMenuState.show) {
          this.sideMenuState.show = true;
          this.updateSideMenu(this.sideMenuState);
        }
        this.menuFrozen = false;
      });
      __publicField(this, "onMouseMove", (event) => {
        var _a, _b, _c, _d, _e;
        if (this.menuFrozen) {
          return;
        }
        const editorBoundingBox = this.pmView.dom.firstChild.getBoundingClientRect();
        const editorOuterBoundingBox = this.pmView.dom.getBoundingClientRect();
        const cursorWithinEditor = event.clientX >= editorOuterBoundingBox.left && event.clientX <= editorOuterBoundingBox.right && event.clientY >= editorOuterBoundingBox.top && event.clientY <= editorOuterBoundingBox.bottom;
        const editorWrapper = this.pmView.dom.parentElement;
        if (
          // Cursor is within the editor area
          cursorWithinEditor && // An element is hovered
          event && event.target && // Element is outside the editor
          !(editorWrapper === event.target || editorWrapper.contains(event.target))
        ) {
          if ((_a = this.sideMenuState) == null ? void 0 : _a.show) {
            this.sideMenuState.show = false;
            this.updateSideMenu(this.sideMenuState);
          }
          return;
        }
        this.horizontalPosAnchor = editorBoundingBox.x;
        const coords = {
          left: editorBoundingBox.left + editorBoundingBox.width / 2,
          // take middle of editor
          top: event.clientY
        };
        const block2 = getDraggableBlockFromCoords(coords, this.pmView);
        if (!block2 || !this.editor.isEditable) {
          if ((_b = this.sideMenuState) == null ? void 0 : _b.show) {
            this.sideMenuState.show = false;
            this.updateSideMenu(this.sideMenuState);
          }
          return;
        }
        if (((_c = this.sideMenuState) == null ? void 0 : _c.show) && ((_d = this.hoveredBlock) == null ? void 0 : _d.hasAttribute("data-id")) && ((_e = this.hoveredBlock) == null ? void 0 : _e.getAttribute("data-id")) === block2.id) {
          return;
        }
        const outsideTable = block2.node.closest(".tableWrapper");
        const tableContainer = outsideTable == null ? void 0 : outsideTable.parentElement;
        const currentNode = tableContainer || block2.node;
        this.hoveredBlock = currentNode;
        const blockContent = currentNode.firstChild;
        if (!blockContent) {
          return;
        }
        if (this.editor.isEditable) {
          const blockContentBoundingBox = blockContent.getBoundingClientRect();
          this.sideMenuState = {
            show: true,
            referencePos: new DOMRect(
              this.horizontalPosAnchoredAtRoot ? this.horizontalPosAnchor : blockContentBoundingBox.x,
              blockContentBoundingBox.y,
              blockContentBoundingBox.width,
              blockContentBoundingBox.height
            ),
            block: this.editor.getBlock(
              this.hoveredBlock.getAttribute("data-id")
            )
          };
          this.updateSideMenu(this.sideMenuState);
        }
      });
      __publicField(this, "onScroll", () => {
        var _a;
        if ((_a = this.sideMenuState) == null ? void 0 : _a.show) {
          const blockContent = this.hoveredBlock.firstChild;
          const blockContentBoundingBox = blockContent.getBoundingClientRect();
          this.sideMenuState.referencePos = new DOMRect(
            this.horizontalPosAnchoredAtRoot ? this.horizontalPosAnchor : blockContentBoundingBox.x,
            blockContentBoundingBox.y,
            blockContentBoundingBox.width,
            blockContentBoundingBox.height
          );
          this.updateSideMenu(this.sideMenuState);
        }
      });
      this.editor = editor2;
      this.pmView = pmView;
      this.updateSideMenu = updateSideMenu;
      this.horizontalPosAnchoredAtRoot = true;
      this.horizontalPosAnchor = this.pmView.dom.firstChild.getBoundingClientRect().x;
      document.body.addEventListener("drop", this.onDrop, true);
      document.body.addEventListener("dragover", this.onDragOver);
      this.pmView.dom.addEventListener("dragstart", this.onDragStart);
      document.body.addEventListener("mousemove", this.onMouseMove, true);
      document.addEventListener("scroll", this.onScroll);
      document.body.addEventListener("mousedown", this.onMouseDown, true);
      document.body.addEventListener("keydown", this.onKeyDown, true);
    }
    destroy() {
      var _a;
      if ((_a = this.sideMenuState) == null ? void 0 : _a.show) {
        this.sideMenuState.show = false;
        this.updateSideMenu(this.sideMenuState);
      }
      document.body.removeEventListener("mousemove", this.onMouseMove);
      document.body.removeEventListener("dragover", this.onDragOver);
      this.pmView.dom.removeEventListener("dragstart", this.onDragStart);
      document.body.removeEventListener("drop", this.onDrop, true);
      document.removeEventListener("scroll", this.onScroll);
      document.body.removeEventListener("mousedown", this.onMouseDown, true);
      document.body.removeEventListener("keydown", this.onKeyDown, true);
    }
    addBlock() {
      var _a;
      if ((_a = this.sideMenuState) == null ? void 0 : _a.show) {
        this.sideMenuState.show = false;
        this.updateSideMenu(this.sideMenuState);
      }
      this.menuFrozen = true;
      const blockContent = this.hoveredBlock.firstChild;
      const blockContentBoundingBox = blockContent.getBoundingClientRect();
      const isTable = blockContent.querySelector("table");
      const pos = this.pmView.posAtCoords({
        left: blockContentBoundingBox.left + blockContentBoundingBox.width / 2,
        top: isTable ? blockContentBoundingBox.top + blockContentBoundingBox.height : blockContentBoundingBox.top + blockContentBoundingBox.height / 2
      });
      if (!pos) {
        return;
      }
      const blockInfo = getBlockInfoFromPos(
        this.editor._tiptapEditor.state.doc,
        pos.pos
      );
      if (blockInfo === void 0) {
        return;
      }
      const { contentNode, startPos, endPos } = blockInfo;
      if (contentNode.type.spec.content !== "inline*" || contentNode.textContent.length !== 0) {
        const newBlockInsertionPos = endPos + 1;
        const newBlockContentPos = newBlockInsertionPos + 2;
        this.editor._tiptapEditor.chain().BNCreateBlock(newBlockInsertionPos).BNUpdateBlock(newBlockContentPos, { type: "paragraph", props: {} }).setTextSelection(newBlockContentPos).run();
      } else {
        this.editor._tiptapEditor.commands.setTextSelection(startPos + 1);
      }
      this.pmView.focus();
      this.pmView.dispatch(
        this.pmView.state.tr.scrollIntoView().setMeta(slashMenuPluginKey, {
          // TODO import suggestion plugin key
          activate: true,
          type: "drag"
        })
      );
    }
  }
  const sideMenuPluginKey = new PluginKey("SideMenuPlugin");
  class SideMenuProsemirrorPlugin extends EventEmitter {
    constructor(editor2) {
      super();
      __publicField(this, "sideMenuView");
      __publicField(this, "plugin");
      /**
       * If the block is empty, opens the slash menu. If the block has content,
       * creates a new block below and opens the slash menu in it.
       */
      __publicField(this, "addBlock", () => this.sideMenuView.addBlock());
      /**
       * Handles drag & drop events for blocks.
       */
      __publicField(this, "blockDragStart", (event) => {
        this.sideMenuView.isDragging = true;
        dragStart(event, this.editor);
      });
      /**
       * Handles drag & drop events for blocks.
       */
      __publicField(this, "blockDragEnd", () => unsetDragImage());
      /**
       * Freezes the side menu. When frozen, the side menu will stay
       * attached to the same block regardless of which block is hovered by the
       * mouse cursor.
       */
      __publicField(this, "freezeMenu", () => this.sideMenuView.menuFrozen = true);
      /**
       * Unfreezes the side menu. When frozen, the side menu will stay
       * attached to the same block regardless of which block is hovered by the
       * mouse cursor.
       */
      __publicField(this, "unfreezeMenu", () => this.sideMenuView.menuFrozen = false);
      this.editor = editor2;
      this.plugin = new Plugin({
        key: sideMenuPluginKey,
        view: (editorView) => {
          this.sideMenuView = new SideMenuView(
            editor2,
            editorView,
            (sideMenuState) => {
              this.emit("update", sideMenuState);
            }
          );
          return this.sideMenuView;
        }
      });
    }
    onUpdate(callback) {
      return this.on("update", callback);
    }
  }
  function setSelectionToNextContentEditableBlock(editor2) {
    let block2 = editor2.getTextCursorPosition().block;
    let contentType = editor2.blockSchema[block2.type].content;
    while (contentType === "none") {
      block2 = editor2.getTextCursorPosition().nextBlock;
      if (!block2)
        break;
      contentType = editor2.blockSchema[block2.type].content;
      editor2.setTextCursorPosition(block2, "end");
    }
  }
  function insertOrUpdateBlock(editor2, block2) {
    const currentBlock = editor2.getTextCursorPosition().block;
    if (currentBlock.content === void 0) {
      throw new Error("Slash Menu open in a block that doesn't contain content.");
    }
    if (Array.isArray(currentBlock.content) && (currentBlock.content.length === 1 && isStyledTextInlineContent(currentBlock.content[0]) && currentBlock.content[0].type === "text" && currentBlock.content[0].text === "/" || currentBlock.content.length === 0)) {
      editor2.updateBlock(currentBlock, block2);
    } else {
      editor2.insertBlocks([block2], currentBlock, "after");
      editor2.setTextCursorPosition(
        editor2.getTextCursorPosition().nextBlock,
        "end"
      );
    }
    const insertedBlock = editor2.getTextCursorPosition().block;
    setSelectionToNextContentEditableBlock(editor2);
    return insertedBlock;
  }
  const getDefaultSlashMenuItems = (schema = defaultBlockSchema) => {
    var _a, _b, _c, _d, _e, _f;
    const slashMenuItems = [];
    if ("heading" in schema && "level" in schema.heading.propSchema) {
      if ((_a = schema.heading.propSchema.level.values) == null ? void 0 : _a.includes(1)) {
        slashMenuItems.push({
          name: "Heading",
          aliases: ["h", "heading1", "h1"],
          execute: (editor2) => insertOrUpdateBlock(editor2, {
            type: "heading",
            props: { level: 1 }
          })
        });
      }
      if ((_b = schema.heading.propSchema.level.values) == null ? void 0 : _b.includes(2)) {
        slashMenuItems.push({
          name: "Heading 2",
          aliases: ["h2", "heading2", "subheading"],
          execute: (editor2) => insertOrUpdateBlock(editor2, {
            type: "heading",
            props: { level: 2 }
          })
        });
      }
      if ((_c = schema.heading.propSchema.level.values) == null ? void 0 : _c.includes(3)) {
        slashMenuItems.push({
          name: "Heading 3",
          aliases: ["h3", "heading3", "subheading"],
          execute: (editor2) => insertOrUpdateBlock(editor2, {
            type: "heading",
            props: { level: 3 }
          })
        });
      }
      if ((_d = schema.heading.propSchema.level.values) == null ? void 0 : _d.includes(4)) {
        slashMenuItems.push({
          name: "Heading 4",
          aliases: ["h4", "heading4", "subheading"],
          execute: (editor2) => insertOrUpdateBlock(editor2, {
            type: "heading",
            props: { level: 4 }
          })
        });
      }
      if ((_e = schema.heading.propSchema.level.values) == null ? void 0 : _e.includes(5)) {
        slashMenuItems.push({
          name: "Heading 5",
          aliases: ["h5", "heading5", "subheading"],
          execute: (editor2) => insertOrUpdateBlock(editor2, {
            type: "heading",
            props: { level: 5 }
          })
        });
      }
      if ((_f = schema.heading.propSchema.level.values) == null ? void 0 : _f.includes(6)) {
        slashMenuItems.push({
          name: "Heading 6",
          aliases: ["h6", "heading6", "subheading"],
          execute: (editor2) => insertOrUpdateBlock(editor2, {
            type: "heading",
            props: { level: 6 }
          })
        });
      }
    }
    if ("bulletListItem" in schema) {
      slashMenuItems.push({
        name: "Bullet List",
        aliases: ["ul", "list", "bulletlist", "bullet list"],
        execute: (editor2) => insertOrUpdateBlock(editor2, {
          type: "bulletListItem"
        })
      });
    }
    if ("numberedListItem" in schema) {
      slashMenuItems.push({
        name: "Numbered List",
        aliases: ["li", "list", "numberedlist", "numbered list"],
        execute: (editor2) => insertOrUpdateBlock(editor2, {
          type: "numberedListItem"
        })
      });
    }
    if ("paragraph" in schema) {
      slashMenuItems.push({
        name: "Paragraph",
        aliases: ["p"],
        execute: (editor2) => insertOrUpdateBlock(editor2, {
          type: "paragraph"
        })
      });
    }
    if ("table" in schema) {
      slashMenuItems.push({
        name: "Table",
        aliases: ["table"],
        execute: (editor2) => {
          insertOrUpdateBlock(editor2, {
            type: "table",
            content: {
              type: "tableContent",
              rows: [
                {
                  cells: [
                    [
                      {
                        type: "paragraph",
                        content: [{ type: "text", text: "", styles: {} }]
                      }
                    ],
                    [
                      {
                        type: "paragraph",
                        content: [{ type: "text", text: "", styles: {} }]
                      }
                    ],
                    [
                      {
                        type: "paragraph",
                        content: [{ type: "text", text: "", styles: {} }]
                      }
                    ]
                  ]
                },
                {
                  cells: [
                    [
                      {
                        type: "paragraph",
                        content: [{ type: "text", text: "", styles: {} }]
                      }
                    ],
                    [
                      {
                        type: "paragraph",
                        content: [{ type: "text", text: "", styles: {} }]
                      }
                    ],
                    [
                      {
                        type: "paragraph",
                        content: [{ type: "text", text: "", styles: {} }]
                      }
                    ]
                  ]
                },
                {
                  cells: [
                    [
                      {
                        type: "paragraph",
                        content: [{ type: "text", text: "", styles: {} }]
                      }
                    ],
                    [
                      {
                        type: "paragraph",
                        content: [{ type: "text", text: "", styles: {} }]
                      }
                    ],
                    [
                      {
                        type: "paragraph",
                        content: [{ type: "text", text: "", styles: {} }]
                      }
                    ]
                  ]
                }
              ]
            }
          });
        }
      });
    }
    if ("image" in schema) {
      slashMenuItems.push({
        name: "Image",
        aliases: [
          "image",
          "imageUpload",
          "upload",
          "img",
          "picture",
          "media",
          "url",
          "drive",
          "dropbox"
        ],
        execute: (editor2) => {
          const insertedBlock = insertOrUpdateBlock(editor2, {
            type: "image"
          });
          editor2._tiptapEditor.view.dispatch(
            editor2._tiptapEditor.state.tr.setMeta(imageToolbarPluginKey, {
              block: insertedBlock
            })
          );
        }
      });
    }
    return slashMenuItems;
  };
  let dragImageElement;
  function setHiddenDragImage() {
    if (dragImageElement) {
      return;
    }
    dragImageElement = document.createElement("div");
    dragImageElement.innerHTML = "_";
    dragImageElement.style.opacity = "0";
    dragImageElement.style.height = "1px";
    dragImageElement.style.width = "1px";
    document.body.appendChild(dragImageElement);
  }
  function unsetHiddenDragImage() {
    if (dragImageElement) {
      document.body.removeChild(dragImageElement);
      dragImageElement = void 0;
    }
  }
  function getChildIndex(node2) {
    return Array.prototype.indexOf.call(node2.parentElement.childNodes, node2);
  }
  function domCellAround(target) {
    while (target && target.nodeName !== "TD" && target.nodeName !== "TH") {
      target = target.classList && target.classList.contains("ProseMirror") ? null : target.parentNode;
    }
    return target;
  }
  function hideElementsWithClassNames(classNames) {
    classNames.forEach((className) => {
      const elementsToHide = document.getElementsByClassName(className);
      for (let i2 = 0; i2 < elementsToHide.length; i2++) {
        elementsToHide[i2].style.visibility = "hidden";
      }
    });
  }
  class TableHandlesView {
    constructor(editor2, pmView, updateState) {
      __publicField(this, "state");
      __publicField(this, "updateState");
      __publicField(this, "tableId");
      __publicField(this, "tablePos");
      __publicField(this, "menuFrozen", false);
      __publicField(this, "prevWasEditable", null);
      __publicField(this, "mouseMoveHandler", (event) => {
        var _a;
        if (this.menuFrozen) {
          return;
        }
        const target = domCellAround(event.target);
        if (!target || !this.editor.isEditable) {
          if ((_a = this.state) == null ? void 0 : _a.show) {
            this.state.show = false;
            this.updateState();
          }
          return;
        }
        const colIndex = getChildIndex(target);
        const rowIndex = getChildIndex(target.parentElement);
        const cellRect = target.getBoundingClientRect();
        const tableRect = target.parentElement.parentElement.getBoundingClientRect();
        const blockEl = getDraggableBlockFromCoords(cellRect, this.pmView);
        if (!blockEl) {
          throw new Error(
            "Found table cell element, but could not find surrounding blockContent element."
          );
        }
        if (this.state !== void 0 && this.state.show && this.tableId === blockEl.id && this.state.rowIndex === rowIndex && this.state.colIndex === colIndex) {
          return;
        }
        let block2 = void 0;
        this.editor._tiptapEditor.state.doc.descendants((node2, pos) => {
          if (typeof block2 !== "undefined") {
            return false;
          }
          if (node2.type.name !== "blockContainer" || node2.attrs.id !== blockEl.id) {
            return true;
          }
          block2 = nodeToBlock(
            node2,
            this.editor.blockSchema,
            this.editor.inlineContentSchema,
            this.editor.styleSchema,
            this.editor.blockCache
          );
          this.tablePos = pos + 1;
          return false;
        });
        if (block2 && block2["type"] !== "table" && this.tablePos) {
          const resolvePos = this.pmView.state.doc.resolve(this.tablePos);
          const tableNode = findParentNodeClosestToPos(resolvePos, (node2) => {
            return node2.type.name === "table";
          });
          if (tableNode) {
            const containerNode = this.pmView.state.doc.resolve(tableNode.pos).node();
            if (containerNode) {
              block2 = nodeToBlock(
                containerNode,
                this.editor.blockSchema,
                this.editor.inlineContentSchema,
                this.editor.styleSchema,
                this.editor.blockCache
              );
              this.tablePos = tableNode.pos + 1;
              this.tableId = block2.id;
            }
          }
        }
        this.state = {
          show: true,
          referencePosCell: cellRect,
          referencePosTable: tableRect,
          block: block2,
          colIndex,
          rowIndex,
          draggingState: void 0
        };
        this.updateState();
        return false;
      });
      __publicField(this, "dragOverHandler", (event) => {
        var _a;
        if (((_a = this.state) == null ? void 0 : _a.draggingState) === void 0) {
          return;
        }
        event.preventDefault();
        event.dataTransfer.dropEffect = "move";
        hideElementsWithClassNames([
          "column-resize-handle",
          "prosemirror-dropcursor-block",
          "prosemirror-dropcursor-inline"
        ]);
        const boundedMouseCoords = {
          left: Math.min(
            Math.max(event.clientX, this.state.referencePosTable.left + 1),
            this.state.referencePosTable.right - 1
          ),
          top: Math.min(
            Math.max(event.clientY, this.state.referencePosTable.top + 1),
            this.state.referencePosTable.bottom - 1
          )
        };
        const tableCellElements = document.elementsFromPoint(boundedMouseCoords.left, boundedMouseCoords.top).filter(
          (element2) => element2.tagName === "TD" || element2.tagName === "TH"
        );
        if (tableCellElements.length === 0) {
          throw new Error(
            "Could not find table cell element that the mouse cursor is hovering over."
          );
        }
        const tableCellElement = tableCellElements[0];
        let emitStateUpdate = false;
        const rowIndex = getChildIndex(tableCellElement.parentElement);
        const colIndex = getChildIndex(tableCellElement);
        const oldIndex = this.state.draggingState.draggedCellOrientation === "row" ? this.state.rowIndex : this.state.colIndex;
        const newIndex = this.state.draggingState.draggedCellOrientation === "row" ? rowIndex : colIndex;
        const dispatchDecorationsTransaction = newIndex !== oldIndex;
        if (this.state.rowIndex !== rowIndex || this.state.colIndex !== colIndex) {
          this.state.rowIndex = rowIndex;
          this.state.colIndex = colIndex;
          this.state.referencePosCell = tableCellElement.getBoundingClientRect();
          emitStateUpdate = true;
        }
        const mousePos = this.state.draggingState.draggedCellOrientation === "row" ? boundedMouseCoords.top : boundedMouseCoords.left;
        if (this.state.draggingState.mousePos !== mousePos) {
          this.state.draggingState.mousePos = mousePos;
          emitStateUpdate = true;
        }
        if (emitStateUpdate) {
          this.updateState();
        }
        if (dispatchDecorationsTransaction) {
          this.pmView.dispatch(
            this.pmView.state.tr.setMeta(tableHandlesPluginKey, true)
          );
        }
      });
      __publicField(this, "dropHandler", (event) => {
        if (this.state === void 0 || this.state.draggingState === void 0) {
          return;
        }
        event.preventDefault();
        const rows = this.state.block.content.rows;
        if (this.state.draggingState.draggedCellOrientation === "row") {
          const rowToMove = rows[this.state.draggingState.originalIndex];
          rows.splice(this.state.draggingState.originalIndex, 1);
          rows.splice(this.state.rowIndex, 0, rowToMove);
        } else {
          const cellsToMove = rows.map(
            (row2) => row2.cells[this.state.draggingState.originalIndex]
          );
          rows.forEach((row2, rowIndex) => {
            row2.cells.splice(this.state.draggingState.originalIndex, 1);
            row2.cells.splice(this.state.colIndex, 0, cellsToMove[rowIndex]);
          });
        }
        this.editor.updateBlock(this.state.block, {
          type: "table",
          content: {
            type: "tableContent",
            rows
          }
        });
      });
      __publicField(this, "scrollHandler", () => {
        var _a;
        if ((_a = this.state) == null ? void 0 : _a.show) {
          const tableElement = document.querySelector(
            `[data-node-type="blockContainer"][data-id="${this.tableId}"] table`
          );
          const cellElement = this.state.rowIndex === 0 ? tableElement.querySelector(
            `tr:nth-child(${this.state.rowIndex + 1}) > th:nth-child(${this.state.colIndex + 1})`
          ) : tableElement.querySelector(
            `tr:nth-child(${this.state.rowIndex + 1}) > td:nth-child(${this.state.colIndex + 1})`
          );
          this.state.referencePosTable = tableElement.getBoundingClientRect();
          this.state.referencePosCell = cellElement.getBoundingClientRect();
          this.updateState();
        }
      });
      this.editor = editor2;
      this.pmView = pmView;
      this.updateState = () => {
        if (!this.state) {
          throw new Error("Attempting to update uninitialized image toolbar");
        }
        updateState(this.state);
      };
      pmView.dom.addEventListener("mousemove", this.mouseMoveHandler);
      document.addEventListener("dragover", this.dragOverHandler);
      document.addEventListener("drop", this.dropHandler);
      document.addEventListener("scroll", this.scrollHandler);
    }
    destroy() {
      this.pmView.dom.removeEventListener("mousedown", this.mouseMoveHandler);
      document.removeEventListener("dragover", this.dragOverHandler);
      document.removeEventListener("drop", this.dropHandler);
      document.removeEventListener("scroll", this.scrollHandler);
    }
  }
  const tableHandlesPluginKey = new PluginKey("TableHandlesPlugin");
  class TableHandlesProsemirrorPlugin extends EventEmitter {
    constructor(editor2) {
      super();
      __publicField(this, "view");
      __publicField(this, "plugin");
      /**
       * Callback that should be set on the `dragStart` event for whichever element
       * is used as the column drag handle.
       */
      __publicField(this, "colDragStart", (event) => {
        if (this.view.state === void 0) {
          throw new Error(
            "Attempted to drag table column, but no table block was hovered prior."
          );
        }
        this.view.state.draggingState = {
          draggedCellOrientation: "col",
          originalIndex: this.view.state.colIndex,
          mousePos: event.clientX
        };
        this.view.updateState();
        this.editor._tiptapEditor.view.dispatch(
          this.editor._tiptapEditor.state.tr.setMeta(tableHandlesPluginKey, {
            draggedCellOrientation: this.view.state.draggingState.draggedCellOrientation,
            originalIndex: this.view.state.colIndex,
            newIndex: this.view.state.colIndex,
            tablePos: this.view.tablePos
          })
        );
        setHiddenDragImage();
        event.dataTransfer.setDragImage(dragImageElement, 0, 0);
        event.dataTransfer.effectAllowed = "move";
      });
      /**
       * Callback that should be set on the `dragStart` event for whichever element
       * is used as the row drag handle.
       */
      __publicField(this, "rowDragStart", (event) => {
        if (this.view.state === void 0) {
          throw new Error(
            "Attempted to drag table row, but no table block was hovered prior."
          );
        }
        this.view.state.draggingState = {
          draggedCellOrientation: "row",
          originalIndex: this.view.state.rowIndex,
          mousePos: event.clientY
        };
        this.view.updateState();
        this.editor._tiptapEditor.view.dispatch(
          this.editor._tiptapEditor.state.tr.setMeta(tableHandlesPluginKey, {
            draggedCellOrientation: this.view.state.draggingState.draggedCellOrientation,
            originalIndex: this.view.state.rowIndex,
            newIndex: this.view.state.rowIndex,
            tablePos: this.view.tablePos
          })
        );
        setHiddenDragImage();
        event.dataTransfer.setDragImage(dragImageElement, 0, 0);
        event.dataTransfer.effectAllowed = "copyMove";
      });
      /**
       * Callback that should be set on the `dragEnd` event for both the element
       * used as the row drag handle, and the one used as the column drag handle.
       */
      __publicField(this, "dragEnd", () => {
        if (this.view.state === void 0) {
          throw new Error(
            "Attempted to drag table row, but no table block was hovered prior."
          );
        }
        this.view.state.draggingState = void 0;
        this.view.updateState();
        this.editor._tiptapEditor.view.dispatch(
          this.editor._tiptapEditor.state.tr.setMeta(tableHandlesPluginKey, null)
        );
        unsetHiddenDragImage();
      });
      /**
       * Freezes the drag handles. When frozen, they will stay attached to the same
       * cell regardless of which cell is hovered by the mouse cursor.
       */
      __publicField(this, "freezeHandles", () => this.view.menuFrozen = true);
      /**
       * Unfreezes the drag handles. When frozen, they will stay attached to the
       * same cell regardless of which cell is hovered by the mouse cursor.
       */
      __publicField(this, "unfreezeHandles", () => this.view.menuFrozen = false);
      this.editor = editor2;
      this.plugin = new Plugin({
        key: tableHandlesPluginKey,
        view: (editorView) => {
          this.view = new TableHandlesView(editor2, editorView, (state) => {
            this.emit("update", state);
          });
          return this.view;
        },
        // We use decorations to render the drop cursor when dragging a table row
        // or column. The decorations are updated in the `dragOverHandler` method.
        props: {
          decorations: (state) => {
            if (this.view === void 0 || this.view.state === void 0 || this.view.state.draggingState === void 0 || this.view.tablePos === void 0) {
              return;
            }
            const newIndex = this.view.state.draggingState.draggedCellOrientation === "row" ? this.view.state.rowIndex : this.view.state.colIndex;
            const decorations = [];
            if (newIndex === this.view.state.draggingState.originalIndex) {
              return DecorationSet.create(state.doc, decorations);
            }
            const tableResolvedPos = state.doc.resolve(this.view.tablePos + 1);
            const tableNode = tableResolvedPos.node();
            if (this.view.state.draggingState.draggedCellOrientation === "row") {
              const rowResolvedPos = state.doc.resolve(
                tableResolvedPos.posAtIndex(newIndex) + 1
              );
              const rowNode = rowResolvedPos.node();
              for (let i2 = 0; i2 < rowNode.childCount; i2++) {
                const cellResolvedPos = state.doc.resolve(
                  rowResolvedPos.posAtIndex(i2) + 1
                );
                const cellNode = cellResolvedPos.node();
                const decorationPos = cellResolvedPos.pos + (newIndex > this.view.state.draggingState.originalIndex ? cellNode.nodeSize - 2 : 0);
                decorations.push(
                  // The widget is a small bar which spans the width of the cell.
                  Decoration.widget(decorationPos, () => {
                    const widget = document.createElement("div");
                    widget.className = "bn-table-drop-cursor";
                    widget.style.left = "0";
                    widget.style.right = "0";
                    if (newIndex > this.view.state.draggingState.originalIndex) {
                      widget.style.bottom = "-2px";
                    } else {
                      widget.style.top = "-3px";
                    }
                    widget.style.height = "4px";
                    return widget;
                  })
                );
              }
            } else {
              for (let i2 = 0; i2 < tableNode.childCount; i2++) {
                const rowResolvedPos = state.doc.resolve(
                  tableResolvedPos.posAtIndex(i2) + 1
                );
                const cellResolvedPos = state.doc.resolve(
                  rowResolvedPos.posAtIndex(newIndex) + 1
                );
                const cellNode = cellResolvedPos.node();
                const decorationPos = cellResolvedPos.pos + (newIndex > this.view.state.draggingState.originalIndex ? cellNode.nodeSize - 2 : 0);
                decorations.push(
                  // The widget is a small bar which spans the height of the cell.
                  Decoration.widget(decorationPos, () => {
                    const widget = document.createElement("div");
                    widget.className = "bn-table-drop-cursor";
                    widget.style.top = "0";
                    widget.style.bottom = "0";
                    if (newIndex > this.view.state.draggingState.originalIndex) {
                      widget.style.right = "-2px";
                    } else {
                      widget.style.left = "-3px";
                    }
                    widget.style.width = "4px";
                    return widget;
                  })
                );
              }
            }
            return DecorationSet.create(state.doc, decorations);
          }
        }
      });
    }
    onUpdate(callback) {
      return this.on("update", callback);
    }
  }
  const create$5 = () => /* @__PURE__ */ new Map();
  const copy = (m) => {
    const r = create$5();
    m.forEach((v, k) => {
      r.set(k, v);
    });
    return r;
  };
  const setIfUndefined = (map2, key2, createT) => {
    let set = map2.get(key2);
    if (set === void 0) {
      map2.set(key2, set = createT());
    }
    return set;
  };
  const map = (m, f) => {
    const res = [];
    for (const [key2, value] of m) {
      res.push(f(value, key2));
    }
    return res;
  };
  const any = (m, f) => {
    for (const [key2, value] of m) {
      if (f(value, key2)) {
        return true;
      }
    }
    return false;
  };
  const create$4 = () => /* @__PURE__ */ new Set();
  const last = (arr) => arr[arr.length - 1];
  const appendTo = (dest, src) => {
    for (let i2 = 0; i2 < src.length; i2++) {
      dest.push(src[i2]);
    }
  };
  const from = Array.from;
  const some = (arr, f) => {
    for (let i2 = 0; i2 < arr.length; i2++) {
      if (f(arr[i2], i2, arr)) {
        return true;
      }
    }
    return false;
  };
  const isArray = Array.isArray;
  class ObservableV2 {
    constructor() {
      this._observers = create$5();
    }
    /**
     * @template {keyof EVENTS & string} NAME
     * @param {NAME} name
     * @param {EVENTS[NAME]} f
     */
    on(name, f) {
      setIfUndefined(
        this._observers,
        /** @type {string} */
        name,
        create$4
      ).add(f);
      return f;
    }
    /**
     * @template {keyof EVENTS & string} NAME
     * @param {NAME} name
     * @param {EVENTS[NAME]} f
     */
    once(name, f) {
      const _f = (...args) => {
        this.off(
          name,
          /** @type {any} */
          _f
        );
        f(...args);
      };
      this.on(
        name,
        /** @type {any} */
        _f
      );
    }
    /**
     * @template {keyof EVENTS & string} NAME
     * @param {NAME} name
     * @param {EVENTS[NAME]} f
     */
    off(name, f) {
      const observers = this._observers.get(name);
      if (observers !== void 0) {
        observers.delete(f);
        if (observers.size === 0) {
          this._observers.delete(name);
        }
      }
    }
    /**
     * Emit a named event. All registered event listeners that listen to the
     * specified name will receive the event.
     *
     * @todo This should catch exceptions
     *
     * @template {keyof EVENTS & string} NAME
     * @param {NAME} name The event name.
     * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
     */
    emit(name, args) {
      return from((this._observers.get(name) || create$5()).values()).forEach((f) => f(...args));
    }
    destroy() {
      this._observers = create$5();
    }
  }
  const floor = Math.floor;
  const abs = Math.abs;
  const min = (a2, b) => a2 < b ? a2 : b;
  const max = (a2, b) => a2 > b ? a2 : b;
  const isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;
  const BIT1 = 1;
  const BIT2 = 2;
  const BIT3 = 4;
  const BIT4 = 8;
  const BIT6 = 32;
  const BIT7 = 64;
  const BIT8 = 128;
  const BITS5 = 31;
  const BITS6 = 63;
  const BITS7 = 127;
  const BITS31 = 2147483647;
  const isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
  const toLowerCase = (s2) => s2.toLowerCase();
  const trimLeftRegex = /^\s*/g;
  const trimLeft = (s2) => s2.replace(trimLeftRegex, "");
  const fromCamelCaseRegex = /([A-Z])/g;
  const fromCamelCase = (s2, separator) => trimLeft(s2.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
  const _encodeUtf8Polyfill = (str) => {
    const encodedString = unescape(encodeURIComponent(str));
    const len = encodedString.length;
    const buf = new Uint8Array(len);
    for (let i2 = 0; i2 < len; i2++) {
      buf[i2] = /** @type {number} */
      encodedString.codePointAt(i2);
    }
    return buf;
  };
  const utf8TextEncoder = (
    /** @type {TextEncoder} */
    typeof TextEncoder !== "undefined" ? new TextEncoder() : null
  );
  const _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
  const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
  let utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
  if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
    utf8TextDecoder = null;
  }
  class Encoder {
    constructor() {
      this.cpos = 0;
      this.cbuf = new Uint8Array(100);
      this.bufs = [];
    }
  }
  const createEncoder = () => new Encoder();
  const length$1 = (encoder) => {
    let len = encoder.cpos;
    for (let i2 = 0; i2 < encoder.bufs.length; i2++) {
      len += encoder.bufs[i2].length;
    }
    return len;
  };
  const toUint8Array = (encoder) => {
    const uint8arr = new Uint8Array(length$1(encoder));
    let curPos = 0;
    for (let i2 = 0; i2 < encoder.bufs.length; i2++) {
      const d = encoder.bufs[i2];
      uint8arr.set(d, curPos);
      curPos += d.length;
    }
    uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
    return uint8arr;
  };
  const verifyLen = (encoder, len) => {
    const bufferLen = encoder.cbuf.length;
    if (bufferLen - encoder.cpos < len) {
      encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
      encoder.cbuf = new Uint8Array(max(bufferLen, len) * 2);
      encoder.cpos = 0;
    }
  };
  const write = (encoder, num) => {
    const bufferLen = encoder.cbuf.length;
    if (encoder.cpos === bufferLen) {
      encoder.bufs.push(encoder.cbuf);
      encoder.cbuf = new Uint8Array(bufferLen * 2);
      encoder.cpos = 0;
    }
    encoder.cbuf[encoder.cpos++] = num;
  };
  const writeUint8 = write;
  const writeVarUint = (encoder, num) => {
    while (num > BITS7) {
      write(encoder, BIT8 | BITS7 & num);
      num = floor(num / 128);
    }
    write(encoder, BITS7 & num);
  };
  const writeVarInt = (encoder, num) => {
    const isNegative = isNegativeZero(num);
    if (isNegative) {
      num = -num;
    }
    write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
    num = floor(num / 64);
    while (num > 0) {
      write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
      num = floor(num / 128);
    }
  };
  const _strBuffer = new Uint8Array(3e4);
  const _maxStrBSize = _strBuffer.length / 3;
  const _writeVarStringNative = (encoder, str) => {
    if (str.length < _maxStrBSize) {
      const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
      writeVarUint(encoder, written);
      for (let i2 = 0; i2 < written; i2++) {
        write(encoder, _strBuffer[i2]);
      }
    } else {
      writeVarUint8Array(encoder, encodeUtf8(str));
    }
  };
  const _writeVarStringPolyfill = (encoder, str) => {
    const encodedString = unescape(encodeURIComponent(str));
    const len = encodedString.length;
    writeVarUint(encoder, len);
    for (let i2 = 0; i2 < len; i2++) {
      write(
        encoder,
        /** @type {number} */
        encodedString.codePointAt(i2)
      );
    }
  };
  const writeVarString = utf8TextEncoder && /** @type {any} */
  utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
  const writeUint8Array = (encoder, uint8Array) => {
    const bufferLen = encoder.cbuf.length;
    const cpos = encoder.cpos;
    const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
    const rightCopyLen = uint8Array.length - leftCopyLen;
    encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
    encoder.cpos += leftCopyLen;
    if (rightCopyLen > 0) {
      encoder.bufs.push(encoder.cbuf);
      encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
      encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
      encoder.cpos = rightCopyLen;
    }
  };
  const writeVarUint8Array = (encoder, uint8Array) => {
    writeVarUint(encoder, uint8Array.byteLength);
    writeUint8Array(encoder, uint8Array);
  };
  const writeOnDataView = (encoder, len) => {
    verifyLen(encoder, len);
    const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
    encoder.cpos += len;
    return dview;
  };
  const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
  const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
  const writeBigInt64 = (encoder, num) => (
    /** @type {any} */
    writeOnDataView(encoder, 8).setBigInt64(0, num, false)
  );
  const floatTestBed = new DataView(new ArrayBuffer(4));
  const isFloat32 = (num) => {
    floatTestBed.setFloat32(0, num);
    return floatTestBed.getFloat32(0) === num;
  };
  const writeAny = (encoder, data) => {
    switch (typeof data) {
      case "string":
        write(encoder, 119);
        writeVarString(encoder, data);
        break;
      case "number":
        if (isInteger(data) && abs(data) <= BITS31) {
          write(encoder, 125);
          writeVarInt(encoder, data);
        } else if (isFloat32(data)) {
          write(encoder, 124);
          writeFloat32(encoder, data);
        } else {
          write(encoder, 123);
          writeFloat64(encoder, data);
        }
        break;
      case "bigint":
        write(encoder, 122);
        writeBigInt64(encoder, data);
        break;
      case "object":
        if (data === null) {
          write(encoder, 126);
        } else if (isArray(data)) {
          write(encoder, 117);
          writeVarUint(encoder, data.length);
          for (let i2 = 0; i2 < data.length; i2++) {
            writeAny(encoder, data[i2]);
          }
        } else if (data instanceof Uint8Array) {
          write(encoder, 116);
          writeVarUint8Array(encoder, data);
        } else {
          write(encoder, 118);
          const keys2 = Object.keys(data);
          writeVarUint(encoder, keys2.length);
          for (let i2 = 0; i2 < keys2.length; i2++) {
            const key2 = keys2[i2];
            writeVarString(encoder, key2);
            writeAny(encoder, data[key2]);
          }
        }
        break;
      case "boolean":
        write(encoder, data ? 120 : 121);
        break;
      default:
        write(encoder, 127);
    }
  };
  class RleEncoder extends Encoder {
    /**
     * @param {function(Encoder, T):void} writer
     */
    constructor(writer) {
      super();
      this.w = writer;
      this.s = null;
      this.count = 0;
    }
    /**
     * @param {T} v
     */
    write(v) {
      if (this.s === v) {
        this.count++;
      } else {
        if (this.count > 0) {
          writeVarUint(this, this.count - 1);
        }
        this.count = 1;
        this.w(this, v);
        this.s = v;
      }
    }
  }
  const flushUintOptRleEncoder = (encoder) => {
    if (encoder.count > 0) {
      writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
      if (encoder.count > 1) {
        writeVarUint(encoder.encoder, encoder.count - 2);
      }
    }
  };
  class UintOptRleEncoder {
    constructor() {
      this.encoder = new Encoder();
      this.s = 0;
      this.count = 0;
    }
    /**
     * @param {number} v
     */
    write(v) {
      if (this.s === v) {
        this.count++;
      } else {
        flushUintOptRleEncoder(this);
        this.count = 1;
        this.s = v;
      }
    }
    /**
     * Flush the encoded state and transform this to a Uint8Array.
     *
     * Note that this should only be called once.
     */
    toUint8Array() {
      flushUintOptRleEncoder(this);
      return toUint8Array(this.encoder);
    }
  }
  const flushIntDiffOptRleEncoder = (encoder) => {
    if (encoder.count > 0) {
      const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
      writeVarInt(encoder.encoder, encodedDiff);
      if (encoder.count > 1) {
        writeVarUint(encoder.encoder, encoder.count - 2);
      }
    }
  };
  class IntDiffOptRleEncoder {
    constructor() {
      this.encoder = new Encoder();
      this.s = 0;
      this.count = 0;
      this.diff = 0;
    }
    /**
     * @param {number} v
     */
    write(v) {
      if (this.diff === v - this.s) {
        this.s = v;
        this.count++;
      } else {
        flushIntDiffOptRleEncoder(this);
        this.count = 1;
        this.diff = v - this.s;
        this.s = v;
      }
    }
    /**
     * Flush the encoded state and transform this to a Uint8Array.
     *
     * Note that this should only be called once.
     */
    toUint8Array() {
      flushIntDiffOptRleEncoder(this);
      return toUint8Array(this.encoder);
    }
  }
  class StringEncoder {
    constructor() {
      this.sarr = [];
      this.s = "";
      this.lensE = new UintOptRleEncoder();
    }
    /**
     * @param {string} string
     */
    write(string2) {
      this.s += string2;
      if (this.s.length > 19) {
        this.sarr.push(this.s);
        this.s = "";
      }
      this.lensE.write(string2.length);
    }
    toUint8Array() {
      const encoder = new Encoder();
      this.sarr.push(this.s);
      this.s = "";
      writeVarString(encoder, this.sarr.join(""));
      writeUint8Array(encoder, this.lensE.toUint8Array());
      return toUint8Array(encoder);
    }
  }
  const create$3 = (s2) => new Error(s2);
  const methodUnimplemented = () => {
    throw create$3("Method unimplemented");
  };
  const unexpectedCase = () => {
    throw create$3("Unexpected case");
  };
  const getRandomValues = crypto.getRandomValues.bind(crypto);
  const rand = Math.random;
  const uint32 = () => getRandomValues(new Uint32Array(1))[0];
  const oneOf = (arr) => arr[floor(rand() * arr.length)];
  const uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;
  const uuidv4 = () => uuidv4Template.replace(
    /[018]/g,
    /** @param {number} c */
    (c) => (c ^ uint32() & 15 >> c / 4).toString(16)
  );
  const getUnixTime = Date.now;
  const create$2 = (f) => (
    /** @type {Promise<T>} */
    new Promise(f)
  );
  Promise.all.bind(Promise);
  const undefinedToNull = (v) => v === void 0 ? null : v;
  class VarStoragePolyfill {
    constructor() {
      this.map = /* @__PURE__ */ new Map();
    }
    /**
     * @param {string} key
     * @param {any} newValue
     */
    setItem(key2, newValue) {
      this.map.set(key2, newValue);
    }
    /**
     * @param {string} key
     */
    getItem(key2) {
      return this.map.get(key2);
    }
  }
  let _localStorage = new VarStoragePolyfill();
  let usePolyfill = true;
  try {
    if (typeof localStorage !== "undefined" && localStorage) {
      _localStorage = localStorage;
      usePolyfill = false;
    }
  } catch (e) {
  }
  const varStorage = _localStorage;
  const assign$1 = Object.assign;
  const keys = Object.keys;
  const forEach = (obj, f) => {
    for (const key2 in obj) {
      f(obj[key2], key2);
    }
  };
  const length = (obj) => keys(obj).length;
  const isEmpty = (obj) => {
    for (const _k in obj) {
      return false;
    }
    return true;
  };
  const every = (obj, f) => {
    for (const key2 in obj) {
      if (!f(obj[key2], key2)) {
        return false;
      }
    }
    return true;
  };
  const hasProperty = (obj, key2) => Object.prototype.hasOwnProperty.call(obj, key2);
  const equalFlat = (a2, b) => a2 === b || length(a2) === length(b) && every(a2, (val, key2) => (val !== void 0 || hasProperty(b, key2)) && b[key2] === val);
  const callAll = (fs, args, i2 = 0) => {
    try {
      for (; i2 < fs.length; i2++) {
        fs[i2](...args);
      }
    } finally {
      if (i2 < fs.length) {
        callAll(fs, args, i2 + 1);
      }
    }
  };
  const isOneOf = (value, options) => options.includes(value);
  const isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
  const isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && !isNode;
  let params;
  const computeParams = () => {
    if (params === void 0) {
      if (isNode) {
        params = create$5();
        const pargs = process.argv;
        let currParamName = null;
        for (let i2 = 0; i2 < pargs.length; i2++) {
          const parg = pargs[i2];
          if (parg[0] === "-") {
            if (currParamName !== null) {
              params.set(currParamName, "");
            }
            currParamName = parg;
          } else {
            if (currParamName !== null) {
              params.set(currParamName, parg);
              currParamName = null;
            }
          }
        }
        if (currParamName !== null) {
          params.set(currParamName, "");
        }
      } else if (typeof location === "object") {
        params = create$5();
        (location.search || "?").slice(1).split("&").forEach((kv) => {
          if (kv.length !== 0) {
            const [key2, value] = kv.split("=");
            params.set(`--${fromCamelCase(key2, "-")}`, value);
            params.set(`-${fromCamelCase(key2, "-")}`, value);
          }
        });
      } else {
        params = create$5();
      }
    }
    return params;
  };
  const hasParam = (name) => computeParams().has(name);
  const getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name));
  const hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
  hasConf("production");
  const forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
  const supportsColor = !hasParam("no-colors") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam("color") || forceColor || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));
  class Pair {
    /**
     * @param {L} left
     * @param {R} right
     */
    constructor(left, right) {
      this.left = left;
      this.right = right;
    }
  }
  const create$1 = (left, right) => new Pair(left, right);
  const doc = (
    /** @type {Document} */
    typeof document !== "undefined" ? document : {}
  );
  typeof DOMParser !== "undefined" ? new DOMParser() : null;
  const mapToStyleString = (m) => map(m, (value, key2) => `${key2}:${value};`).join("");
  const createTimeoutClass = (clearFunction) => class TT {
    /**
     * @param {number} timeoutId
     */
    constructor(timeoutId) {
      this._ = timeoutId;
    }
    destroy() {
      clearFunction(this._);
    }
  };
  const Timeout = createTimeoutClass(clearTimeout);
  const timeout = (timeout2, callback) => new Timeout(setTimeout(callback, timeout2));
  const create = Symbol;
  const BOLD = create();
  const UNBOLD = create();
  const BLUE = create();
  const GREY = create();
  const GREEN = create();
  const RED = create();
  const PURPLE = create();
  const ORANGE = create();
  const UNCOLOR = create();
  const computeNoColorLoggingArgs = (args) => {
    var _a;
    if (args.length === 1 && ((_a = args[0]) == null ? void 0 : _a.constructor) === Function) {
      args = /** @type {Array<string|Symbol|Object|number>} */
      /** @type {[function]} */
      args[0]();
    }
    const logArgs = [];
    let i2 = 0;
    for (; i2 < args.length; i2++) {
      const arg = args[i2];
      if (arg === void 0)
        ;
      else if (arg.constructor === String || arg.constructor === Number)
        ;
      else if (arg.constructor === Object) {
        logArgs.push(JSON.stringify(arg));
      }
    }
    return logArgs;
  };
  const _browserStyleMap = {
    [BOLD]: create$1("font-weight", "bold"),
    [UNBOLD]: create$1("font-weight", "normal"),
    [BLUE]: create$1("color", "blue"),
    [GREEN]: create$1("color", "green"),
    [GREY]: create$1("color", "grey"),
    [RED]: create$1("color", "red"),
    [PURPLE]: create$1("color", "purple"),
    [ORANGE]: create$1("color", "orange"),
    // not well supported in chrome when debugging node with inspector - TODO: deprecate
    [UNCOLOR]: create$1("color", "black")
  };
  const computeBrowserLoggingArgs = (args) => {
    var _a;
    if (args.length === 1 && ((_a = args[0]) == null ? void 0 : _a.constructor) === Function) {
      args = /** @type {Array<string|Symbol|Object|number>} */
      /** @type {[function]} */
      args[0]();
    }
    const strBuilder = [];
    const styles = [];
    const currentStyle = create$5();
    let logArgs = [];
    let i2 = 0;
    for (; i2 < args.length; i2++) {
      const arg = args[i2];
      const style2 = _browserStyleMap[arg];
      if (style2 !== void 0) {
        currentStyle.set(style2.left, style2.right);
      } else {
        if (arg === void 0) {
          break;
        }
        if (arg.constructor === String || arg.constructor === Number) {
          const style3 = mapToStyleString(currentStyle);
          if (i2 > 0 || style3.length > 0) {
            strBuilder.push("%c" + arg);
            styles.push(style3);
          } else {
            strBuilder.push(arg);
          }
        } else {
          break;
        }
      }
    }
    if (i2 > 0) {
      logArgs = styles;
      logArgs.unshift(strBuilder.join(""));
    }
    for (; i2 < args.length; i2++) {
      const arg = args[i2];
      if (!(arg instanceof Symbol)) {
        logArgs.push(arg);
      }
    }
    return logArgs;
  };
  const computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;
  const print = (...args) => {
    console.log(...computeLoggingArgs(args));
    vconsoles.forEach((vc) => vc.print(args));
  };
  const warn$1 = (...args) => {
    console.warn(...computeLoggingArgs(args));
    args.unshift(ORANGE);
    vconsoles.forEach((vc) => vc.print(args));
  };
  const vconsoles = create$4();
  const createIterator = (next) => ({
    /**
     * @return {IterableIterator<T>}
     */
    [Symbol.iterator]() {
      return this;
    },
    // @ts-ignore
    next
  });
  const iteratorFilter = (iterator, filter) => createIterator(() => {
    let res;
    do {
      res = iterator.next();
    } while (!res.done && !filter(res.value));
    return res;
  });
  const iteratorMap = (iterator, fmap) => createIterator(() => {
    const { done, value } = iterator.next();
    return { done, value: done ? void 0 : fmap(value) };
  });
  class DeleteItem {
    /**
     * @param {number} clock
     * @param {number} len
     */
    constructor(clock, len) {
      this.clock = clock;
      this.len = len;
    }
  }
  class DeleteSet {
    constructor() {
      this.clients = /* @__PURE__ */ new Map();
    }
  }
  const iterateDeletedStructs = (transaction, ds, f) => ds.clients.forEach((deletes, clientid) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      transaction.doc.store.clients.get(clientid)
    );
    for (let i2 = 0; i2 < deletes.length; i2++) {
      const del2 = deletes[i2];
      iterateStructs(transaction, structs, del2.clock, del2.len, f);
    }
  });
  const findIndexDS = (dis, clock) => {
    let left = 0;
    let right = dis.length - 1;
    while (left <= right) {
      const midindex = floor((left + right) / 2);
      const mid = dis[midindex];
      const midclock = mid.clock;
      if (midclock <= clock) {
        if (clock < midclock + mid.len) {
          return midindex;
        }
        left = midindex + 1;
      } else {
        right = midindex - 1;
      }
    }
    return null;
  };
  const isDeleted = (ds, id) => {
    const dis = ds.clients.get(id.client);
    return dis !== void 0 && findIndexDS(dis, id.clock) !== null;
  };
  const sortAndMergeDeleteSet = (ds) => {
    ds.clients.forEach((dels) => {
      dels.sort((a2, b) => a2.clock - b.clock);
      let i2, j;
      for (i2 = 1, j = 1; i2 < dels.length; i2++) {
        const left = dels[j - 1];
        const right = dels[i2];
        if (left.clock + left.len >= right.clock) {
          left.len = max(left.len, right.clock + right.len - left.clock);
        } else {
          if (j < i2) {
            dels[j] = right;
          }
          j++;
        }
      }
      dels.length = j;
    });
  };
  const mergeDeleteSets = (dss) => {
    const merged = new DeleteSet();
    for (let dssI = 0; dssI < dss.length; dssI++) {
      dss[dssI].clients.forEach((delsLeft, client) => {
        if (!merged.clients.has(client)) {
          const dels = delsLeft.slice();
          for (let i2 = dssI + 1; i2 < dss.length; i2++) {
            appendTo(dels, dss[i2].clients.get(client) || []);
          }
          merged.clients.set(client, dels);
        }
      });
    }
    sortAndMergeDeleteSet(merged);
    return merged;
  };
  const addToDeleteSet = (ds, client, clock, length2) => {
    setIfUndefined(ds.clients, client, () => (
      /** @type {Array<DeleteItem>} */
      []
    )).push(new DeleteItem(clock, length2));
  };
  const createDeleteSet = () => new DeleteSet();
  const createDeleteSetFromStructStore = (ss) => {
    const ds = createDeleteSet();
    ss.clients.forEach((structs, client) => {
      const dsitems = [];
      for (let i2 = 0; i2 < structs.length; i2++) {
        const struct = structs[i2];
        if (struct.deleted) {
          const clock = struct.id.clock;
          let len = struct.length;
          if (i2 + 1 < structs.length) {
            for (let next = structs[i2 + 1]; i2 + 1 < structs.length && next.deleted; next = structs[++i2 + 1]) {
              len += next.length;
            }
          }
          dsitems.push(new DeleteItem(clock, len));
        }
      }
      if (dsitems.length > 0) {
        ds.clients.set(client, dsitems);
      }
    });
    return ds;
  };
  const writeDeleteSet = (encoder, ds) => {
    writeVarUint(encoder.restEncoder, ds.clients.size);
    from(ds.clients.entries()).sort((a2, b) => b[0] - a2[0]).forEach(([client, dsitems]) => {
      encoder.resetDsCurVal();
      writeVarUint(encoder.restEncoder, client);
      const len = dsitems.length;
      writeVarUint(encoder.restEncoder, len);
      for (let i2 = 0; i2 < len; i2++) {
        const item = dsitems[i2];
        encoder.writeDsClock(item.clock);
        encoder.writeDsLen(item.len);
      }
    });
  };
  const generateNewClientId = uint32;
  let Doc$1 = class Doc2 extends ObservableV2 {
    /**
     * @param {DocOpts} opts configuration
     */
    constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta: meta2 = null, autoLoad = false, shouldLoad = true } = {}) {
      super();
      this.gc = gc;
      this.gcFilter = gcFilter;
      this.clientID = generateNewClientId();
      this.guid = guid;
      this.collectionid = collectionid;
      this.share = /* @__PURE__ */ new Map();
      this.store = new StructStore();
      this._transaction = null;
      this._transactionCleanups = [];
      this.subdocs = /* @__PURE__ */ new Set();
      this._item = null;
      this.shouldLoad = shouldLoad;
      this.autoLoad = autoLoad;
      this.meta = meta2;
      this.isLoaded = false;
      this.isSynced = false;
      this.whenLoaded = create$2((resolve2) => {
        this.on("load", () => {
          this.isLoaded = true;
          resolve2(this);
        });
      });
      const provideSyncedPromise = () => create$2((resolve2) => {
        const eventHandler = (isSynced) => {
          if (isSynced === void 0 || isSynced === true) {
            this.off("sync", eventHandler);
            resolve2();
          }
        };
        this.on("sync", eventHandler);
      });
      this.on("sync", (isSynced) => {
        if (isSynced === false && this.isSynced) {
          this.whenSynced = provideSyncedPromise();
        }
        this.isSynced = isSynced === void 0 || isSynced === true;
        if (this.isSynced && !this.isLoaded) {
          this.emit("load", [this]);
        }
      });
      this.whenSynced = provideSyncedPromise();
    }
    /**
     * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
     *
     * `load()` might be used in the future to request any provider to load the most current data.
     *
     * It is safe to call `load()` multiple times.
     */
    load() {
      const item = this._item;
      if (item !== null && !this.shouldLoad) {
        transact(
          /** @type {any} */
          item.parent.doc,
          (transaction) => {
            transaction.subdocsLoaded.add(this);
          },
          null,
          true
        );
      }
      this.shouldLoad = true;
    }
    getSubdocs() {
      return this.subdocs;
    }
    getSubdocGuids() {
      return new Set(from(this.subdocs).map((doc2) => doc2.guid));
    }
    /**
     * Changes that happen inside of a transaction are bundled. This means that
     * the observer fires _after_ the transaction is finished and that all changes
     * that happened inside of the transaction are sent as one message to the
     * other peers.
     *
     * @template T
     * @param {function(Transaction):T} f The function that should be executed as a transaction
     * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
     * @return T
     *
     * @public
     */
    transact(f, origin = null) {
      return transact(this, f, origin);
    }
    /**
     * Define a shared data type.
     *
     * Multiple calls of `y.get(name, TypeConstructor)` yield the same result
     * and do not overwrite each other. I.e.
     * `y.define(name, Y.Array) === y.define(name, Y.Array)`
     *
     * After this method is called, the type is also available on `y.share.get(name)`.
     *
     * *Best Practices:*
     * Define all types right after the Yjs instance is created and store them in a separate object.
     * Also use the typed methods `getText(name)`, `getArray(name)`, ..
     *
     * @template {typeof AbstractType<any>} Type
     * @example
     *   const y = new Y(..)
     *   const appState = {
     *     document: y.getText('document')
     *     comments: y.getArray('comments')
     *   }
     *
     * @param {string} name
     * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
     * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
     *
     * @public
     */
    get(name, TypeConstructor = (
      /** @type {any} */
      AbstractType
    )) {
      const type = setIfUndefined(this.share, name, () => {
        const t = new TypeConstructor();
        t._integrate(this, null);
        return t;
      });
      const Constr = type.constructor;
      if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
        if (Constr === AbstractType) {
          const t = new TypeConstructor();
          t._map = type._map;
          type._map.forEach(
            /** @param {Item?} n */
            (n) => {
              for (; n !== null; n = n.left) {
                n.parent = t;
              }
            }
          );
          t._start = type._start;
          for (let n = t._start; n !== null; n = n.right) {
            n.parent = t;
          }
          t._length = type._length;
          this.share.set(name, t);
          t._integrate(this, null);
          return (
            /** @type {InstanceType<Type>} */
            t
          );
        } else {
          throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
        }
      }
      return (
        /** @type {InstanceType<Type>} */
        type
      );
    }
    /**
     * @template T
     * @param {string} [name]
     * @return {YArray<T>}
     *
     * @public
     */
    getArray(name = "") {
      return (
        /** @type {YArray<T>} */
        this.get(name, YArray)
      );
    }
    /**
     * @param {string} [name]
     * @return {YText}
     *
     * @public
     */
    getText(name = "") {
      return this.get(name, YText);
    }
    /**
     * @template T
     * @param {string} [name]
     * @return {YMap<T>}
     *
     * @public
     */
    getMap(name = "") {
      return (
        /** @type {YMap<T>} */
        this.get(name, YMap)
      );
    }
    /**
     * @param {string} [name]
     * @return {YXmlElement}
     *
     * @public
     */
    getXmlElement(name = "") {
      return (
        /** @type {YXmlElement<{[key:string]:string}>} */
        this.get(name, YXmlElement)
      );
    }
    /**
     * @param {string} [name]
     * @return {YXmlFragment}
     *
     * @public
     */
    getXmlFragment(name = "") {
      return this.get(name, YXmlFragment);
    }
    /**
     * Converts the entire document into a js object, recursively traversing each yjs type
     * Doesn't log types that have not been defined (using ydoc.getType(..)).
     *
     * @deprecated Do not use this method and rather call toJSON directly on the shared types.
     *
     * @return {Object<string, any>}
     */
    toJSON() {
      const doc2 = {};
      this.share.forEach((value, key2) => {
        doc2[key2] = value.toJSON();
      });
      return doc2;
    }
    /**
     * Emit `destroy` event and unregister all event handlers.
     */
    destroy() {
      from(this.subdocs).forEach((subdoc) => subdoc.destroy());
      const item = this._item;
      if (item !== null) {
        this._item = null;
        const content2 = (
          /** @type {ContentDoc} */
          item.content
        );
        content2.doc = new Doc2({ guid: this.guid, ...content2.opts, shouldLoad: false });
        content2.doc._item = item;
        transact(
          /** @type {any} */
          item.parent.doc,
          (transaction) => {
            const doc2 = content2.doc;
            if (!item.deleted) {
              transaction.subdocsAdded.add(doc2);
            }
            transaction.subdocsRemoved.add(this);
          },
          null,
          true
        );
      }
      this.emit("destroyed", [true]);
      this.emit("destroy", [this]);
      super.destroy();
    }
  };
  class DSEncoderV1 {
    constructor() {
      this.restEncoder = createEncoder();
    }
    toUint8Array() {
      return toUint8Array(this.restEncoder);
    }
    resetDsCurVal() {
    }
    /**
     * @param {number} clock
     */
    writeDsClock(clock) {
      writeVarUint(this.restEncoder, clock);
    }
    /**
     * @param {number} len
     */
    writeDsLen(len) {
      writeVarUint(this.restEncoder, len);
    }
  }
  class UpdateEncoderV1 extends DSEncoderV1 {
    /**
     * @param {ID} id
     */
    writeLeftID(id) {
      writeVarUint(this.restEncoder, id.client);
      writeVarUint(this.restEncoder, id.clock);
    }
    /**
     * @param {ID} id
     */
    writeRightID(id) {
      writeVarUint(this.restEncoder, id.client);
      writeVarUint(this.restEncoder, id.clock);
    }
    /**
     * Use writeClient and writeClock instead of writeID if possible.
     * @param {number} client
     */
    writeClient(client) {
      writeVarUint(this.restEncoder, client);
    }
    /**
     * @param {number} info An unsigned 8-bit integer
     */
    writeInfo(info) {
      writeUint8(this.restEncoder, info);
    }
    /**
     * @param {string} s
     */
    writeString(s2) {
      writeVarString(this.restEncoder, s2);
    }
    /**
     * @param {boolean} isYKey
     */
    writeParentInfo(isYKey) {
      writeVarUint(this.restEncoder, isYKey ? 1 : 0);
    }
    /**
     * @param {number} info An unsigned 8-bit integer
     */
    writeTypeRef(info) {
      writeVarUint(this.restEncoder, info);
    }
    /**
     * Write len of a struct - well suited for Opt RLE encoder.
     *
     * @param {number} len
     */
    writeLen(len) {
      writeVarUint(this.restEncoder, len);
    }
    /**
     * @param {any} any
     */
    writeAny(any2) {
      writeAny(this.restEncoder, any2);
    }
    /**
     * @param {Uint8Array} buf
     */
    writeBuf(buf) {
      writeVarUint8Array(this.restEncoder, buf);
    }
    /**
     * @param {any} embed
     */
    writeJSON(embed) {
      writeVarString(this.restEncoder, JSON.stringify(embed));
    }
    /**
     * @param {string} key
     */
    writeKey(key2) {
      writeVarString(this.restEncoder, key2);
    }
  }
  class DSEncoderV2 {
    constructor() {
      this.restEncoder = createEncoder();
      this.dsCurrVal = 0;
    }
    toUint8Array() {
      return toUint8Array(this.restEncoder);
    }
    resetDsCurVal() {
      this.dsCurrVal = 0;
    }
    /**
     * @param {number} clock
     */
    writeDsClock(clock) {
      const diff = clock - this.dsCurrVal;
      this.dsCurrVal = clock;
      writeVarUint(this.restEncoder, diff);
    }
    /**
     * @param {number} len
     */
    writeDsLen(len) {
      if (len === 0) {
        unexpectedCase();
      }
      writeVarUint(this.restEncoder, len - 1);
      this.dsCurrVal += len;
    }
  }
  class UpdateEncoderV2 extends DSEncoderV2 {
    constructor() {
      super();
      this.keyMap = /* @__PURE__ */ new Map();
      this.keyClock = 0;
      this.keyClockEncoder = new IntDiffOptRleEncoder();
      this.clientEncoder = new UintOptRleEncoder();
      this.leftClockEncoder = new IntDiffOptRleEncoder();
      this.rightClockEncoder = new IntDiffOptRleEncoder();
      this.infoEncoder = new RleEncoder(writeUint8);
      this.stringEncoder = new StringEncoder();
      this.parentInfoEncoder = new RleEncoder(writeUint8);
      this.typeRefEncoder = new UintOptRleEncoder();
      this.lenEncoder = new UintOptRleEncoder();
    }
    toUint8Array() {
      const encoder = createEncoder();
      writeVarUint(encoder, 0);
      writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
      writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
      writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
      writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
      writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));
      writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
      writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));
      writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
      writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
      writeUint8Array(encoder, toUint8Array(this.restEncoder));
      return toUint8Array(encoder);
    }
    /**
     * @param {ID} id
     */
    writeLeftID(id) {
      this.clientEncoder.write(id.client);
      this.leftClockEncoder.write(id.clock);
    }
    /**
     * @param {ID} id
     */
    writeRightID(id) {
      this.clientEncoder.write(id.client);
      this.rightClockEncoder.write(id.clock);
    }
    /**
     * @param {number} client
     */
    writeClient(client) {
      this.clientEncoder.write(client);
    }
    /**
     * @param {number} info An unsigned 8-bit integer
     */
    writeInfo(info) {
      this.infoEncoder.write(info);
    }
    /**
     * @param {string} s
     */
    writeString(s2) {
      this.stringEncoder.write(s2);
    }
    /**
     * @param {boolean} isYKey
     */
    writeParentInfo(isYKey) {
      this.parentInfoEncoder.write(isYKey ? 1 : 0);
    }
    /**
     * @param {number} info An unsigned 8-bit integer
     */
    writeTypeRef(info) {
      this.typeRefEncoder.write(info);
    }
    /**
     * Write len of a struct - well suited for Opt RLE encoder.
     *
     * @param {number} len
     */
    writeLen(len) {
      this.lenEncoder.write(len);
    }
    /**
     * @param {any} any
     */
    writeAny(any2) {
      writeAny(this.restEncoder, any2);
    }
    /**
     * @param {Uint8Array} buf
     */
    writeBuf(buf) {
      writeVarUint8Array(this.restEncoder, buf);
    }
    /**
     * This is mainly here for legacy purposes.
     *
     * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
     *
     * @param {any} embed
     */
    writeJSON(embed) {
      writeAny(this.restEncoder, embed);
    }
    /**
     * Property keys are often reused. For example, in y-prosemirror the key `bold` might
     * occur very often. For a 3d application, the key `position` might occur very often.
     *
     * We cache these keys in a Map and refer to them via a unique number.
     *
     * @param {string} key
     */
    writeKey(key2) {
      const clock = this.keyMap.get(key2);
      if (clock === void 0) {
        this.keyClockEncoder.write(this.keyClock++);
        this.stringEncoder.write(key2);
      } else {
        this.keyClockEncoder.write(clock);
      }
    }
  }
  const writeStructs = (encoder, structs, client, clock) => {
    clock = max(clock, structs[0].id.clock);
    const startNewStructs = findIndexSS(structs, clock);
    writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
    encoder.writeClient(client);
    writeVarUint(encoder.restEncoder, clock);
    const firstStruct = structs[startNewStructs];
    firstStruct.write(encoder, clock - firstStruct.id.clock);
    for (let i2 = startNewStructs + 1; i2 < structs.length; i2++) {
      structs[i2].write(encoder, 0);
    }
  };
  const writeClientsStructs = (encoder, store, _sm) => {
    const sm = /* @__PURE__ */ new Map();
    _sm.forEach((clock, client) => {
      if (getState(store, client) > clock) {
        sm.set(client, clock);
      }
    });
    getStateVector(store).forEach((_clock, client) => {
      if (!_sm.has(client)) {
        sm.set(client, 0);
      }
    });
    writeVarUint(encoder.restEncoder, sm.size);
    from(sm.entries()).sort((a2, b) => b[0] - a2[0]).forEach(([client, clock]) => {
      writeStructs(
        encoder,
        /** @type {Array<GC|Item>} */
        store.clients.get(client),
        client,
        clock
      );
    });
  };
  const writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
  class EventHandler {
    constructor() {
      this.l = [];
    }
  }
  const createEventHandler = () => new EventHandler();
  const addEventHandlerListener = (eventHandler, f) => eventHandler.l.push(f);
  const removeEventHandlerListener = (eventHandler, f) => {
    const l = eventHandler.l;
    const len = l.length;
    eventHandler.l = l.filter((g) => f !== g);
    if (len === eventHandler.l.length) {
      console.error("[yjs] Tried to remove event handler that doesn't exist.");
    }
  };
  const callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);
  class ID {
    /**
     * @param {number} client client id
     * @param {number} clock unique per client id, continuous number
     */
    constructor(client, clock) {
      this.client = client;
      this.clock = clock;
    }
  }
  const compareIDs = (a2, b) => a2 === b || a2 !== null && b !== null && a2.client === b.client && a2.clock === b.clock;
  const createID = (client, clock) => new ID(client, clock);
  const findRootTypeKey = (type) => {
    for (const [key2, value] of type.doc.share.entries()) {
      if (value === type) {
        return key2;
      }
    }
    throw unexpectedCase();
  };
  const isParentOf = (parent, child) => {
    while (child !== null) {
      if (child.parent === parent) {
        return true;
      }
      child = /** @type {AbstractType<any>} */
      child.parent._item;
    }
    return false;
  };
  class RelativePosition {
    /**
     * @param {ID|null} type
     * @param {string|null} tname
     * @param {ID|null} item
     * @param {number} assoc
     */
    constructor(type, tname, item, assoc = 0) {
      this.type = type;
      this.tname = tname;
      this.item = item;
      this.assoc = assoc;
    }
  }
  const createRelativePositionFromJSON = (json) => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
  class AbsolutePosition {
    /**
     * @param {AbstractType<any>} type
     * @param {number} index
     * @param {number} [assoc]
     */
    constructor(type, index2, assoc = 0) {
      this.type = type;
      this.index = index2;
      this.assoc = assoc;
    }
  }
  const createAbsolutePosition = (type, index2, assoc = 0) => new AbsolutePosition(type, index2, assoc);
  const createRelativePosition$1 = (type, item, assoc) => {
    let typeid = null;
    let tname = null;
    if (type._item === null) {
      tname = findRootTypeKey(type);
    } else {
      typeid = createID(type._item.id.client, type._item.id.clock);
    }
    return new RelativePosition(typeid, tname, item, assoc);
  };
  const createRelativePositionFromTypeIndex = (type, index2, assoc = 0) => {
    let t = type._start;
    if (assoc < 0) {
      if (index2 === 0) {
        return createRelativePosition$1(type, null, assoc);
      }
      index2--;
    }
    while (t !== null) {
      if (!t.deleted && t.countable) {
        if (t.length > index2) {
          return createRelativePosition$1(type, createID(t.id.client, t.id.clock + index2), assoc);
        }
        index2 -= t.length;
      }
      if (t.right === null && assoc < 0) {
        return createRelativePosition$1(type, t.lastId, assoc);
      }
      t = t.right;
    }
    return createRelativePosition$1(type, null, assoc);
  };
  const createAbsolutePositionFromRelativePosition = (rpos, doc2) => {
    const store = doc2.store;
    const rightID = rpos.item;
    const typeID = rpos.type;
    const tname = rpos.tname;
    const assoc = rpos.assoc;
    let type = null;
    let index2 = 0;
    if (rightID !== null) {
      if (getState(store, rightID.client) <= rightID.clock) {
        return null;
      }
      const res = followRedone(store, rightID);
      const right = res.item;
      if (!(right instanceof Item$1)) {
        return null;
      }
      type = /** @type {AbstractType<any>} */
      right.parent;
      if (type._item === null || !type._item.deleted) {
        index2 = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1);
        let n = right.left;
        while (n !== null) {
          if (!n.deleted && n.countable) {
            index2 += n.length;
          }
          n = n.left;
        }
      }
    } else {
      if (tname !== null) {
        type = doc2.get(tname);
      } else if (typeID !== null) {
        if (getState(store, typeID.client) <= typeID.clock) {
          return null;
        }
        const { item } = followRedone(store, typeID);
        if (item instanceof Item$1 && item.content instanceof ContentType) {
          type = item.content.type;
        } else {
          return null;
        }
      } else {
        throw unexpectedCase();
      }
      if (assoc >= 0) {
        index2 = type._length;
      } else {
        index2 = 0;
      }
    }
    return createAbsolutePosition(type, index2, rpos.assoc);
  };
  const compareRelativePositions = (a2, b) => a2 === b || a2 !== null && b !== null && a2.tname === b.tname && compareIDs(a2.item, b.item) && compareIDs(a2.type, b.type) && a2.assoc === b.assoc;
  class Snapshot {
    /**
     * @param {DeleteSet} ds
     * @param {Map<number,number>} sv state map
     */
    constructor(ds, sv) {
      this.ds = ds;
      this.sv = sv;
    }
  }
  const createSnapshot = (ds, sm) => new Snapshot(ds, sm);
  createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
  const snapshot = (doc2) => createSnapshot(createDeleteSetFromStructStore(doc2.store), getStateVector(doc2.store));
  const isVisible$1 = (item, snapshot2) => snapshot2 === void 0 ? !item.deleted : snapshot2.sv.has(item.id.client) && (snapshot2.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot2.ds, item.id);
  const splitSnapshotAffectedStructs = (transaction, snapshot2) => {
    const meta2 = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create$4);
    const store = transaction.doc.store;
    if (!meta2.has(snapshot2)) {
      snapshot2.sv.forEach((clock, client) => {
        if (clock < getState(store, client)) {
          getItemCleanStart(transaction, createID(client, clock));
        }
      });
      iterateDeletedStructs(transaction, snapshot2.ds, (_item) => {
      });
      meta2.add(snapshot2);
    }
  };
  class StructStore {
    constructor() {
      this.clients = /* @__PURE__ */ new Map();
      this.pendingStructs = null;
      this.pendingDs = null;
    }
  }
  const getStateVector = (store) => {
    const sm = /* @__PURE__ */ new Map();
    store.clients.forEach((structs, client) => {
      const struct = structs[structs.length - 1];
      sm.set(client, struct.id.clock + struct.length);
    });
    return sm;
  };
  const getState = (store, client) => {
    const structs = store.clients.get(client);
    if (structs === void 0) {
      return 0;
    }
    const lastStruct = structs[structs.length - 1];
    return lastStruct.id.clock + lastStruct.length;
  };
  const addStruct = (store, struct) => {
    let structs = store.clients.get(struct.id.client);
    if (structs === void 0) {
      structs = [];
      store.clients.set(struct.id.client, structs);
    } else {
      const lastStruct = structs[structs.length - 1];
      if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
        throw unexpectedCase();
      }
    }
    structs.push(struct);
  };
  const findIndexSS = (structs, clock) => {
    let left = 0;
    let right = structs.length - 1;
    let mid = structs[right];
    let midclock = mid.id.clock;
    if (midclock === clock) {
      return right;
    }
    let midindex = floor(clock / (midclock + mid.length - 1) * right);
    while (left <= right) {
      mid = structs[midindex];
      midclock = mid.id.clock;
      if (midclock <= clock) {
        if (clock < midclock + mid.length) {
          return midindex;
        }
        left = midindex + 1;
      } else {
        right = midindex - 1;
      }
      midindex = floor((left + right) / 2);
    }
    throw unexpectedCase();
  };
  const find$1 = (store, id) => {
    const structs = store.clients.get(id.client);
    return structs[findIndexSS(structs, id.clock)];
  };
  const getItem = (
    /** @type {function(StructStore,ID):Item} */
    find$1
  );
  const findIndexCleanStart = (transaction, structs, clock) => {
    const index2 = findIndexSS(structs, clock);
    const struct = structs[index2];
    if (struct.id.clock < clock && struct instanceof Item$1) {
      structs.splice(index2 + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
      return index2 + 1;
    }
    return index2;
  };
  const getItemCleanStart = (transaction, id) => {
    const structs = (
      /** @type {Array<Item>} */
      transaction.doc.store.clients.get(id.client)
    );
    return structs[findIndexCleanStart(transaction, structs, id.clock)];
  };
  const getItemCleanEnd = (transaction, store, id) => {
    const structs = store.clients.get(id.client);
    const index2 = findIndexSS(structs, id.clock);
    const struct = structs[index2];
    if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
      structs.splice(index2 + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));
    }
    return struct;
  };
  const replaceStruct = (store, struct, newStruct) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(struct.id.client)
    );
    structs[findIndexSS(structs, struct.id.clock)] = newStruct;
  };
  const iterateStructs = (transaction, structs, clockStart, len, f) => {
    if (len === 0) {
      return;
    }
    const clockEnd = clockStart + len;
    let index2 = findIndexCleanStart(transaction, structs, clockStart);
    let struct;
    do {
      struct = structs[index2++];
      if (clockEnd < struct.id.clock + struct.length) {
        findIndexCleanStart(transaction, structs, clockEnd);
      }
      f(struct);
    } while (index2 < structs.length && structs[index2].id.clock < clockEnd);
  };
  class Transaction {
    /**
     * @param {Doc} doc
     * @param {any} origin
     * @param {boolean} local
     */
    constructor(doc2, origin, local) {
      this.doc = doc2;
      this.deleteSet = new DeleteSet();
      this.beforeState = getStateVector(doc2.store);
      this.afterState = /* @__PURE__ */ new Map();
      this.changed = /* @__PURE__ */ new Map();
      this.changedParentTypes = /* @__PURE__ */ new Map();
      this._mergeStructs = [];
      this.origin = origin;
      this.meta = /* @__PURE__ */ new Map();
      this.local = local;
      this.subdocsAdded = /* @__PURE__ */ new Set();
      this.subdocsRemoved = /* @__PURE__ */ new Set();
      this.subdocsLoaded = /* @__PURE__ */ new Set();
      this._needFormattingCleanup = false;
    }
  }
  const writeUpdateMessageFromTransaction = (encoder, transaction) => {
    if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
      return false;
    }
    sortAndMergeDeleteSet(transaction.deleteSet);
    writeStructsFromTransaction(encoder, transaction);
    writeDeleteSet(encoder, transaction.deleteSet);
    return true;
  };
  const addChangedTypeToTransaction = (transaction, type, parentSub) => {
    const item = type._item;
    if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
      setIfUndefined(transaction.changed, type, create$4).add(parentSub);
    }
  };
  const tryToMergeWithLefts = (structs, pos) => {
    let right = structs[pos];
    let left = structs[pos - 1];
    let i2 = pos;
    for (; i2 > 0; right = left, left = structs[--i2 - 1]) {
      if (left.deleted === right.deleted && left.constructor === right.constructor) {
        if (left.mergeWith(right)) {
          if (right instanceof Item$1 && right.parentSub !== null && /** @type {AbstractType<any>} */
          right.parent._map.get(right.parentSub) === right) {
            right.parent._map.set(
              right.parentSub,
              /** @type {Item} */
              left
            );
          }
          continue;
        }
      }
      break;
    }
    const merged = pos - i2;
    if (merged) {
      structs.splice(pos + 1 - merged, merged);
    }
    return merged;
  };
  const tryGcDeleteSet = (ds, store, gcFilter) => {
    for (const [client, deleteItems] of ds.clients.entries()) {
      const structs = (
        /** @type {Array<GC|Item>} */
        store.clients.get(client)
      );
      for (let di = deleteItems.length - 1; di >= 0; di--) {
        const deleteItem = deleteItems[di];
        const endDeleteItemClock = deleteItem.clock + deleteItem.len;
        for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
          const struct2 = structs[si];
          if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
            break;
          }
          if (struct2 instanceof Item$1 && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
            struct2.gc(store, false);
          }
        }
      }
    }
  };
  const tryMergeDeleteSet = (ds, store) => {
    ds.clients.forEach((deleteItems, client) => {
      const structs = (
        /** @type {Array<GC|Item>} */
        store.clients.get(client)
      );
      for (let di = deleteItems.length - 1; di >= 0; di--) {
        const deleteItem = deleteItems[di];
        const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
        for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {
          si -= 1 + tryToMergeWithLefts(structs, si);
        }
      }
    });
  };
  const cleanupTransactions = (transactionCleanups, i2) => {
    if (i2 < transactionCleanups.length) {
      const transaction = transactionCleanups[i2];
      const doc2 = transaction.doc;
      const store = doc2.store;
      const ds = transaction.deleteSet;
      const mergeStructs = transaction._mergeStructs;
      try {
        sortAndMergeDeleteSet(ds);
        transaction.afterState = getStateVector(transaction.doc.store);
        doc2.emit("beforeObserverCalls", [transaction, doc2]);
        const fs = [];
        transaction.changed.forEach(
          (subs, itemtype) => fs.push(() => {
            if (itemtype._item === null || !itemtype._item.deleted) {
              itemtype._callObserver(transaction, subs);
            }
          })
        );
        fs.push(() => {
          transaction.changedParentTypes.forEach((events, type) => {
            if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
              events = events.filter(
                (event) => event.target._item === null || !event.target._item.deleted
              );
              events.forEach((event) => {
                event.currentTarget = type;
                event._path = null;
              });
              events.sort((event1, event2) => event1.path.length - event2.path.length);
              callEventHandlerListeners(type._dEH, events, transaction);
            }
          });
        });
        fs.push(() => doc2.emit("afterTransaction", [transaction, doc2]));
        callAll(fs, []);
        if (transaction._needFormattingCleanup) {
          cleanupYTextAfterTransaction(transaction);
        }
      } finally {
        if (doc2.gc) {
          tryGcDeleteSet(ds, store, doc2.gcFilter);
        }
        tryMergeDeleteSet(ds, store);
        transaction.afterState.forEach((clock, client) => {
          const beforeClock = transaction.beforeState.get(client) || 0;
          if (beforeClock !== clock) {
            const structs = (
              /** @type {Array<GC|Item>} */
              store.clients.get(client)
            );
            const firstChangePos = max(findIndexSS(structs, beforeClock), 1);
            for (let i3 = structs.length - 1; i3 >= firstChangePos; ) {
              i3 -= 1 + tryToMergeWithLefts(structs, i3);
            }
          }
        });
        for (let i3 = mergeStructs.length - 1; i3 >= 0; i3--) {
          const { client, clock } = mergeStructs[i3].id;
          const structs = (
            /** @type {Array<GC|Item>} */
            store.clients.get(client)
          );
          const replacedStructPos = findIndexSS(structs, clock);
          if (replacedStructPos + 1 < structs.length) {
            if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
              continue;
            }
          }
          if (replacedStructPos > 0) {
            tryToMergeWithLefts(structs, replacedStructPos);
          }
        }
        if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {
          print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
          doc2.clientID = generateNewClientId();
        }
        doc2.emit("afterTransactionCleanup", [transaction, doc2]);
        if (doc2._observers.has("update")) {
          const encoder = new UpdateEncoderV1();
          const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);
          if (hasContent) {
            doc2.emit("update", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
          }
        }
        if (doc2._observers.has("updateV2")) {
          const encoder = new UpdateEncoderV2();
          const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);
          if (hasContent) {
            doc2.emit("updateV2", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
          }
        }
        const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
        if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
          subdocsAdded.forEach((subdoc) => {
            subdoc.clientID = doc2.clientID;
            if (subdoc.collectionid == null) {
              subdoc.collectionid = doc2.collectionid;
            }
            doc2.subdocs.add(subdoc);
          });
          subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));
          doc2.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);
          subdocsRemoved.forEach((subdoc) => subdoc.destroy());
        }
        if (transactionCleanups.length <= i2 + 1) {
          doc2._transactionCleanups = [];
          doc2.emit("afterAllTransactions", [doc2, transactionCleanups]);
        } else {
          cleanupTransactions(transactionCleanups, i2 + 1);
        }
      }
    }
  };
  const transact = (doc2, f, origin = null, local = true) => {
    const transactionCleanups = doc2._transactionCleanups;
    let initialCall = false;
    let result = null;
    if (doc2._transaction === null) {
      initialCall = true;
      doc2._transaction = new Transaction(doc2, origin, local);
      transactionCleanups.push(doc2._transaction);
      if (transactionCleanups.length === 1) {
        doc2.emit("beforeAllTransactions", [doc2]);
      }
      doc2.emit("beforeTransaction", [doc2._transaction, doc2]);
    }
    try {
      result = f(doc2._transaction);
    } finally {
      if (initialCall) {
        const finishCleanup = doc2._transaction === transactionCleanups[0];
        doc2._transaction = null;
        if (finishCleanup) {
          cleanupTransactions(transactionCleanups, 0);
        }
      }
    }
    return result;
  };
  class StackItem {
    /**
     * @param {DeleteSet} deletions
     * @param {DeleteSet} insertions
     */
    constructor(deletions, insertions) {
      this.insertions = insertions;
      this.deletions = deletions;
      this.meta = /* @__PURE__ */ new Map();
    }
  }
  const clearUndoManagerStackItem = (tr2, um, stackItem) => {
    iterateDeletedStructs(tr2, stackItem.deletions, (item) => {
      if (item instanceof Item$1 && um.scope.some((type) => isParentOf(type, item))) {
        keepItem(item, false);
      }
    });
  };
  const popStackItem = (undoManager, stack, eventType) => {
    let _tr = null;
    const doc2 = undoManager.doc;
    const scope = undoManager.scope;
    transact(doc2, (transaction) => {
      while (stack.length > 0 && undoManager.currStackItem === null) {
        const store = doc2.store;
        const stackItem = (
          /** @type {StackItem} */
          stack.pop()
        );
        const itemsToRedo = /* @__PURE__ */ new Set();
        const itemsToDelete = [];
        let performedChange = false;
        iterateDeletedStructs(transaction, stackItem.insertions, (struct) => {
          if (struct instanceof Item$1) {
            if (struct.redone !== null) {
              let { item, diff } = followRedone(store, struct.id);
              if (diff > 0) {
                item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));
              }
              struct = item;
            }
            if (!struct.deleted && scope.some((type) => isParentOf(
              type,
              /** @type {Item} */
              struct
            ))) {
              itemsToDelete.push(struct);
            }
          }
        });
        iterateDeletedStructs(transaction, stackItem.deletions, (struct) => {
          if (struct instanceof Item$1 && scope.some((type) => isParentOf(type, struct)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
          !isDeleted(stackItem.insertions, struct.id)) {
            itemsToRedo.add(struct);
          }
        });
        itemsToRedo.forEach((struct) => {
          performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;
        });
        for (let i2 = itemsToDelete.length - 1; i2 >= 0; i2--) {
          const item = itemsToDelete[i2];
          if (undoManager.deleteFilter(item)) {
            item.delete(transaction);
            performedChange = true;
          }
        }
        undoManager.currStackItem = performedChange ? stackItem : null;
      }
      transaction.changed.forEach((subProps, type) => {
        if (subProps.has(null) && type._searchMarker) {
          type._searchMarker.length = 0;
        }
      });
      _tr = transaction;
    }, undoManager);
    if (undoManager.currStackItem != null) {
      const changedParentTypes = _tr.changedParentTypes;
      undoManager.emit("stack-item-popped", [{ stackItem: undoManager.currStackItem, type: eventType, changedParentTypes, origin: undoManager }, undoManager]);
      undoManager.currStackItem = null;
    }
    return undoManager.currStackItem;
  };
  class UndoManager extends ObservableV2 {
    /**
     * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types
     * @param {UndoManagerOptions} options
     */
    constructor(typeScope, {
      captureTimeout = 500,
      captureTransaction = (_tr) => true,
      deleteFilter = () => true,
      trackedOrigins = /* @__PURE__ */ new Set([null]),
      ignoreRemoteMapChanges = false,
      doc: doc2 = (
        /** @type {Doc} */
        isArray(typeScope) ? typeScope[0].doc : typeScope.doc
      )
    } = {}) {
      super();
      this.scope = [];
      this.doc = doc2;
      this.addToScope(typeScope);
      this.deleteFilter = deleteFilter;
      trackedOrigins.add(this);
      this.trackedOrigins = trackedOrigins;
      this.captureTransaction = captureTransaction;
      this.undoStack = [];
      this.redoStack = [];
      this.undoing = false;
      this.redoing = false;
      this.currStackItem = null;
      this.lastChange = 0;
      this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
      this.captureTimeout = captureTimeout;
      this.afterTransactionHandler = (transaction) => {
        if (!this.captureTransaction(transaction) || !this.scope.some((type) => transaction.changedParentTypes.has(type)) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {
          return;
        }
        const undoing = this.undoing;
        const redoing = this.redoing;
        const stack = undoing ? this.redoStack : this.undoStack;
        if (undoing) {
          this.stopCapturing();
        } else if (!redoing) {
          this.clear(false, true);
        }
        const insertions = new DeleteSet();
        transaction.afterState.forEach((endClock, client) => {
          const startClock = transaction.beforeState.get(client) || 0;
          const len = endClock - startClock;
          if (len > 0) {
            addToDeleteSet(insertions, client, startClock, len);
          }
        });
        const now = getUnixTime();
        let didAdd = false;
        if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
          const lastOp = stack[stack.length - 1];
          lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);
          lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);
        } else {
          stack.push(new StackItem(transaction.deleteSet, insertions));
          didAdd = true;
        }
        if (!undoing && !redoing) {
          this.lastChange = now;
        }
        iterateDeletedStructs(
          transaction,
          transaction.deleteSet,
          /** @param {Item|GC} item */
          (item) => {
            if (item instanceof Item$1 && this.scope.some((type) => isParentOf(type, item))) {
              keepItem(item, true);
            }
          }
        );
        const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? "redo" : "undo", changedParentTypes: transaction.changedParentTypes }, this];
        if (didAdd) {
          this.emit("stack-item-added", changeEvent);
        } else {
          this.emit("stack-item-updated", changeEvent);
        }
      };
      this.doc.on("afterTransaction", this.afterTransactionHandler);
      this.doc.on("destroy", () => {
        this.destroy();
      });
    }
    /**
     * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes
     */
    addToScope(ytypes) {
      ytypes = isArray(ytypes) ? ytypes : [ytypes];
      ytypes.forEach((ytype) => {
        if (this.scope.every((yt) => yt !== ytype)) {
          if (ytype.doc !== this.doc)
            warn$1("[yjs#509] Not same Y.Doc");
          this.scope.push(ytype);
        }
      });
    }
    /**
     * @param {any} origin
     */
    addTrackedOrigin(origin) {
      this.trackedOrigins.add(origin);
    }
    /**
     * @param {any} origin
     */
    removeTrackedOrigin(origin) {
      this.trackedOrigins.delete(origin);
    }
    clear(clearUndoStack = true, clearRedoStack = true) {
      if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {
        this.doc.transact((tr2) => {
          if (clearUndoStack) {
            this.undoStack.forEach((item) => clearUndoManagerStackItem(tr2, this, item));
            this.undoStack = [];
          }
          if (clearRedoStack) {
            this.redoStack.forEach((item) => clearUndoManagerStackItem(tr2, this, item));
            this.redoStack = [];
          }
          this.emit("stack-cleared", [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);
        });
      }
    }
    /**
     * UndoManager merges Undo-StackItem if they are created within time-gap
     * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
     * StackItem won't be merged.
     *
     *
     * @example
     *     // without stopCapturing
     *     ytext.insert(0, 'a')
     *     ytext.insert(1, 'b')
     *     um.undo()
     *     ytext.toString() // => '' (note that 'ab' was removed)
     *     // with stopCapturing
     *     ytext.insert(0, 'a')
     *     um.stopCapturing()
     *     ytext.insert(0, 'b')
     *     um.undo()
     *     ytext.toString() // => 'a' (note that only 'b' was removed)
     *
     */
    stopCapturing() {
      this.lastChange = 0;
    }
    /**
     * Undo last changes on type.
     *
     * @return {StackItem?} Returns StackItem if a change was applied
     */
    undo() {
      this.undoing = true;
      let res;
      try {
        res = popStackItem(this, this.undoStack, "undo");
      } finally {
        this.undoing = false;
      }
      return res;
    }
    /**
     * Redo last undo operation.
     *
     * @return {StackItem?} Returns StackItem if a change was applied
     */
    redo() {
      this.redoing = true;
      let res;
      try {
        res = popStackItem(this, this.redoStack, "redo");
      } finally {
        this.redoing = false;
      }
      return res;
    }
    /**
     * Are undo steps available?
     *
     * @return {boolean} `true` if undo is possible
     */
    canUndo() {
      return this.undoStack.length > 0;
    }
    /**
     * Are redo steps available?
     *
     * @return {boolean} `true` if redo is possible
     */
    canRedo() {
      return this.redoStack.length > 0;
    }
    destroy() {
      this.trackedOrigins.delete(this);
      this.doc.off("afterTransaction", this.afterTransactionHandler);
      super.destroy();
    }
  }
  const errorComputeChanges = "You must not compute changes after the event-handler fired.";
  class YEvent {
    /**
     * @param {T} target The changed type.
     * @param {Transaction} transaction
     */
    constructor(target, transaction) {
      this.target = target;
      this.currentTarget = target;
      this.transaction = transaction;
      this._changes = null;
      this._keys = null;
      this._delta = null;
      this._path = null;
    }
    /**
     * Computes the path from `y` to the changed type.
     *
     * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
     *
     * The following property holds:
     * @example
     *   let type = y
     *   event.path.forEach(dir => {
     *     type = type.get(dir)
     *   })
     *   type === event.target // => true
     */
    get path() {
      return this._path || (this._path = getPathTo(this.currentTarget, this.target));
    }
    /**
     * Check if a struct is deleted by this event.
     *
     * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
     *
     * @param {AbstractStruct} struct
     * @return {boolean}
     */
    deletes(struct) {
      return isDeleted(this.transaction.deleteSet, struct.id);
    }
    /**
     * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
     */
    get keys() {
      if (this._keys === null) {
        if (this.transaction.doc._transactionCleanups.length === 0) {
          throw create$3(errorComputeChanges);
        }
        const keys2 = /* @__PURE__ */ new Map();
        const target = this.target;
        const changed = (
          /** @type Set<string|null> */
          this.transaction.changed.get(target)
        );
        changed.forEach((key2) => {
          if (key2 !== null) {
            const item = (
              /** @type {Item} */
              target._map.get(key2)
            );
            let action;
            let oldValue;
            if (this.adds(item)) {
              let prev = item.left;
              while (prev !== null && this.adds(prev)) {
                prev = prev.left;
              }
              if (this.deletes(item)) {
                if (prev !== null && this.deletes(prev)) {
                  action = "delete";
                  oldValue = last(prev.content.getContent());
                } else {
                  return;
                }
              } else {
                if (prev !== null && this.deletes(prev)) {
                  action = "update";
                  oldValue = last(prev.content.getContent());
                } else {
                  action = "add";
                  oldValue = void 0;
                }
              }
            } else {
              if (this.deletes(item)) {
                action = "delete";
                oldValue = last(
                  /** @type {Item} */
                  item.content.getContent()
                );
              } else {
                return;
              }
            }
            keys2.set(key2, { action, oldValue });
          }
        });
        this._keys = keys2;
      }
      return this._keys;
    }
    /**
     * This is a computed property. Note that this can only be safely computed during the
     * event call. Computing this property after other changes happened might result in
     * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
     * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
     *
     * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
     */
    get delta() {
      return this.changes.delta;
    }
    /**
     * Check if a struct is added by this event.
     *
     * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
     *
     * @param {AbstractStruct} struct
     * @return {boolean}
     */
    adds(struct) {
      return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
    }
    /**
     * This is a computed property. Note that this can only be safely computed during the
     * event call. Computing this property after other changes happened might result in
     * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
     * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
     *
     * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
     */
    get changes() {
      let changes = this._changes;
      if (changes === null) {
        if (this.transaction.doc._transactionCleanups.length === 0) {
          throw create$3(errorComputeChanges);
        }
        const target = this.target;
        const added = create$4();
        const deleted = create$4();
        const delta = [];
        changes = {
          added,
          deleted,
          delta,
          keys: this.keys
        };
        const changed = (
          /** @type Set<string|null> */
          this.transaction.changed.get(target)
        );
        if (changed.has(null)) {
          let lastOp = null;
          const packOp = () => {
            if (lastOp) {
              delta.push(lastOp);
            }
          };
          for (let item = target._start; item !== null; item = item.right) {
            if (item.deleted) {
              if (this.deletes(item) && !this.adds(item)) {
                if (lastOp === null || lastOp.delete === void 0) {
                  packOp();
                  lastOp = { delete: 0 };
                }
                lastOp.delete += item.length;
                deleted.add(item);
              }
            } else {
              if (this.adds(item)) {
                if (lastOp === null || lastOp.insert === void 0) {
                  packOp();
                  lastOp = { insert: [] };
                }
                lastOp.insert = lastOp.insert.concat(item.content.getContent());
                added.add(item);
              } else {
                if (lastOp === null || lastOp.retain === void 0) {
                  packOp();
                  lastOp = { retain: 0 };
                }
                lastOp.retain += item.length;
              }
            }
          }
          if (lastOp !== null && lastOp.retain === void 0) {
            packOp();
          }
        }
        this._changes = changes;
      }
      return (
        /** @type {any} */
        changes
      );
    }
  }
  const getPathTo = (parent, child) => {
    const path2 = [];
    while (child._item !== null && child !== parent) {
      if (child._item.parentSub !== null) {
        path2.unshift(child._item.parentSub);
      } else {
        let i2 = 0;
        let c = (
          /** @type {AbstractType<any>} */
          child._item.parent._start
        );
        while (c !== child._item && c !== null) {
          if (!c.deleted) {
            i2++;
          }
          c = c.right;
        }
        path2.unshift(i2);
      }
      child = /** @type {AbstractType<any>} */
      child._item.parent;
    }
    return path2;
  };
  const maxSearchMarker = 80;
  let globalSearchMarkerTimestamp = 0;
  class ArraySearchMarker {
    /**
     * @param {Item} p
     * @param {number} index
     */
    constructor(p2, index2) {
      p2.marker = true;
      this.p = p2;
      this.index = index2;
      this.timestamp = globalSearchMarkerTimestamp++;
    }
  }
  const refreshMarkerTimestamp = (marker) => {
    marker.timestamp = globalSearchMarkerTimestamp++;
  };
  const overwriteMarker = (marker, p2, index2) => {
    marker.p.marker = false;
    marker.p = p2;
    p2.marker = true;
    marker.index = index2;
    marker.timestamp = globalSearchMarkerTimestamp++;
  };
  const markPosition = (searchMarker, p2, index2) => {
    if (searchMarker.length >= maxSearchMarker) {
      const marker = searchMarker.reduce((a2, b) => a2.timestamp < b.timestamp ? a2 : b);
      overwriteMarker(marker, p2, index2);
      return marker;
    } else {
      const pm = new ArraySearchMarker(p2, index2);
      searchMarker.push(pm);
      return pm;
    }
  };
  const findMarker = (yarray, index2) => {
    if (yarray._start === null || index2 === 0 || yarray._searchMarker === null) {
      return null;
    }
    const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a2, b) => abs(index2 - a2.index) < abs(index2 - b.index) ? a2 : b);
    let p2 = yarray._start;
    let pindex = 0;
    if (marker !== null) {
      p2 = marker.p;
      pindex = marker.index;
      refreshMarkerTimestamp(marker);
    }
    while (p2.right !== null && pindex < index2) {
      if (!p2.deleted && p2.countable) {
        if (index2 < pindex + p2.length) {
          break;
        }
        pindex += p2.length;
      }
      p2 = p2.right;
    }
    while (p2.left !== null && pindex > index2) {
      p2 = p2.left;
      if (!p2.deleted && p2.countable) {
        pindex -= p2.length;
      }
    }
    while (p2.left !== null && p2.left.id.client === p2.id.client && p2.left.id.clock + p2.left.length === p2.id.clock) {
      p2 = p2.left;
      if (!p2.deleted && p2.countable) {
        pindex -= p2.length;
      }
    }
    if (marker !== null && abs(marker.index - pindex) < /** @type {YText|YArray<any>} */
    p2.parent.length / maxSearchMarker) {
      overwriteMarker(marker, p2, pindex);
      return marker;
    } else {
      return markPosition(yarray._searchMarker, p2, pindex);
    }
  };
  const updateMarkerChanges = (searchMarker, index2, len) => {
    for (let i2 = searchMarker.length - 1; i2 >= 0; i2--) {
      const m = searchMarker[i2];
      if (len > 0) {
        let p2 = m.p;
        p2.marker = false;
        while (p2 && (p2.deleted || !p2.countable)) {
          p2 = p2.left;
          if (p2 && !p2.deleted && p2.countable) {
            m.index -= p2.length;
          }
        }
        if (p2 === null || p2.marker === true) {
          searchMarker.splice(i2, 1);
          continue;
        }
        m.p = p2;
        p2.marker = true;
      }
      if (index2 < m.index || len > 0 && index2 === m.index) {
        m.index = max(index2, m.index + len);
      }
    }
  };
  const callTypeObservers = (type, transaction, event) => {
    const changedType = type;
    const changedParentTypes = transaction.changedParentTypes;
    while (true) {
      setIfUndefined(changedParentTypes, type, () => []).push(event);
      if (type._item === null) {
        break;
      }
      type = /** @type {AbstractType<any>} */
      type._item.parent;
    }
    callEventHandlerListeners(changedType._eH, event, transaction);
  };
  class AbstractType {
    constructor() {
      this._item = null;
      this._map = /* @__PURE__ */ new Map();
      this._start = null;
      this.doc = null;
      this._length = 0;
      this._eH = createEventHandler();
      this._dEH = createEventHandler();
      this._searchMarker = null;
    }
    /**
     * @return {AbstractType<any>|null}
     */
    get parent() {
      return this._item ? (
        /** @type {AbstractType<any>} */
        this._item.parent
      ) : null;
    }
    /**
     * Integrate this type into the Yjs instance.
     *
     * * Save this struct in the os
     * * This type is sent to other client
     * * Observer functions are fired
     *
     * @param {Doc} y The Yjs instance
     * @param {Item|null} item
     */
    _integrate(y, item) {
      this.doc = y;
      this._item = item;
    }
    /**
     * @return {AbstractType<EventType>}
     */
    _copy() {
      throw methodUnimplemented();
    }
    /**
     * @return {AbstractType<EventType>}
     */
    clone() {
      throw methodUnimplemented();
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
     */
    _write(_encoder) {
    }
    /**
     * The first non-deleted item
     */
    get _first() {
      let n = this._start;
      while (n !== null && n.deleted) {
        n = n.right;
      }
      return n;
    }
    /**
     * Creates YEvent and calls all type observers.
     * Must be implemented by each type.
     *
     * @param {Transaction} transaction
     * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
     */
    _callObserver(transaction, _parentSubs) {
      if (!transaction.local && this._searchMarker) {
        this._searchMarker.length = 0;
      }
    }
    /**
     * Observe all events that are created on this type.
     *
     * @param {function(EventType, Transaction):void} f Observer function
     */
    observe(f) {
      addEventHandlerListener(this._eH, f);
    }
    /**
     * Observe all events that are created by this type and its children.
     *
     * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
     */
    observeDeep(f) {
      addEventHandlerListener(this._dEH, f);
    }
    /**
     * Unregister an observer function.
     *
     * @param {function(EventType,Transaction):void} f Observer function
     */
    unobserve(f) {
      removeEventHandlerListener(this._eH, f);
    }
    /**
     * Unregister an observer function.
     *
     * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
     */
    unobserveDeep(f) {
      removeEventHandlerListener(this._dEH, f);
    }
    /**
     * @abstract
     * @return {any}
     */
    toJSON() {
    }
  }
  const typeListSlice = (type, start, end) => {
    if (start < 0) {
      start = type._length + start;
    }
    if (end < 0) {
      end = type._length + end;
    }
    let len = end - start;
    const cs = [];
    let n = type._start;
    while (n !== null && len > 0) {
      if (n.countable && !n.deleted) {
        const c = n.content.getContent();
        if (c.length <= start) {
          start -= c.length;
        } else {
          for (let i2 = start; i2 < c.length && len > 0; i2++) {
            cs.push(c[i2]);
            len--;
          }
          start = 0;
        }
      }
      n = n.right;
    }
    return cs;
  };
  const typeListToArray = (type) => {
    const cs = [];
    let n = type._start;
    while (n !== null) {
      if (n.countable && !n.deleted) {
        const c = n.content.getContent();
        for (let i2 = 0; i2 < c.length; i2++) {
          cs.push(c[i2]);
        }
      }
      n = n.right;
    }
    return cs;
  };
  const typeListToArraySnapshot = (type, snapshot2) => {
    const cs = [];
    let n = type._start;
    while (n !== null) {
      if (n.countable && isVisible$1(n, snapshot2)) {
        const c = n.content.getContent();
        for (let i2 = 0; i2 < c.length; i2++) {
          cs.push(c[i2]);
        }
      }
      n = n.right;
    }
    return cs;
  };
  const typeListForEach = (type, f) => {
    let index2 = 0;
    let n = type._start;
    while (n !== null) {
      if (n.countable && !n.deleted) {
        const c = n.content.getContent();
        for (let i2 = 0; i2 < c.length; i2++) {
          f(c[i2], index2++, type);
        }
      }
      n = n.right;
    }
  };
  const typeListMap = (type, f) => {
    const result = [];
    typeListForEach(type, (c, i2) => {
      result.push(f(c, i2, type));
    });
    return result;
  };
  const typeListCreateIterator = (type) => {
    let n = type._start;
    let currentContent = null;
    let currentContentIndex = 0;
    return {
      [Symbol.iterator]() {
        return this;
      },
      next: () => {
        if (currentContent === null) {
          while (n !== null && n.deleted) {
            n = n.right;
          }
          if (n === null) {
            return {
              done: true,
              value: void 0
            };
          }
          currentContent = n.content.getContent();
          currentContentIndex = 0;
          n = n.right;
        }
        const value = currentContent[currentContentIndex++];
        if (currentContent.length <= currentContentIndex) {
          currentContent = null;
        }
        return {
          done: false,
          value
        };
      }
    };
  };
  const typeListGet = (type, index2) => {
    const marker = findMarker(type, index2);
    let n = type._start;
    if (marker !== null) {
      n = marker.p;
      index2 -= marker.index;
    }
    for (; n !== null; n = n.right) {
      if (!n.deleted && n.countable) {
        if (index2 < n.length) {
          return n.content.getContent()[index2];
        }
        index2 -= n.length;
      }
    }
  };
  const typeListInsertGenericsAfter = (transaction, parent, referenceItem, content2) => {
    let left = referenceItem;
    const doc2 = transaction.doc;
    const ownClientId = doc2.clientID;
    const store = doc2.store;
    const right = referenceItem === null ? parent._start : referenceItem.right;
    let jsonContent = [];
    const packJsonContent = () => {
      if (jsonContent.length > 0) {
        left = new Item$1(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
        left.integrate(transaction, 0);
        jsonContent = [];
      }
    };
    content2.forEach((c) => {
      if (c === null) {
        jsonContent.push(c);
      } else {
        switch (c.constructor) {
          case Number:
          case Object:
          case Boolean:
          case Array:
          case String:
            jsonContent.push(c);
            break;
          default:
            packJsonContent();
            switch (c.constructor) {
              case Uint8Array:
              case ArrayBuffer:
                left = new Item$1(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(
                  /** @type {Uint8Array} */
                  c
                )));
                left.integrate(transaction, 0);
                break;
              case Doc$1:
                left = new Item$1(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(
                  /** @type {Doc} */
                  c
                ));
                left.integrate(transaction, 0);
                break;
              default:
                if (c instanceof AbstractType) {
                  left = new Item$1(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));
                  left.integrate(transaction, 0);
                } else {
                  throw new Error("Unexpected content type in insert operation");
                }
            }
        }
      }
    });
    packJsonContent();
  };
  const lengthExceeded = () => create$3("Length exceeded!");
  const typeListInsertGenerics = (transaction, parent, index2, content2) => {
    if (index2 > parent._length) {
      throw lengthExceeded();
    }
    if (index2 === 0) {
      if (parent._searchMarker) {
        updateMarkerChanges(parent._searchMarker, index2, content2.length);
      }
      return typeListInsertGenericsAfter(transaction, parent, null, content2);
    }
    const startIndex = index2;
    const marker = findMarker(parent, index2);
    let n = parent._start;
    if (marker !== null) {
      n = marker.p;
      index2 -= marker.index;
      if (index2 === 0) {
        n = n.prev;
        index2 += n && n.countable && !n.deleted ? n.length : 0;
      }
    }
    for (; n !== null; n = n.right) {
      if (!n.deleted && n.countable) {
        if (index2 <= n.length) {
          if (index2 < n.length) {
            getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index2));
          }
          break;
        }
        index2 -= n.length;
      }
    }
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, startIndex, content2.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, n, content2);
  };
  const typeListPushGenerics = (transaction, parent, content2) => {
    const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
    let n = marker.p;
    if (n) {
      while (n.right) {
        n = n.right;
      }
    }
    return typeListInsertGenericsAfter(transaction, parent, n, content2);
  };
  const typeListDelete = (transaction, parent, index2, length2) => {
    if (length2 === 0) {
      return;
    }
    const startIndex = index2;
    const startLength = length2;
    const marker = findMarker(parent, index2);
    let n = parent._start;
    if (marker !== null) {
      n = marker.p;
      index2 -= marker.index;
    }
    for (; n !== null && index2 > 0; n = n.right) {
      if (!n.deleted && n.countable) {
        if (index2 < n.length) {
          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index2));
        }
        index2 -= n.length;
      }
    }
    while (length2 > 0 && n !== null) {
      if (!n.deleted) {
        if (length2 < n.length) {
          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length2));
        }
        n.delete(transaction);
        length2 -= n.length;
      }
      n = n.right;
    }
    if (length2 > 0) {
      throw lengthExceeded();
    }
    if (parent._searchMarker) {
      updateMarkerChanges(
        parent._searchMarker,
        startIndex,
        -startLength + length2
        /* in case we remove the above exception */
      );
    }
  };
  const typeMapDelete = (transaction, parent, key2) => {
    const c = parent._map.get(key2);
    if (c !== void 0) {
      c.delete(transaction);
    }
  };
  const typeMapSet = (transaction, parent, key2, value) => {
    const left = parent._map.get(key2) || null;
    const doc2 = transaction.doc;
    const ownClientId = doc2.clientID;
    let content2;
    if (value == null) {
      content2 = new ContentAny([value]);
    } else {
      switch (value.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          content2 = new ContentAny([value]);
          break;
        case Uint8Array:
          content2 = new ContentBinary(
            /** @type {Uint8Array} */
            value
          );
          break;
        case Doc$1:
          content2 = new ContentDoc(
            /** @type {Doc} */
            value
          );
          break;
        default:
          if (value instanceof AbstractType) {
            content2 = new ContentType(value);
          } else {
            throw new Error("Unexpected content type");
          }
      }
    }
    new Item$1(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key2, content2).integrate(transaction, 0);
  };
  const typeMapGet = (parent, key2) => {
    const val = parent._map.get(key2);
    return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
  };
  const typeMapGetAll = (parent) => {
    const res = {};
    parent._map.forEach((value, key2) => {
      if (!value.deleted) {
        res[key2] = value.content.getContent()[value.length - 1];
      }
    });
    return res;
  };
  const typeMapHas = (parent, key2) => {
    const val = parent._map.get(key2);
    return val !== void 0 && !val.deleted;
  };
  const typeMapGetAllSnapshot = (parent, snapshot2) => {
    const res = {};
    parent._map.forEach((value, key2) => {
      let v = value;
      while (v !== null && (!snapshot2.sv.has(v.id.client) || v.id.clock >= (snapshot2.sv.get(v.id.client) || 0))) {
        v = v.left;
      }
      if (v !== null && isVisible$1(v, snapshot2)) {
        res[key2] = v.content.getContent()[v.length - 1];
      }
    });
    return res;
  };
  const createMapIterator = (map2) => iteratorFilter(
    map2.entries(),
    /** @param {any} entry */
    (entry) => !entry[1].deleted
  );
  class YArrayEvent extends YEvent {
    /**
     * @param {YArray<T>} yarray The changed type
     * @param {Transaction} transaction The transaction object
     */
    constructor(yarray, transaction) {
      super(yarray, transaction);
      this._transaction = transaction;
    }
  }
  class YArray extends AbstractType {
    constructor() {
      super();
      this._prelimContent = [];
      this._searchMarker = [];
    }
    /**
     * Construct a new YArray containing the specified items.
     * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
     * @param {Array<T>} items
     * @return {YArray<T>}
     */
    static from(items) {
      const a2 = new YArray();
      a2.push(items);
      return a2;
    }
    /**
     * Integrate this type into the Yjs instance.
     *
     * * Save this struct in the os
     * * This type is sent to other client
     * * Observer functions are fired
     *
     * @param {Doc} y The Yjs instance
     * @param {Item} item
     */
    _integrate(y, item) {
      super._integrate(y, item);
      this.insert(
        0,
        /** @type {Array<any>} */
        this._prelimContent
      );
      this._prelimContent = null;
    }
    /**
     * @return {YArray<T>}
     */
    _copy() {
      return new YArray();
    }
    /**
     * @return {YArray<T>}
     */
    clone() {
      const arr = new YArray();
      arr.insert(0, this.toArray().map(
        (el) => el instanceof AbstractType ? (
          /** @type {typeof el} */
          el.clone()
        ) : el
      ));
      return arr;
    }
    get length() {
      return this._prelimContent === null ? this._length : this._prelimContent.length;
    }
    /**
     * Creates YArrayEvent and calls observers.
     *
     * @param {Transaction} transaction
     * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
     */
    _callObserver(transaction, parentSubs) {
      super._callObserver(transaction, parentSubs);
      callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
    }
    /**
     * Inserts new content at an index.
     *
     * Important: This function expects an array of content. Not just a content
     * object. The reason for this "weirdness" is that inserting several elements
     * is very efficient when it is done as a single operation.
     *
     * @example
     *  // Insert character 'a' at position 0
     *  yarray.insert(0, ['a'])
     *  // Insert numbers 1, 2 at position 1
     *  yarray.insert(1, [1, 2])
     *
     * @param {number} index The index to insert content at.
     * @param {Array<T>} content The array of content
     */
    insert(index2, content2) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeListInsertGenerics(
            transaction,
            this,
            index2,
            /** @type {any} */
            content2
          );
        });
      } else {
        this._prelimContent.splice(index2, 0, ...content2);
      }
    }
    /**
     * Appends content to this YArray.
     *
     * @param {Array<T>} content Array of content to append.
     *
     * @todo Use the following implementation in all types.
     */
    push(content2) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeListPushGenerics(
            transaction,
            this,
            /** @type {any} */
            content2
          );
        });
      } else {
        this._prelimContent.push(...content2);
      }
    }
    /**
     * Preppends content to this YArray.
     *
     * @param {Array<T>} content Array of content to preppend.
     */
    unshift(content2) {
      this.insert(0, content2);
    }
    /**
     * Deletes elements starting from an index.
     *
     * @param {number} index Index at which to start deleting elements
     * @param {number} length The number of elements to remove. Defaults to 1.
     */
    delete(index2, length2 = 1) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeListDelete(transaction, this, index2, length2);
        });
      } else {
        this._prelimContent.splice(index2, length2);
      }
    }
    /**
     * Returns the i-th element from a YArray.
     *
     * @param {number} index The index of the element to return from the YArray
     * @return {T}
     */
    get(index2) {
      return typeListGet(this, index2);
    }
    /**
     * Transforms this YArray to a JavaScript Array.
     *
     * @return {Array<T>}
     */
    toArray() {
      return typeListToArray(this);
    }
    /**
     * Transforms this YArray to a JavaScript Array.
     *
     * @param {number} [start]
     * @param {number} [end]
     * @return {Array<T>}
     */
    slice(start = 0, end = this.length) {
      return typeListSlice(this, start, end);
    }
    /**
     * Transforms this Shared Type to a JSON object.
     *
     * @return {Array<any>}
     */
    toJSON() {
      return this.map((c) => c instanceof AbstractType ? c.toJSON() : c);
    }
    /**
     * Returns an Array with the result of calling a provided function on every
     * element of this YArray.
     *
     * @template M
     * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
     * @return {Array<M>} A new array with each element being the result of the
     *                 callback function
     */
    map(f) {
      return typeListMap(
        this,
        /** @type {any} */
        f
      );
    }
    /**
     * Executes a provided function once on overy element of this YArray.
     *
     * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
     */
    forEach(f) {
      typeListForEach(this, f);
    }
    /**
     * @return {IterableIterator<T>}
     */
    [Symbol.iterator]() {
      return typeListCreateIterator(this);
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     */
    _write(encoder) {
      encoder.writeTypeRef(YArrayRefID);
    }
  }
  class YMapEvent extends YEvent {
    /**
     * @param {YMap<T>} ymap The YArray that changed.
     * @param {Transaction} transaction
     * @param {Set<any>} subs The keys that changed.
     */
    constructor(ymap, transaction, subs) {
      super(ymap, transaction);
      this.keysChanged = subs;
    }
  }
  class YMap extends AbstractType {
    /**
     *
     * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
     */
    constructor(entries) {
      super();
      this._prelimContent = null;
      if (entries === void 0) {
        this._prelimContent = /* @__PURE__ */ new Map();
      } else {
        this._prelimContent = new Map(entries);
      }
    }
    /**
     * Integrate this type into the Yjs instance.
     *
     * * Save this struct in the os
     * * This type is sent to other client
     * * Observer functions are fired
     *
     * @param {Doc} y The Yjs instance
     * @param {Item} item
     */
    _integrate(y, item) {
      super._integrate(y, item);
      this._prelimContent.forEach((value, key2) => {
        this.set(key2, value);
      });
      this._prelimContent = null;
    }
    /**
     * @return {YMap<MapType>}
     */
    _copy() {
      return new YMap();
    }
    /**
     * @return {YMap<MapType>}
     */
    clone() {
      const map2 = new YMap();
      this.forEach((value, key2) => {
        map2.set(key2, value instanceof AbstractType ? (
          /** @type {typeof value} */
          value.clone()
        ) : value);
      });
      return map2;
    }
    /**
     * Creates YMapEvent and calls observers.
     *
     * @param {Transaction} transaction
     * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
     */
    _callObserver(transaction, parentSubs) {
      callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
    }
    /**
     * Transforms this Shared Type to a JSON object.
     *
     * @return {Object<string,any>}
     */
    toJSON() {
      const map2 = {};
      this._map.forEach((item, key2) => {
        if (!item.deleted) {
          const v = item.content.getContent()[item.length - 1];
          map2[key2] = v instanceof AbstractType ? v.toJSON() : v;
        }
      });
      return map2;
    }
    /**
     * Returns the size of the YMap (count of key/value pairs)
     *
     * @return {number}
     */
    get size() {
      return [...createMapIterator(this._map)].length;
    }
    /**
     * Returns the keys for each element in the YMap Type.
     *
     * @return {IterableIterator<string>}
     */
    keys() {
      return iteratorMap(
        createMapIterator(this._map),
        /** @param {any} v */
        (v) => v[0]
      );
    }
    /**
     * Returns the values for each element in the YMap Type.
     *
     * @return {IterableIterator<MapType>}
     */
    values() {
      return iteratorMap(
        createMapIterator(this._map),
        /** @param {any} v */
        (v) => v[1].content.getContent()[v[1].length - 1]
      );
    }
    /**
     * Returns an Iterator of [key, value] pairs
     *
     * @return {IterableIterator<[string, MapType]>}
     */
    entries() {
      return iteratorMap(
        createMapIterator(this._map),
        /** @param {any} v */
        (v) => (
          /** @type {any} */
          [v[0], v[1].content.getContent()[v[1].length - 1]]
        )
      );
    }
    /**
     * Executes a provided function on once on every key-value pair.
     *
     * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
     */
    forEach(f) {
      this._map.forEach((item, key2) => {
        if (!item.deleted) {
          f(item.content.getContent()[item.length - 1], key2, this);
        }
      });
    }
    /**
     * Returns an Iterator of [key, value] pairs
     *
     * @return {IterableIterator<[string, MapType]>}
     */
    [Symbol.iterator]() {
      return this.entries();
    }
    /**
     * Remove a specified element from this YMap.
     *
     * @param {string} key The key of the element to remove.
     */
    delete(key2) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapDelete(transaction, this, key2);
        });
      } else {
        this._prelimContent.delete(key2);
      }
    }
    /**
     * Adds or updates an element with a specified key and value.
     * @template {MapType} VAL
     *
     * @param {string} key The key of the element to add to this YMap
     * @param {VAL} value The value of the element to add
     * @return {VAL}
     */
    set(key2, value) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapSet(
            transaction,
            this,
            key2,
            /** @type {any} */
            value
          );
        });
      } else {
        this._prelimContent.set(key2, value);
      }
      return value;
    }
    /**
     * Returns a specified element from this YMap.
     *
     * @param {string} key
     * @return {MapType|undefined}
     */
    get(key2) {
      return (
        /** @type {any} */
        typeMapGet(this, key2)
      );
    }
    /**
     * Returns a boolean indicating whether the specified key exists or not.
     *
     * @param {string} key The key to test.
     * @return {boolean}
     */
    has(key2) {
      return typeMapHas(this, key2);
    }
    /**
     * Removes all elements from this YMap.
     */
    clear() {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          this.forEach(function(_value, key2, map2) {
            typeMapDelete(transaction, map2, key2);
          });
        });
      } else {
        this._prelimContent.clear();
      }
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     */
    _write(encoder) {
      encoder.writeTypeRef(YMapRefID);
    }
  }
  const equalAttrs$1 = (a2, b) => a2 === b || typeof a2 === "object" && typeof b === "object" && a2 && b && equalFlat(a2, b);
  class ItemTextListPosition {
    /**
     * @param {Item|null} left
     * @param {Item|null} right
     * @param {number} index
     * @param {Map<string,any>} currentAttributes
     */
    constructor(left, right, index2, currentAttributes) {
      this.left = left;
      this.right = right;
      this.index = index2;
      this.currentAttributes = currentAttributes;
    }
    /**
     * Only call this if you know that this.right is defined
     */
    forward() {
      if (this.right === null) {
        unexpectedCase();
      }
      switch (this.right.content.constructor) {
        case ContentFormat:
          if (!this.right.deleted) {
            updateCurrentAttributes(
              this.currentAttributes,
              /** @type {ContentFormat} */
              this.right.content
            );
          }
          break;
        default:
          if (!this.right.deleted) {
            this.index += this.right.length;
          }
          break;
      }
      this.left = this.right;
      this.right = this.right.right;
    }
  }
  const findNextPosition = (transaction, pos, count) => {
    while (pos.right !== null && count > 0) {
      switch (pos.right.content.constructor) {
        case ContentFormat:
          if (!pos.right.deleted) {
            updateCurrentAttributes(
              pos.currentAttributes,
              /** @type {ContentFormat} */
              pos.right.content
            );
          }
          break;
        default:
          if (!pos.right.deleted) {
            if (count < pos.right.length) {
              getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));
            }
            pos.index += pos.right.length;
            count -= pos.right.length;
          }
          break;
      }
      pos.left = pos.right;
      pos.right = pos.right.right;
    }
    return pos;
  };
  const findPosition = (transaction, parent, index2, useSearchMarker) => {
    const currentAttributes = /* @__PURE__ */ new Map();
    const marker = useSearchMarker ? findMarker(parent, index2) : null;
    if (marker) {
      const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
      return findNextPosition(transaction, pos, index2 - marker.index);
    } else {
      const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
      return findNextPosition(transaction, pos, index2);
    }
  };
  const insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
    while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs$1(
      negatedAttributes.get(
        /** @type {ContentFormat} */
        currPos.right.content.key
      ),
      /** @type {ContentFormat} */
      currPos.right.content.value
    ))) {
      if (!currPos.right.deleted) {
        negatedAttributes.delete(
          /** @type {ContentFormat} */
          currPos.right.content.key
        );
      }
      currPos.forward();
    }
    const doc2 = transaction.doc;
    const ownClientId = doc2.clientID;
    negatedAttributes.forEach((val, key2) => {
      const left = currPos.left;
      const right = currPos.right;
      const nextFormat = new Item$1(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key2, val));
      nextFormat.integrate(transaction, 0);
      currPos.right = nextFormat;
      currPos.forward();
    });
  };
  const updateCurrentAttributes = (currentAttributes, format) => {
    const { key: key2, value } = format;
    if (value === null) {
      currentAttributes.delete(key2);
    } else {
      currentAttributes.set(key2, value);
    }
  };
  const minimizeAttributeChanges = (currPos, attributes) => {
    while (true) {
      if (currPos.right === null) {
        break;
      } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs$1(
        attributes[
          /** @type {ContentFormat} */
          currPos.right.content.key
        ] ?? null,
        /** @type {ContentFormat} */
        currPos.right.content.value
      ))
        ;
      else {
        break;
      }
      currPos.forward();
    }
  };
  const insertAttributes = (transaction, parent, currPos, attributes) => {
    const doc2 = transaction.doc;
    const ownClientId = doc2.clientID;
    const negatedAttributes = /* @__PURE__ */ new Map();
    for (const key2 in attributes) {
      const val = attributes[key2];
      const currentVal = currPos.currentAttributes.get(key2) ?? null;
      if (!equalAttrs$1(currentVal, val)) {
        negatedAttributes.set(key2, currentVal);
        const { left, right } = currPos;
        currPos.right = new Item$1(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key2, val));
        currPos.right.integrate(transaction, 0);
        currPos.forward();
      }
    }
    return negatedAttributes;
  };
  const insertText = (transaction, parent, currPos, text2, attributes) => {
    currPos.currentAttributes.forEach((_val, key2) => {
      if (attributes[key2] === void 0) {
        attributes[key2] = null;
      }
    });
    const doc2 = transaction.doc;
    const ownClientId = doc2.clientID;
    minimizeAttributeChanges(currPos, attributes);
    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
    const content2 = text2.constructor === String ? new ContentString(
      /** @type {string} */
      text2
    ) : text2 instanceof AbstractType ? new ContentType(text2) : new ContentEmbed(text2);
    let { left, right, index: index2 } = currPos;
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, currPos.index, content2.getLength());
    }
    right = new Item$1(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content2);
    right.integrate(transaction, 0);
    currPos.right = right;
    currPos.index = index2;
    currPos.forward();
    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
  };
  const formatText = (transaction, parent, currPos, length2, attributes) => {
    const doc2 = transaction.doc;
    const ownClientId = doc2.clientID;
    minimizeAttributeChanges(currPos, attributes);
    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
    iterationLoop:
      while (currPos.right !== null && (length2 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
        if (!currPos.right.deleted) {
          switch (currPos.right.content.constructor) {
            case ContentFormat: {
              const { key: key2, value } = (
                /** @type {ContentFormat} */
                currPos.right.content
              );
              const attr = attributes[key2];
              if (attr !== void 0) {
                if (equalAttrs$1(attr, value)) {
                  negatedAttributes.delete(key2);
                } else {
                  if (length2 === 0) {
                    break iterationLoop;
                  }
                  negatedAttributes.set(key2, value);
                }
                currPos.right.delete(transaction);
              } else {
                currPos.currentAttributes.set(key2, value);
              }
              break;
            }
            default:
              if (length2 < currPos.right.length) {
                getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length2));
              }
              length2 -= currPos.right.length;
              break;
          }
        }
        currPos.forward();
      }
    if (length2 > 0) {
      let newlines = "";
      for (; length2 > 0; length2--) {
        newlines += "\n";
      }
      currPos.right = new Item$1(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
  };
  const cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {
    let end = start;
    const endFormats = create$5();
    while (end && (!end.countable || end.deleted)) {
      if (!end.deleted && end.content.constructor === ContentFormat) {
        const cf = (
          /** @type {ContentFormat} */
          end.content
        );
        endFormats.set(cf.key, cf);
      }
      end = end.right;
    }
    let cleanups = 0;
    let reachedCurr = false;
    while (start !== end) {
      if (curr === start) {
        reachedCurr = true;
      }
      if (!start.deleted) {
        const content2 = start.content;
        switch (content2.constructor) {
          case ContentFormat: {
            const { key: key2, value } = (
              /** @type {ContentFormat} */
              content2
            );
            const startAttrValue = startAttributes.get(key2) ?? null;
            if (endFormats.get(key2) !== content2 || startAttrValue === value) {
              start.delete(transaction);
              cleanups++;
              if (!reachedCurr && (currAttributes.get(key2) ?? null) === value && startAttrValue !== value) {
                if (startAttrValue === null) {
                  currAttributes.delete(key2);
                } else {
                  currAttributes.set(key2, startAttrValue);
                }
              }
            }
            if (!reachedCurr && !start.deleted) {
              updateCurrentAttributes(
                currAttributes,
                /** @type {ContentFormat} */
                content2
              );
            }
            break;
          }
        }
      }
      start = /** @type {Item} */
      start.right;
    }
    return cleanups;
  };
  const cleanupContextlessFormattingGap = (transaction, item) => {
    while (item && item.right && (item.right.deleted || !item.right.countable)) {
      item = item.right;
    }
    const attrs = /* @__PURE__ */ new Set();
    while (item && (item.deleted || !item.countable)) {
      if (!item.deleted && item.content.constructor === ContentFormat) {
        const key2 = (
          /** @type {ContentFormat} */
          item.content.key
        );
        if (attrs.has(key2)) {
          item.delete(transaction);
        } else {
          attrs.add(key2);
        }
      }
      item = item.left;
    }
  };
  const cleanupYTextFormatting = (type) => {
    let res = 0;
    transact(
      /** @type {Doc} */
      type.doc,
      (transaction) => {
        let start = (
          /** @type {Item} */
          type._start
        );
        let end = type._start;
        let startAttributes = create$5();
        const currentAttributes = copy(startAttributes);
        while (end) {
          if (end.deleted === false) {
            switch (end.content.constructor) {
              case ContentFormat:
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  end.content
                );
                break;
              default:
                res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
                startAttributes = copy(currentAttributes);
                start = end;
                break;
            }
          }
          end = end.right;
        }
      }
    );
    return res;
  };
  const cleanupYTextAfterTransaction = (transaction) => {
    const needFullCleanup = /* @__PURE__ */ new Set();
    const doc2 = transaction.doc;
    for (const [client, afterClock] of transaction.afterState.entries()) {
      const clock = transaction.beforeState.get(client) || 0;
      if (afterClock === clock) {
        continue;
      }
      iterateStructs(
        transaction,
        /** @type {Array<Item|GC>} */
        doc2.store.clients.get(client),
        clock,
        afterClock,
        (item) => {
          if (!item.deleted && /** @type {Item} */
          item.content.constructor === ContentFormat && item.constructor !== GC) {
            needFullCleanup.add(
              /** @type {any} */
              item.parent
            );
          }
        }
      );
    }
    transact(doc2, (t) => {
      iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
        if (item instanceof GC || !/** @type {YText} */
        item.parent._hasFormatting || needFullCleanup.has(
          /** @type {YText} */
          item.parent
        )) {
          return;
        }
        const parent = (
          /** @type {YText} */
          item.parent
        );
        if (item.content.constructor === ContentFormat) {
          needFullCleanup.add(parent);
        } else {
          cleanupContextlessFormattingGap(t, item);
        }
      });
      for (const yText of needFullCleanup) {
        cleanupYTextFormatting(yText);
      }
    });
  };
  const deleteText = (transaction, currPos, length2) => {
    const startLength = length2;
    const startAttrs = copy(currPos.currentAttributes);
    const start = currPos.right;
    while (length2 > 0 && currPos.right !== null) {
      if (currPos.right.deleted === false) {
        switch (currPos.right.content.constructor) {
          case ContentType:
          case ContentEmbed:
          case ContentString:
            if (length2 < currPos.right.length) {
              getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length2));
            }
            length2 -= currPos.right.length;
            currPos.right.delete(transaction);
            break;
        }
      }
      currPos.forward();
    }
    if (start) {
      cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
    }
    const parent = (
      /** @type {AbstractType<any>} */
      /** @type {Item} */
      (currPos.left || currPos.right).parent
    );
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length2);
    }
    return currPos;
  };
  class YTextEvent extends YEvent {
    /**
     * @param {YText} ytext
     * @param {Transaction} transaction
     * @param {Set<any>} subs The keys that changed
     */
    constructor(ytext, transaction, subs) {
      super(ytext, transaction);
      this.childListChanged = false;
      this.keysChanged = /* @__PURE__ */ new Set();
      subs.forEach((sub) => {
        if (sub === null) {
          this.childListChanged = true;
        } else {
          this.keysChanged.add(sub);
        }
      });
    }
    /**
     * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
     */
    get changes() {
      if (this._changes === null) {
        const changes = {
          keys: this.keys,
          delta: this.delta,
          added: /* @__PURE__ */ new Set(),
          deleted: /* @__PURE__ */ new Set()
        };
        this._changes = changes;
      }
      return (
        /** @type {any} */
        this._changes
      );
    }
    /**
     * Compute the changes in the delta format.
     * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
     *
     * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
     *
     * @public
     */
    get delta() {
      if (this._delta === null) {
        const y = (
          /** @type {Doc} */
          this.target.doc
        );
        const delta = [];
        transact(y, (transaction) => {
          const currentAttributes = /* @__PURE__ */ new Map();
          const oldAttributes = /* @__PURE__ */ new Map();
          let item = this.target._start;
          let action = null;
          const attributes = {};
          let insert = "";
          let retain = 0;
          let deleteLen = 0;
          const addOp = () => {
            if (action !== null) {
              let op = null;
              switch (action) {
                case "delete":
                  if (deleteLen > 0) {
                    op = { delete: deleteLen };
                  }
                  deleteLen = 0;
                  break;
                case "insert":
                  if (typeof insert === "object" || insert.length > 0) {
                    op = { insert };
                    if (currentAttributes.size > 0) {
                      op.attributes = {};
                      currentAttributes.forEach((value, key2) => {
                        if (value !== null) {
                          op.attributes[key2] = value;
                        }
                      });
                    }
                  }
                  insert = "";
                  break;
                case "retain":
                  if (retain > 0) {
                    op = { retain };
                    if (!isEmpty(attributes)) {
                      op.attributes = assign$1({}, attributes);
                    }
                  }
                  retain = 0;
                  break;
              }
              if (op)
                delta.push(op);
              action = null;
            }
          };
          while (item !== null) {
            switch (item.content.constructor) {
              case ContentType:
              case ContentEmbed:
                if (this.adds(item)) {
                  if (!this.deletes(item)) {
                    addOp();
                    action = "insert";
                    insert = item.content.getContent()[0];
                    addOp();
                  }
                } else if (this.deletes(item)) {
                  if (action !== "delete") {
                    addOp();
                    action = "delete";
                  }
                  deleteLen += 1;
                } else if (!item.deleted) {
                  if (action !== "retain") {
                    addOp();
                    action = "retain";
                  }
                  retain += 1;
                }
                break;
              case ContentString:
                if (this.adds(item)) {
                  if (!this.deletes(item)) {
                    if (action !== "insert") {
                      addOp();
                      action = "insert";
                    }
                    insert += /** @type {ContentString} */
                    item.content.str;
                  }
                } else if (this.deletes(item)) {
                  if (action !== "delete") {
                    addOp();
                    action = "delete";
                  }
                  deleteLen += item.length;
                } else if (!item.deleted) {
                  if (action !== "retain") {
                    addOp();
                    action = "retain";
                  }
                  retain += item.length;
                }
                break;
              case ContentFormat: {
                const { key: key2, value } = (
                  /** @type {ContentFormat} */
                  item.content
                );
                if (this.adds(item)) {
                  if (!this.deletes(item)) {
                    const curVal = currentAttributes.get(key2) ?? null;
                    if (!equalAttrs$1(curVal, value)) {
                      if (action === "retain") {
                        addOp();
                      }
                      if (equalAttrs$1(value, oldAttributes.get(key2) ?? null)) {
                        delete attributes[key2];
                      } else {
                        attributes[key2] = value;
                      }
                    } else if (value !== null) {
                      item.delete(transaction);
                    }
                  }
                } else if (this.deletes(item)) {
                  oldAttributes.set(key2, value);
                  const curVal = currentAttributes.get(key2) ?? null;
                  if (!equalAttrs$1(curVal, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    attributes[key2] = curVal;
                  }
                } else if (!item.deleted) {
                  oldAttributes.set(key2, value);
                  const attr = attributes[key2];
                  if (attr !== void 0) {
                    if (!equalAttrs$1(attr, value)) {
                      if (action === "retain") {
                        addOp();
                      }
                      if (value === null) {
                        delete attributes[key2];
                      } else {
                        attributes[key2] = value;
                      }
                    } else if (attr !== null) {
                      item.delete(transaction);
                    }
                  }
                }
                if (!item.deleted) {
                  if (action === "insert") {
                    addOp();
                  }
                  updateCurrentAttributes(
                    currentAttributes,
                    /** @type {ContentFormat} */
                    item.content
                  );
                }
                break;
              }
            }
            item = item.right;
          }
          addOp();
          while (delta.length > 0) {
            const lastOp = delta[delta.length - 1];
            if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
              delta.pop();
            } else {
              break;
            }
          }
        });
        this._delta = delta;
      }
      return (
        /** @type {any} */
        this._delta
      );
    }
  }
  class YText extends AbstractType {
    /**
     * @param {String} [string] The initial value of the YText.
     */
    constructor(string2) {
      super();
      this._pending = string2 !== void 0 ? [() => this.insert(0, string2)] : [];
      this._searchMarker = [];
      this._hasFormatting = false;
    }
    /**
     * Number of characters of this text type.
     *
     * @type {number}
     */
    get length() {
      return this._length;
    }
    /**
     * @param {Doc} y
     * @param {Item} item
     */
    _integrate(y, item) {
      super._integrate(y, item);
      try {
        this._pending.forEach((f) => f());
      } catch (e) {
        console.error(e);
      }
      this._pending = null;
    }
    _copy() {
      return new YText();
    }
    /**
     * @return {YText}
     */
    clone() {
      const text2 = new YText();
      text2.applyDelta(this.toDelta());
      return text2;
    }
    /**
     * Creates YTextEvent and calls observers.
     *
     * @param {Transaction} transaction
     * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
     */
    _callObserver(transaction, parentSubs) {
      super._callObserver(transaction, parentSubs);
      const event = new YTextEvent(this, transaction, parentSubs);
      callTypeObservers(this, transaction, event);
      if (!transaction.local && this._hasFormatting) {
        transaction._needFormattingCleanup = true;
      }
    }
    /**
     * Returns the unformatted string representation of this YText type.
     *
     * @public
     */
    toString() {
      let str = "";
      let n = this._start;
      while (n !== null) {
        if (!n.deleted && n.countable && n.content.constructor === ContentString) {
          str += /** @type {ContentString} */
          n.content.str;
        }
        n = n.right;
      }
      return str;
    }
    /**
     * Returns the unformatted string representation of this YText type.
     *
     * @return {string}
     * @public
     */
    toJSON() {
      return this.toString();
    }
    /**
     * Apply a {@link Delta} on this shared YText type.
     *
     * @param {any} delta The changes to apply on this element.
     * @param {object}  opts
     * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
     *
     *
     * @public
     */
    applyDelta(delta, { sanitize = true } = {}) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
          for (let i2 = 0; i2 < delta.length; i2++) {
            const op = delta[i2];
            if (op.insert !== void 0) {
              const ins = !sanitize && typeof op.insert === "string" && i2 === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
              if (typeof ins !== "string" || ins.length > 0) {
                insertText(transaction, this, currPos, ins, op.attributes || {});
              }
            } else if (op.retain !== void 0) {
              formatText(transaction, this, currPos, op.retain, op.attributes || {});
            } else if (op.delete !== void 0) {
              deleteText(transaction, currPos, op.delete);
            }
          }
        });
      } else {
        this._pending.push(() => this.applyDelta(delta));
      }
    }
    /**
     * Returns the Delta representation of this YText type.
     *
     * @param {Snapshot} [snapshot]
     * @param {Snapshot} [prevSnapshot]
     * @param {function('removed' | 'added', ID):any} [computeYChange]
     * @return {any} The Delta representation of this type.
     *
     * @public
     */
    toDelta(snapshot2, prevSnapshot, computeYChange) {
      const ops = [];
      const currentAttributes = /* @__PURE__ */ new Map();
      const doc2 = (
        /** @type {Doc} */
        this.doc
      );
      let str = "";
      let n = this._start;
      function packStr() {
        if (str.length > 0) {
          const attributes = {};
          let addAttributes = false;
          currentAttributes.forEach((value, key2) => {
            addAttributes = true;
            attributes[key2] = value;
          });
          const op = { insert: str };
          if (addAttributes) {
            op.attributes = attributes;
          }
          ops.push(op);
          str = "";
        }
      }
      const computeDelta = () => {
        while (n !== null) {
          if (isVisible$1(n, snapshot2) || prevSnapshot !== void 0 && isVisible$1(n, prevSnapshot)) {
            switch (n.content.constructor) {
              case ContentString: {
                const cur = currentAttributes.get("ychange");
                if (snapshot2 !== void 0 && !isVisible$1(n, snapshot2)) {
                  if (cur === void 0 || cur.user !== n.id.client || cur.type !== "removed") {
                    packStr();
                    currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n.id) : { type: "removed" });
                  }
                } else if (prevSnapshot !== void 0 && !isVisible$1(n, prevSnapshot)) {
                  if (cur === void 0 || cur.user !== n.id.client || cur.type !== "added") {
                    packStr();
                    currentAttributes.set("ychange", computeYChange ? computeYChange("added", n.id) : { type: "added" });
                  }
                } else if (cur !== void 0) {
                  packStr();
                  currentAttributes.delete("ychange");
                }
                str += /** @type {ContentString} */
                n.content.str;
                break;
              }
              case ContentType:
              case ContentEmbed: {
                packStr();
                const op = {
                  insert: n.content.getContent()[0]
                };
                if (currentAttributes.size > 0) {
                  const attrs = (
                    /** @type {Object<string,any>} */
                    {}
                  );
                  op.attributes = attrs;
                  currentAttributes.forEach((value, key2) => {
                    attrs[key2] = value;
                  });
                }
                ops.push(op);
                break;
              }
              case ContentFormat:
                if (isVisible$1(n, snapshot2)) {
                  packStr();
                  updateCurrentAttributes(
                    currentAttributes,
                    /** @type {ContentFormat} */
                    n.content
                  );
                }
                break;
            }
          }
          n = n.right;
        }
        packStr();
      };
      if (snapshot2 || prevSnapshot) {
        transact(doc2, (transaction) => {
          if (snapshot2) {
            splitSnapshotAffectedStructs(transaction, snapshot2);
          }
          if (prevSnapshot) {
            splitSnapshotAffectedStructs(transaction, prevSnapshot);
          }
          computeDelta();
        }, "cleanup");
      } else {
        computeDelta();
      }
      return ops;
    }
    /**
     * Insert text at a given index.
     *
     * @param {number} index The index at which to start inserting.
     * @param {String} text The text to insert at the specified position.
     * @param {TextAttributes} [attributes] Optionally define some formatting
     *                                    information to apply on the inserted
     *                                    Text.
     * @public
     */
    insert(index2, text2, attributes) {
      if (text2.length <= 0) {
        return;
      }
      const y = this.doc;
      if (y !== null) {
        transact(y, (transaction) => {
          const pos = findPosition(transaction, this, index2, !attributes);
          if (!attributes) {
            attributes = {};
            pos.currentAttributes.forEach((v, k) => {
              attributes[k] = v;
            });
          }
          insertText(transaction, this, pos, text2, attributes);
        });
      } else {
        this._pending.push(() => this.insert(index2, text2, attributes));
      }
    }
    /**
     * Inserts an embed at a index.
     *
     * @param {number} index The index to insert the embed at.
     * @param {Object | AbstractType<any>} embed The Object that represents the embed.
     * @param {TextAttributes} [attributes] Attribute information to apply on the
     *                                    embed
     *
     * @public
     */
    insertEmbed(index2, embed, attributes) {
      const y = this.doc;
      if (y !== null) {
        transact(y, (transaction) => {
          const pos = findPosition(transaction, this, index2, !attributes);
          insertText(transaction, this, pos, embed, attributes || {});
        });
      } else {
        this._pending.push(() => this.insertEmbed(index2, embed, attributes || {}));
      }
    }
    /**
     * Deletes text starting from an index.
     *
     * @param {number} index Index at which to start deleting.
     * @param {number} length The number of characters to remove. Defaults to 1.
     *
     * @public
     */
    delete(index2, length2) {
      if (length2 === 0) {
        return;
      }
      const y = this.doc;
      if (y !== null) {
        transact(y, (transaction) => {
          deleteText(transaction, findPosition(transaction, this, index2, true), length2);
        });
      } else {
        this._pending.push(() => this.delete(index2, length2));
      }
    }
    /**
     * Assigns properties to a range of text.
     *
     * @param {number} index The position where to start formatting.
     * @param {number} length The amount of characters to assign properties to.
     * @param {TextAttributes} attributes Attribute information to apply on the
     *                                    text.
     *
     * @public
     */
    format(index2, length2, attributes) {
      if (length2 === 0) {
        return;
      }
      const y = this.doc;
      if (y !== null) {
        transact(y, (transaction) => {
          const pos = findPosition(transaction, this, index2, false);
          if (pos.right === null) {
            return;
          }
          formatText(transaction, this, pos, length2, attributes);
        });
      } else {
        this._pending.push(() => this.format(index2, length2, attributes));
      }
    }
    /**
     * Removes an attribute.
     *
     * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
     *
     * @param {String} attributeName The attribute name that is to be removed.
     *
     * @public
     */
    removeAttribute(attributeName) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapDelete(transaction, this, attributeName);
        });
      } else {
        this._pending.push(() => this.removeAttribute(attributeName));
      }
    }
    /**
     * Sets or updates an attribute.
     *
     * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
     *
     * @param {String} attributeName The attribute name that is to be set.
     * @param {any} attributeValue The attribute value that is to be set.
     *
     * @public
     */
    setAttribute(attributeName, attributeValue) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapSet(transaction, this, attributeName, attributeValue);
        });
      } else {
        this._pending.push(() => this.setAttribute(attributeName, attributeValue));
      }
    }
    /**
     * Returns an attribute value that belongs to the attribute name.
     *
     * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
     *
     * @param {String} attributeName The attribute name that identifies the
     *                               queried value.
     * @return {any} The queried attribute value.
     *
     * @public
     */
    getAttribute(attributeName) {
      return (
        /** @type {any} */
        typeMapGet(this, attributeName)
      );
    }
    /**
     * Returns all attribute name/value pairs in a JSON Object.
     *
     * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
     *
     * @return {Object<string, any>} A JSON Object that describes the attributes.
     *
     * @public
     */
    getAttributes() {
      return typeMapGetAll(this);
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     */
    _write(encoder) {
      encoder.writeTypeRef(YTextRefID);
    }
  }
  class YXmlTreeWalker {
    /**
     * @param {YXmlFragment | YXmlElement} root
     * @param {function(AbstractType<any>):boolean} [f]
     */
    constructor(root2, f = () => true) {
      this._filter = f;
      this._root = root2;
      this._currentNode = /** @type {Item} */
      root2._start;
      this._firstCall = true;
    }
    [Symbol.iterator]() {
      return this;
    }
    /**
     * Get the next node.
     *
     * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
     *
     * @public
     */
    next() {
      let n = this._currentNode;
      let type = n && n.content && /** @type {any} */
      n.content.type;
      if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {
        do {
          type = /** @type {any} */
          n.content.type;
          if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {
            n = type._start;
          } else {
            while (n !== null) {
              if (n.right !== null) {
                n = n.right;
                break;
              } else if (n.parent === this._root) {
                n = null;
              } else {
                n = /** @type {AbstractType<any>} */
                n.parent._item;
              }
            }
          }
        } while (n !== null && (n.deleted || !this._filter(
          /** @type {ContentType} */
          n.content.type
        )));
      }
      this._firstCall = false;
      if (n === null) {
        return { value: void 0, done: true };
      }
      this._currentNode = n;
      return { value: (
        /** @type {any} */
        n.content.type
      ), done: false };
    }
  }
  class YXmlFragment extends AbstractType {
    constructor() {
      super();
      this._prelimContent = [];
    }
    /**
     * @type {YXmlElement|YXmlText|null}
     */
    get firstChild() {
      const first2 = this._first;
      return first2 ? first2.content.getContent()[0] : null;
    }
    /**
     * Integrate this type into the Yjs instance.
     *
     * * Save this struct in the os
     * * This type is sent to other client
     * * Observer functions are fired
     *
     * @param {Doc} y The Yjs instance
     * @param {Item} item
     */
    _integrate(y, item) {
      super._integrate(y, item);
      this.insert(
        0,
        /** @type {Array<any>} */
        this._prelimContent
      );
      this._prelimContent = null;
    }
    _copy() {
      return new YXmlFragment();
    }
    /**
     * @return {YXmlFragment}
     */
    clone() {
      const el = new YXmlFragment();
      el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
      return el;
    }
    get length() {
      return this._prelimContent === null ? this._length : this._prelimContent.length;
    }
    /**
     * Create a subtree of childNodes.
     *
     * @example
     * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
     * for (let node in walker) {
     *   // `node` is a div node
     *   nop(node)
     * }
     *
     * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
     *                          returns a Boolean indicating whether the child
     *                          is to be included in the subtree.
     * @return {YXmlTreeWalker} A subtree and a position within it.
     *
     * @public
     */
    createTreeWalker(filter) {
      return new YXmlTreeWalker(this, filter);
    }
    /**
     * Returns the first YXmlElement that matches the query.
     * Similar to DOM's {@link querySelector}.
     *
     * Query support:
     *   - tagname
     * TODO:
     *   - id
     *   - attribute
     *
     * @param {CSS_Selector} query The query on the children.
     * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
     *
     * @public
     */
    querySelector(query) {
      query = query.toUpperCase();
      const iterator = new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query);
      const next = iterator.next();
      if (next.done) {
        return null;
      } else {
        return next.value;
      }
    }
    /**
     * Returns all YXmlElements that match the query.
     * Similar to Dom's {@link querySelectorAll}.
     *
     * @todo Does not yet support all queries. Currently only query by tagName.
     *
     * @param {CSS_Selector} query The query on the children
     * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
     *
     * @public
     */
    querySelectorAll(query) {
      query = query.toUpperCase();
      return from(new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query));
    }
    /**
     * Creates YXmlEvent and calls observers.
     *
     * @param {Transaction} transaction
     * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
     */
    _callObserver(transaction, parentSubs) {
      callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
    }
    /**
     * Get the string representation of all the children of this YXmlFragment.
     *
     * @return {string} The string representation of all children.
     */
    toString() {
      return typeListMap(this, (xml2) => xml2.toString()).join("");
    }
    /**
     * @return {string}
     */
    toJSON() {
      return this.toString();
    }
    /**
     * Creates a Dom Element that mirrors this YXmlElement.
     *
     * @param {Document} [_document=document] The document object (you must define
     *                                        this when calling this method in
     *                                        nodejs)
     * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
     *                                             are presented in the DOM
     * @param {any} [binding] You should not set this property. This is
     *                               used if DomBinding wants to create a
     *                               association to the created DOM type.
     * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
     *
     * @public
     */
    toDOM(_document = document, hooks = {}, binding) {
      const fragment = _document.createDocumentFragment();
      if (binding !== void 0) {
        binding._createAssociation(fragment, this);
      }
      typeListForEach(this, (xmlType) => {
        fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
      });
      return fragment;
    }
    /**
     * Inserts new content at an index.
     *
     * @example
     *  // Insert character 'a' at position 0
     *  xml.insert(0, [new Y.XmlText('text')])
     *
     * @param {number} index The index to insert content at
     * @param {Array<YXmlElement|YXmlText>} content The array of content
     */
    insert(index2, content2) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeListInsertGenerics(transaction, this, index2, content2);
        });
      } else {
        this._prelimContent.splice(index2, 0, ...content2);
      }
    }
    /**
     * Inserts new content at an index.
     *
     * @example
     *  // Insert character 'a' at position 0
     *  xml.insert(0, [new Y.XmlText('text')])
     *
     * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
     * @param {Array<YXmlElement|YXmlText>} content The array of content
     */
    insertAfter(ref, content2) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
          typeListInsertGenericsAfter(transaction, this, refItem, content2);
        });
      } else {
        const pc = (
          /** @type {Array<any>} */
          this._prelimContent
        );
        const index2 = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
        if (index2 === 0 && ref !== null) {
          throw create$3("Reference item not found");
        }
        pc.splice(index2, 0, ...content2);
      }
    }
    /**
     * Deletes elements starting from an index.
     *
     * @param {number} index Index at which to start deleting elements
     * @param {number} [length=1] The number of elements to remove. Defaults to 1.
     */
    delete(index2, length2 = 1) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeListDelete(transaction, this, index2, length2);
        });
      } else {
        this._prelimContent.splice(index2, length2);
      }
    }
    /**
     * Transforms this YArray to a JavaScript Array.
     *
     * @return {Array<YXmlElement|YXmlText|YXmlHook>}
     */
    toArray() {
      return typeListToArray(this);
    }
    /**
     * Appends content to this YArray.
     *
     * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
     */
    push(content2) {
      this.insert(this.length, content2);
    }
    /**
     * Preppends content to this YArray.
     *
     * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.
     */
    unshift(content2) {
      this.insert(0, content2);
    }
    /**
     * Returns the i-th element from a YArray.
     *
     * @param {number} index The index of the element to return from the YArray
     * @return {YXmlElement|YXmlText}
     */
    get(index2) {
      return typeListGet(this, index2);
    }
    /**
     * Transforms this YArray to a JavaScript Array.
     *
     * @param {number} [start]
     * @param {number} [end]
     * @return {Array<YXmlElement|YXmlText>}
     */
    slice(start = 0, end = this.length) {
      return typeListSlice(this, start, end);
    }
    /**
     * Executes a provided function on once on overy child element.
     *
     * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
     */
    forEach(f) {
      typeListForEach(this, f);
    }
    /**
     * Transform the properties of this type to binary and write it to an
     * BinaryEncoder.
     *
     * This is called when this Item is sent to a remote peer.
     *
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
     */
    _write(encoder) {
      encoder.writeTypeRef(YXmlFragmentRefID);
    }
  }
  class YXmlElement extends YXmlFragment {
    constructor(nodeName = "UNDEFINED") {
      super();
      this.nodeName = nodeName;
      this._prelimAttrs = /* @__PURE__ */ new Map();
    }
    /**
     * @type {YXmlElement|YXmlText|null}
     */
    get nextSibling() {
      const n = this._item ? this._item.next : null;
      return n ? (
        /** @type {YXmlElement|YXmlText} */
        /** @type {ContentType} */
        n.content.type
      ) : null;
    }
    /**
     * @type {YXmlElement|YXmlText|null}
     */
    get prevSibling() {
      const n = this._item ? this._item.prev : null;
      return n ? (
        /** @type {YXmlElement|YXmlText} */
        /** @type {ContentType} */
        n.content.type
      ) : null;
    }
    /**
     * Integrate this type into the Yjs instance.
     *
     * * Save this struct in the os
     * * This type is sent to other client
     * * Observer functions are fired
     *
     * @param {Doc} y The Yjs instance
     * @param {Item} item
     */
    _integrate(y, item) {
      super._integrate(y, item);
      /** @type {Map<string, any>} */
      this._prelimAttrs.forEach((value, key2) => {
        this.setAttribute(key2, value);
      });
      this._prelimAttrs = null;
    }
    /**
     * Creates an Item with the same effect as this Item (without position effect)
     *
     * @return {YXmlElement}
     */
    _copy() {
      return new YXmlElement(this.nodeName);
    }
    /**
     * @return {YXmlElement<KV>}
     */
    clone() {
      const el = new YXmlElement(this.nodeName);
      const attrs = this.getAttributes();
      forEach(attrs, (value, key2) => {
        if (typeof value === "string") {
          el.setAttribute(key2, value);
        }
      });
      el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
      return el;
    }
    /**
     * Returns the XML serialization of this YXmlElement.
     * The attributes are ordered by attribute-name, so you can easily use this
     * method to compare YXmlElements
     *
     * @return {string} The string representation of this type.
     *
     * @public
     */
    toString() {
      const attrs = this.getAttributes();
      const stringBuilder = [];
      const keys2 = [];
      for (const key2 in attrs) {
        keys2.push(key2);
      }
      keys2.sort();
      const keysLen = keys2.length;
      for (let i2 = 0; i2 < keysLen; i2++) {
        const key2 = keys2[i2];
        stringBuilder.push(key2 + '="' + attrs[key2] + '"');
      }
      const nodeName = this.nodeName.toLocaleLowerCase();
      const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
      return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
    }
    /**
     * Removes an attribute from this YXmlElement.
     *
     * @param {string} attributeName The attribute name that is to be removed.
     *
     * @public
     */
    removeAttribute(attributeName) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapDelete(transaction, this, attributeName);
        });
      } else {
        this._prelimAttrs.delete(attributeName);
      }
    }
    /**
     * Sets or updates an attribute.
     *
     * @template {keyof KV & string} KEY
     *
     * @param {KEY} attributeName The attribute name that is to be set.
     * @param {KV[KEY]} attributeValue The attribute value that is to be set.
     *
     * @public
     */
    setAttribute(attributeName, attributeValue) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapSet(transaction, this, attributeName, attributeValue);
        });
      } else {
        this._prelimAttrs.set(attributeName, attributeValue);
      }
    }
    /**
     * Returns an attribute value that belongs to the attribute name.
     *
     * @template {keyof KV & string} KEY
     *
     * @param {KEY} attributeName The attribute name that identifies the
     *                               queried value.
     * @return {KV[KEY]|undefined} The queried attribute value.
     *
     * @public
     */
    getAttribute(attributeName) {
      return (
        /** @type {any} */
        typeMapGet(this, attributeName)
      );
    }
    /**
     * Returns whether an attribute exists
     *
     * @param {string} attributeName The attribute name to check for existence.
     * @return {boolean} whether the attribute exists.
     *
     * @public
     */
    hasAttribute(attributeName) {
      return (
        /** @type {any} */
        typeMapHas(this, attributeName)
      );
    }
    /**
     * Returns all attribute name/value pairs in a JSON Object.
     *
     * @param {Snapshot} [snapshot]
     * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
     *
     * @public
     */
    getAttributes(snapshot2) {
      return (
        /** @type {any} */
        snapshot2 ? typeMapGetAllSnapshot(this, snapshot2) : typeMapGetAll(this)
      );
    }
    /**
     * Creates a Dom Element that mirrors this YXmlElement.
     *
     * @param {Document} [_document=document] The document object (you must define
     *                                        this when calling this method in
     *                                        nodejs)
     * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
     *                                             are presented in the DOM
     * @param {any} [binding] You should not set this property. This is
     *                               used if DomBinding wants to create a
     *                               association to the created DOM type.
     * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
     *
     * @public
     */
    toDOM(_document = document, hooks = {}, binding) {
      const dom = _document.createElement(this.nodeName);
      const attrs = this.getAttributes();
      for (const key2 in attrs) {
        const value = attrs[key2];
        if (typeof value === "string") {
          dom.setAttribute(key2, value);
        }
      }
      typeListForEach(this, (yxml) => {
        dom.appendChild(yxml.toDOM(_document, hooks, binding));
      });
      if (binding !== void 0) {
        binding._createAssociation(dom, this);
      }
      return dom;
    }
    /**
     * Transform the properties of this type to binary and write it to an
     * BinaryEncoder.
     *
     * This is called when this Item is sent to a remote peer.
     *
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
     */
    _write(encoder) {
      encoder.writeTypeRef(YXmlElementRefID);
      encoder.writeKey(this.nodeName);
    }
  }
  class YXmlEvent extends YEvent {
    /**
     * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
     * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
     *                   child list changed.
     * @param {Transaction} transaction The transaction instance with wich the
     *                                  change was created.
     */
    constructor(target, subs, transaction) {
      super(target, transaction);
      this.childListChanged = false;
      this.attributesChanged = /* @__PURE__ */ new Set();
      subs.forEach((sub) => {
        if (sub === null) {
          this.childListChanged = true;
        } else {
          this.attributesChanged.add(sub);
        }
      });
    }
  }
  class YXmlText extends YText {
    /**
     * @type {YXmlElement|YXmlText|null}
     */
    get nextSibling() {
      const n = this._item ? this._item.next : null;
      return n ? (
        /** @type {YXmlElement|YXmlText} */
        /** @type {ContentType} */
        n.content.type
      ) : null;
    }
    /**
     * @type {YXmlElement|YXmlText|null}
     */
    get prevSibling() {
      const n = this._item ? this._item.prev : null;
      return n ? (
        /** @type {YXmlElement|YXmlText} */
        /** @type {ContentType} */
        n.content.type
      ) : null;
    }
    _copy() {
      return new YXmlText();
    }
    /**
     * @return {YXmlText}
     */
    clone() {
      const text2 = new YXmlText();
      text2.applyDelta(this.toDelta());
      return text2;
    }
    /**
     * Creates a Dom Element that mirrors this YXmlText.
     *
     * @param {Document} [_document=document] The document object (you must define
     *                                        this when calling this method in
     *                                        nodejs)
     * @param {Object<string, any>} [hooks] Optional property to customize how hooks
     *                                             are presented in the DOM
     * @param {any} [binding] You should not set this property. This is
     *                               used if DomBinding wants to create a
     *                               association to the created DOM type.
     * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
     *
     * @public
     */
    toDOM(_document = document, hooks, binding) {
      const dom = _document.createTextNode(this.toString());
      if (binding !== void 0) {
        binding._createAssociation(dom, this);
      }
      return dom;
    }
    toString() {
      return this.toDelta().map((delta) => {
        const nestedNodes = [];
        for (const nodeName in delta.attributes) {
          const attrs = [];
          for (const key2 in delta.attributes[nodeName]) {
            attrs.push({ key: key2, value: delta.attributes[nodeName][key2] });
          }
          attrs.sort((a2, b) => a2.key < b.key ? -1 : 1);
          nestedNodes.push({ nodeName, attrs });
        }
        nestedNodes.sort((a2, b) => a2.nodeName < b.nodeName ? -1 : 1);
        let str = "";
        for (let i2 = 0; i2 < nestedNodes.length; i2++) {
          const node2 = nestedNodes[i2];
          str += `<${node2.nodeName}`;
          for (let j = 0; j < node2.attrs.length; j++) {
            const attr = node2.attrs[j];
            str += ` ${attr.key}="${attr.value}"`;
          }
          str += ">";
        }
        str += delta.insert;
        for (let i2 = nestedNodes.length - 1; i2 >= 0; i2--) {
          str += `</${nestedNodes[i2].nodeName}>`;
        }
        return str;
      }).join("");
    }
    /**
     * @return {string}
     */
    toJSON() {
      return this.toString();
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     */
    _write(encoder) {
      encoder.writeTypeRef(YXmlTextRefID);
    }
  }
  class AbstractStruct {
    /**
     * @param {ID} id
     * @param {number} length
     */
    constructor(id, length2) {
      this.id = id;
      this.length = length2;
    }
    /**
     * @type {boolean}
     */
    get deleted() {
      throw methodUnimplemented();
    }
    /**
     * Merge this struct with the item to the right.
     * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
     * Also this method does *not* remove right from StructStore!
     * @param {AbstractStruct} right
     * @return {boolean} wether this merged with right
     */
    mergeWith(right) {
      return false;
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
     * @param {number} offset
     * @param {number} encodingRef
     */
    write(encoder, offset, encodingRef) {
      throw methodUnimplemented();
    }
    /**
     * @param {Transaction} transaction
     * @param {number} offset
     */
    integrate(transaction, offset) {
      throw methodUnimplemented();
    }
  }
  const structGCRefNumber = 0;
  class GC extends AbstractStruct {
    get deleted() {
      return true;
    }
    delete() {
    }
    /**
     * @param {GC} right
     * @return {boolean}
     */
    mergeWith(right) {
      if (this.constructor !== right.constructor) {
        return false;
      }
      this.length += right.length;
      return true;
    }
    /**
     * @param {Transaction} transaction
     * @param {number} offset
     */
    integrate(transaction, offset) {
      if (offset > 0) {
        this.id.clock += offset;
        this.length -= offset;
      }
      addStruct(transaction.doc.store, this);
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      encoder.writeInfo(structGCRefNumber);
      encoder.writeLen(this.length - offset);
    }
    /**
     * @param {Transaction} transaction
     * @param {StructStore} store
     * @return {null | number}
     */
    getMissing(transaction, store) {
      return null;
    }
  }
  class ContentBinary {
    /**
     * @param {Uint8Array} content
     */
    constructor(content2) {
      this.content = content2;
    }
    /**
     * @return {number}
     */
    getLength() {
      return 1;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return [this.content];
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return true;
    }
    /**
     * @return {ContentBinary}
     */
    copy() {
      return new ContentBinary(this.content);
    }
    /**
     * @param {number} offset
     * @return {ContentBinary}
     */
    splice(offset) {
      throw methodUnimplemented();
    }
    /**
     * @param {ContentBinary} right
     * @return {boolean}
     */
    mergeWith(right) {
      return false;
    }
    /**
     * @param {Transaction} transaction
     * @param {Item} item
     */
    integrate(transaction, item) {
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      encoder.writeBuf(this.content);
    }
    /**
     * @return {number}
     */
    getRef() {
      return 3;
    }
  }
  class ContentDeleted {
    /**
     * @param {number} len
     */
    constructor(len) {
      this.len = len;
    }
    /**
     * @return {number}
     */
    getLength() {
      return this.len;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return [];
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return false;
    }
    /**
     * @return {ContentDeleted}
     */
    copy() {
      return new ContentDeleted(this.len);
    }
    /**
     * @param {number} offset
     * @return {ContentDeleted}
     */
    splice(offset) {
      const right = new ContentDeleted(this.len - offset);
      this.len = offset;
      return right;
    }
    /**
     * @param {ContentDeleted} right
     * @return {boolean}
     */
    mergeWith(right) {
      this.len += right.len;
      return true;
    }
    /**
     * @param {Transaction} transaction
     * @param {Item} item
     */
    integrate(transaction, item) {
      addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
      item.markDeleted();
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      encoder.writeLen(this.len - offset);
    }
    /**
     * @return {number}
     */
    getRef() {
      return 1;
    }
  }
  const createDocFromOpts = (guid, opts) => new Doc$1({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });
  class ContentDoc {
    /**
     * @param {Doc} doc
     */
    constructor(doc2) {
      if (doc2._item) {
        console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
      }
      this.doc = doc2;
      const opts = {};
      this.opts = opts;
      if (!doc2.gc) {
        opts.gc = false;
      }
      if (doc2.autoLoad) {
        opts.autoLoad = true;
      }
      if (doc2.meta !== null) {
        opts.meta = doc2.meta;
      }
    }
    /**
     * @return {number}
     */
    getLength() {
      return 1;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return [this.doc];
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return true;
    }
    /**
     * @return {ContentDoc}
     */
    copy() {
      return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
    }
    /**
     * @param {number} offset
     * @return {ContentDoc}
     */
    splice(offset) {
      throw methodUnimplemented();
    }
    /**
     * @param {ContentDoc} right
     * @return {boolean}
     */
    mergeWith(right) {
      return false;
    }
    /**
     * @param {Transaction} transaction
     * @param {Item} item
     */
    integrate(transaction, item) {
      this.doc._item = item;
      transaction.subdocsAdded.add(this.doc);
      if (this.doc.shouldLoad) {
        transaction.subdocsLoaded.add(this.doc);
      }
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
      if (transaction.subdocsAdded.has(this.doc)) {
        transaction.subdocsAdded.delete(this.doc);
      } else {
        transaction.subdocsRemoved.add(this.doc);
      }
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      encoder.writeString(this.doc.guid);
      encoder.writeAny(this.opts);
    }
    /**
     * @return {number}
     */
    getRef() {
      return 9;
    }
  }
  class ContentEmbed {
    /**
     * @param {Object} embed
     */
    constructor(embed) {
      this.embed = embed;
    }
    /**
     * @return {number}
     */
    getLength() {
      return 1;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return [this.embed];
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return true;
    }
    /**
     * @return {ContentEmbed}
     */
    copy() {
      return new ContentEmbed(this.embed);
    }
    /**
     * @param {number} offset
     * @return {ContentEmbed}
     */
    splice(offset) {
      throw methodUnimplemented();
    }
    /**
     * @param {ContentEmbed} right
     * @return {boolean}
     */
    mergeWith(right) {
      return false;
    }
    /**
     * @param {Transaction} transaction
     * @param {Item} item
     */
    integrate(transaction, item) {
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      encoder.writeJSON(this.embed);
    }
    /**
     * @return {number}
     */
    getRef() {
      return 5;
    }
  }
  class ContentFormat {
    /**
     * @param {string} key
     * @param {Object} value
     */
    constructor(key2, value) {
      this.key = key2;
      this.value = value;
    }
    /**
     * @return {number}
     */
    getLength() {
      return 1;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return [];
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return false;
    }
    /**
     * @return {ContentFormat}
     */
    copy() {
      return new ContentFormat(this.key, this.value);
    }
    /**
     * @param {number} _offset
     * @return {ContentFormat}
     */
    splice(_offset) {
      throw methodUnimplemented();
    }
    /**
     * @param {ContentFormat} _right
     * @return {boolean}
     */
    mergeWith(_right) {
      return false;
    }
    /**
     * @param {Transaction} _transaction
     * @param {Item} item
     */
    integrate(_transaction, item) {
      const p2 = (
        /** @type {YText} */
        item.parent
      );
      p2._searchMarker = null;
      p2._hasFormatting = true;
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      encoder.writeKey(this.key);
      encoder.writeJSON(this.value);
    }
    /**
     * @return {number}
     */
    getRef() {
      return 6;
    }
  }
  class ContentAny {
    /**
     * @param {Array<any>} arr
     */
    constructor(arr) {
      this.arr = arr;
    }
    /**
     * @return {number}
     */
    getLength() {
      return this.arr.length;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return this.arr;
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return true;
    }
    /**
     * @return {ContentAny}
     */
    copy() {
      return new ContentAny(this.arr);
    }
    /**
     * @param {number} offset
     * @return {ContentAny}
     */
    splice(offset) {
      const right = new ContentAny(this.arr.slice(offset));
      this.arr = this.arr.slice(0, offset);
      return right;
    }
    /**
     * @param {ContentAny} right
     * @return {boolean}
     */
    mergeWith(right) {
      this.arr = this.arr.concat(right.arr);
      return true;
    }
    /**
     * @param {Transaction} transaction
     * @param {Item} item
     */
    integrate(transaction, item) {
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      const len = this.arr.length;
      encoder.writeLen(len - offset);
      for (let i2 = offset; i2 < len; i2++) {
        const c = this.arr[i2];
        encoder.writeAny(c);
      }
    }
    /**
     * @return {number}
     */
    getRef() {
      return 8;
    }
  }
  class ContentString {
    /**
     * @param {string} str
     */
    constructor(str) {
      this.str = str;
    }
    /**
     * @return {number}
     */
    getLength() {
      return this.str.length;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return this.str.split("");
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return true;
    }
    /**
     * @return {ContentString}
     */
    copy() {
      return new ContentString(this.str);
    }
    /**
     * @param {number} offset
     * @return {ContentString}
     */
    splice(offset) {
      const right = new ContentString(this.str.slice(offset));
      this.str = this.str.slice(0, offset);
      const firstCharCode = this.str.charCodeAt(offset - 1);
      if (firstCharCode >= 55296 && firstCharCode <= 56319) {
        this.str = this.str.slice(0, offset - 1) + "�";
        right.str = "�" + right.str.slice(1);
      }
      return right;
    }
    /**
     * @param {ContentString} right
     * @return {boolean}
     */
    mergeWith(right) {
      this.str += right.str;
      return true;
    }
    /**
     * @param {Transaction} transaction
     * @param {Item} item
     */
    integrate(transaction, item) {
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
    }
    /**
     * @return {number}
     */
    getRef() {
      return 4;
    }
  }
  const YArrayRefID = 0;
  const YMapRefID = 1;
  const YTextRefID = 2;
  const YXmlElementRefID = 3;
  const YXmlFragmentRefID = 4;
  const YXmlTextRefID = 6;
  class ContentType {
    /**
     * @param {AbstractType<any>} type
     */
    constructor(type) {
      this.type = type;
    }
    /**
     * @return {number}
     */
    getLength() {
      return 1;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return [this.type];
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return true;
    }
    /**
     * @return {ContentType}
     */
    copy() {
      return new ContentType(this.type._copy());
    }
    /**
     * @param {number} offset
     * @return {ContentType}
     */
    splice(offset) {
      throw methodUnimplemented();
    }
    /**
     * @param {ContentType} right
     * @return {boolean}
     */
    mergeWith(right) {
      return false;
    }
    /**
     * @param {Transaction} transaction
     * @param {Item} item
     */
    integrate(transaction, item) {
      this.type._integrate(transaction.doc, item);
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
      let item = this.type._start;
      while (item !== null) {
        if (!item.deleted) {
          item.delete(transaction);
        } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
          transaction._mergeStructs.push(item);
        }
        item = item.right;
      }
      this.type._map.forEach((item2) => {
        if (!item2.deleted) {
          item2.delete(transaction);
        } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {
          transaction._mergeStructs.push(item2);
        }
      });
      transaction.changed.delete(this.type);
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
      let item = this.type._start;
      while (item !== null) {
        item.gc(store, true);
        item = item.right;
      }
      this.type._start = null;
      this.type._map.forEach(
        /** @param {Item | null} item */
        (item2) => {
          while (item2 !== null) {
            item2.gc(store, true);
            item2 = item2.left;
          }
        }
      );
      this.type._map = /* @__PURE__ */ new Map();
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      this.type._write(encoder);
    }
    /**
     * @return {number}
     */
    getRef() {
      return 7;
    }
  }
  const followRedone = (store, id) => {
    let nextID = id;
    let diff = 0;
    let item;
    do {
      if (diff > 0) {
        nextID = createID(nextID.client, nextID.clock + diff);
      }
      item = getItem(store, nextID);
      diff = nextID.clock - item.id.clock;
      nextID = item.redone;
    } while (nextID !== null && item instanceof Item$1);
    return {
      item,
      diff
    };
  };
  const keepItem = (item, keep) => {
    while (item !== null && item.keep !== keep) {
      item.keep = keep;
      item = /** @type {AbstractType<any>} */
      item.parent._item;
    }
  };
  const splitItem = (transaction, leftItem, diff) => {
    const { client, clock } = leftItem.id;
    const rightItem = new Item$1(
      createID(client, clock + diff),
      leftItem,
      createID(client, clock + diff - 1),
      leftItem.right,
      leftItem.rightOrigin,
      leftItem.parent,
      leftItem.parentSub,
      leftItem.content.splice(diff)
    );
    if (leftItem.deleted) {
      rightItem.markDeleted();
    }
    if (leftItem.keep) {
      rightItem.keep = true;
    }
    if (leftItem.redone !== null) {
      rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
    }
    leftItem.right = rightItem;
    if (rightItem.right !== null) {
      rightItem.right.left = rightItem;
    }
    transaction._mergeStructs.push(rightItem);
    if (rightItem.parentSub !== null && rightItem.right === null) {
      rightItem.parent._map.set(rightItem.parentSub, rightItem);
    }
    leftItem.length = diff;
    return rightItem;
  };
  const isDeletedByUndoStack = (stack, id) => some(
    stack,
    /** @param {StackItem} s */
    (s2) => isDeleted(s2.deletions, id)
  );
  const redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {
    const doc2 = transaction.doc;
    const store = doc2.store;
    const ownClientID = doc2.clientID;
    const redone = item.redone;
    if (redone !== null) {
      return getItemCleanStart(transaction, redone);
    }
    let parentItem = (
      /** @type {AbstractType<any>} */
      item.parent._item
    );
    let left = null;
    let right;
    if (parentItem !== null && parentItem.deleted === true) {
      if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {
        return null;
      }
      while (parentItem.redone !== null) {
        parentItem = getItemCleanStart(transaction, parentItem.redone);
      }
    }
    const parentType = parentItem === null ? (
      /** @type {AbstractType<any>} */
      item.parent
    ) : (
      /** @type {ContentType} */
      parentItem.content.type
    );
    if (item.parentSub === null) {
      left = item.left;
      right = item;
      while (left !== null) {
        let leftTrace = left;
        while (leftTrace !== null && /** @type {AbstractType<any>} */
        leftTrace.parent._item !== parentItem) {
          leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
        }
        if (leftTrace !== null && /** @type {AbstractType<any>} */
        leftTrace.parent._item === parentItem) {
          left = leftTrace;
          break;
        }
        left = left.left;
      }
      while (right !== null) {
        let rightTrace = right;
        while (rightTrace !== null && /** @type {AbstractType<any>} */
        rightTrace.parent._item !== parentItem) {
          rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
        }
        if (rightTrace !== null && /** @type {AbstractType<any>} */
        rightTrace.parent._item === parentItem) {
          right = rightTrace;
          break;
        }
        right = right.right;
      }
    } else {
      right = null;
      if (item.right && !ignoreRemoteMapChanges) {
        left = item;
        while (left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {
          left = left.right;
          while (left.redone)
            left = getItemCleanStart(transaction, left.redone);
        }
        if (left && left.right !== null) {
          return null;
        }
      } else {
        left = parentType._map.get(item.parentSub) || null;
      }
    }
    const nextClock = getState(store, ownClientID);
    const nextId = createID(ownClientID, nextClock);
    const redoneItem = new Item$1(
      nextId,
      left,
      left && left.lastId,
      right,
      right && right.id,
      parentType,
      item.parentSub,
      item.content.copy()
    );
    item.redone = nextId;
    keepItem(redoneItem, true);
    redoneItem.integrate(transaction, 0);
    return redoneItem;
  };
  let Item$1 = class Item2 extends AbstractStruct {
    /**
     * @param {ID} id
     * @param {Item | null} left
     * @param {ID | null} origin
     * @param {Item | null} right
     * @param {ID | null} rightOrigin
     * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
     * @param {string | null} parentSub
     * @param {AbstractContent} content
     */
    constructor(id, left, origin, right, rightOrigin, parent, parentSub, content2) {
      super(id, content2.getLength());
      this.origin = origin;
      this.left = left;
      this.right = right;
      this.rightOrigin = rightOrigin;
      this.parent = parent;
      this.parentSub = parentSub;
      this.redone = null;
      this.content = content2;
      this.info = this.content.isCountable() ? BIT2 : 0;
    }
    /**
     * This is used to mark the item as an indexed fast-search marker
     *
     * @type {boolean}
     */
    set marker(isMarked) {
      if ((this.info & BIT4) > 0 !== isMarked) {
        this.info ^= BIT4;
      }
    }
    get marker() {
      return (this.info & BIT4) > 0;
    }
    /**
     * If true, do not garbage collect this Item.
     */
    get keep() {
      return (this.info & BIT1) > 0;
    }
    set keep(doKeep) {
      if (this.keep !== doKeep) {
        this.info ^= BIT1;
      }
    }
    get countable() {
      return (this.info & BIT2) > 0;
    }
    /**
     * Whether this item was deleted or not.
     * @type {Boolean}
     */
    get deleted() {
      return (this.info & BIT3) > 0;
    }
    set deleted(doDelete) {
      if (this.deleted !== doDelete) {
        this.info ^= BIT3;
      }
    }
    markDeleted() {
      this.info |= BIT3;
    }
    /**
     * Return the creator clientID of the missing op or define missing items and return null.
     *
     * @param {Transaction} transaction
     * @param {StructStore} store
     * @return {null | number}
     */
    getMissing(transaction, store) {
      if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
        return this.origin.client;
      }
      if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
        return this.rightOrigin.client;
      }
      if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
        return this.parent.client;
      }
      if (this.origin) {
        this.left = getItemCleanEnd(transaction, store, this.origin);
        this.origin = this.left.lastId;
      }
      if (this.rightOrigin) {
        this.right = getItemCleanStart(transaction, this.rightOrigin);
        this.rightOrigin = this.right.id;
      }
      if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
        this.parent = null;
      } else if (!this.parent) {
        if (this.left && this.left.constructor === Item2) {
          this.parent = this.left.parent;
          this.parentSub = this.left.parentSub;
        }
        if (this.right && this.right.constructor === Item2) {
          this.parent = this.right.parent;
          this.parentSub = this.right.parentSub;
        }
      } else if (this.parent.constructor === ID) {
        const parentItem = getItem(store, this.parent);
        if (parentItem.constructor === GC) {
          this.parent = null;
        } else {
          this.parent = /** @type {ContentType} */
          parentItem.content.type;
        }
      }
      return null;
    }
    /**
     * @param {Transaction} transaction
     * @param {number} offset
     */
    integrate(transaction, offset) {
      if (offset > 0) {
        this.id.clock += offset;
        this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
        this.origin = this.left.lastId;
        this.content = this.content.splice(offset);
        this.length -= offset;
      }
      if (this.parent) {
        if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
          let left = this.left;
          let o;
          if (left !== null) {
            o = left.right;
          } else if (this.parentSub !== null) {
            o = /** @type {AbstractType<any>} */
            this.parent._map.get(this.parentSub) || null;
            while (o !== null && o.left !== null) {
              o = o.left;
            }
          } else {
            o = /** @type {AbstractType<any>} */
            this.parent._start;
          }
          const conflictingItems = /* @__PURE__ */ new Set();
          const itemsBeforeOrigin = /* @__PURE__ */ new Set();
          while (o !== null && o !== this.right) {
            itemsBeforeOrigin.add(o);
            conflictingItems.add(o);
            if (compareIDs(this.origin, o.origin)) {
              if (o.id.client < this.id.client) {
                left = o;
                conflictingItems.clear();
              } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
                break;
              }
            } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {
              if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
                left = o;
                conflictingItems.clear();
              }
            } else {
              break;
            }
            o = o.right;
          }
          this.left = left;
        }
        if (this.left !== null) {
          const right = this.left.right;
          this.right = right;
          this.left.right = this;
        } else {
          let r;
          if (this.parentSub !== null) {
            r = /** @type {AbstractType<any>} */
            this.parent._map.get(this.parentSub) || null;
            while (r !== null && r.left !== null) {
              r = r.left;
            }
          } else {
            r = /** @type {AbstractType<any>} */
            this.parent._start;
            this.parent._start = this;
          }
          this.right = r;
        }
        if (this.right !== null) {
          this.right.left = this;
        } else if (this.parentSub !== null) {
          this.parent._map.set(this.parentSub, this);
          if (this.left !== null) {
            this.left.delete(transaction);
          }
        }
        if (this.parentSub === null && this.countable && !this.deleted) {
          this.parent._length += this.length;
        }
        addStruct(transaction.doc.store, this);
        this.content.integrate(transaction, this);
        addChangedTypeToTransaction(
          transaction,
          /** @type {AbstractType<any>} */
          this.parent,
          this.parentSub
        );
        if (
          /** @type {AbstractType<any>} */
          this.parent._item !== null && /** @type {AbstractType<any>} */
          this.parent._item.deleted || this.parentSub !== null && this.right !== null
        ) {
          this.delete(transaction);
        }
      } else {
        new GC(this.id, this.length).integrate(transaction, 0);
      }
    }
    /**
     * Returns the next non-deleted item
     */
    get next() {
      let n = this.right;
      while (n !== null && n.deleted) {
        n = n.right;
      }
      return n;
    }
    /**
     * Returns the previous non-deleted item
     */
    get prev() {
      let n = this.left;
      while (n !== null && n.deleted) {
        n = n.left;
      }
      return n;
    }
    /**
     * Computes the last content address of this Item.
     */
    get lastId() {
      return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
    }
    /**
     * Try to merge two items
     *
     * @param {Item} right
     * @return {boolean}
     */
    mergeWith(right) {
      if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
        const searchMarker = (
          /** @type {AbstractType<any>} */
          this.parent._searchMarker
        );
        if (searchMarker) {
          searchMarker.forEach((marker) => {
            if (marker.p === right) {
              marker.p = this;
              if (!this.deleted && this.countable) {
                marker.index -= this.length;
              }
            }
          });
        }
        if (right.keep) {
          this.keep = true;
        }
        this.right = right.right;
        if (this.right !== null) {
          this.right.left = this;
        }
        this.length += right.length;
        return true;
      }
      return false;
    }
    /**
     * Mark this Item as deleted.
     *
     * @param {Transaction} transaction
     */
    delete(transaction) {
      if (!this.deleted) {
        const parent = (
          /** @type {AbstractType<any>} */
          this.parent
        );
        if (this.countable && this.parentSub === null) {
          parent._length -= this.length;
        }
        this.markDeleted();
        addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
        addChangedTypeToTransaction(transaction, parent, this.parentSub);
        this.content.delete(transaction);
      }
    }
    /**
     * @param {StructStore} store
     * @param {boolean} parentGCd
     */
    gc(store, parentGCd) {
      if (!this.deleted) {
        throw unexpectedCase();
      }
      this.content.gc(store);
      if (parentGCd) {
        replaceStruct(store, this, new GC(this.id, this.length));
      } else {
        this.content = new ContentDeleted(this.length);
      }
    }
    /**
     * Transform the properties of this type to binary and write it to an
     * BinaryEncoder.
     *
     * This is called when this Item is sent to a remote peer.
     *
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
     * @param {number} offset
     */
    write(encoder, offset) {
      const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
      const rightOrigin = this.rightOrigin;
      const parentSub = this.parentSub;
      const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined
      (rightOrigin === null ? 0 : BIT7) | // right origin is defined
      (parentSub === null ? 0 : BIT6);
      encoder.writeInfo(info);
      if (origin !== null) {
        encoder.writeLeftID(origin);
      }
      if (rightOrigin !== null) {
        encoder.writeRightID(rightOrigin);
      }
      if (origin === null && rightOrigin === null) {
        const parent = (
          /** @type {AbstractType<any>} */
          this.parent
        );
        if (parent._item !== void 0) {
          const parentItem = parent._item;
          if (parentItem === null) {
            const ykey = findRootTypeKey(parent);
            encoder.writeParentInfo(true);
            encoder.writeString(ykey);
          } else {
            encoder.writeParentInfo(false);
            encoder.writeLeftID(parentItem.id);
          }
        } else if (parent.constructor === String) {
          encoder.writeParentInfo(true);
          encoder.writeString(parent);
        } else if (parent.constructor === ID) {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parent);
        } else {
          unexpectedCase();
        }
        if (parentSub !== null) {
          encoder.writeString(parentSub);
        }
      }
      this.content.write(encoder, offset);
    }
  };
  const glo = (
    /** @type {any} */
    typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
  );
  const importIdentifier = "__ $YJS$ __";
  if (glo[importIdentifier] === true) {
    console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
  }
  glo[importIdentifier] = true;
  const createMutex = () => {
    let token = true;
    return (f, g) => {
      if (token) {
        token = false;
        try {
          f();
        } finally {
          token = true;
        }
      } else if (g !== void 0) {
        g();
      }
    };
  };
  const highSurrogateRegex = /[\uD800-\uDBFF]/;
  const lowSurrogateRegex = /[\uDC00-\uDFFF]/;
  const simpleDiffString = (a2, b) => {
    let left = 0;
    let right = 0;
    while (left < a2.length && left < b.length && a2[left] === b[left]) {
      left++;
    }
    if (left > 0 && highSurrogateRegex.test(a2[left - 1]))
      left--;
    while (right + left < a2.length && right + left < b.length && a2[a2.length - right - 1] === b[b.length - right - 1]) {
      right++;
    }
    if (right > 0 && lowSurrogateRegex.test(a2[a2.length - right]))
      right--;
    return {
      index: left,
      remove: a2.length - left - right,
      insert: b.slice(left, b.length - right)
    };
  };
  const simpleDiff = simpleDiffString;
  const ySyncPluginKey = new PluginKey("y-sync");
  const yUndoPluginKey = new PluginKey("y-undo");
  const yCursorPluginKey = new PluginKey("yjs-cursor");
  const isVisible = (item, snapshot2) => snapshot2 === void 0 ? !item.deleted : snapshot2.sv.has(item.id.client) && /** @type {number} */
  snapshot2.sv.get(item.id.client) > item.id.clock && !isDeleted(snapshot2.ds, item.id);
  const defaultColors = [{ light: "#ecd44433", dark: "#ecd444" }];
  const getUserColor = (colorMapping, colors, user) => {
    if (!colorMapping.has(user)) {
      if (colorMapping.size < colors.length) {
        const usedColors = create$4();
        colorMapping.forEach((color2) => usedColors.add(color2));
        colors = colors.filter((color2) => !usedColors.has(color2));
      }
      colorMapping.set(user, oneOf(colors));
    }
    return (
      /** @type {ColorDef} */
      colorMapping.get(user)
    );
  };
  const ySyncPlugin = (yXmlFragment, {
    colors = defaultColors,
    colorMapping = /* @__PURE__ */ new Map(),
    permanentUserData = null,
    onFirstRender = () => {
    }
  } = {}) => {
    let changedInitialContent = false;
    let rerenderTimeout;
    const plugin = new Plugin({
      props: {
        editable: (state) => {
          const syncState = ySyncPluginKey.getState(state);
          return syncState.snapshot == null && syncState.prevSnapshot == null;
        }
      },
      key: ySyncPluginKey,
      state: {
        /**
         * @returns {any}
         */
        init: (_initargs, _state) => {
          return {
            type: yXmlFragment,
            doc: yXmlFragment.doc,
            binding: null,
            snapshot: null,
            prevSnapshot: null,
            isChangeOrigin: false,
            isUndoRedoOperation: false,
            addToHistory: true,
            colors,
            colorMapping,
            permanentUserData
          };
        },
        apply: (tr2, pluginState) => {
          const change = tr2.getMeta(ySyncPluginKey);
          if (change !== void 0) {
            pluginState = Object.assign({}, pluginState);
            for (const key2 in change) {
              pluginState[key2] = change[key2];
            }
          }
          pluginState.addToHistory = tr2.getMeta("addToHistory") !== false;
          pluginState.isChangeOrigin = change !== void 0 && !!change.isChangeOrigin;
          pluginState.isUndoRedoOperation = change !== void 0 && !!change.isChangeOrigin && !!change.isUndoRedoOperation;
          if (pluginState.binding !== null) {
            if (change !== void 0 && (change.snapshot != null || change.prevSnapshot != null)) {
              timeout(0, () => {
                if (pluginState.binding == null || pluginState.binding.isDestroyed) {
                  return;
                }
                if (change.restore == null) {
                  pluginState.binding._renderSnapshot(
                    change.snapshot,
                    change.prevSnapshot,
                    pluginState
                  );
                } else {
                  pluginState.binding._renderSnapshot(
                    change.snapshot,
                    change.snapshot,
                    pluginState
                  );
                  delete pluginState.restore;
                  delete pluginState.snapshot;
                  delete pluginState.prevSnapshot;
                  pluginState.binding.mux(() => {
                    pluginState.binding._prosemirrorChanged(
                      pluginState.binding.prosemirrorView.state.doc
                    );
                  });
                }
              });
            }
          }
          return pluginState;
        }
      },
      view: (view) => {
        const binding = new ProsemirrorBinding(yXmlFragment, view);
        if (rerenderTimeout != null) {
          rerenderTimeout.destroy();
        }
        rerenderTimeout = timeout(0, () => {
          binding._forceRerender();
          view.dispatch(view.state.tr.setMeta(ySyncPluginKey, { binding }));
          onFirstRender();
        });
        return {
          update: () => {
            const pluginState = plugin.getState(view.state);
            if (pluginState.snapshot == null && pluginState.prevSnapshot == null) {
              if (changedInitialContent || view.state.doc.content.findDiffStart(
                view.state.doc.type.createAndFill().content
              ) !== null) {
                changedInitialContent = true;
                if (pluginState.addToHistory === false && !pluginState.isChangeOrigin) {
                  const yUndoPluginState = yUndoPluginKey.getState(view.state);
                  const um = yUndoPluginState && yUndoPluginState.undoManager;
                  if (um) {
                    um.stopCapturing();
                  }
                }
                binding.mux(() => {
                  pluginState.doc.transact((tr2) => {
                    tr2.meta.set("addToHistory", pluginState.addToHistory);
                    binding._prosemirrorChanged(view.state.doc);
                  }, ySyncPluginKey);
                });
              }
            }
          },
          destroy: () => {
            rerenderTimeout.destroy();
            binding.destroy();
          }
        };
      }
    });
    return plugin;
  };
  const restoreRelativeSelection = (tr2, relSel, binding) => {
    if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {
      const anchor = relativePositionToAbsolutePosition(
        binding.doc,
        binding.type,
        relSel.anchor,
        binding.mapping
      );
      const head2 = relativePositionToAbsolutePosition(
        binding.doc,
        binding.type,
        relSel.head,
        binding.mapping
      );
      if (anchor !== null && head2 !== null) {
        tr2 = tr2.setSelection(TextSelection.create(tr2.doc, anchor, head2));
      }
    }
  };
  const getRelativeSelection = (pmbinding, state) => ({
    anchor: absolutePositionToRelativePosition(
      state.selection.anchor,
      pmbinding.type,
      pmbinding.mapping
    ),
    head: absolutePositionToRelativePosition(
      state.selection.head,
      pmbinding.type,
      pmbinding.mapping
    )
  });
  class ProsemirrorBinding {
    /**
     * @param {Y.XmlFragment} yXmlFragment The bind source
     * @param {any} prosemirrorView The target binding
     */
    constructor(yXmlFragment, prosemirrorView) {
      this.type = yXmlFragment;
      this.prosemirrorView = prosemirrorView;
      this.mux = createMutex();
      this.isDestroyed = false;
      this.mapping = /* @__PURE__ */ new Map();
      this._observeFunction = this._typeChanged.bind(this);
      this.doc = yXmlFragment.doc;
      this.beforeTransactionSelection = null;
      this.beforeAllTransactions = () => {
        if (this.beforeTransactionSelection === null) {
          this.beforeTransactionSelection = getRelativeSelection(
            this,
            prosemirrorView.state
          );
        }
      };
      this.afterAllTransactions = () => {
        this.beforeTransactionSelection = null;
      };
      this.doc.on("beforeAllTransactions", this.beforeAllTransactions);
      this.doc.on("afterAllTransactions", this.afterAllTransactions);
      yXmlFragment.observeDeep(this._observeFunction);
      this._domSelectionInView = null;
    }
    /**
     * Create a transaction for changing the prosemirror state.
     *
     * @returns
     */
    get _tr() {
      return this.prosemirrorView.state.tr.setMeta("addToHistory", false);
    }
    _isLocalCursorInView() {
      if (!this.prosemirrorView.hasFocus())
        return false;
      if (isBrowser && this._domSelectionInView === null) {
        timeout(0, () => {
          this._domSelectionInView = null;
        });
        this._domSelectionInView = this._isDomSelectionInView();
      }
      return this._domSelectionInView;
    }
    _isDomSelectionInView() {
      const selection = this.prosemirrorView._root.getSelection();
      const range = this.prosemirrorView._root.createRange();
      range.setStart(selection.anchorNode, selection.anchorOffset);
      range.setEnd(selection.focusNode, selection.focusOffset);
      const rects = range.getClientRects();
      if (rects.length === 0) {
        if (range.startContainer && range.collapsed) {
          range.selectNodeContents(range.startContainer);
        }
      }
      const bounding = range.getBoundingClientRect();
      const documentElement = doc.documentElement;
      return bounding.bottom >= 0 && bounding.right >= 0 && bounding.left <= (window.innerWidth || documentElement.clientWidth || 0) && bounding.top <= (window.innerHeight || documentElement.clientHeight || 0);
    }
    /**
     * @param {Y.Snapshot} snapshot
     * @param {Y.Snapshot} prevSnapshot
     */
    renderSnapshot(snapshot2, prevSnapshot) {
      if (!prevSnapshot) {
        prevSnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
      }
      this.prosemirrorView.dispatch(
        this._tr.setMeta(ySyncPluginKey, { snapshot: snapshot2, prevSnapshot })
      );
    }
    unrenderSnapshot() {
      this.mapping = /* @__PURE__ */ new Map();
      this.mux(() => {
        const fragmentContent = this.type.toArray().map(
          (t) => createNodeFromYElement(
            /** @type {Y.XmlElement} */
            t,
            this.prosemirrorView.state.schema,
            this.mapping
          )
        ).filter((n) => n !== null);
        const tr2 = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new Slice(Fragment.from(fragmentContent), 0, 0)
        );
        tr2.setMeta(ySyncPluginKey, { snapshot: null, prevSnapshot: null });
        this.prosemirrorView.dispatch(tr2);
      });
    }
    _forceRerender() {
      this.mapping = /* @__PURE__ */ new Map();
      this.mux(() => {
        const fragmentContent = this.type.toArray().map(
          (t) => createNodeFromYElement(
            /** @type {Y.XmlElement} */
            t,
            this.prosemirrorView.state.schema,
            this.mapping
          )
        ).filter((n) => n !== null);
        const tr2 = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new Slice(Fragment.from(fragmentContent), 0, 0)
        );
        this.prosemirrorView.dispatch(
          tr2.setMeta(ySyncPluginKey, { isChangeOrigin: true })
        );
      });
    }
    /**
     * @param {Y.Snapshot} snapshot
     * @param {Y.Snapshot} prevSnapshot
     * @param {Object} pluginState
     */
    _renderSnapshot(snapshot$1, prevSnapshot, pluginState) {
      if (!snapshot$1) {
        snapshot$1 = snapshot(this.doc);
      }
      this.mapping = /* @__PURE__ */ new Map();
      this.mux(() => {
        this.doc.transact((transaction) => {
          const pud = pluginState.permanentUserData;
          if (pud) {
            pud.dss.forEach((ds) => {
              iterateDeletedStructs(transaction, ds, (_item) => {
              });
            });
          }
          const computeYChange = (type, id) => {
            const user = type === "added" ? pud.getUserByClientId(id.client) : pud.getUserByDeletedId(id);
            return {
              user,
              type,
              color: getUserColor(
                pluginState.colorMapping,
                pluginState.colors,
                user
              )
            };
          };
          const fragmentContent = typeListToArraySnapshot(
            this.type,
            new Snapshot(prevSnapshot.ds, snapshot$1.sv)
          ).map((t) => {
            if (!t._item.deleted || isVisible(t._item, snapshot$1) || isVisible(t._item, prevSnapshot)) {
              return createNodeFromYElement(
                t,
                this.prosemirrorView.state.schema,
                /* @__PURE__ */ new Map(),
                snapshot$1,
                prevSnapshot,
                computeYChange
              );
            } else {
              return null;
            }
          }).filter((n) => n !== null);
          const tr2 = this._tr.replace(
            0,
            this.prosemirrorView.state.doc.content.size,
            new Slice(Fragment.from(fragmentContent), 0, 0)
          );
          this.prosemirrorView.dispatch(
            tr2.setMeta(ySyncPluginKey, { isChangeOrigin: true })
          );
        }, ySyncPluginKey);
      });
    }
    /**
     * @param {Array<Y.YEvent<any>>} events
     * @param {Y.Transaction} transaction
     */
    _typeChanged(events, transaction) {
      const syncState = ySyncPluginKey.getState(this.prosemirrorView.state);
      if (events.length === 0 || syncState.snapshot != null || syncState.prevSnapshot != null) {
        this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot);
        return;
      }
      this.mux(() => {
        const delType = (_, type) => this.mapping.delete(type);
        iterateDeletedStructs(
          transaction,
          transaction.deleteSet,
          (struct) => {
            if (struct.constructor === Item$1) {
              const type = (
                /** @type {Y.ContentType} */
                /** @type {Y.Item} */
                struct.content.type
              );
              type && this.mapping.delete(type);
            }
          }
        );
        transaction.changed.forEach(delType);
        transaction.changedParentTypes.forEach(delType);
        const fragmentContent = this.type.toArray().map(
          (t) => createNodeIfNotExists(
            /** @type {Y.XmlElement | Y.XmlHook} */
            t,
            this.prosemirrorView.state.schema,
            this.mapping
          )
        ).filter((n) => n !== null);
        let tr2 = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new Slice(Fragment.from(fragmentContent), 0, 0)
        );
        restoreRelativeSelection(tr2, this.beforeTransactionSelection, this);
        tr2 = tr2.setMeta(ySyncPluginKey, { isChangeOrigin: true, isUndoRedoOperation: transaction.origin instanceof UndoManager });
        if (this.beforeTransactionSelection !== null && this._isLocalCursorInView()) {
          tr2.scrollIntoView();
        }
        this.prosemirrorView.dispatch(tr2);
      });
    }
    _prosemirrorChanged(doc2) {
      this.doc.transact(() => {
        updateYFragment(this.doc, this.type, doc2, this.mapping);
        this.beforeTransactionSelection = getRelativeSelection(
          this,
          this.prosemirrorView.state
        );
      }, ySyncPluginKey);
    }
    destroy() {
      this.isDestroyed = true;
      this.type.unobserveDeep(this._observeFunction);
      this.doc.off("beforeAllTransactions", this.beforeAllTransactions);
      this.doc.off("afterAllTransactions", this.afterAllTransactions);
    }
  }
  const createNodeIfNotExists = (el, schema, mapping, snapshot2, prevSnapshot, computeYChange) => {
    const node2 = (
      /** @type {PModel.Node} */
      mapping.get(el)
    );
    if (node2 === void 0) {
      if (el instanceof YXmlElement) {
        return createNodeFromYElement(
          el,
          schema,
          mapping,
          snapshot2,
          prevSnapshot,
          computeYChange
        );
      } else {
        throw methodUnimplemented();
      }
    }
    return node2;
  };
  const createNodeFromYElement = (el, schema, mapping, snapshot2, prevSnapshot, computeYChange) => {
    const children = [];
    const createChildren = (type) => {
      if (type.constructor === YXmlElement) {
        const n = createNodeIfNotExists(
          type,
          schema,
          mapping,
          snapshot2,
          prevSnapshot,
          computeYChange
        );
        if (n !== null) {
          children.push(n);
        }
      } else {
        const ns = createTextNodesFromYText(
          type,
          schema,
          mapping,
          snapshot2,
          prevSnapshot,
          computeYChange
        );
        if (ns !== null) {
          ns.forEach((textchild) => {
            if (textchild !== null) {
              children.push(textchild);
            }
          });
        }
      }
    };
    if (snapshot2 === void 0 || prevSnapshot === void 0) {
      el.toArray().forEach(createChildren);
    } else {
      typeListToArraySnapshot(el, new Snapshot(prevSnapshot.ds, snapshot2.sv)).forEach(createChildren);
    }
    try {
      const attrs = el.getAttributes(snapshot2);
      if (snapshot2 !== void 0) {
        if (!isVisible(
          /** @type {Y.Item} */
          el._item,
          snapshot2
        )) {
          attrs.ychange = computeYChange ? computeYChange(
            "removed",
            /** @type {Y.Item} */
            el._item.id
          ) : { type: "removed" };
        } else if (!isVisible(
          /** @type {Y.Item} */
          el._item,
          prevSnapshot
        )) {
          attrs.ychange = computeYChange ? computeYChange(
            "added",
            /** @type {Y.Item} */
            el._item.id
          ) : { type: "added" };
        }
      }
      const node2 = schema.node(el.nodeName, attrs, children);
      mapping.set(el, node2);
      return node2;
    } catch (e) {
      el.doc.transact((transaction) => {
        el._item.delete(transaction);
      }, ySyncPluginKey);
      mapping.delete(el);
      return null;
    }
  };
  const createTextNodesFromYText = (text2, schema, _mapping, snapshot2, prevSnapshot, computeYChange) => {
    const nodes = [];
    const deltas = text2.toDelta(snapshot2, prevSnapshot, computeYChange);
    try {
      for (let i2 = 0; i2 < deltas.length; i2++) {
        const delta = deltas[i2];
        const marks = [];
        for (const markName in delta.attributes) {
          marks.push(schema.mark(markName, delta.attributes[markName]));
        }
        nodes.push(schema.text(delta.insert, marks));
      }
    } catch (e) {
      text2.doc.transact((transaction) => {
        text2._item.delete(transaction);
      }, ySyncPluginKey);
      return null;
    }
    return nodes;
  };
  const createTypeFromTextNodes = (nodes, mapping) => {
    const type = new YXmlText();
    const delta = nodes.map((node2) => ({
      // @ts-ignore
      insert: node2.text,
      attributes: marksToAttributes(node2.marks)
    }));
    type.applyDelta(delta);
    mapping.set(type, nodes);
    return type;
  };
  const createTypeFromElementNode = (node2, mapping) => {
    const type = new YXmlElement(node2.type.name);
    for (const key2 in node2.attrs) {
      const val = node2.attrs[key2];
      if (val !== null && key2 !== "ychange") {
        type.setAttribute(key2, val);
      }
    }
    type.insert(
      0,
      normalizePNodeContent(node2).map(
        (n) => createTypeFromTextOrElementNode(n, mapping)
      )
    );
    mapping.set(type, node2);
    return type;
  };
  const createTypeFromTextOrElementNode = (node2, mapping) => node2 instanceof Array ? createTypeFromTextNodes(node2, mapping) : createTypeFromElementNode(node2, mapping);
  const isObject = (val) => typeof val === "object" && val !== null;
  const equalAttrs = (pattrs, yattrs) => {
    const keys2 = Object.keys(pattrs).filter((key2) => pattrs[key2] !== null);
    let eq = keys2.length === Object.keys(yattrs).filter((key2) => yattrs[key2] !== null).length;
    for (let i2 = 0; i2 < keys2.length && eq; i2++) {
      const key2 = keys2[i2];
      const l = pattrs[key2];
      const r = yattrs[key2];
      eq = key2 === "ychange" || l === r || isObject(l) && isObject(r) && equalAttrs(l, r);
    }
    return eq;
  };
  const normalizePNodeContent = (pnode) => {
    const c = pnode.content.content;
    const res = [];
    for (let i2 = 0; i2 < c.length; i2++) {
      const n = c[i2];
      if (n.isText) {
        const textNodes = [];
        for (let tnode = c[i2]; i2 < c.length && tnode.isText; tnode = c[++i2]) {
          textNodes.push(tnode);
        }
        i2--;
        res.push(textNodes);
      } else {
        res.push(n);
      }
    }
    return res;
  };
  const equalYTextPText = (ytext, ptexts) => {
    const delta = ytext.toDelta();
    return delta.length === ptexts.length && delta.every(
      (d, i2) => d.insert === /** @type {any} */
      ptexts[i2].text && keys(d.attributes || {}).length === ptexts[i2].marks.length && ptexts[i2].marks.every(
        (mark2) => equalAttrs(d.attributes[mark2.type.name] || {}, mark2.attrs)
      )
    );
  };
  const equalYTypePNode = (ytype, pnode) => {
    if (ytype instanceof YXmlElement && !(pnode instanceof Array) && matchNodeName(ytype, pnode)) {
      const normalizedContent = normalizePNodeContent(pnode);
      return ytype._length === normalizedContent.length && equalAttrs(ytype.getAttributes(), pnode.attrs) && ytype.toArray().every(
        (ychild, i2) => equalYTypePNode(ychild, normalizedContent[i2])
      );
    }
    return ytype instanceof YXmlText && pnode instanceof Array && equalYTextPText(ytype, pnode);
  };
  const mappedIdentity = (mapped, pcontent) => mapped === pcontent || mapped instanceof Array && pcontent instanceof Array && mapped.length === pcontent.length && mapped.every(
    (a2, i2) => pcontent[i2] === a2
  );
  const computeChildEqualityFactor = (ytype, pnode, mapping) => {
    const yChildren = ytype.toArray();
    const pChildren = normalizePNodeContent(pnode);
    const pChildCnt = pChildren.length;
    const yChildCnt = yChildren.length;
    const minCnt = min(yChildCnt, pChildCnt);
    let left = 0;
    let right = 0;
    let foundMappedChild = false;
    for (; left < minCnt; left++) {
      const leftY = yChildren[left];
      const leftP = pChildren[left];
      if (mappedIdentity(mapping.get(leftY), leftP)) {
        foundMappedChild = true;
      } else if (!equalYTypePNode(leftY, leftP)) {
        break;
      }
    }
    for (; left + right < minCnt; right++) {
      const rightY = yChildren[yChildCnt - right - 1];
      const rightP = pChildren[pChildCnt - right - 1];
      if (mappedIdentity(mapping.get(rightY), rightP)) {
        foundMappedChild = true;
      } else if (!equalYTypePNode(rightY, rightP)) {
        break;
      }
    }
    return {
      equalityFactor: left + right,
      foundMappedChild
    };
  };
  const ytextTrans = (ytext) => {
    let str = "";
    let n = ytext._start;
    const nAttrs = {};
    while (n !== null) {
      if (!n.deleted) {
        if (n.countable && n.content instanceof ContentString) {
          str += n.content.str;
        } else if (n.content instanceof ContentFormat) {
          nAttrs[n.content.key] = null;
        }
      }
      n = n.right;
    }
    return {
      str,
      nAttrs
    };
  };
  const updateYText = (ytext, ptexts, mapping) => {
    mapping.set(ytext, ptexts);
    const { nAttrs, str } = ytextTrans(ytext);
    const content2 = ptexts.map((p2) => ({
      insert: (
        /** @type {any} */
        p2.text
      ),
      attributes: Object.assign({}, nAttrs, marksToAttributes(p2.marks))
    }));
    const { insert, remove, index: index2 } = simpleDiff(
      str,
      content2.map((c) => c.insert).join("")
    );
    ytext.delete(index2, remove);
    ytext.insert(index2, insert);
    ytext.applyDelta(
      content2.map((c) => ({ retain: c.insert.length, attributes: c.attributes }))
    );
  };
  const marksToAttributes = (marks) => {
    const pattrs = {};
    marks.forEach((mark2) => {
      if (mark2.type.name !== "ychange") {
        pattrs[mark2.type.name] = mark2.attrs;
      }
    });
    return pattrs;
  };
  const updateYFragment = (y, yDomFragment, pNode, mapping) => {
    if (yDomFragment instanceof YXmlElement && yDomFragment.nodeName !== pNode.type.name) {
      throw new Error("node name mismatch!");
    }
    mapping.set(yDomFragment, pNode);
    if (yDomFragment instanceof YXmlElement) {
      const yDomAttrs = yDomFragment.getAttributes();
      const pAttrs = pNode.attrs;
      for (const key2 in pAttrs) {
        if (pAttrs[key2] !== null) {
          if (yDomAttrs[key2] !== pAttrs[key2] && key2 !== "ychange") {
            yDomFragment.setAttribute(key2, pAttrs[key2]);
          }
        } else {
          yDomFragment.removeAttribute(key2);
        }
      }
      for (const key2 in yDomAttrs) {
        if (pAttrs[key2] === void 0) {
          yDomFragment.removeAttribute(key2);
        }
      }
    }
    const pChildren = normalizePNodeContent(pNode);
    const pChildCnt = pChildren.length;
    const yChildren = yDomFragment.toArray();
    const yChildCnt = yChildren.length;
    const minCnt = min(pChildCnt, yChildCnt);
    let left = 0;
    let right = 0;
    for (; left < minCnt; left++) {
      const leftY = yChildren[left];
      const leftP = pChildren[left];
      if (!mappedIdentity(mapping.get(leftY), leftP)) {
        if (equalYTypePNode(leftY, leftP)) {
          mapping.set(leftY, leftP);
        } else {
          break;
        }
      }
    }
    for (; right + left + 1 < minCnt; right++) {
      const rightY = yChildren[yChildCnt - right - 1];
      const rightP = pChildren[pChildCnt - right - 1];
      if (!mappedIdentity(mapping.get(rightY), rightP)) {
        if (equalYTypePNode(rightY, rightP)) {
          mapping.set(rightY, rightP);
        } else {
          break;
        }
      }
    }
    y.transact(() => {
      while (yChildCnt - left - right > 0 && pChildCnt - left - right > 0) {
        const leftY = yChildren[left];
        const leftP = pChildren[left];
        const rightY = yChildren[yChildCnt - right - 1];
        const rightP = pChildren[pChildCnt - right - 1];
        if (leftY instanceof YXmlText && leftP instanceof Array) {
          if (!equalYTextPText(leftY, leftP)) {
            updateYText(leftY, leftP, mapping);
          }
          left += 1;
        } else {
          let updateLeft = leftY instanceof YXmlElement && matchNodeName(leftY, leftP);
          let updateRight = rightY instanceof YXmlElement && matchNodeName(rightY, rightP);
          if (updateLeft && updateRight) {
            const equalityLeft = computeChildEqualityFactor(
              /** @type {Y.XmlElement} */
              leftY,
              /** @type {PModel.Node} */
              leftP,
              mapping
            );
            const equalityRight = computeChildEqualityFactor(
              /** @type {Y.XmlElement} */
              rightY,
              /** @type {PModel.Node} */
              rightP,
              mapping
            );
            if (equalityLeft.foundMappedChild && !equalityRight.foundMappedChild) {
              updateRight = false;
            } else if (!equalityLeft.foundMappedChild && equalityRight.foundMappedChild) {
              updateLeft = false;
            } else if (equalityLeft.equalityFactor < equalityRight.equalityFactor) {
              updateLeft = false;
            } else {
              updateRight = false;
            }
          }
          if (updateLeft) {
            updateYFragment(
              y,
              /** @type {Y.XmlFragment} */
              leftY,
              /** @type {PModel.Node} */
              leftP,
              mapping
            );
            left += 1;
          } else if (updateRight) {
            updateYFragment(
              y,
              /** @type {Y.XmlFragment} */
              rightY,
              /** @type {PModel.Node} */
              rightP,
              mapping
            );
            right += 1;
          } else {
            mapping.delete(yDomFragment.get(left));
            yDomFragment.delete(left, 1);
            yDomFragment.insert(left, [
              createTypeFromTextOrElementNode(leftP, mapping)
            ]);
            left += 1;
          }
        }
      }
      const yDelLen = yChildCnt - left - right;
      if (yChildCnt === 1 && pChildCnt === 0 && yChildren[0] instanceof YXmlText) {
        mapping.delete(yChildren[0]);
        yChildren[0].delete(0, yChildren[0].length);
      } else if (yDelLen > 0) {
        yDomFragment.slice(left, left + yDelLen).forEach((type) => mapping.delete(type));
        yDomFragment.delete(left, yDelLen);
      }
      if (left + right < pChildCnt) {
        const ins = [];
        for (let i2 = left; i2 < pChildCnt - right; i2++) {
          ins.push(createTypeFromTextOrElementNode(pChildren[i2], mapping));
        }
        yDomFragment.insert(left, ins);
      }
    }, ySyncPluginKey);
  };
  const matchNodeName = (yElement, pNode) => !(pNode instanceof Array) && yElement.nodeName === pNode.type.name;
  let viewsToUpdate = null;
  const updateMetas = () => {
    const ups = (
      /** @type {Map<EditorView, Map<any, any>>} */
      viewsToUpdate
    );
    viewsToUpdate = null;
    ups.forEach((metas, view) => {
      const tr2 = view.state.tr;
      const syncState = ySyncPluginKey.getState(view.state);
      if (syncState && syncState.binding && !syncState.binding.isDestroyed) {
        metas.forEach((val, key2) => {
          tr2.setMeta(key2, val);
        });
        view.dispatch(tr2);
      }
    });
  };
  const setMeta = (view, key2, value) => {
    if (!viewsToUpdate) {
      viewsToUpdate = /* @__PURE__ */ new Map();
      timeout(0, updateMetas);
    }
    setIfUndefined(viewsToUpdate, view, create$5).set(key2, value);
  };
  const absolutePositionToRelativePosition = (pos, type, mapping) => {
    if (pos === 0) {
      return createRelativePositionFromTypeIndex(type, 0);
    }
    let n = type._first === null ? null : (
      /** @type {Y.ContentType} */
      type._first.content.type
    );
    while (n !== null && type !== n) {
      if (n instanceof YXmlText) {
        if (n._length >= pos) {
          return createRelativePositionFromTypeIndex(n, pos);
        } else {
          pos -= n._length;
        }
        if (n._item !== null && n._item.next !== null) {
          n = /** @type {Y.ContentType} */
          n._item.next.content.type;
        } else {
          do {
            n = n._item === null ? null : n._item.parent;
            pos--;
          } while (n !== type && n !== null && n._item !== null && n._item.next === null);
          if (n !== null && n !== type) {
            n = n._item === null ? null : (
              /** @type {Y.ContentType} */
              /** @type Y.Item */
              n._item.next.content.type
            );
          }
        }
      } else {
        const pNodeSize = (
          /** @type {any} */
          (mapping.get(n) || { nodeSize: 0 }).nodeSize
        );
        if (n._first !== null && pos < pNodeSize) {
          n = /** @type {Y.ContentType} */
          n._first.content.type;
          pos--;
        } else {
          if (pos === 1 && n._length === 0 && pNodeSize > 1) {
            return new RelativePosition(n._item === null ? null : n._item.id, n._item === null ? findRootTypeKey(n) : null, null);
          }
          pos -= pNodeSize;
          if (n._item !== null && n._item.next !== null) {
            n = /** @type {Y.ContentType} */
            n._item.next.content.type;
          } else {
            if (pos === 0) {
              n = n._item === null ? n : n._item.parent;
              return new RelativePosition(n._item === null ? null : n._item.id, n._item === null ? findRootTypeKey(n) : null, null);
            }
            do {
              n = /** @type {Y.Item} */
              n._item.parent;
              pos--;
            } while (n !== type && /** @type {Y.Item} */
            n._item.next === null);
            if (n !== type) {
              n = /** @type {Y.ContentType} */
              /** @type {Y.Item} */
              /** @type {Y.Item} */
              n._item.next.content.type;
            }
          }
        }
      }
      if (n === null) {
        throw unexpectedCase();
      }
      if (pos === 0 && n.constructor !== YXmlText && n !== type) {
        return createRelativePosition(n._item.parent, n._item);
      }
    }
    return createRelativePositionFromTypeIndex(type, type._length);
  };
  const createRelativePosition = (type, item) => {
    let typeid = null;
    let tname = null;
    if (type._item === null) {
      tname = findRootTypeKey(type);
    } else {
      typeid = createID(type._item.id.client, type._item.id.clock);
    }
    return new RelativePosition(typeid, tname, item.id);
  };
  const relativePositionToAbsolutePosition = (y, documentType, relPos, mapping) => {
    const decodedPos = createAbsolutePositionFromRelativePosition(relPos, y);
    if (decodedPos === null || decodedPos.type !== documentType && !isParentOf(documentType, decodedPos.type._item)) {
      return null;
    }
    let type = decodedPos.type;
    let pos = 0;
    if (type.constructor === YXmlText) {
      pos = decodedPos.index;
    } else if (type._item === null || !type._item.deleted) {
      let n = type._first;
      let i2 = 0;
      while (i2 < type._length && i2 < decodedPos.index && n !== null) {
        if (!n.deleted) {
          const t = (
            /** @type {Y.ContentType} */
            n.content.type
          );
          i2++;
          if (t instanceof YXmlText) {
            pos += t._length;
          } else {
            pos += /** @type {any} */
            mapping.get(t).nodeSize;
          }
        }
        n = /** @type {Y.Item} */
        n.right;
      }
      pos += 1;
    }
    while (type !== documentType && type._item !== null) {
      const parent = type._item.parent;
      if (parent._item === null || !parent._item.deleted) {
        pos += 1;
        let n = (
          /** @type {Y.AbstractType} */
          parent._first
        );
        while (n !== null) {
          const contentType = (
            /** @type {Y.ContentType} */
            n.content.type
          );
          if (contentType === type) {
            break;
          }
          if (!n.deleted) {
            if (contentType instanceof YXmlText) {
              pos += contentType._length;
            } else {
              pos += /** @type {any} */
              mapping.get(contentType).nodeSize;
            }
          }
          n = n.right;
        }
      }
      type = /** @type {Y.AbstractType} */
      parent;
    }
    return pos - 1;
  };
  const defaultCursorBuilder = (user) => {
    const cursor = document.createElement("span");
    cursor.classList.add("ProseMirror-yjs-cursor");
    cursor.setAttribute("style", `border-color: ${user.color}`);
    const userDiv = document.createElement("div");
    userDiv.setAttribute("style", `background-color: ${user.color}`);
    userDiv.insertBefore(document.createTextNode(user.name), null);
    const nonbreakingSpace1 = document.createTextNode("⁠");
    const nonbreakingSpace2 = document.createTextNode("⁠");
    cursor.insertBefore(nonbreakingSpace1, null);
    cursor.insertBefore(userDiv, null);
    cursor.insertBefore(nonbreakingSpace2, null);
    return cursor;
  };
  const defaultSelectionBuilder = (user) => {
    return {
      style: `background-color: ${user.color}70`,
      class: "ProseMirror-yjs-selection"
    };
  };
  const rxValidColor = /^#[0-9a-fA-F]{6}$/;
  const createDecorations = (state, awareness, createCursor, createSelection) => {
    const ystate = ySyncPluginKey.getState(state);
    const y = ystate.doc;
    const decorations = [];
    if (ystate.snapshot != null || ystate.prevSnapshot != null || ystate.binding === null) {
      return DecorationSet.create(state.doc, []);
    }
    awareness.getStates().forEach((aw, clientId) => {
      if (clientId === y.clientID) {
        return;
      }
      if (aw.cursor != null) {
        const user = aw.user || {};
        if (user.color == null) {
          user.color = "#ffa500";
        } else if (!rxValidColor.test(user.color)) {
          console.warn("A user uses an unsupported color format", user);
        }
        if (user.name == null) {
          user.name = `User: ${clientId}`;
        }
        let anchor = relativePositionToAbsolutePosition(
          y,
          ystate.type,
          createRelativePositionFromJSON(aw.cursor.anchor),
          ystate.binding.mapping
        );
        let head2 = relativePositionToAbsolutePosition(
          y,
          ystate.type,
          createRelativePositionFromJSON(aw.cursor.head),
          ystate.binding.mapping
        );
        if (anchor !== null && head2 !== null) {
          const maxsize = max(state.doc.content.size - 1, 0);
          anchor = min(anchor, maxsize);
          head2 = min(head2, maxsize);
          decorations.push(
            Decoration.widget(head2, () => createCursor(user), {
              key: clientId + "",
              side: 10
            })
          );
          const from2 = min(anchor, head2);
          const to = max(anchor, head2);
          decorations.push(
            Decoration.inline(from2, to, createSelection(user), {
              inclusiveEnd: true,
              inclusiveStart: false
            })
          );
        }
      }
    });
    return DecorationSet.create(state.doc, decorations);
  };
  const yCursorPlugin = (awareness, {
    cursorBuilder = defaultCursorBuilder,
    selectionBuilder = defaultSelectionBuilder,
    getSelection: getSelection2 = (state) => state.selection
  } = {}, cursorStateField = "cursor") => new Plugin({
    key: yCursorPluginKey,
    state: {
      init(_, state) {
        return createDecorations(
          state,
          awareness,
          cursorBuilder,
          selectionBuilder
        );
      },
      apply(tr2, prevState, _oldState, newState) {
        const ystate = ySyncPluginKey.getState(newState);
        const yCursorState = tr2.getMeta(yCursorPluginKey);
        if (ystate && ystate.isChangeOrigin || yCursorState && yCursorState.awarenessUpdated) {
          return createDecorations(
            newState,
            awareness,
            cursorBuilder,
            selectionBuilder
          );
        }
        return prevState.map(tr2.mapping, tr2.doc);
      }
    },
    props: {
      decorations: (state) => {
        return yCursorPluginKey.getState(state);
      }
    },
    view: (view) => {
      const awarenessListener = () => {
        if (view.docView) {
          setMeta(view, yCursorPluginKey, { awarenessUpdated: true });
        }
      };
      const updateCursorInfo = () => {
        const ystate = ySyncPluginKey.getState(view.state);
        const current = awareness.getLocalState() || {};
        if (ystate.binding == null) {
          return;
        }
        if (view.hasFocus()) {
          const selection = getSelection2(view.state);
          const anchor = absolutePositionToRelativePosition(
            selection.anchor,
            ystate.type,
            ystate.binding.mapping
          );
          const head2 = absolutePositionToRelativePosition(
            selection.head,
            ystate.type,
            ystate.binding.mapping
          );
          if (current.cursor == null || !compareRelativePositions(
            createRelativePositionFromJSON(current.cursor.anchor),
            anchor
          ) || !compareRelativePositions(
            createRelativePositionFromJSON(current.cursor.head),
            head2
          )) {
            awareness.setLocalStateField(cursorStateField, {
              anchor,
              head: head2
            });
          }
        } else if (current.cursor != null && relativePositionToAbsolutePosition(
          ystate.doc,
          ystate.type,
          createRelativePositionFromJSON(current.cursor.anchor),
          ystate.binding.mapping
        ) !== null) {
          awareness.setLocalStateField(cursorStateField, null);
        }
      };
      awareness.on("change", awarenessListener);
      view.dom.addEventListener("focusin", updateCursorInfo);
      view.dom.addEventListener("focusout", updateCursorInfo);
      return {
        update: updateCursorInfo,
        destroy: () => {
          view.dom.removeEventListener("focusin", updateCursorInfo);
          view.dom.removeEventListener("focusout", updateCursorInfo);
          awareness.off("change", awarenessListener);
          awareness.setLocalStateField(cursorStateField, null);
        }
      };
    }
  });
  const undo$1 = (state) => {
    const undoManager = yUndoPluginKey.getState(state).undoManager;
    if (undoManager != null) {
      undoManager.undo();
      return true;
    }
  };
  const redo$1 = (state) => {
    const undoManager = yUndoPluginKey.getState(state).undoManager;
    if (undoManager != null) {
      undoManager.redo();
      return true;
    }
  };
  const defaultProtectedNodes = /* @__PURE__ */ new Set(["paragraph"]);
  const defaultDeleteFilter = (item, protectedNodes) => !(item instanceof Item$1) || !(item.content instanceof ContentType) || !(item.content.type instanceof YText || item.content.type instanceof YXmlElement && protectedNodes.has(item.content.type.nodeName)) || item.content.type._length === 0;
  const yUndoPlugin = ({ protectedNodes = defaultProtectedNodes, trackedOrigins = [], undoManager = null } = {}) => new Plugin({
    key: yUndoPluginKey,
    state: {
      init: (initargs, state) => {
        const ystate = ySyncPluginKey.getState(state);
        const _undoManager = undoManager || new UndoManager(ystate.type, {
          trackedOrigins: new Set([ySyncPluginKey].concat(trackedOrigins)),
          deleteFilter: (item) => defaultDeleteFilter(item, protectedNodes),
          captureTransaction: (tr2) => tr2.meta.get("addToHistory") !== false
        });
        return {
          undoManager: _undoManager,
          prevSel: null,
          hasUndoOps: _undoManager.undoStack.length > 0,
          hasRedoOps: _undoManager.redoStack.length > 0
        };
      },
      /**
       * @returns {any}
       */
      apply: (tr2, val, oldState, state) => {
        const binding = ySyncPluginKey.getState(state).binding;
        const undoManager2 = val.undoManager;
        const hasUndoOps = undoManager2.undoStack.length > 0;
        const hasRedoOps = undoManager2.redoStack.length > 0;
        if (binding) {
          return {
            undoManager: undoManager2,
            prevSel: getRelativeSelection(binding, oldState),
            hasUndoOps,
            hasRedoOps
          };
        } else {
          if (hasUndoOps !== val.hasUndoOps || hasRedoOps !== val.hasRedoOps) {
            return Object.assign({}, val, {
              hasUndoOps: undoManager2.undoStack.length > 0,
              hasRedoOps: undoManager2.redoStack.length > 0
            });
          } else {
            return val;
          }
        }
      }
    },
    view: (view) => {
      const ystate = ySyncPluginKey.getState(view.state);
      const undoManager2 = yUndoPluginKey.getState(view.state).undoManager;
      undoManager2.on("stack-item-added", ({ stackItem }) => {
        const binding = ystate.binding;
        if (binding) {
          stackItem.meta.set(binding, yUndoPluginKey.getState(view.state).prevSel);
        }
      });
      undoManager2.on("stack-item-popped", ({ stackItem }) => {
        const binding = ystate.binding;
        if (binding) {
          binding.beforeTransactionSelection = stackItem.meta.get(binding) || binding.beforeTransactionSelection;
        }
      });
      return {
        destroy: () => {
          undoManager2.destroy();
        }
      };
    }
  });
  const Collaboration = Extension.create({
    name: "collaboration",
    priority: 1e3,
    addOptions() {
      return {
        document: null,
        field: "default",
        fragment: null
      };
    },
    onCreate() {
      if (this.editor.extensionManager.extensions.find((extension2) => extension2.name === "history")) {
        console.warn('[tiptap warn]: "@tiptap/extension-collaboration" comes with its own history support and is not compatible with "@tiptap/extension-history".');
      }
    },
    addCommands() {
      return {
        undo: () => ({ tr: tr2, state, dispatch }) => {
          tr2.setMeta("preventDispatch", true);
          const undoManager = yUndoPluginKey.getState(state).undoManager;
          if (undoManager.undoStack.length === 0) {
            return false;
          }
          if (!dispatch) {
            return true;
          }
          return undo$1(state);
        },
        redo: () => ({ tr: tr2, state, dispatch }) => {
          tr2.setMeta("preventDispatch", true);
          const undoManager = yUndoPluginKey.getState(state).undoManager;
          if (undoManager.redoStack.length === 0) {
            return false;
          }
          if (!dispatch) {
            return true;
          }
          return redo$1(state);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-z": () => this.editor.commands.undo(),
        "Mod-y": () => this.editor.commands.redo(),
        "Shift-Mod-z": () => this.editor.commands.redo()
      };
    },
    addProseMirrorPlugins() {
      const fragment = this.options.fragment ? this.options.fragment : this.options.document.getXmlFragment(this.options.field);
      const yUndoPluginInstance = yUndoPlugin();
      const originalUndoPluginView = yUndoPluginInstance.spec.view;
      yUndoPluginInstance.spec.view = (view) => {
        const { undoManager } = yUndoPluginKey.getState(view.state);
        if (undoManager.restore) {
          undoManager.restore();
          undoManager.restore = () => {
          };
        }
        const viewRet = originalUndoPluginView ? originalUndoPluginView(view) : void 0;
        return {
          destroy: () => {
            const hasUndoManSelf = undoManager.trackedOrigins.has(undoManager);
            const observers = undoManager._observers;
            undoManager.restore = () => {
              if (hasUndoManSelf) {
                undoManager.trackedOrigins.add(undoManager);
              }
              undoManager.doc.on("afterTransaction", undoManager.afterTransactionHandler);
              undoManager._observers = observers;
            };
            if (viewRet === null || viewRet === void 0 ? void 0 : viewRet.destroy) {
              viewRet.destroy();
            }
          }
        };
      };
      const onFirstRender = this.options.onFirstRender;
      const ySyncPluginOptions = onFirstRender ? { onFirstRender } : {};
      const ySyncPluginInstance = ySyncPlugin(fragment, ySyncPluginOptions);
      return [ySyncPluginInstance, yUndoPluginInstance];
    }
  });
  const awarenessStatesToArray = (states) => {
    return Array.from(states.entries()).map(([key2, value]) => {
      return {
        clientId: key2,
        ...value.user
      };
    });
  };
  const defaultOnUpdate = () => null;
  const CollaborationCursor = Extension.create({
    name: "collaborationCursor",
    addOptions() {
      return {
        provider: null,
        user: {
          name: null,
          color: null
        },
        render: (user) => {
          const cursor = document.createElement("span");
          cursor.classList.add("collaboration-cursor__caret");
          cursor.setAttribute("style", `border-color: ${user.color}`);
          const label = document.createElement("div");
          label.classList.add("collaboration-cursor__label");
          label.setAttribute("style", `background-color: ${user.color}`);
          label.insertBefore(document.createTextNode(user.name), null);
          cursor.insertBefore(label, null);
          return cursor;
        },
        selectionRender: defaultSelectionBuilder,
        onUpdate: defaultOnUpdate
      };
    },
    onCreate() {
      if (this.options.onUpdate !== defaultOnUpdate) {
        console.warn('[tiptap warn]: DEPRECATED: The "onUpdate" option is deprecated. Please use `editor.storage.collaborationCursor.users` instead. Read more: https://tiptap.dev/api/extensions/collaboration-cursor');
      }
    },
    addStorage() {
      return {
        users: []
      };
    },
    addCommands() {
      return {
        updateUser: (attributes) => () => {
          this.options.user = attributes;
          this.options.provider.awareness.setLocalStateField("user", this.options.user);
          return true;
        },
        user: (attributes) => ({ editor: editor2 }) => {
          console.warn('[tiptap warn]: DEPRECATED: The "user" command is deprecated. Please use "updateUser" instead. Read more: https://tiptap.dev/api/extensions/collaboration-cursor');
          return editor2.commands.updateUser(attributes);
        }
      };
    },
    addProseMirrorPlugins() {
      return [
        yCursorPlugin(
          (() => {
            this.options.provider.awareness.setLocalStateField("user", this.options.user);
            this.storage.users = awarenessStatesToArray(this.options.provider.awareness.states);
            this.options.provider.awareness.on("update", () => {
              this.storage.users = awarenessStatesToArray(this.options.provider.awareness.states);
            });
            return this.options.provider.awareness;
          })(),
          // @ts-ignore
          {
            cursorBuilder: this.options.render,
            selectionBuilder: this.options.selectionRender
          }
        )
      ];
    }
  });
  function dropCursor(options = {}) {
    return new Plugin({
      view(editorView) {
        return new DropCursorView(editorView, options);
      }
    });
  }
  class DropCursorView {
    constructor(editorView, options) {
      var _a;
      this.editorView = editorView;
      this.cursorPos = null;
      this.element = null;
      this.timeout = -1;
      this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
      this.color = options.color === false ? void 0 : options.color || "black";
      this.class = options.class;
      this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
        let handler = (e) => {
          this[name](e);
        };
        editorView.dom.addEventListener(name, handler);
        return { name, handler };
      });
    }
    destroy() {
      this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
    }
    update(editorView, prevState) {
      if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
        if (this.cursorPos > editorView.state.doc.content.size)
          this.setCursor(null);
        else
          this.updateOverlay();
      }
    }
    setCursor(pos) {
      if (pos == this.cursorPos)
        return;
      this.cursorPos = pos;
      if (pos == null) {
        this.element.parentNode.removeChild(this.element);
        this.element = null;
      } else {
        this.updateOverlay();
      }
    }
    updateOverlay() {
      let $pos = this.editorView.state.doc.resolve(this.cursorPos);
      let isBlock = !$pos.parent.inlineContent, rect;
      if (isBlock) {
        let before = $pos.nodeBefore, after = $pos.nodeAfter;
        if (before || after) {
          let node2 = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
          if (node2) {
            let nodeRect = node2.getBoundingClientRect();
            let top = before ? nodeRect.bottom : nodeRect.top;
            if (before && after)
              top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
            rect = { left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2 };
          }
        }
      }
      if (!rect) {
        let coords = this.editorView.coordsAtPos(this.cursorPos);
        rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };
      }
      let parent = this.editorView.dom.offsetParent;
      if (!this.element) {
        this.element = parent.appendChild(document.createElement("div"));
        if (this.class)
          this.element.className = this.class;
        this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
        if (this.color) {
          this.element.style.backgroundColor = this.color;
        }
      }
      this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
      this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
      let parentLeft, parentTop;
      if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
        parentLeft = -pageXOffset;
        parentTop = -pageYOffset;
      } else {
        let rect2 = parent.getBoundingClientRect();
        parentLeft = rect2.left - parent.scrollLeft;
        parentTop = rect2.top - parent.scrollTop;
      }
      this.element.style.left = rect.left - parentLeft + "px";
      this.element.style.top = rect.top - parentTop + "px";
      this.element.style.width = rect.right - rect.left + "px";
      this.element.style.height = rect.bottom - rect.top + "px";
    }
    scheduleRemoval(timeout2) {
      clearTimeout(this.timeout);
      this.timeout = setTimeout(() => this.setCursor(null), timeout2);
    }
    dragover(event) {
      if (!this.editorView.editable)
        return;
      let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
      let node2 = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
      let disableDropCursor = node2 && node2.type.spec.disableDropCursor;
      let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
      if (pos && !disabled) {
        let target = pos.pos;
        if (this.editorView.dragging && this.editorView.dragging.slice) {
          let point2 = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
          if (point2 != null)
            target = point2;
        }
        this.setCursor(target);
        this.scheduleRemoval(5e3);
      }
    }
    dragend() {
      this.scheduleRemoval(20);
    }
    drop() {
      this.scheduleRemoval(20);
    }
    dragleave(event) {
      if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
        this.setCursor(null);
    }
  }
  const Dropcursor = Extension.create({
    name: "dropCursor",
    addOptions() {
      return {
        color: "currentColor",
        width: 1,
        class: void 0
      };
    },
    addProseMirrorPlugins() {
      return [
        dropCursor(this.options)
      ];
    }
  });
  class GapCursor extends Selection {
    /**
    Create a gap cursor.
    */
    constructor($pos) {
      super($pos, $pos);
    }
    map(doc2, mapping) {
      let $pos = doc2.resolve(mapping.map(this.head));
      return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
    }
    content() {
      return Slice.empty;
    }
    eq(other) {
      return other instanceof GapCursor && other.head == this.head;
    }
    toJSON() {
      return { type: "gapcursor", pos: this.head };
    }
    /**
    @internal
    */
    static fromJSON(doc2, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for GapCursor.fromJSON");
      return new GapCursor(doc2.resolve(json.pos));
    }
    /**
    @internal
    */
    getBookmark() {
      return new GapBookmark(this.anchor);
    }
    /**
    @internal
    */
    static valid($pos) {
      let parent = $pos.parent;
      if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
        return false;
      let override = parent.type.spec.allowGapCursor;
      if (override != null)
        return override;
      let deflt = parent.contentMatchAt($pos.index()).defaultType;
      return deflt && deflt.isTextblock;
    }
    /**
    @internal
    */
    static findGapCursorFrom($pos, dir, mustMove = false) {
      search:
        for (; ; ) {
          if (!mustMove && GapCursor.valid($pos))
            return $pos;
          let pos = $pos.pos, next = null;
          for (let d = $pos.depth; ; d--) {
            let parent = $pos.node(d);
            if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
              next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
              break;
            } else if (d == 0) {
              return null;
            }
            pos += dir;
            let $cur = $pos.doc.resolve(pos);
            if (GapCursor.valid($cur))
              return $cur;
          }
          for (; ; ) {
            let inside = dir > 0 ? next.firstChild : next.lastChild;
            if (!inside) {
              if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
                $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
                mustMove = false;
                continue search;
              }
              break;
            }
            next = inside;
            pos += dir;
            let $cur = $pos.doc.resolve(pos);
            if (GapCursor.valid($cur))
              return $cur;
          }
          return null;
        }
    }
  }
  GapCursor.prototype.visible = false;
  GapCursor.findFrom = GapCursor.findGapCursorFrom;
  Selection.jsonID("gapcursor", GapCursor);
  class GapBookmark {
    constructor(pos) {
      this.pos = pos;
    }
    map(mapping) {
      return new GapBookmark(mapping.map(this.pos));
    }
    resolve(doc2) {
      let $pos = doc2.resolve(this.pos);
      return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
    }
  }
  function closedBefore($pos) {
    for (let d = $pos.depth; d >= 0; d--) {
      let index2 = $pos.index(d), parent = $pos.node(d);
      if (index2 == 0) {
        if (parent.type.spec.isolating)
          return true;
        continue;
      }
      for (let before = parent.child(index2 - 1); ; before = before.lastChild) {
        if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
          return true;
        if (before.inlineContent)
          return false;
      }
    }
    return true;
  }
  function closedAfter($pos) {
    for (let d = $pos.depth; d >= 0; d--) {
      let index2 = $pos.indexAfter(d), parent = $pos.node(d);
      if (index2 == parent.childCount) {
        if (parent.type.spec.isolating)
          return true;
        continue;
      }
      for (let after = parent.child(index2); ; after = after.firstChild) {
        if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
          return true;
        if (after.inlineContent)
          return false;
      }
    }
    return true;
  }
  function gapCursor() {
    return new Plugin({
      props: {
        decorations: drawGapCursor,
        createSelectionBetween(_view, $anchor, $head) {
          return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
        },
        handleClick,
        handleKeyDown,
        handleDOMEvents: { beforeinput }
      }
    });
  }
  const handleKeyDown = keydownHandler({
    "ArrowLeft": arrow("horiz", -1),
    "ArrowRight": arrow("horiz", 1),
    "ArrowUp": arrow("vert", -1),
    "ArrowDown": arrow("vert", 1)
  });
  function arrow(axis, dir) {
    const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
    return function(state, dispatch, view) {
      let sel = state.selection;
      let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
      if (sel instanceof TextSelection) {
        if (!view.endOfTextblock(dirStr) || $start.depth == 0)
          return false;
        mustMove = false;
        $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
      }
      let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
      if (!$found)
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(new GapCursor($found)));
      return true;
    };
  }
  function handleClick(view, pos, event) {
    if (!view || !view.editable)
      return false;
    let $pos = view.state.doc.resolve(pos);
    if (!GapCursor.valid($pos))
      return false;
    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
    if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
      return false;
    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
    return true;
  }
  function beforeinput(view, event) {
    if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
      return false;
    let { $from } = view.state.selection;
    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
    if (!insert)
      return false;
    let frag = Fragment.empty;
    for (let i2 = insert.length - 1; i2 >= 0; i2--)
      frag = Fragment.from(insert[i2].createAndFill(null, frag));
    let tr2 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
    tr2.setSelection(TextSelection.near(tr2.doc.resolve($from.pos + 1)));
    view.dispatch(tr2);
    return false;
  }
  function drawGapCursor(state) {
    if (!(state.selection instanceof GapCursor))
      return null;
    let node2 = document.createElement("div");
    node2.className = "ProseMirror-gapcursor";
    return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node2, { key: "gapcursor" })]);
  }
  const Gapcursor = Extension.create({
    name: "gapCursor",
    addProseMirrorPlugins() {
      return [
        gapCursor()
      ];
    },
    extendNodeSchema(extension2) {
      var _a;
      const context = {
        name: extension2.name,
        options: extension2.options,
        storage: extension2.storage
      };
      return {
        allowGapCursor: (_a = callOrReturn(getExtensionField(extension2, "allowGapCursor", context))) !== null && _a !== void 0 ? _a : null
      };
    }
  });
  const HardBreak = Node.create({
    name: "hardBreak",
    addOptions() {
      return {
        keepMarks: true,
        HTMLAttributes: {}
      };
    },
    inline: true,
    group: "inline",
    selectable: false,
    parseHTML() {
      return [
        { tag: "br" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
    },
    renderText() {
      return "\n";
    },
    addCommands() {
      return {
        setHardBreak: () => ({ commands: commands2, chain, state, editor: editor2 }) => {
          return commands2.first([
            () => commands2.exitCode(),
            () => commands2.command(() => {
              const { selection, storedMarks } = state;
              if (selection.$from.parent.type.spec.isolating) {
                return false;
              }
              const { keepMarks } = this.options;
              const { splittableMarks } = editor2.extensionManager;
              const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
              return chain().insertContent({ type: this.name }).command(({ tr: tr2, dispatch }) => {
                if (dispatch && marks && keepMarks) {
                  const filteredMarks = marks.filter((mark2) => splittableMarks.includes(mark2.type.name));
                  tr2.ensureMarks(filteredMarks);
                }
                return true;
              }).run();
            })
          ]);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Enter": () => this.editor.commands.setHardBreak(),
        "Shift-Enter": () => this.editor.commands.setHardBreak()
      };
    }
  });
  var GOOD_LEAF_SIZE = 200;
  var RopeSequence = function RopeSequence2() {
  };
  RopeSequence.prototype.append = function append(other) {
    if (!other.length) {
      return this;
    }
    other = RopeSequence.from(other);
    return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
  };
  RopeSequence.prototype.prepend = function prepend(other) {
    if (!other.length) {
      return this;
    }
    return RopeSequence.from(other).append(this);
  };
  RopeSequence.prototype.appendInner = function appendInner(other) {
    return new Append(this, other);
  };
  RopeSequence.prototype.slice = function slice(from2, to) {
    if (from2 === void 0)
      from2 = 0;
    if (to === void 0)
      to = this.length;
    if (from2 >= to) {
      return RopeSequence.empty;
    }
    return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
  };
  RopeSequence.prototype.get = function get(i2) {
    if (i2 < 0 || i2 >= this.length) {
      return void 0;
    }
    return this.getInner(i2);
  };
  RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
    if (from2 === void 0)
      from2 = 0;
    if (to === void 0)
      to = this.length;
    if (from2 <= to) {
      this.forEachInner(f, from2, to, 0);
    } else {
      this.forEachInvertedInner(f, from2, to, 0);
    }
  };
  RopeSequence.prototype.map = function map2(f, from2, to) {
    if (from2 === void 0)
      from2 = 0;
    if (to === void 0)
      to = this.length;
    var result = [];
    this.forEach(function(elt, i2) {
      return result.push(f(elt, i2));
    }, from2, to);
    return result;
  };
  RopeSequence.from = function from2(values) {
    if (values instanceof RopeSequence) {
      return values;
    }
    return values && values.length ? new Leaf(values) : RopeSequence.empty;
  };
  var Leaf = /* @__PURE__ */ function(RopeSequence2) {
    function Leaf2(values) {
      RopeSequence2.call(this);
      this.values = values;
    }
    if (RopeSequence2)
      Leaf2.__proto__ = RopeSequence2;
    Leaf2.prototype = Object.create(RopeSequence2 && RopeSequence2.prototype);
    Leaf2.prototype.constructor = Leaf2;
    var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
    Leaf2.prototype.flatten = function flatten2() {
      return this.values;
    };
    Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
      if (from2 == 0 && to == this.length) {
        return this;
      }
      return new Leaf2(this.values.slice(from2, to));
    };
    Leaf2.prototype.getInner = function getInner(i2) {
      return this.values[i2];
    };
    Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
      for (var i2 = from2; i2 < to; i2++) {
        if (f(this.values[i2], start + i2) === false) {
          return false;
        }
      }
    };
    Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
      for (var i2 = from2 - 1; i2 >= to; i2--) {
        if (f(this.values[i2], start + i2) === false) {
          return false;
        }
      }
    };
    Leaf2.prototype.leafAppend = function leafAppend(other) {
      if (this.length + other.length <= GOOD_LEAF_SIZE) {
        return new Leaf2(this.values.concat(other.flatten()));
      }
    };
    Leaf2.prototype.leafPrepend = function leafPrepend(other) {
      if (this.length + other.length <= GOOD_LEAF_SIZE) {
        return new Leaf2(other.flatten().concat(this.values));
      }
    };
    prototypeAccessors.length.get = function() {
      return this.values.length;
    };
    prototypeAccessors.depth.get = function() {
      return 0;
    };
    Object.defineProperties(Leaf2.prototype, prototypeAccessors);
    return Leaf2;
  }(RopeSequence);
  RopeSequence.empty = new Leaf([]);
  var Append = /* @__PURE__ */ function(RopeSequence2) {
    function Append2(left, right) {
      RopeSequence2.call(this);
      this.left = left;
      this.right = right;
      this.length = left.length + right.length;
      this.depth = Math.max(left.depth, right.depth) + 1;
    }
    if (RopeSequence2)
      Append2.__proto__ = RopeSequence2;
    Append2.prototype = Object.create(RopeSequence2 && RopeSequence2.prototype);
    Append2.prototype.constructor = Append2;
    Append2.prototype.flatten = function flatten2() {
      return this.left.flatten().concat(this.right.flatten());
    };
    Append2.prototype.getInner = function getInner(i2) {
      return i2 < this.left.length ? this.left.get(i2) : this.right.get(i2 - this.left.length);
    };
    Append2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
      var leftLen = this.left.length;
      if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start) === false) {
        return false;
      }
      if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {
        return false;
      }
    };
    Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
      var leftLen = this.left.length;
      if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {
        return false;
      }
      if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start) === false) {
        return false;
      }
    };
    Append2.prototype.sliceInner = function sliceInner(from2, to) {
      if (from2 == 0 && to == this.length) {
        return this;
      }
      var leftLen = this.left.length;
      if (to <= leftLen) {
        return this.left.slice(from2, to);
      }
      if (from2 >= leftLen) {
        return this.right.slice(from2 - leftLen, to - leftLen);
      }
      return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
    };
    Append2.prototype.leafAppend = function leafAppend(other) {
      var inner = this.right.leafAppend(other);
      if (inner) {
        return new Append2(this.left, inner);
      }
    };
    Append2.prototype.leafPrepend = function leafPrepend(other) {
      var inner = this.left.leafPrepend(other);
      if (inner) {
        return new Append2(inner, this.right);
      }
    };
    Append2.prototype.appendInner = function appendInner(other) {
      if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
        return new Append2(this.left, new Append2(this.right, other));
      }
      return new Append2(this, other);
    };
    return Append2;
  }(RopeSequence);
  const max_empty_items = 500;
  class Branch {
    constructor(items, eventCount) {
      this.items = items;
      this.eventCount = eventCount;
    }
    // Pop the latest event off the branch's history and apply it
    // to a document transform.
    popEvent(state, preserveItems) {
      if (this.eventCount == 0)
        return null;
      let end = this.items.length;
      for (; ; end--) {
        let next = this.items.get(end - 1);
        if (next.selection) {
          --end;
          break;
        }
      }
      let remap, mapFrom;
      if (preserveItems) {
        remap = this.remapping(end, this.items.length);
        mapFrom = remap.maps.length;
      }
      let transform2 = state.tr;
      let selection, remaining;
      let addAfter = [], addBefore = [];
      this.items.forEach((item, i2) => {
        if (!item.step) {
          if (!remap) {
            remap = this.remapping(end, i2 + 1);
            mapFrom = remap.maps.length;
          }
          mapFrom--;
          addBefore.push(item);
          return;
        }
        if (remap) {
          addBefore.push(new Item(item.map));
          let step = item.step.map(remap.slice(mapFrom)), map2;
          if (step && transform2.maybeStep(step).doc) {
            map2 = transform2.mapping.maps[transform2.mapping.maps.length - 1];
            addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));
          }
          mapFrom--;
          if (map2)
            remap.appendMap(map2, mapFrom);
        } else {
          transform2.maybeStep(item.step);
        }
        if (item.selection) {
          selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
          remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
          return false;
        }
      }, this.items.length, 0);
      return { remaining, transform: transform2, selection };
    }
    // Create a new branch with the given transform added.
    addTransform(transform2, selection, histOptions, preserveItems) {
      let newItems = [], eventCount = this.eventCount;
      let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
      for (let i2 = 0; i2 < transform2.steps.length; i2++) {
        let step = transform2.steps[i2].invert(transform2.docs[i2]);
        let item = new Item(transform2.mapping.maps[i2], step, selection), merged;
        if (merged = lastItem && lastItem.merge(item)) {
          item = merged;
          if (i2)
            newItems.pop();
          else
            oldItems = oldItems.slice(0, oldItems.length - 1);
        }
        newItems.push(item);
        if (selection) {
          eventCount++;
          selection = void 0;
        }
        if (!preserveItems)
          lastItem = item;
      }
      let overflow = eventCount - histOptions.depth;
      if (overflow > DEPTH_OVERFLOW) {
        oldItems = cutOffEvents(oldItems, overflow);
        eventCount -= overflow;
      }
      return new Branch(oldItems.append(newItems), eventCount);
    }
    remapping(from2, to) {
      let maps = new Mapping();
      this.items.forEach((item, i2) => {
        let mirrorPos = item.mirrorOffset != null && i2 - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
        maps.appendMap(item.map, mirrorPos);
      }, from2, to);
      return maps;
    }
    addMaps(array) {
      if (this.eventCount == 0)
        return this;
      return new Branch(this.items.append(array.map((map2) => new Item(map2))), this.eventCount);
    }
    // When the collab module receives remote changes, the history has
    // to know about those, so that it can adjust the steps that were
    // rebased on top of the remote changes, and include the position
    // maps for the remote changes in its array of items.
    rebased(rebasedTransform, rebasedCount) {
      if (!this.eventCount)
        return this;
      let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
      let mapping = rebasedTransform.mapping;
      let newUntil = rebasedTransform.steps.length;
      let eventCount = this.eventCount;
      this.items.forEach((item) => {
        if (item.selection)
          eventCount--;
      }, start);
      let iRebased = rebasedCount;
      this.items.forEach((item) => {
        let pos = mapping.getMirror(--iRebased);
        if (pos == null)
          return;
        newUntil = Math.min(newUntil, pos);
        let map2 = mapping.maps[pos];
        if (item.step) {
          let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
          let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
          if (selection)
            eventCount++;
          rebasedItems.push(new Item(map2, step, selection));
        } else {
          rebasedItems.push(new Item(map2));
        }
      }, start);
      let newMaps = [];
      for (let i2 = rebasedCount; i2 < newUntil; i2++)
        newMaps.push(new Item(mapping.maps[i2]));
      let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
      let branch = new Branch(items, eventCount);
      if (branch.emptyItemCount() > max_empty_items)
        branch = branch.compress(this.items.length - rebasedItems.length);
      return branch;
    }
    emptyItemCount() {
      let count = 0;
      this.items.forEach((item) => {
        if (!item.step)
          count++;
      });
      return count;
    }
    // Compressing a branch means rewriting it to push the air (map-only
    // items) out. During collaboration, these naturally accumulate
    // because each remote change adds one. The `upto` argument is used
    // to ensure that only the items below a given level are compressed,
    // because `rebased` relies on a clean, untouched set of items in
    // order to associate old items with rebased steps.
    compress(upto = this.items.length) {
      let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
      let items = [], events = 0;
      this.items.forEach((item, i2) => {
        if (i2 >= upto) {
          items.push(item);
          if (item.selection)
            events++;
        } else if (item.step) {
          let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
          mapFrom--;
          if (map2)
            remap.appendMap(map2, mapFrom);
          if (step) {
            let selection = item.selection && item.selection.map(remap.slice(mapFrom));
            if (selection)
              events++;
            let newItem = new Item(map2.invert(), step, selection), merged, last2 = items.length - 1;
            if (merged = items.length && items[last2].merge(newItem))
              items[last2] = merged;
            else
              items.push(newItem);
          }
        } else if (item.map) {
          mapFrom--;
        }
      }, this.items.length, 0);
      return new Branch(RopeSequence.from(items.reverse()), events);
    }
  }
  Branch.empty = new Branch(RopeSequence.empty, 0);
  function cutOffEvents(items, n) {
    let cutPoint;
    items.forEach((item, i2) => {
      if (item.selection && n-- == 0) {
        cutPoint = i2;
        return false;
      }
    });
    return items.slice(cutPoint);
  }
  class Item {
    constructor(map2, step, selection, mirrorOffset) {
      this.map = map2;
      this.step = step;
      this.selection = selection;
      this.mirrorOffset = mirrorOffset;
    }
    merge(other) {
      if (this.step && other.step && !other.selection) {
        let step = other.step.merge(this.step);
        if (step)
          return new Item(step.getMap().invert(), step, this.selection);
      }
    }
  }
  class HistoryState {
    constructor(done, undone, prevRanges, prevTime, prevComposition) {
      this.done = done;
      this.undone = undone;
      this.prevRanges = prevRanges;
      this.prevTime = prevTime;
      this.prevComposition = prevComposition;
    }
  }
  const DEPTH_OVERFLOW = 20;
  function applyTransaction(history2, state, tr2, options) {
    let historyTr = tr2.getMeta(historyKey), rebased;
    if (historyTr)
      return historyTr.historyState;
    if (tr2.getMeta(closeHistoryKey))
      history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
    let appended = tr2.getMeta("appendedTransaction");
    if (tr2.steps.length == 0) {
      return history2;
    } else if (appended && appended.getMeta(historyKey)) {
      if (appended.getMeta(historyKey).redo)
        return new HistoryState(history2.done.addTransform(tr2, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr2.mapping.maps[tr2.steps.length - 1]), history2.prevTime, history2.prevComposition);
      else
        return new HistoryState(history2.done, history2.undone.addTransform(tr2, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
    } else if (tr2.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
      let composition = tr2.getMeta("composition");
      let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr2.time || 0) - options.newGroupDelay || !isAdjacentTo(tr2, history2.prevRanges));
      let prevRanges = appended ? mapRanges(history2.prevRanges, tr2.mapping) : rangesFor(tr2.mapping.maps[tr2.steps.length - 1]);
      return new HistoryState(history2.done.addTransform(tr2, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr2.time, composition == null ? history2.prevComposition : composition);
    } else if (rebased = tr2.getMeta("rebased")) {
      return new HistoryState(history2.done.rebased(tr2, rebased), history2.undone.rebased(tr2, rebased), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
    } else {
      return new HistoryState(history2.done.addMaps(tr2.mapping.maps), history2.undone.addMaps(tr2.mapping.maps), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
    }
  }
  function isAdjacentTo(transform2, prevRanges) {
    if (!prevRanges)
      return false;
    if (!transform2.docChanged)
      return true;
    let adjacent = false;
    transform2.mapping.maps[0].forEach((start, end) => {
      for (let i2 = 0; i2 < prevRanges.length; i2 += 2)
        if (start <= prevRanges[i2 + 1] && end >= prevRanges[i2])
          adjacent = true;
    });
    return adjacent;
  }
  function rangesFor(map2) {
    let result = [];
    map2.forEach((_from, _to, from2, to) => result.push(from2, to));
    return result;
  }
  function mapRanges(ranges, mapping) {
    if (!ranges)
      return null;
    let result = [];
    for (let i2 = 0; i2 < ranges.length; i2 += 2) {
      let from2 = mapping.map(ranges[i2], 1), to = mapping.map(ranges[i2 + 1], -1);
      if (from2 <= to)
        result.push(from2, to);
    }
    return result;
  }
  function histTransaction(history2, state, redo2) {
    let preserveItems = mustPreserveItems(state);
    let histOptions = historyKey.get(state).spec.config;
    let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
    if (!pop)
      return null;
    let selection = pop.selection.resolve(pop.transform.doc);
    let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
    let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
    return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
  }
  let cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
  function mustPreserveItems(state) {
    let plugins = state.plugins;
    if (cachedPreserveItemsPlugins != plugins) {
      cachedPreserveItems = false;
      cachedPreserveItemsPlugins = plugins;
      for (let i2 = 0; i2 < plugins.length; i2++)
        if (plugins[i2].spec.historyPreserveItems) {
          cachedPreserveItems = true;
          break;
        }
    }
    return cachedPreserveItems;
  }
  const historyKey = new PluginKey("history");
  const closeHistoryKey = new PluginKey("closeHistory");
  function history(config = {}) {
    config = {
      depth: config.depth || 100,
      newGroupDelay: config.newGroupDelay || 500
    };
    return new Plugin({
      key: historyKey,
      state: {
        init() {
          return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
        },
        apply(tr2, hist, state) {
          return applyTransaction(hist, state, tr2, config);
        }
      },
      config,
      props: {
        handleDOMEvents: {
          beforeinput(view, e) {
            let inputType = e.inputType;
            let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
            if (!command2)
              return false;
            e.preventDefault();
            return command2(view.state, view.dispatch);
          }
        }
      }
    });
  }
  function buildCommand(redo2, scroll) {
    return (state, dispatch) => {
      let hist = historyKey.getState(state);
      if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
        return false;
      if (dispatch) {
        let tr2 = histTransaction(hist, state, redo2);
        if (tr2)
          dispatch(scroll ? tr2.scrollIntoView() : tr2);
      }
      return true;
    };
  }
  const undo = buildCommand(false, true);
  const redo = buildCommand(true, true);
  const History = Extension.create({
    name: "history",
    addOptions() {
      return {
        depth: 100,
        newGroupDelay: 500
      };
    },
    addCommands() {
      return {
        undo: () => ({ state, dispatch }) => {
          return undo(state, dispatch);
        },
        redo: () => ({ state, dispatch }) => {
          return redo(state, dispatch);
        }
      };
    },
    addProseMirrorPlugins() {
      return [
        history(this.options)
      ];
    },
    addKeyboardShortcuts() {
      return {
        "Mod-z": () => this.editor.commands.undo(),
        "Shift-Mod-z": () => this.editor.commands.redo(),
        "Mod-y": () => this.editor.commands.redo(),
        // Russian keyboard layouts
        "Mod-я": () => this.editor.commands.undo(),
        "Shift-Mod-я": () => this.editor.commands.redo()
      };
    }
  });
  const encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
  const encodedUtlds = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2";
  const assign = (target, properties) => {
    for (const key2 in properties) {
      target[key2] = properties[key2];
    }
    return target;
  };
  const numeric = "numeric";
  const ascii = "ascii";
  const alpha = "alpha";
  const asciinumeric = "asciinumeric";
  const alphanumeric = "alphanumeric";
  const domain = "domain";
  const emoji = "emoji";
  const scheme = "scheme";
  const slashscheme = "slashscheme";
  const whitespace = "whitespace";
  function registerGroup(name, groups) {
    if (!(name in groups)) {
      groups[name] = [];
    }
    return groups[name];
  }
  function addToGroups(t, flags, groups) {
    if (flags[numeric]) {
      flags[asciinumeric] = true;
      flags[alphanumeric] = true;
    }
    if (flags[ascii]) {
      flags[asciinumeric] = true;
      flags[alpha] = true;
    }
    if (flags[asciinumeric]) {
      flags[alphanumeric] = true;
    }
    if (flags[alpha]) {
      flags[alphanumeric] = true;
    }
    if (flags[alphanumeric]) {
      flags[domain] = true;
    }
    if (flags[emoji]) {
      flags[domain] = true;
    }
    for (const k in flags) {
      const group = registerGroup(k, groups);
      if (group.indexOf(t) < 0) {
        group.push(t);
      }
    }
  }
  function flagsForToken(t, groups) {
    const result = {};
    for (const c in groups) {
      if (groups[c].indexOf(t) >= 0) {
        result[c] = true;
      }
    }
    return result;
  }
  function State(token) {
    if (token === void 0) {
      token = null;
    }
    this.j = {};
    this.jr = [];
    this.jd = null;
    this.t = token;
  }
  State.groups = {};
  State.prototype = {
    accepts() {
      return !!this.t;
    },
    /**
     * Follow an existing transition from the given input to the next state.
     * Does not mutate.
     * @param {string} input character or token type to transition on
     * @returns {?State<T>} the next state, if any
     */
    go(input2) {
      const state = this;
      const nextState = state.j[input2];
      if (nextState) {
        return nextState;
      }
      for (let i2 = 0; i2 < state.jr.length; i2++) {
        const regex = state.jr[i2][0];
        const nextState2 = state.jr[i2][1];
        if (nextState2 && regex.test(input2)) {
          return nextState2;
        }
      }
      return state.jd;
    },
    /**
     * Whether the state has a transition for the given input. Set the second
     * argument to true to only look for an exact match (and not a default or
     * regular-expression-based transition)
     * @param {string} input
     * @param {boolean} exactOnly
     */
    has(input2, exactOnly) {
      if (exactOnly === void 0) {
        exactOnly = false;
      }
      return exactOnly ? input2 in this.j : !!this.go(input2);
    },
    /**
     * Short for "transition all"; create a transition from the array of items
     * in the given list to the same final resulting state.
     * @param {string | string[]} inputs Group of inputs to transition on
     * @param {Transition<T> | State<T>} [next] Transition options
     * @param {Flags} [flags] Collections flags to add token to
     * @param {Collections<T>} [groups] Master list of token groups
     */
    ta(inputs, next, flags, groups) {
      for (let i2 = 0; i2 < inputs.length; i2++) {
        this.tt(inputs[i2], next, flags, groups);
      }
    },
    /**
     * Short for "take regexp transition"; defines a transition for this state
     * when it encounters a token which matches the given regular expression
     * @param {RegExp} regexp Regular expression transition (populate first)
     * @param {T | State<T>} [next] Transition options
     * @param {Flags} [flags] Collections flags to add token to
     * @param {Collections<T>} [groups] Master list of token groups
     * @returns {State<T>} taken after the given input
     */
    tr(regexp, next, flags, groups) {
      groups = groups || State.groups;
      let nextState;
      if (next && next.j) {
        nextState = next;
      } else {
        nextState = new State(next);
        if (flags && groups) {
          addToGroups(next, flags, groups);
        }
      }
      this.jr.push([regexp, nextState]);
      return nextState;
    },
    /**
     * Short for "take transitions", will take as many sequential transitions as
     * the length of the given input and returns the
     * resulting final state.
     * @param {string | string[]} input
     * @param {T | State<T>} [next] Transition options
     * @param {Flags} [flags] Collections flags to add token to
     * @param {Collections<T>} [groups] Master list of token groups
     * @returns {State<T>} taken after the given input
     */
    ts(input2, next, flags, groups) {
      let state = this;
      const len = input2.length;
      if (!len) {
        return state;
      }
      for (let i2 = 0; i2 < len - 1; i2++) {
        state = state.tt(input2[i2]);
      }
      return state.tt(input2[len - 1], next, flags, groups);
    },
    /**
     * Short for "take transition", this is a method for building/working with
     * state machines.
     *
     * If a state already exists for the given input, returns it.
     *
     * If a token is specified, that state will emit that token when reached by
     * the linkify engine.
     *
     * If no state exists, it will be initialized with some default transitions
     * that resemble existing default transitions.
     *
     * If a state is given for the second argument, that state will be
     * transitioned to on the given input regardless of what that input
     * previously did.
     *
     * Specify a token group flags to define groups that this token belongs to.
     * The token will be added to corresponding entires in the given groups
     * object.
     *
     * @param {string} input character, token type to transition on
     * @param {T | State<T>} [next] Transition options
     * @param {Flags} [flags] Collections flags to add token to
     * @param {Collections<T>} [groups] Master list of groups
     * @returns {State<T>} taken after the given input
     */
    tt(input2, next, flags, groups) {
      groups = groups || State.groups;
      const state = this;
      if (next && next.j) {
        state.j[input2] = next;
        return next;
      }
      const t = next;
      let nextState, templateState = state.go(input2);
      if (templateState) {
        nextState = new State();
        assign(nextState.j, templateState.j);
        nextState.jr.push.apply(nextState.jr, templateState.jr);
        nextState.jd = templateState.jd;
        nextState.t = templateState.t;
      } else {
        nextState = new State();
      }
      if (t) {
        if (groups) {
          if (nextState.t && typeof nextState.t === "string") {
            const allFlags = assign(flagsForToken(nextState.t, groups), flags);
            addToGroups(t, allFlags, groups);
          } else if (flags) {
            addToGroups(t, flags, groups);
          }
        }
        nextState.t = t;
      }
      state.j[input2] = nextState;
      return nextState;
    }
  };
  const ta = (state, input2, next, flags, groups) => state.ta(input2, next, flags, groups);
  const tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);
  const ts = (state, input2, next, flags, groups) => state.ts(input2, next, flags, groups);
  const tt = (state, input2, next, flags, groups) => state.tt(input2, next, flags, groups);
  const WORD = "WORD";
  const UWORD = "UWORD";
  const LOCALHOST = "LOCALHOST";
  const TLD = "TLD";
  const UTLD = "UTLD";
  const SCHEME = "SCHEME";
  const SLASH_SCHEME = "SLASH_SCHEME";
  const NUM = "NUM";
  const WS = "WS";
  const NL$1 = "NL";
  const OPENBRACE = "OPENBRACE";
  const CLOSEBRACE = "CLOSEBRACE";
  const OPENBRACKET = "OPENBRACKET";
  const CLOSEBRACKET = "CLOSEBRACKET";
  const OPENPAREN = "OPENPAREN";
  const CLOSEPAREN = "CLOSEPAREN";
  const OPENANGLEBRACKET = "OPENANGLEBRACKET";
  const CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
  const FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
  const FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
  const LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
  const RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
  const LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
  const RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
  const FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
  const FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
  const AMPERSAND = "AMPERSAND";
  const APOSTROPHE = "APOSTROPHE";
  const ASTERISK = "ASTERISK";
  const AT = "AT";
  const BACKSLASH = "BACKSLASH";
  const BACKTICK = "BACKTICK";
  const CARET = "CARET";
  const COLON = "COLON";
  const COMMA = "COMMA";
  const DOLLAR = "DOLLAR";
  const DOT = "DOT";
  const EQUALS = "EQUALS";
  const EXCLAMATION = "EXCLAMATION";
  const HYPHEN = "HYPHEN";
  const PERCENT = "PERCENT";
  const PIPE = "PIPE";
  const PLUS = "PLUS";
  const POUND = "POUND";
  const QUERY = "QUERY";
  const QUOTE = "QUOTE";
  const SEMI = "SEMI";
  const SLASH = "SLASH";
  const TILDE = "TILDE";
  const UNDERSCORE = "UNDERSCORE";
  const EMOJI$1 = "EMOJI";
  const SYM = "SYM";
  var tk = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    WORD,
    UWORD,
    LOCALHOST,
    TLD,
    UTLD,
    SCHEME,
    SLASH_SCHEME,
    NUM,
    WS,
    NL: NL$1,
    OPENBRACE,
    CLOSEBRACE,
    OPENBRACKET,
    CLOSEBRACKET,
    OPENPAREN,
    CLOSEPAREN,
    OPENANGLEBRACKET,
    CLOSEANGLEBRACKET,
    FULLWIDTHLEFTPAREN,
    FULLWIDTHRIGHTPAREN,
    LEFTCORNERBRACKET,
    RIGHTCORNERBRACKET,
    LEFTWHITECORNERBRACKET,
    RIGHTWHITECORNERBRACKET,
    FULLWIDTHLESSTHAN,
    FULLWIDTHGREATERTHAN,
    AMPERSAND,
    APOSTROPHE,
    ASTERISK,
    AT,
    BACKSLASH,
    BACKTICK,
    CARET,
    COLON,
    COMMA,
    DOLLAR,
    DOT,
    EQUALS,
    EXCLAMATION,
    HYPHEN,
    PERCENT,
    PIPE,
    PLUS,
    POUND,
    QUERY,
    QUOTE,
    SEMI,
    SLASH,
    TILDE,
    UNDERSCORE,
    EMOJI: EMOJI$1,
    SYM
  });
  const ASCII_LETTER = /[a-z]/;
  const LETTER = /\p{L}/u;
  const EMOJI = /\p{Emoji}/u;
  const DIGIT = /\d/;
  const SPACE = /\s/;
  const NL = "\n";
  const EMOJI_VARIATION = "️";
  const EMOJI_JOINER = "‍";
  let tlds = null, utlds = null;
  function init$2(customSchemes) {
    if (customSchemes === void 0) {
      customSchemes = [];
    }
    const groups = {};
    State.groups = groups;
    const Start = new State();
    if (tlds == null) {
      tlds = decodeTlds(encodedTlds);
    }
    if (utlds == null) {
      utlds = decodeTlds(encodedUtlds);
    }
    tt(Start, "'", APOSTROPHE);
    tt(Start, "{", OPENBRACE);
    tt(Start, "}", CLOSEBRACE);
    tt(Start, "[", OPENBRACKET);
    tt(Start, "]", CLOSEBRACKET);
    tt(Start, "(", OPENPAREN);
    tt(Start, ")", CLOSEPAREN);
    tt(Start, "<", OPENANGLEBRACKET);
    tt(Start, ">", CLOSEANGLEBRACKET);
    tt(Start, "（", FULLWIDTHLEFTPAREN);
    tt(Start, "）", FULLWIDTHRIGHTPAREN);
    tt(Start, "「", LEFTCORNERBRACKET);
    tt(Start, "」", RIGHTCORNERBRACKET);
    tt(Start, "『", LEFTWHITECORNERBRACKET);
    tt(Start, "』", RIGHTWHITECORNERBRACKET);
    tt(Start, "＜", FULLWIDTHLESSTHAN);
    tt(Start, "＞", FULLWIDTHGREATERTHAN);
    tt(Start, "&", AMPERSAND);
    tt(Start, "*", ASTERISK);
    tt(Start, "@", AT);
    tt(Start, "`", BACKTICK);
    tt(Start, "^", CARET);
    tt(Start, ":", COLON);
    tt(Start, ",", COMMA);
    tt(Start, "$", DOLLAR);
    tt(Start, ".", DOT);
    tt(Start, "=", EQUALS);
    tt(Start, "!", EXCLAMATION);
    tt(Start, "-", HYPHEN);
    tt(Start, "%", PERCENT);
    tt(Start, "|", PIPE);
    tt(Start, "+", PLUS);
    tt(Start, "#", POUND);
    tt(Start, "?", QUERY);
    tt(Start, '"', QUOTE);
    tt(Start, "/", SLASH);
    tt(Start, ";", SEMI);
    tt(Start, "~", TILDE);
    tt(Start, "_", UNDERSCORE);
    tt(Start, "\\", BACKSLASH);
    const Num = tr(Start, DIGIT, NUM, {
      [numeric]: true
    });
    tr(Num, DIGIT, Num);
    const Word = tr(Start, ASCII_LETTER, WORD, {
      [ascii]: true
    });
    tr(Word, ASCII_LETTER, Word);
    const UWord = tr(Start, LETTER, UWORD, {
      [alpha]: true
    });
    tr(UWord, ASCII_LETTER);
    tr(UWord, LETTER, UWord);
    const Ws = tr(Start, SPACE, WS, {
      [whitespace]: true
    });
    tt(Start, NL, NL$1, {
      [whitespace]: true
    });
    tt(Ws, NL);
    tr(Ws, SPACE, Ws);
    const Emoji = tr(Start, EMOJI, EMOJI$1, {
      [emoji]: true
    });
    tr(Emoji, EMOJI, Emoji);
    tt(Emoji, EMOJI_VARIATION, Emoji);
    const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
    tr(EmojiJoiner, EMOJI, Emoji);
    const wordjr = [[ASCII_LETTER, Word]];
    const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];
    for (let i2 = 0; i2 < tlds.length; i2++) {
      fastts(Start, tlds[i2], TLD, WORD, wordjr);
    }
    for (let i2 = 0; i2 < utlds.length; i2++) {
      fastts(Start, utlds[i2], UTLD, UWORD, uwordjr);
    }
    addToGroups(TLD, {
      tld: true,
      ascii: true
    }, groups);
    addToGroups(UTLD, {
      utld: true,
      alpha: true
    }, groups);
    fastts(Start, "file", SCHEME, WORD, wordjr);
    fastts(Start, "mailto", SCHEME, WORD, wordjr);
    fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
    fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
    fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
    fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
    addToGroups(SCHEME, {
      scheme: true,
      ascii: true
    }, groups);
    addToGroups(SLASH_SCHEME, {
      slashscheme: true,
      ascii: true
    }, groups);
    customSchemes = customSchemes.sort((a2, b) => a2[0] > b[0] ? 1 : -1);
    for (let i2 = 0; i2 < customSchemes.length; i2++) {
      const sch = customSchemes[i2][0];
      const optionalSlashSlash = customSchemes[i2][1];
      const flags = optionalSlashSlash ? {
        [scheme]: true
      } : {
        [slashscheme]: true
      };
      if (sch.indexOf("-") >= 0) {
        flags[domain] = true;
      } else if (!ASCII_LETTER.test(sch)) {
        flags[numeric] = true;
      } else if (DIGIT.test(sch)) {
        flags[asciinumeric] = true;
      } else {
        flags[ascii] = true;
      }
      ts(Start, sch, sch, flags);
    }
    ts(Start, "localhost", LOCALHOST, {
      ascii: true
    });
    Start.jd = new State(SYM);
    return {
      start: Start,
      tokens: assign({
        groups
      }, tk)
    };
  }
  function run$1(start, str) {
    const iterable = stringToArray(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
    const charCount = iterable.length;
    const tokens = [];
    let cursor = 0;
    let charCursor = 0;
    while (charCursor < charCount) {
      let state = start;
      let nextState = null;
      let tokenLength = 0;
      let latestAccepting = null;
      let sinceAccepts = -1;
      let charsSinceAccepts = -1;
      while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
        state = nextState;
        if (state.accepts()) {
          sinceAccepts = 0;
          charsSinceAccepts = 0;
          latestAccepting = state;
        } else if (sinceAccepts >= 0) {
          sinceAccepts += iterable[charCursor].length;
          charsSinceAccepts++;
        }
        tokenLength += iterable[charCursor].length;
        cursor += iterable[charCursor].length;
        charCursor++;
      }
      cursor -= sinceAccepts;
      charCursor -= charsSinceAccepts;
      tokenLength -= sinceAccepts;
      tokens.push({
        t: latestAccepting.t,
        // token type/name
        v: str.slice(cursor - tokenLength, cursor),
        // string value
        s: cursor - tokenLength,
        // start index
        e: cursor
        // end index (excluding)
      });
    }
    return tokens;
  }
  function stringToArray(str) {
    const result = [];
    const len = str.length;
    let index2 = 0;
    while (index2 < len) {
      let first2 = str.charCodeAt(index2);
      let second;
      let char = first2 < 55296 || first2 > 56319 || index2 + 1 === len || (second = str.charCodeAt(index2 + 1)) < 56320 || second > 57343 ? str[index2] : str.slice(index2, index2 + 2);
      result.push(char);
      index2 += char.length;
    }
    return result;
  }
  function fastts(state, input2, t, defaultt, jr) {
    let next;
    const len = input2.length;
    for (let i2 = 0; i2 < len - 1; i2++) {
      const char = input2[i2];
      if (state.j[char]) {
        next = state.j[char];
      } else {
        next = new State(defaultt);
        next.jr = jr.slice();
        state.j[char] = next;
      }
      state = next;
    }
    next = new State(t);
    next.jr = jr.slice();
    state.j[input2[len - 1]] = next;
    return next;
  }
  function decodeTlds(encoded) {
    const words = [];
    const stack = [];
    let i2 = 0;
    let digits = "0123456789";
    while (i2 < encoded.length) {
      let popDigitCount = 0;
      while (digits.indexOf(encoded[i2 + popDigitCount]) >= 0) {
        popDigitCount++;
      }
      if (popDigitCount > 0) {
        words.push(stack.join(""));
        for (let popCount = parseInt(encoded.substring(i2, i2 + popDigitCount), 10); popCount > 0; popCount--) {
          stack.pop();
        }
        i2 += popDigitCount;
      } else {
        stack.push(encoded[i2]);
        i2++;
      }
    }
    return words;
  }
  const defaults = {
    defaultProtocol: "http",
    events: null,
    format: noop,
    formatHref: noop,
    nl2br: false,
    tagName: "a",
    target: null,
    rel: null,
    validate: true,
    truncate: Infinity,
    className: null,
    attributes: null,
    ignoreTags: [],
    render: null
  };
  function Options(opts, defaultRender) {
    if (defaultRender === void 0) {
      defaultRender = null;
    }
    let o = assign({}, defaults);
    if (opts) {
      o = assign(o, opts instanceof Options ? opts.o : opts);
    }
    const ignoredTags = o.ignoreTags;
    const uppercaseIgnoredTags = [];
    for (let i2 = 0; i2 < ignoredTags.length; i2++) {
      uppercaseIgnoredTags.push(ignoredTags[i2].toUpperCase());
    }
    this.o = o;
    if (defaultRender) {
      this.defaultRender = defaultRender;
    }
    this.ignoreTags = uppercaseIgnoredTags;
  }
  Options.prototype = {
    o: defaults,
    /**
     * @type string[]
     */
    ignoreTags: [],
    /**
     * @param {IntermediateRepresentation} ir
     * @returns {any}
     */
    defaultRender(ir) {
      return ir;
    },
    /**
     * Returns true or false based on whether a token should be displayed as a
     * link based on the user options.
     * @param {MultiToken} token
     * @returns {boolean}
     */
    check(token) {
      return this.get("validate", token.toString(), token);
    },
    // Private methods
    /**
     * Resolve an option's value based on the value of the option and the given
     * params. If operator and token are specified and the target option is
     * callable, automatically calls the function with the given argument.
     * @template {keyof Opts} K
     * @param {K} key Name of option to use
     * @param {string} [operator] will be passed to the target option if it's a
     * function. If not specified, RAW function value gets returned
     * @param {MultiToken} [token] The token from linkify.tokenize
     * @returns {Opts[K] | any}
     */
    get(key2, operator, token) {
      const isCallable = operator != null;
      let option2 = this.o[key2];
      if (!option2) {
        return option2;
      }
      if (typeof option2 === "object") {
        option2 = token.t in option2 ? option2[token.t] : defaults[key2];
        if (typeof option2 === "function" && isCallable) {
          option2 = option2(operator, token);
        }
      } else if (typeof option2 === "function" && isCallable) {
        option2 = option2(operator, token.t, token);
      }
      return option2;
    },
    /**
     * @template {keyof Opts} L
     * @param {L} key Name of options object to use
     * @param {string} [operator]
     * @param {MultiToken} [token]
     * @returns {Opts[L] | any}
     */
    getObj(key2, operator, token) {
      let obj = this.o[key2];
      if (typeof obj === "function" && operator != null) {
        obj = obj(operator, token.t, token);
      }
      return obj;
    },
    /**
     * Convert the given token to a rendered element that may be added to the
     * calling-interface's DOM
     * @param {MultiToken} token Token to render to an HTML element
     * @returns {any} Render result; e.g., HTML string, DOM element, React
     *   Component, etc.
     */
    render(token) {
      const ir = token.render(this);
      const renderFn = this.get("render", null, token) || this.defaultRender;
      return renderFn(ir, token.t, token);
    }
  };
  function noop(val) {
    return val;
  }
  function MultiToken(value, tokens) {
    this.t = "token";
    this.v = value;
    this.tk = tokens;
  }
  MultiToken.prototype = {
    isLink: false,
    /**
     * Return the string this token represents.
     * @return {string}
     */
    toString() {
      return this.v;
    },
    /**
     * What should the value for this token be in the `href` HTML attribute?
     * Returns the `.toString` value by default.
     * @param {string} [scheme]
     * @return {string}
    */
    toHref(scheme2) {
      return this.toString();
    },
    /**
     * @param {Options} options Formatting options
     * @returns {string}
     */
    toFormattedString(options) {
      const val = this.toString();
      const truncate = options.get("truncate", val, this);
      const formatted = options.get("format", val, this);
      return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "…" : formatted;
    },
    /**
     *
     * @param {Options} options
     * @returns {string}
     */
    toFormattedHref(options) {
      return options.get("formatHref", this.toHref(options.get("defaultProtocol")), this);
    },
    /**
     * The start index of this token in the original input string
     * @returns {number}
     */
    startIndex() {
      return this.tk[0].s;
    },
    /**
     * The end index of this token in the original input string (up to this
     * index but not including it)
     * @returns {number}
     */
    endIndex() {
      return this.tk[this.tk.length - 1].e;
    },
    /**
    	Returns an object  of relevant values for this token, which includes keys
    	* type - Kind of token ('url', 'email', etc.)
    	* value - Original text
    	* href - The value that should be added to the anchor tag's href
    		attribute
    		@method toObject
    	@param {string} [protocol] `'http'` by default
    */
    toObject(protocol) {
      if (protocol === void 0) {
        protocol = defaults.defaultProtocol;
      }
      return {
        type: this.t,
        value: this.toString(),
        isLink: this.isLink,
        href: this.toHref(protocol),
        start: this.startIndex(),
        end: this.endIndex()
      };
    },
    /**
     *
     * @param {Options} options Formatting option
     */
    toFormattedObject(options) {
      return {
        type: this.t,
        value: this.toFormattedString(options),
        isLink: this.isLink,
        href: this.toFormattedHref(options),
        start: this.startIndex(),
        end: this.endIndex()
      };
    },
    /**
     * Whether this token should be rendered as a link according to the given options
     * @param {Options} options
     * @returns {boolean}
     */
    validate(options) {
      return options.get("validate", this.toString(), this);
    },
    /**
     * Return an object that represents how this link should be rendered.
     * @param {Options} options Formattinng options
     */
    render(options) {
      const token = this;
      const href = this.toHref(options.get("defaultProtocol"));
      const formattedHref = options.get("formatHref", href, this);
      const tagName = options.get("tagName", href, token);
      const content2 = this.toFormattedString(options);
      const attributes = {};
      const className = options.get("className", href, token);
      const target = options.get("target", href, token);
      const rel = options.get("rel", href, token);
      const attrs = options.getObj("attributes", href, token);
      const eventListeners = options.getObj("events", href, token);
      attributes.href = formattedHref;
      if (className) {
        attributes.class = className;
      }
      if (target) {
        attributes.target = target;
      }
      if (rel) {
        attributes.rel = rel;
      }
      if (attrs) {
        assign(attributes, attrs);
      }
      return {
        tagName,
        attributes,
        content: content2,
        eventListeners
      };
    }
  };
  function createTokenClass(type, props) {
    class Token extends MultiToken {
      constructor(value, tokens) {
        super(value, tokens);
        this.t = type;
      }
    }
    for (const p2 in props) {
      Token.prototype[p2] = props[p2];
    }
    Token.t = type;
    return Token;
  }
  const Email = createTokenClass("email", {
    isLink: true,
    toHref() {
      return "mailto:" + this.toString();
    }
  });
  const Text$1 = createTokenClass("text");
  const Nl = createTokenClass("nl");
  const Url = createTokenClass("url", {
    isLink: true,
    /**
    	Lowercases relevant parts of the domain and adds the protocol if
    	required. Note that this will not escape unsafe HTML characters in the
    	URL.
    		@param {string} [scheme] default scheme (e.g., 'https')
    	@return {string} the full href
    */
    toHref(scheme2) {
      if (scheme2 === void 0) {
        scheme2 = defaults.defaultProtocol;
      }
      return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
    },
    /**
     * Check whether this URL token has a protocol
     * @return {boolean}
     */
    hasProtocol() {
      const tokens = this.tk;
      return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
    }
  });
  const makeState = (arg) => new State(arg);
  function init$1(_ref) {
    let {
      groups
    } = _ref;
    const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
    const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];
    const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
    const Start = makeState();
    const Localpart = tt(Start, TILDE);
    ta(Localpart, localpartAccepting, Localpart);
    ta(Localpart, groups.domain, Localpart);
    const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
    ta(Start, groups.domain, Domain);
    ta(Start, groups.scheme, Scheme);
    ta(Start, groups.slashscheme, SlashScheme);
    ta(Domain, localpartAccepting, Localpart);
    ta(Domain, groups.domain, Domain);
    const LocalpartAt = tt(Domain, AT);
    tt(Localpart, AT, LocalpartAt);
    tt(Scheme, AT, LocalpartAt);
    tt(SlashScheme, AT, LocalpartAt);
    const LocalpartDot = tt(Localpart, DOT);
    ta(LocalpartDot, localpartAccepting, Localpart);
    ta(LocalpartDot, groups.domain, Localpart);
    const EmailDomain = makeState();
    ta(LocalpartAt, groups.domain, EmailDomain);
    ta(EmailDomain, groups.domain, EmailDomain);
    const EmailDomainDot = tt(EmailDomain, DOT);
    ta(EmailDomainDot, groups.domain, EmailDomain);
    const Email$1 = makeState(Email);
    ta(EmailDomainDot, groups.tld, Email$1);
    ta(EmailDomainDot, groups.utld, Email$1);
    tt(LocalpartAt, LOCALHOST, Email$1);
    const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
    ta(EmailDomainHyphen, groups.domain, EmailDomain);
    ta(Email$1, groups.domain, EmailDomain);
    tt(Email$1, DOT, EmailDomainDot);
    tt(Email$1, HYPHEN, EmailDomainHyphen);
    const EmailColon = tt(Email$1, COLON);
    ta(EmailColon, groups.numeric, Email);
    const DomainHyphen = tt(Domain, HYPHEN);
    const DomainDot = tt(Domain, DOT);
    ta(DomainHyphen, groups.domain, Domain);
    ta(DomainDot, localpartAccepting, Localpart);
    ta(DomainDot, groups.domain, Domain);
    const DomainDotTld = makeState(Url);
    ta(DomainDot, groups.tld, DomainDotTld);
    ta(DomainDot, groups.utld, DomainDotTld);
    ta(DomainDotTld, groups.domain, Domain);
    ta(DomainDotTld, localpartAccepting, Localpart);
    tt(DomainDotTld, DOT, DomainDot);
    tt(DomainDotTld, HYPHEN, DomainHyphen);
    tt(DomainDotTld, AT, LocalpartAt);
    const DomainDotTldColon = tt(DomainDotTld, COLON);
    const DomainDotTldColonPort = makeState(Url);
    ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
    const Url$1 = makeState(Url);
    const UrlNonaccept = makeState();
    ta(Url$1, qsAccepting, Url$1);
    ta(Url$1, qsNonAccepting, UrlNonaccept);
    ta(UrlNonaccept, qsAccepting, Url$1);
    ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
    tt(DomainDotTld, SLASH, Url$1);
    tt(DomainDotTldColonPort, SLASH, Url$1);
    const SchemeColon = tt(Scheme, COLON);
    const SlashSchemeColon = tt(SlashScheme, COLON);
    const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
    const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
    ta(Scheme, groups.domain, Domain);
    tt(Scheme, DOT, DomainDot);
    tt(Scheme, HYPHEN, DomainHyphen);
    ta(SlashScheme, groups.domain, Domain);
    tt(SlashScheme, DOT, DomainDot);
    tt(SlashScheme, HYPHEN, DomainHyphen);
    ta(SchemeColon, groups.domain, Url$1);
    tt(SchemeColon, SLASH, Url$1);
    ta(UriPrefix, groups.domain, Url$1);
    ta(UriPrefix, qsAccepting, Url$1);
    tt(UriPrefix, SLASH, Url$1);
    const bracketPairs = [
      [OPENBRACE, CLOSEBRACE],
      // {}
      [OPENBRACKET, CLOSEBRACKET],
      // []
      [OPENPAREN, CLOSEPAREN],
      // ()
      [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
      // <>
      [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
      // （）
      [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
      // 「」
      [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
      // 『』
      [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
      // ＜＞
    ];
    for (let i2 = 0; i2 < bracketPairs.length; i2++) {
      const [OPEN, CLOSE] = bracketPairs[i2];
      const UrlOpen = tt(Url$1, OPEN);
      tt(UrlNonaccept, OPEN, UrlOpen);
      tt(UrlOpen, CLOSE, Url$1);
      const UrlOpenQ = makeState(Url);
      ta(UrlOpen, qsAccepting, UrlOpenQ);
      const UrlOpenSyms = makeState();
      ta(UrlOpen, qsNonAccepting);
      ta(UrlOpenQ, qsAccepting, UrlOpenQ);
      ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
      ta(UrlOpenSyms, qsAccepting, UrlOpenQ);
      ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
      tt(UrlOpenQ, CLOSE, Url$1);
      tt(UrlOpenSyms, CLOSE, Url$1);
    }
    tt(Start, LOCALHOST, DomainDotTld);
    tt(Start, NL$1, Nl);
    return {
      start: Start,
      tokens: tk
    };
  }
  function run(start, input2, tokens) {
    let len = tokens.length;
    let cursor = 0;
    let multis = [];
    let textTokens = [];
    while (cursor < len) {
      let state = start;
      let secondState = null;
      let nextState = null;
      let multiLength = 0;
      let latestAccepting = null;
      let sinceAccepts = -1;
      while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
        textTokens.push(tokens[cursor++]);
      }
      while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
        secondState = null;
        state = nextState;
        if (state.accepts()) {
          sinceAccepts = 0;
          latestAccepting = state;
        } else if (sinceAccepts >= 0) {
          sinceAccepts++;
        }
        cursor++;
        multiLength++;
      }
      if (sinceAccepts < 0) {
        cursor -= multiLength;
        if (cursor < len) {
          textTokens.push(tokens[cursor]);
          cursor++;
        }
      } else {
        if (textTokens.length > 0) {
          multis.push(initMultiToken(Text$1, input2, textTokens));
          textTokens = [];
        }
        cursor -= sinceAccepts;
        multiLength -= sinceAccepts;
        const Multi = latestAccepting.t;
        const subtokens = tokens.slice(cursor - multiLength, cursor);
        multis.push(initMultiToken(Multi, input2, subtokens));
      }
    }
    if (textTokens.length > 0) {
      multis.push(initMultiToken(Text$1, input2, textTokens));
    }
    return multis;
  }
  function initMultiToken(Multi, input2, tokens) {
    const startIdx = tokens[0].s;
    const endIdx = tokens[tokens.length - 1].e;
    const value = input2.slice(startIdx, endIdx);
    return new Multi(value, tokens);
  }
  const warn = typeof console !== "undefined" && console && console.warn || (() => {
  });
  const warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
  const INIT = {
    scanner: null,
    parser: null,
    tokenQueue: [],
    pluginQueue: [],
    customSchemes: [],
    initialized: false
  };
  function reset() {
    State.groups = {};
    INIT.scanner = null;
    INIT.parser = null;
    INIT.tokenQueue = [];
    INIT.pluginQueue = [];
    INIT.customSchemes = [];
    INIT.initialized = false;
  }
  function registerCustomProtocol(scheme2, optionalSlashSlash) {
    if (optionalSlashSlash === void 0) {
      optionalSlashSlash = false;
    }
    if (INIT.initialized) {
      warn(`linkifyjs: already initialized - will not register custom scheme "${scheme2}" ${warnAdvice}`);
    }
    if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
      throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
    }
    INIT.customSchemes.push([scheme2, optionalSlashSlash]);
  }
  function init() {
    INIT.scanner = init$2(INIT.customSchemes);
    for (let i2 = 0; i2 < INIT.tokenQueue.length; i2++) {
      INIT.tokenQueue[i2][1]({
        scanner: INIT.scanner
      });
    }
    INIT.parser = init$1(INIT.scanner.tokens);
    for (let i2 = 0; i2 < INIT.pluginQueue.length; i2++) {
      INIT.pluginQueue[i2][1]({
        scanner: INIT.scanner,
        parser: INIT.parser
      });
    }
    INIT.initialized = true;
  }
  function tokenize(str) {
    if (!INIT.initialized) {
      init();
    }
    return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
  }
  function find(str, type, opts) {
    if (type === void 0) {
      type = null;
    }
    if (opts === void 0) {
      opts = null;
    }
    if (type && typeof type === "object") {
      if (opts) {
        throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);
      }
      opts = type;
      type = null;
    }
    const options = new Options(opts);
    const tokens = tokenize(str);
    const filtered = [];
    for (let i2 = 0; i2 < tokens.length; i2++) {
      const token = tokens[i2];
      if (token.isLink && (!type || token.t === type) && options.check(token)) {
        filtered.push(token.toFormattedObject(options));
      }
    }
    return filtered;
  }
  function autolink(options) {
    return new Plugin({
      key: new PluginKey("autolink"),
      appendTransaction: (transactions, oldState, newState) => {
        const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
        const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
        if (!docChanges || preventAutolink) {
          return;
        }
        const { tr: tr2 } = newState;
        const transform2 = combineTransactionSteps(oldState.doc, [...transactions]);
        const changes = getChangedRanges(transform2);
        changes.forEach(({ newRange }) => {
          const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node2) => node2.isTextblock);
          let textBlock;
          let textBeforeWhitespace;
          if (nodesInChangedRanges.length > 1) {
            textBlock = nodesInChangedRanges[0];
            textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
          } else if (nodesInChangedRanges.length && newState.doc.textBetween(newRange.from, newRange.to, " ", " ").endsWith(" ")) {
            textBlock = nodesInChangedRanges[0];
            textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
          }
          if (textBlock && textBeforeWhitespace) {
            const wordsBeforeWhitespace = textBeforeWhitespace.split(" ").filter((s2) => s2 !== "");
            if (wordsBeforeWhitespace.length <= 0) {
              return false;
            }
            const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
            const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
            if (!lastWordBeforeSpace) {
              return false;
            }
            find(lastWordBeforeSpace).filter((link2) => link2.isLink).map((link2) => ({
              ...link2,
              from: lastWordAndBlockOffset + link2.start + 1,
              to: lastWordAndBlockOffset + link2.end + 1
            })).filter((link2) => {
              if (!newState.schema.marks.code) {
                return true;
              }
              return !newState.doc.rangeHasMark(link2.from, link2.to, newState.schema.marks.code);
            }).filter((link2) => {
              if (options.validate) {
                return options.validate(link2.value);
              }
              return true;
            }).forEach((link2) => {
              if (getMarksBetween(link2.from, link2.to, newState.doc).some((item) => item.mark.type === options.type)) {
                return;
              }
              tr2.addMark(link2.from, link2.to, options.type.create({
                href: link2.href
              }));
            });
          }
        });
        if (!tr2.steps.length) {
          return;
        }
        return tr2;
      }
    });
  }
  function clickHandler(options) {
    return new Plugin({
      key: new PluginKey("handleClickLink"),
      props: {
        handleClick: (view, pos, event) => {
          var _a, _b;
          if (event.button !== 0) {
            return false;
          }
          let a2 = event.target;
          const els = [];
          while (a2.nodeName !== "DIV") {
            els.push(a2);
            a2 = a2.parentNode;
          }
          if (!els.find((value) => value.nodeName === "A")) {
            return false;
          }
          const attrs = getAttributes(view.state, options.type.name);
          const link2 = event.target;
          const href = (_a = link2 === null || link2 === void 0 ? void 0 : link2.href) !== null && _a !== void 0 ? _a : attrs.href;
          const target = (_b = link2 === null || link2 === void 0 ? void 0 : link2.target) !== null && _b !== void 0 ? _b : attrs.target;
          if (link2 && href) {
            window.open(href, target);
            return true;
          }
          return false;
        }
      }
    });
  }
  function pasteHandler(options) {
    return new Plugin({
      key: new PluginKey("handlePasteLink"),
      props: {
        handlePaste: (view, event, slice) => {
          const { state } = view;
          const { selection } = state;
          const { empty: empty2 } = selection;
          if (empty2) {
            return false;
          }
          let textContent = "";
          slice.content.forEach((node2) => {
            textContent += node2.textContent;
          });
          const link2 = find(textContent).find((item) => item.isLink && item.value === textContent);
          if (!textContent || !link2) {
            return false;
          }
          options.editor.commands.setMark(options.type, {
            href: link2.href
          });
          return true;
        }
      }
    });
  }
  const Link = Mark.create({
    name: "link",
    priority: 1e3,
    keepOnSplit: false,
    onCreate() {
      this.options.protocols.forEach((protocol) => {
        if (typeof protocol === "string") {
          registerCustomProtocol(protocol);
          return;
        }
        registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);
      });
    },
    onDestroy() {
      reset();
    },
    inclusive() {
      return this.options.autolink;
    },
    addOptions() {
      return {
        openOnClick: true,
        linkOnPaste: true,
        autolink: true,
        protocols: [],
        HTMLAttributes: {
          target: "_blank",
          rel: "noopener noreferrer nofollow",
          class: null
        },
        validate: void 0
      };
    },
    addAttributes() {
      return {
        href: {
          default: null
        },
        target: {
          default: this.options.HTMLAttributes.target
        },
        rel: {
          default: this.options.HTMLAttributes.rel
        },
        class: {
          default: this.options.HTMLAttributes.class
        }
      };
    },
    parseHTML() {
      return [{ tag: 'a[href]:not([href *= "javascript:" i])' }];
    },
    renderHTML({ HTMLAttributes }) {
      var _a;
      if ((_a = HTMLAttributes.href) === null || _a === void 0 ? void 0 : _a.startsWith("javascript:")) {
        return ["a", mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: "" }), 0];
      }
      return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setLink: (attributes) => ({ chain }) => {
          return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
        },
        toggleLink: (attributes) => ({ chain }) => {
          return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
        },
        unsetLink: () => ({ chain }) => {
          return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
        }
      };
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: (text2) => {
            const foundLinks = [];
            if (text2) {
              const links = find(text2).filter((item) => item.isLink);
              if (links.length) {
                links.forEach((link2) => foundLinks.push({
                  text: link2.value,
                  data: {
                    href: link2.href
                  },
                  index: link2.start
                }));
              }
            }
            return foundLinks;
          },
          type: this.type,
          getAttributes: (match) => {
            var _a;
            return {
              href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href
            };
          }
        })
      ];
    },
    addProseMirrorPlugins() {
      const plugins = [];
      if (this.options.autolink) {
        plugins.push(autolink({
          type: this.type,
          validate: this.options.validate
        }));
      }
      if (this.options.openOnClick) {
        plugins.push(clickHandler({
          type: this.type
        }));
      }
      if (this.options.linkOnPaste) {
        plugins.push(pasteHandler({
          editor: this.editor,
          type: this.type
        }));
      }
      return plugins;
    }
  });
  const Text = Node.create({
    name: "text",
    group: "inline"
  });
  function selectedFragmentToHTML(view, editor2) {
    const selectedFragment = view.state.selection.content().content;
    const internalHTMLSerializer = createInternalHTMLSerializer(
      view.state.schema,
      editor2
    );
    const internalHTML = internalHTMLSerializer.serializeProseMirrorFragment(selectedFragment);
    const externalHTMLExporter = createExternalHTMLExporter(
      view.state.schema,
      editor2
    );
    const externalHTML = externalHTMLExporter.exportProseMirrorFragment(selectedFragment);
    const plainText = cleanHTMLToMarkdown(externalHTML);
    return { internalHTML, externalHTML, plainText };
  }
  const createCopyToClipboardExtension = (editor2) => Extension.create({
    name: "copyToClipboard",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          props: {
            handleDOMEvents: {
              copy(view, event) {
                event.preventDefault();
                event.clipboardData.clearData();
                if ("node" in view.state.selection && view.state.selection.node.type.spec.group === "blockContent") {
                  view.dispatch(
                    view.state.tr.setSelection(
                      new NodeSelection(
                        view.state.doc.resolve(view.state.selection.from - 1)
                      )
                    )
                  );
                }
                const { internalHTML, externalHTML, plainText } = selectedFragmentToHTML(view, editor2);
                event.clipboardData.setData("blocknote/html", internalHTML);
                event.clipboardData.setData("text/html", externalHTML);
                event.clipboardData.setData("text/plain", plainText);
                return true;
              },
              // This is for the use-case in which only a block without content
              // is selected, e.g. an image block, and dragged (not using the
              // drag handle).
              dragstart(view, event) {
                if (!("node" in view.state.selection)) {
                  return;
                }
                if (view.state.selection.node.type.spec.group !== "blockContent") {
                  return;
                }
                view.dispatch(
                  view.state.tr.setSelection(
                    new NodeSelection(
                      view.state.doc.resolve(view.state.selection.from - 1)
                    )
                  )
                );
                event.preventDefault();
                event.dataTransfer.clearData();
                const { internalHTML, externalHTML, plainText } = selectedFragmentToHTML(view, editor2);
                event.dataTransfer.setData("blocknote/html", internalHTML);
                event.dataTransfer.setData("text/html", externalHTML);
                event.dataTransfer.setData("text/plain", plainText);
                return true;
              }
            }
          }
        })
      ];
    }
  });
  const acceptedMIMETypes = [
    "blocknote/html",
    "text/html",
    "text/plain"
  ];
  const createPasteFromClipboardExtension = (editor2) => Extension.create({
    name: "pasteFromClipboard",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          props: {
            handleDOMEvents: {
              paste(_view, event) {
                event.preventDefault();
                let format = null;
                for (const mimeType of acceptedMIMETypes) {
                  if (event.clipboardData.types.includes(mimeType)) {
                    format = mimeType;
                    break;
                  }
                }
                if (format !== null) {
                  let data = event.clipboardData.getData(format);
                  if (format === "text/html") {
                    const htmlNode = nestedListsToBlockNoteStructure(
                      data.trim()
                    );
                    data = htmlNode.innerHTML;
                  }
                  editor2._tiptapEditor.view.pasteHTML(data);
                }
                return true;
              }
            }
          }
        })
      ];
    }
  });
  const BackgroundColorExtension = Extension.create({
    name: "blockBackgroundColor",
    addGlobalAttributes() {
      return [
        {
          types: ["blockContainer"],
          attributes: {
            backgroundColor: {
              default: defaultProps.backgroundColor.default,
              parseHTML: (element2) => element2.hasAttribute("data-background-color") ? element2.getAttribute("data-background-color") : defaultProps.backgroundColor.default,
              renderHTML: (attributes) => attributes.backgroundColor !== defaultProps.backgroundColor.default && {
                "data-background-color": attributes.backgroundColor
              }
            }
          }
        }
      ];
    }
  });
  const PLUGIN_KEY$2 = new PluginKey(`blocknote-placeholder`);
  const Placeholder = Extension.create({
    name: "placeholder",
    addOptions() {
      return {
        emptyEditorClass: "bn-is-editor-empty",
        emptyNodeClass: "bn-is-empty",
        isFilterClass: "bn-is-filter",
        hasAnchorClass: "bn-has-anchor",
        placeholder: "Write something …",
        showOnlyWhenEditable: true,
        showOnlyCurrent: true,
        includeChildren: false
      };
    },
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: PLUGIN_KEY$2,
          props: {
            decorations: (state) => {
              const { doc: doc2, selection } = state;
              const menuState = slashMenuPluginKey.getState(state);
              const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
              const { anchor } = selection;
              const decorations = [];
              if (!active) {
                return;
              }
              doc2.descendants((node2, pos) => {
                const hasAnchor = anchor >= pos && anchor <= pos + node2.nodeSize;
                const isEmpty2 = !node2.isLeaf && !node2.childCount;
                if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty2) {
                  const classes = [this.options.emptyNodeClass];
                  if (this.editor.isEmpty) {
                    classes.push(this.options.emptyEditorClass);
                  }
                  if (hasAnchor) {
                    classes.push(this.options.hasAnchorClass);
                  }
                  if ((menuState == null ? void 0 : menuState.triggerCharacter) === "" && (menuState == null ? void 0 : menuState.active)) {
                    classes.push(this.options.isFilterClass);
                  }
                  const decoration = Decoration.node(pos, pos + node2.nodeSize, {
                    class: classes.join(" ")
                  });
                  decorations.push(decoration);
                }
                return this.options.includeChildren;
              });
              return DecorationSet.create(doc2, decorations);
            }
          }
        })
      ];
    }
  });
  const TextAlignmentExtension = Extension.create({
    name: "textAlignment",
    addGlobalAttributes() {
      return [
        {
          // Attribute is applied to block content instead of container so that child blocks don't inherit the text
          // alignment styling.
          types: ["paragraph", "heading", "bulletListItem", "numberedListItem"],
          attributes: {
            textAlignment: {
              default: "left",
              parseHTML: (element2) => {
                return element2.getAttribute("data-text-alignment");
              },
              renderHTML: (attributes) => attributes.textAlignment !== "left" && {
                "data-text-alignment": attributes.textAlignment
              }
            }
          }
        }
      ];
    }
  });
  const TextColorExtension = Extension.create({
    name: "blockTextColor",
    addGlobalAttributes() {
      return [
        {
          types: ["blockContainer"],
          attributes: {
            textColor: {
              default: defaultProps.textColor.default,
              parseHTML: (element2) => element2.hasAttribute("data-text-color") ? element2.getAttribute("data-text-color") : defaultProps.textColor.default,
              renderHTML: (attributes) => attributes.textColor !== defaultProps.textColor.default && {
                "data-text-color": attributes.textColor
              }
            }
          }
        }
      ];
    }
  });
  const TrailingNode = Extension.create({
    name: "trailingNode",
    addProseMirrorPlugins() {
      const plugin = new PluginKey(this.name);
      return [
        new Plugin({
          key: plugin,
          appendTransaction: (_, __, state) => {
            const { doc: doc2, tr: tr2, schema } = state;
            const shouldInsertNodeAtEnd = plugin.getState(state);
            const endPosition = doc2.content.size - 2;
            const type = schema.nodes["blockContainer"];
            const contentType = schema.nodes["paragraph"];
            if (!shouldInsertNodeAtEnd) {
              return;
            }
            return tr2.insert(
              endPosition,
              type.create(void 0, contentType.create())
            );
          },
          state: {
            init: (_, _state) => {
            },
            apply: (tr2, value) => {
              if (!tr2.docChanged) {
                return value;
              }
              let lastNode = tr2.doc.lastChild;
              if (!lastNode || lastNode.type.name !== "blockGroup") {
                throw new Error("Expected blockGroup");
              }
              lastNode = lastNode.lastChild;
              if (!lastNode || lastNode.type.name !== "blockContainer") {
                throw new Error("Expected blockContainer");
              }
              const lastContentNode = lastNode.firstChild;
              if (!lastContentNode) {
                throw new Error("Expected blockContent");
              }
              return lastNode.nodeSize > 4 || lastContentNode.type.spec.content !== "inline*";
            }
          }
        })
      ];
    }
  });
  const PLUGIN_KEY$1 = new PluginKey("non-editable-block");
  const NonEditableBlockPlugin = () => {
    return new Plugin({
      key: PLUGIN_KEY$1,
      props: {
        handleKeyDown: (view, event) => {
          if ("node" in view.state.selection) {
            if (event.key.length === 1 && !event.ctrlKey && !event.altKey && !event.metaKey && !event.shiftKey) {
              event.preventDefault();
            }
          }
        }
      }
    });
  };
  const PLUGIN_KEY = new PluginKey(`previous-blocks`);
  const nodeAttributes = {
    // Numbered List Items
    index: "index",
    // Headings
    level: "level",
    // All Blocks
    type: "type",
    depth: "depth",
    "depth-change": "depth-change"
  };
  const PreviousBlockTypePlugin = () => {
    let timeout2;
    return new Plugin({
      key: PLUGIN_KEY,
      view(_editorView) {
        return {
          update: async (view, _prevState) => {
            var _a;
            if (((_a = this.key) == null ? void 0 : _a.getState(view.state).updatedBlocks.size) > 0) {
              timeout2 = setTimeout(() => {
                view.dispatch(
                  view.state.tr.setMeta(PLUGIN_KEY, { clearUpdate: true })
                );
              }, 0);
            }
          },
          destroy: () => {
            if (timeout2) {
              clearTimeout(timeout2);
            }
          }
        };
      },
      state: {
        init() {
          return {
            // Block attributes, by block ID, from just before the previous transaction.
            prevTransactionOldBlockAttrs: {},
            // Block attributes, by block ID, from just before the current transaction.
            currentTransactionOldBlockAttrs: {},
            // Set of IDs of blocks whose attributes changed from the current transaction.
            updatedBlocks: /* @__PURE__ */ new Set()
          };
        },
        apply(transaction, prev, oldState, newState) {
          prev.currentTransactionOldBlockAttrs = {};
          prev.updatedBlocks.clear();
          if (!transaction.docChanged || oldState.doc.eq(newState.doc)) {
            return prev;
          }
          const currentTransactionOriginalOldBlockAttrs = {};
          const oldNodes = findChildren(oldState.doc, (node2) => node2.attrs.id);
          const oldNodesById = new Map(
            oldNodes.map((node2) => [node2.node.attrs.id, node2])
          );
          const newNodes = findChildren(newState.doc, (node2) => node2.attrs.id);
          for (const node2 of newNodes) {
            const oldNode = oldNodesById.get(node2.node.attrs.id);
            const oldContentNode = oldNode == null ? void 0 : oldNode.node.firstChild;
            const newContentNode = node2.node.firstChild;
            if (oldNode && oldContentNode && newContentNode) {
              const newAttrs = {
                index: newContentNode.attrs.index,
                level: newContentNode.attrs.level,
                type: newContentNode.type.name,
                depth: newState.doc.resolve(node2.pos).depth
              };
              let oldAttrs = {
                index: oldContentNode.attrs.index,
                level: oldContentNode.attrs.level,
                type: oldContentNode.type.name,
                depth: oldState.doc.resolve(oldNode.pos).depth
              };
              currentTransactionOriginalOldBlockAttrs[node2.node.attrs.id] = oldAttrs;
              if (transaction.getMeta("numberedListIndexing")) {
                if (node2.node.attrs.id in prev.prevTransactionOldBlockAttrs) {
                  oldAttrs = prev.prevTransactionOldBlockAttrs[node2.node.attrs.id];
                }
                if (newAttrs.type === "numberedListItem") {
                  oldAttrs.index = newAttrs.index;
                }
              }
              prev.currentTransactionOldBlockAttrs[node2.node.attrs.id] = oldAttrs;
              if (JSON.stringify(oldAttrs) !== JSON.stringify(newAttrs)) {
                oldAttrs["depth-change"] = oldAttrs.depth - newAttrs.depth;
                prev.updatedBlocks.add(node2.node.attrs.id);
              }
            }
          }
          prev.prevTransactionOldBlockAttrs = currentTransactionOriginalOldBlockAttrs;
          return prev;
        }
      },
      props: {
        decorations(state) {
          const pluginState = this.getState(state);
          if (pluginState.updatedBlocks.size === 0) {
            return void 0;
          }
          const decorations = [];
          state.doc.descendants((node2, pos) => {
            if (!node2.attrs.id) {
              return;
            }
            if (!pluginState.updatedBlocks.has(node2.attrs.id)) {
              return;
            }
            const prevAttrs = pluginState.currentTransactionOldBlockAttrs[node2.attrs.id];
            const decorationAttrs = {};
            for (const [nodeAttr, val] of Object.entries(prevAttrs)) {
              decorationAttrs["data-prev-" + nodeAttributes[nodeAttr]] = val || "none";
            }
            const decoration = Decoration.node(pos, pos + node2.nodeSize, {
              ...decorationAttrs
            });
            decorations.push(decoration);
          });
          return DecorationSet.create(state.doc, decorations);
        }
      }
    });
  };
  const BlockAttributes = {
    blockColor: "data-block-color",
    blockStyle: "data-block-style",
    id: "data-id",
    depth: "data-depth",
    depthChange: "data-depth-change"
  };
  const BlockContainer = Node.create({
    name: "blockContainer",
    group: "blockContainer",
    // A block always contains content, and optionally a blockGroup which contains nested blocks
    content: "blockContent blockGroup?",
    // Ensures content-specific keyboard handlers trigger first.
    priority: 50,
    defining: true,
    parseHTML() {
      return [
        {
          tag: "div",
          getAttrs: (element2) => {
            if (typeof element2 === "string") {
              return false;
            }
            const attrs = {};
            for (const [nodeAttr, HTMLAttr] of Object.entries(BlockAttributes)) {
              if (element2.getAttribute(HTMLAttr)) {
                attrs[nodeAttr] = element2.getAttribute(HTMLAttr);
              }
            }
            if (element2.getAttribute("data-node-type") === "blockContainer") {
              return attrs;
            }
            return false;
          }
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      var _a;
      const blockOuter = document.createElement("div");
      blockOuter.className = "bn-block-outer";
      blockOuter.setAttribute("data-node-type", "blockOuter");
      for (const [attribute, value] of Object.entries(HTMLAttributes)) {
        if (attribute !== "class") {
          blockOuter.setAttribute(attribute, value);
        }
      }
      const blockHTMLAttributes = {
        ...((_a = this.options.domAttributes) == null ? void 0 : _a.blockContainer) || {},
        ...HTMLAttributes
      };
      const block2 = document.createElement("div");
      block2.className = mergeCSSClasses("bn-block", blockHTMLAttributes.class);
      block2.setAttribute("data-node-type", this.name);
      for (const [attribute, value] of Object.entries(blockHTMLAttributes)) {
        if (attribute !== "class") {
          block2.setAttribute(attribute, value);
        }
      }
      blockOuter.appendChild(block2);
      return {
        dom: blockOuter,
        contentDOM: block2
      };
    },
    addCommands() {
      return {
        // Creates a new text block at a given position.
        BNCreateBlock: (pos) => ({ state, dispatch }) => {
          const newBlock = state.schema.nodes["blockContainer"].createAndFill();
          if (dispatch) {
            state.tr.insert(pos, newBlock);
          }
          return true;
        },
        // Deletes a block at a given position.
        BNDeleteBlock: (posInBlock) => ({ state, dispatch }) => {
          const blockInfo = getBlockInfoFromPos(state.doc, posInBlock);
          if (blockInfo === void 0) {
            return false;
          }
          const { startPos, endPos } = blockInfo;
          if (dispatch) {
            state.tr.deleteRange(startPos, endPos);
          }
          return true;
        },
        // Updates a block at a given position.
        BNUpdateBlock: (posInBlock, block2) => ({ state, dispatch }) => {
          const blockInfo = getBlockInfoFromPos(state.doc, posInBlock);
          if (blockInfo === void 0) {
            return false;
          }
          const { startPos, endPos, node: node2, contentNode } = blockInfo;
          if (dispatch) {
            if (block2.children !== void 0) {
              const childNodes = [];
              for (const child of block2.children) {
                childNodes.push(
                  blockToNode(
                    child,
                    state.schema,
                    this.options.editor.styleSchema
                  )
                );
              }
              if (node2.childCount === 2) {
                state.tr.replace(
                  startPos + contentNode.nodeSize + 1,
                  endPos - 1,
                  new Slice(Fragment.from(childNodes), 0, 0)
                );
              } else {
                state.tr.insert(
                  startPos + contentNode.nodeSize,
                  state.schema.nodes["blockGroup"].create({}, childNodes)
                );
              }
            }
            const oldType = contentNode.type.name;
            const newType = block2.type || oldType;
            let content2 = "keep";
            if (block2.content) {
              if (typeof block2.content === "string") {
                content2 = [state.schema.text(block2.content)];
              } else if (Array.isArray(block2.content)) {
                content2 = inlineContentToNodes(
                  block2.content,
                  state.schema,
                  this.options.editor.styleSchema
                );
              } else if (block2.content.type === "tableContent") {
                content2 = tableContentToNodes(
                  block2.content,
                  state.schema,
                  this.options.editor.styleSchema
                );
              } else {
                throw new UnreachableCaseError(block2.content.type);
              }
            } else {
              const oldContentType = state.schema.nodes[oldType].spec.content;
              const newContentType = state.schema.nodes[newType].spec.content;
              if (oldContentType === "")
                ;
              else if (newContentType !== oldContentType) {
                content2 = [];
              } else
                ;
            }
            if (content2 === "keep") {
              state.tr.setNodeMarkup(
                startPos,
                block2.type === void 0 ? void 0 : state.schema.nodes[block2.type],
                {
                  ...contentNode.attrs,
                  ...block2.props
                }
              );
            } else {
              state.tr.replaceWith(
                startPos,
                endPos,
                state.schema.nodes[newType].create(
                  {
                    ...contentNode.attrs,
                    ...block2.props
                  },
                  content2
                )
              ).setSelection(
                state.schema.nodes[newType].spec.content === "" ? new NodeSelection(state.tr.doc.resolve(startPos)) : state.schema.nodes[newType].spec.content === "inline*" ? new TextSelection(state.tr.doc.resolve(startPos)) : (
                  // Need to offset the position as we have to get through the
                  // `tableRow` and `tableCell` nodes to get to the
                  // `tableParagraph` node we want to set the selection in.
                  new TextSelection(state.tr.doc.resolve(startPos + 4))
                )
              );
            }
            state.tr.setNodeMarkup(startPos - 1, void 0, {
              ...node2.attrs,
              ...block2.props
            });
          }
          return true;
        },
        // Appends the text contents of a block to the nearest previous block, given a position between them. Children of
        // the merged block are moved out of it first, rather than also being merged.
        //
        // In the example below, the position passed into the function is between Block1 and Block2.
        //
        // Block1
        //    Block2
        // Block3
        //    Block4
        //        Block5
        //
        // Becomes:
        //
        // Block1
        //    Block2Block3
        // Block4
        //     Block5
        BNMergeBlocks: (posBetweenBlocks) => ({ state, dispatch }) => {
          const nextNodeIsBlock = state.doc.resolve(posBetweenBlocks + 1).node().type.name === "blockContainer";
          const prevNodeIsBlock = state.doc.resolve(posBetweenBlocks - 1).node().type.name === "blockContainer";
          if (!nextNodeIsBlock || !prevNodeIsBlock) {
            return false;
          }
          const nextBlockInfo = getBlockInfoFromPos(
            state.doc,
            posBetweenBlocks + 1
          );
          const { node: node2, contentNode, startPos, endPos, depth } = nextBlockInfo;
          if (node2.childCount === 2) {
            const childBlocksStart = state.doc.resolve(
              startPos + contentNode.nodeSize + 1
            );
            const childBlocksEnd = state.doc.resolve(endPos - 1);
            const childBlocksRange = childBlocksStart.blockRange(childBlocksEnd);
            if (dispatch) {
              state.tr.lift(childBlocksRange, depth - 1);
            }
          }
          let prevBlockEndPos = posBetweenBlocks - 1;
          let prevBlockInfo = getBlockInfoFromPos(state.doc, prevBlockEndPos);
          while (prevBlockInfo.numChildBlocks > 0) {
            prevBlockEndPos--;
            prevBlockInfo = getBlockInfoFromPos(state.doc, prevBlockEndPos);
            if (prevBlockInfo === void 0) {
              return false;
            }
          }
          if (dispatch) {
            dispatch(
              state.tr.deleteRange(startPos, startPos + contentNode.nodeSize).replace(
                prevBlockEndPos - 1,
                startPos,
                new Slice(contentNode.content, 0, 0)
              ).scrollIntoView()
            );
            state.tr.setSelection(
              new TextSelection(state.doc.resolve(prevBlockEndPos - 1))
            );
          }
          return true;
        },
        // Splits a block at a given position. Content after the position is moved to a new block below, at the same
        // nesting level.
        BNSplitBlock: (posInBlock, keepType) => ({ state, dispatch }) => {
          const blockInfo = getBlockInfoFromPos(state.doc, posInBlock);
          if (blockInfo === void 0) {
            return false;
          }
          const { contentNode, contentType, startPos, endPos, depth } = blockInfo;
          const originalBlockContent = state.doc.cut(startPos + 1, posInBlock);
          const newBlockContent = state.doc.cut(posInBlock, endPos - 1);
          const newBlock = state.schema.nodes["blockContainer"].createAndFill();
          const newBlockInsertionPos = endPos + 1;
          const newBlockContentPos = newBlockInsertionPos + 2;
          if (dispatch) {
            state.tr.insert(newBlockInsertionPos, newBlock);
            state.tr.replace(
              newBlockContentPos,
              newBlockContentPos + 1,
              newBlockContent.content.size > 0 ? new Slice(
                Fragment.from(newBlockContent),
                depth + 2,
                depth + 2
              ) : void 0
            );
            if (keepType) {
              state.tr.setBlockType(
                newBlockContentPos,
                newBlockContentPos,
                state.schema.node(contentType).type,
                contentNode.attrs
              );
            }
            state.tr.setSelection(
              new TextSelection(state.doc.resolve(newBlockContentPos))
            );
            state.tr.replace(
              startPos + 1,
              endPos - 1,
              originalBlockContent.content.size > 0 ? new Slice(
                Fragment.from(originalBlockContent),
                depth + 2,
                depth + 2
              ) : void 0
            );
          }
          return true;
        }
      };
    },
    addProseMirrorPlugins() {
      return [PreviousBlockTypePlugin(), NonEditableBlockPlugin()];
    },
    addKeyboardShortcuts() {
      const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
        // Deletes the selection if it's not empty.
        () => commands2.deleteSelection(),
        // Undoes an input rule if one was triggered in the last editor state change.
        () => commands2.undoInputRule(),
        // Reverts block content type to a paragraph if the selection is at the start of the block.
        () => commands2.command(({ state }) => {
          const { contentType, startPos } = getBlockInfoFromPos(
            state.doc,
            state.selection.from
          );
          const selectionAtBlockStart = state.selection.from === startPos + 1;
          const isParagraph = contentType.name === "paragraph";
          if (selectionAtBlockStart && !isParagraph) {
            return commands2.BNUpdateBlock(state.selection.from, {
              type: "paragraph",
              props: {}
            });
          }
          return false;
        }),
        // Removes a level of nesting if the block is indented if the selection is at the start of the block.
        () => commands2.command(({ state }) => {
          const { startPos } = getBlockInfoFromPos(
            state.doc,
            state.selection.from
          );
          const selectionAtBlockStart = state.selection.from === startPos + 1;
          if (selectionAtBlockStart) {
            return commands2.liftListItem("blockContainer");
          }
          return false;
        }),
        // Merges block with the previous one if it isn't indented, isn't the first block in the doc, and the selection
        // is at the start of the block.
        () => commands2.command(({ state }) => {
          const { depth, startPos } = getBlockInfoFromPos(
            state.doc,
            state.selection.from
          );
          const selectionAtBlockStart = state.selection.from === startPos + 1;
          const selectionEmpty = state.selection.empty;
          const blockAtDocStart = startPos === 2;
          const posBetweenBlocks = startPos - 1;
          if (!blockAtDocStart && selectionAtBlockStart && selectionEmpty && depth === 2) {
            return commands2.BNMergeBlocks(posBetweenBlocks);
          }
          return false;
        })
      ]);
      const handleDelete2 = () => this.editor.commands.first(({ commands: commands2 }) => [
        // Deletes the selection if it's not empty.
        () => commands2.deleteSelection(),
        // Merges block with the next one (at the same nesting level or lower),
        // if one exists, the block has no children, and the selection is at the
        // end of the block.
        () => commands2.command(({ state }) => {
          const { node: node2, depth, endPos } = getBlockInfoFromPos(
            state.doc,
            state.selection.from
          );
          const blockAtDocEnd = endPos === state.doc.nodeSize - 4;
          const selectionAtBlockEnd = state.selection.from === endPos - 1;
          const selectionEmpty = state.selection.empty;
          const hasChildBlocks = node2.childCount === 2;
          if (!blockAtDocEnd && selectionAtBlockEnd && selectionEmpty && !hasChildBlocks) {
            let oldDepth = depth;
            let newPos = endPos + 2;
            let newDepth = state.doc.resolve(newPos).depth;
            while (newDepth < oldDepth) {
              oldDepth = newDepth;
              newPos += 2;
              newDepth = state.doc.resolve(newPos).depth;
            }
            return commands2.BNMergeBlocks(newPos - 1);
          }
          return false;
        })
      ]);
      const handleEnter2 = () => this.editor.commands.first(({ commands: commands2 }) => [
        // Removes a level of nesting if the block is empty & indented, while the selection is also empty & at the start
        // of the block.
        () => commands2.command(({ state }) => {
          const { node: node2, depth } = getBlockInfoFromPos(
            state.doc,
            state.selection.from
          );
          const selectionAtBlockStart = state.selection.$anchor.parentOffset === 0;
          const selectionEmpty = state.selection.anchor === state.selection.head;
          const blockEmpty = node2.textContent.length === 0;
          const blockIndented = depth > 2;
          if (selectionAtBlockStart && selectionEmpty && blockEmpty && blockIndented) {
            return commands2.liftListItem("blockContainer");
          }
          return false;
        }),
        // Creates a new block and moves the selection to it if the current one is empty, while the selection is also
        // empty & at the start of the block.
        () => commands2.command(({ state, chain }) => {
          const { node: node2, endPos } = getBlockInfoFromPos(
            state.doc,
            state.selection.from
          );
          const selectionAtBlockStart = state.selection.$anchor.parentOffset === 0;
          const selectionEmpty = state.selection.anchor === state.selection.head;
          const blockEmpty = node2.textContent.length === 0;
          if (selectionAtBlockStart && selectionEmpty && blockEmpty) {
            const newBlockInsertionPos = endPos + 1;
            const newBlockContentPos = newBlockInsertionPos + 2;
            chain().BNCreateBlock(newBlockInsertionPos).setTextSelection(newBlockContentPos).run();
            return true;
          }
          return false;
        }),
        // Splits the current block, moving content inside that's after the cursor to a new text block below. Also
        // deletes the selection beforehand, if it's not empty.
        () => commands2.command(({ state, chain }) => {
          const { node: node2 } = getBlockInfoFromPos(
            state.doc,
            state.selection.from
          );
          const selectionAtBlockStart = state.selection.$anchor.parentOffset === 0;
          const blockEmpty = node2.textContent.length === 0;
          if (!blockEmpty) {
            const currentEl = this.editor.view.domAtPos(
              this.editor.state.selection.from
            ).node;
            if (currentEl.closest("table")) {
              chain().deleteSelection().setHardBreak().run();
            } else {
              chain().deleteSelection().BNSplitBlock(state.selection.from, selectionAtBlockStart).run();
            }
            return true;
          }
          return false;
        })
      ]);
      return {
        Backspace: handleBackspace,
        Delete: handleDelete2,
        Enter: handleEnter2,
        // Always returning true for tab key presses ensures they're not captured by the browser. Otherwise, they blur the
        // editor since the browser will try to use tab for keyboard navigation.
        Tab: () => {
          const currentEl = this.editor.view.domAtPos(
            this.editor.state.selection.from
          ).node;
          if (currentEl.closest("table")) {
            if (this.editor.commands.goToNextCell()) {
              return true;
            }
            if (!this.editor.can().addRowAfter()) {
              return false;
            }
            return this.editor.chain().addRowAfter().goToNextCell().run();
          } else {
            this.editor.commands.sinkListItem("blockContainer");
          }
          return true;
        },
        "Shift-Tab": () => {
          this.editor.commands.liftListItem("blockContainer");
          return true;
        }
      };
    }
  });
  const BlockGroup = Node.create({
    name: "blockGroup",
    group: "blockGroup",
    content: "blockContainer+",
    parseHTML() {
      return [
        {
          tag: "div",
          getAttrs: (element2) => {
            if (typeof element2 === "string") {
              return false;
            }
            if (element2.getAttribute("data-node-type") === "blockGroup") {
              return null;
            }
            return false;
          }
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      var _a;
      const blockGroupHTMLAttributes = {
        ...((_a = this.options.domAttributes) == null ? void 0 : _a.blockGroup) || {},
        ...HTMLAttributes
      };
      const blockGroup = document.createElement("div");
      blockGroup.className = mergeCSSClasses(
        "bn-block-group",
        blockGroupHTMLAttributes.class
      );
      blockGroup.setAttribute("data-node-type", "blockGroup");
      for (const [attribute, value] of Object.entries(blockGroupHTMLAttributes)) {
        if (attribute !== "class") {
          blockGroup.setAttribute(attribute, value);
        }
      }
      return {
        dom: blockGroup,
        contentDOM: blockGroup
      };
    }
  });
  const Doc = Node.create({
    name: "doc",
    topNode: true,
    content: "blockGroup"
  });
  const getBlockNoteExtensions = (opts) => {
    var _a;
    const ret = [
      extensions.ClipboardTextSerializer,
      extensions.Commands,
      extensions.Editable,
      extensions.FocusEvents,
      extensions.Tabindex,
      // DevTools,
      Gapcursor,
      // DropCursor,
      Placeholder.configure({
        includeChildren: true,
        showOnlyCurrent: false
      }),
      UniqueID.configure({
        types: ["blockContainer"]
      }),
      HardBreak,
      // Comments,
      // basics:
      Text,
      // marks:
      Link,
      ...Object.values(opts.styleSpecs).map((styleSpec) => {
        return styleSpec.implementation.mark;
      }),
      TextColorExtension,
      BackgroundColorExtension,
      TextAlignmentExtension,
      // nodes
      Doc,
      BlockContainer.configure({
        editor: opts.editor,
        domAttributes: opts.domAttributes
      }),
      BlockGroup.configure({
        domAttributes: opts.domAttributes
      }),
      ...Object.values(opts.inlineContentSpecs).filter((a2) => a2.config !== "link" && a2.config !== "text").map((inlineContentSpec) => {
        return inlineContentSpec.implementation.node.configure({
          editor: opts.editor
        });
      }),
      ...Object.values(opts.blockSpecs).flatMap((blockSpec) => {
        return [
          // dependent nodes (e.g.: tablecell / row)
          ...(blockSpec.implementation.requiredExtensions || []).map(
            (ext) => ext.configure({
              editor: opts.editor,
              domAttributes: opts.domAttributes
            })
          ),
          // the actual node itself
          blockSpec.implementation.node.configure({
            editor: opts.editor,
            domAttributes: opts.domAttributes
          })
        ];
      }),
      createCopyToClipboardExtension(opts.editor),
      createPasteFromClipboardExtension(opts.editor),
      Dropcursor.configure({ width: 5, color: "#ddeeff" }),
      // This needs to be at the bottom of this list, because Key events (such as enter, when selecting a /command),
      // should be handled before Enter handlers in other components like splitListItem
      TrailingNode
    ];
    if (opts.collaboration) {
      ret.push(
        Collaboration.configure({
          fragment: opts.collaboration.fragment
        })
      );
      if ((_a = opts.collaboration.provider) == null ? void 0 : _a.awareness) {
        const defaultRender = (user) => {
          const cursor = document.createElement("span");
          cursor.classList.add("collaboration-cursor__caret");
          cursor.setAttribute("style", `border-color: ${user.color}`);
          const label = document.createElement("span");
          label.classList.add("collaboration-cursor__label");
          label.setAttribute("style", `background-color: ${user.color}`);
          label.insertBefore(document.createTextNode(user.name), null);
          const nonbreakingSpace1 = document.createTextNode("⁠");
          const nonbreakingSpace2 = document.createTextNode("⁠");
          cursor.insertBefore(nonbreakingSpace1, null);
          cursor.insertBefore(label, null);
          cursor.insertBefore(nonbreakingSpace2, null);
          return cursor;
        };
        ret.push(
          CollaborationCursor.configure({
            user: opts.collaboration.user,
            render: opts.collaboration.renderCursor || defaultRender,
            provider: opts.collaboration.provider
          })
        );
      }
    } else {
      ret.push(History);
    }
    return ret;
  };
  function removeChild(node2, n) {
    const children = [];
    node2.forEach((child, _, i2) => {
      if (i2 !== n) {
        children.push(child);
      }
    });
    return Fragment.from(children);
  }
  function transformPasted(slice, view) {
    let f = Fragment.from(slice.content);
    for (let i2 = 0; i2 < f.childCount; i2++) {
      if (f.child(i2).type.spec.group === "blockContent") {
        const content2 = [f.child(i2)];
        if (i2 + 1 < f.childCount && f.child(i2 + 1).type.spec.group === "blockGroup") {
          const nestedChild = f.child(i2 + 1).child(0).child(0);
          if (nestedChild.type.name === "bulletListItem" || nestedChild.type.name === "numberedListItem") {
            content2.push(f.child(i2 + 1));
            f = removeChild(f, i2 + 1);
          }
        }
        const container = view.state.schema.nodes.blockContainer.create(
          void 0,
          content2
        );
        f = f.replaceChild(i2, container);
      }
    }
    return new Slice(f, slice.openStart, slice.openEnd);
  }
  const Block = "";
  const editor = "";
  const blockNoteTipTapOptions = {
    enableInputRules: true,
    enablePasteRules: true,
    enableCoreExtensions: false
  };
  class BlockNoteEditor {
    constructor(options) {
      __publicField(this, "_tiptapEditor");
      __publicField(this, "blockCache", /* @__PURE__ */ new WeakMap());
      __publicField(this, "blockSchema");
      __publicField(this, "inlineContentSchema");
      __publicField(this, "styleSchema");
      __publicField(this, "blockImplementations");
      __publicField(this, "inlineContentImplementations");
      __publicField(this, "styleImplementations");
      __publicField(this, "ready", false);
      __publicField(this, "sideMenu");
      __publicField(this, "formattingToolbar");
      __publicField(this, "slashMenu");
      __publicField(this, "hyperlinkToolbar");
      __publicField(this, "imageToolbar");
      __publicField(this, "tableHandles");
      __publicField(this, "uploadFile");
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      this.options = options;
      const newOptions = {
        defaultStyles: true,
        blockSpecs: options.blockSpecs || defaultBlockSpecs,
        styleSpecs: options.styleSpecs || defaultStyleSpecs,
        inlineContentSpecs: options.inlineContentSpecs || defaultInlineContentSpecs,
        ...options
      };
      this.blockSchema = getBlockSchemaFromSpecs(newOptions.blockSpecs);
      this.inlineContentSchema = getInlineContentSchemaFromSpecs(
        newOptions.inlineContentSpecs
      );
      this.styleSchema = getStyleSchemaFromSpecs(newOptions.styleSpecs);
      this.blockImplementations = newOptions.blockSpecs;
      this.inlineContentImplementations = newOptions.inlineContentSpecs;
      this.styleImplementations = newOptions.styleSpecs;
      this.sideMenu = new SideMenuProsemirrorPlugin(this);
      this.formattingToolbar = new FormattingToolbarProsemirrorPlugin(this);
      this.slashMenu = new SlashMenuProsemirrorPlugin(
        this,
        newOptions.slashMenuItems || getDefaultSlashMenuItems(this.blockSchema)
      );
      this.hyperlinkToolbar = new HyperlinkToolbarProsemirrorPlugin(this);
      this.imageToolbar = new ImageToolbarProsemirrorPlugin(this);
      if (this.blockSchema.table === defaultBlockSchema.table) {
        this.tableHandles = new TableHandlesProsemirrorPlugin(this);
      }
      const extensions2 = getBlockNoteExtensions({
        editor: this,
        domAttributes: newOptions.domAttributes || {},
        blockSchema: this.blockSchema,
        blockSpecs: newOptions.blockSpecs,
        styleSpecs: newOptions.styleSpecs,
        inlineContentSpecs: newOptions.inlineContentSpecs,
        collaboration: newOptions.collaboration
      });
      const blockNoteUIExtension = Extension.create({
        name: "BlockNoteUIExtension",
        addProseMirrorPlugins: () => {
          return [
            this.sideMenu.plugin,
            this.formattingToolbar.plugin,
            this.slashMenu.plugin,
            this.hyperlinkToolbar.plugin,
            this.imageToolbar.plugin,
            ...this.tableHandles ? [this.tableHandles.plugin] : []
          ];
        }
      });
      extensions2.push(blockNoteUIExtension);
      this.uploadFile = newOptions.uploadFile;
      if (newOptions.collaboration && newOptions.initialContent) {
        console.warn(
          "When using Collaboration, initialContent might cause conflicts, because changes should come from the collaboration provider"
        );
      }
      const initialContent = newOptions.initialContent || (options.collaboration ? void 0 : [
        {
          type: "paragraph",
          id: UniqueID.options.generateID()
        }
      ]);
      const styleSchema = this.styleSchema;
      const tiptapOptions = {
        ...blockNoteTipTapOptions,
        ...newOptions._tiptapOptions,
        onBeforeCreate(editor2) {
          var _a2, _b2;
          (_b2 = (_a2 = newOptions._tiptapOptions) == null ? void 0 : _a2.onBeforeCreate) == null ? void 0 : _b2.call(_a2, editor2);
          const schema = editor2.editor.schema;
          let cache;
          const oldCreateAndFill = schema.nodes.doc.createAndFill;
          schema.nodes.doc.createAndFill = (...args) => {
            if (cache) {
              return cache;
            }
            const ret = oldCreateAndFill.apply(schema.nodes.doc, args);
            const jsonNode = JSON.parse(JSON.stringify(ret.toJSON()));
            jsonNode.content[0].content[0].attrs.id = "initialBlockId";
            cache = Node$1.fromJSON(schema, jsonNode);
            return cache;
          };
          const root2 = schema.node(
            "doc",
            void 0,
            schema.node("blockGroup", void 0, [
              blockToNode(
                { id: "initialBlockId", type: "paragraph" },
                schema,
                styleSchema
              )
            ])
          );
          editor2.editor.options.content = root2.toJSON();
        },
        onCreate: (editor2) => {
          var _a2, _b2, _c2;
          (_b2 = (_a2 = newOptions._tiptapOptions) == null ? void 0 : _a2.onCreate) == null ? void 0 : _b2.call(_a2, editor2);
          if (initialContent !== void 0) {
            this.replaceBlocks(this.topLevelBlocks, initialContent);
          }
          (_c2 = newOptions.onEditorReady) == null ? void 0 : _c2.call(newOptions, this);
          this.ready = true;
        },
        onUpdate: (editor2) => {
          var _a2, _b2, _c2;
          (_b2 = (_a2 = newOptions._tiptapOptions) == null ? void 0 : _a2.onUpdate) == null ? void 0 : _b2.call(_a2, editor2);
          if (!this.ready) {
            return;
          }
          (_c2 = newOptions.onEditorContentChange) == null ? void 0 : _c2.call(newOptions, this);
        },
        onSelectionUpdate: (editor2) => {
          var _a2, _b2, _c2;
          (_b2 = (_a2 = newOptions._tiptapOptions) == null ? void 0 : _a2.onSelectionUpdate) == null ? void 0 : _b2.call(_a2, editor2);
          if (!this.ready) {
            return;
          }
          (_c2 = newOptions.onTextCursorPositionChange) == null ? void 0 : _c2.call(newOptions, this);
        },
        editable: options.editable !== void 0 ? options.editable : ((_a = newOptions._tiptapOptions) == null ? void 0 : _a.editable) !== void 0 ? (_b = newOptions._tiptapOptions) == null ? void 0 : _b.editable : true,
        extensions: newOptions.enableBlockNoteExtensions === false ? ((_c = newOptions._tiptapOptions) == null ? void 0 : _c.extensions) || [] : [...((_d = newOptions._tiptapOptions) == null ? void 0 : _d.extensions) || [], ...extensions2],
        editorProps: {
          ...(_e = newOptions._tiptapOptions) == null ? void 0 : _e.editorProps,
          attributes: {
            ...(_g = (_f = newOptions._tiptapOptions) == null ? void 0 : _f.editorProps) == null ? void 0 : _g.attributes,
            ...(_h = newOptions.domAttributes) == null ? void 0 : _h.editor,
            class: mergeCSSClasses(
              "bn-root",
              "bn-editor",
              newOptions.defaultStyles ? "bn-default-styles" : "",
              ((_j = (_i = newOptions.domAttributes) == null ? void 0 : _i.editor) == null ? void 0 : _j.class) || ""
            )
          },
          transformPasted
        }
      };
      if (newOptions.parentElement) {
        tiptapOptions.element = newOptions.parentElement;
      }
      this._tiptapEditor = new Editor(tiptapOptions);
    }
    static create(options = {}) {
      return new BlockNoteEditor(options);
    }
    get prosemirrorView() {
      return this._tiptapEditor.view;
    }
    get domElement() {
      return this._tiptapEditor.view.dom;
    }
    isFocused() {
      return this._tiptapEditor.view.hasFocus();
    }
    focus() {
      this._tiptapEditor.view.focus();
    }
    /**
     * Gets a snapshot of all top-level (non-nested) blocks in the editor.
     * @returns A snapshot of all top-level (non-nested) blocks in the editor.
     */
    get topLevelBlocks() {
      const blocks2 = [];
      this._tiptapEditor.state.doc.firstChild.descendants((node2) => {
        blocks2.push(
          nodeToBlock(
            node2,
            this.blockSchema,
            this.inlineContentSchema,
            this.styleSchema,
            this.blockCache
          )
        );
        return false;
      });
      return blocks2;
    }
    /**
     * Gets a snapshot of an existing block from the editor.
     * @param blockIdentifier The identifier of an existing block that should be retrieved.
     * @returns The block that matches the identifier, or `undefined` if no matching block was found.
     */
    getBlock(blockIdentifier) {
      const id = typeof blockIdentifier === "string" ? blockIdentifier : blockIdentifier.id;
      let newBlock = void 0;
      this._tiptapEditor.state.doc.firstChild.descendants((node2) => {
        if (typeof newBlock !== "undefined") {
          return false;
        }
        if (node2.type.name !== "blockContainer" || node2.attrs.id !== id) {
          return true;
        }
        newBlock = nodeToBlock(
          node2,
          this.blockSchema,
          this.inlineContentSchema,
          this.styleSchema,
          this.blockCache
        );
        return false;
      });
      return newBlock;
    }
    /**
     * Traverses all blocks in the editor depth-first, and executes a callback for each.
     * @param callback The callback to execute for each block. Returning `false` stops the traversal.
     * @param reverse Whether the blocks should be traversed in reverse order.
     */
    forEachBlock(callback, reverse = false) {
      const blocks2 = this.topLevelBlocks.slice();
      if (reverse) {
        blocks2.reverse();
      }
      function traverseBlockArray(blockArray) {
        for (const block2 of blockArray) {
          if (!callback(block2)) {
            return false;
          }
          const children = reverse ? block2.children.slice().reverse() : block2.children;
          if (!traverseBlockArray(children)) {
            return false;
          }
        }
        return true;
      }
      traverseBlockArray(blocks2);
    }
    /**
     * Executes a callback whenever the editor's contents change.
     * @param callback The callback to execute.
     */
    onEditorContentChange(callback) {
      this._tiptapEditor.on("update", callback);
    }
    /**
     * Executes a callback whenever the editor's selection changes.
     * @param callback The callback to execute.
     */
    onEditorSelectionChange(callback) {
      this._tiptapEditor.on("selectionUpdate", callback);
    }
    /**
     * Gets a snapshot of the current text cursor position.
     * @returns A snapshot of the current text cursor position.
     */
    getTextCursorPosition() {
      const { node: node2, depth, startPos, endPos } = getBlockInfoFromPos(
        this._tiptapEditor.state.doc,
        this._tiptapEditor.state.selection.from
      );
      const nodeIndex = this._tiptapEditor.state.doc.resolve(endPos).index(depth - 1);
      const numNodes = this._tiptapEditor.state.doc.resolve(endPos + 1).node().childCount;
      let prevNode = void 0;
      if (nodeIndex > 0) {
        prevNode = this._tiptapEditor.state.doc.resolve(startPos - 2).node();
      }
      let nextNode = void 0;
      if (nodeIndex < numNodes - 1) {
        nextNode = this._tiptapEditor.state.doc.resolve(endPos + 2).node();
      }
      return {
        block: nodeToBlock(
          node2,
          this.blockSchema,
          this.inlineContentSchema,
          this.styleSchema,
          this.blockCache
        ),
        prevBlock: prevNode === void 0 ? void 0 : nodeToBlock(
          prevNode,
          this.blockSchema,
          this.inlineContentSchema,
          this.styleSchema,
          this.blockCache
        ),
        nextBlock: nextNode === void 0 ? void 0 : nodeToBlock(
          nextNode,
          this.blockSchema,
          this.inlineContentSchema,
          this.styleSchema,
          this.blockCache
        )
      };
    }
    /**
     * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could
     * not be found.
     * @param targetBlock The identifier of an existing block that the text cursor should be moved to.
     * @param placement Whether the text cursor should be placed at the start or end of the block.
     */
    setTextCursorPosition(targetBlock, placement = "start") {
      const id = typeof targetBlock === "string" ? targetBlock : targetBlock == null ? void 0 : targetBlock.id;
      const { posBeforeNode } = getNodeById(id, this._tiptapEditor.state.doc);
      const { startPos, contentNode } = getBlockInfoFromPos(
        this._tiptapEditor.state.doc,
        posBeforeNode + 2
      );
      const contentType = this.blockSchema[contentNode.type.name].content;
      if (contentType === "none") {
        this._tiptapEditor.commands.setNodeSelection(startPos);
        return;
      }
      if (contentType === "inline") {
        if (placement === "start") {
          this._tiptapEditor.commands.setTextSelection(startPos + 1);
        } else {
          this._tiptapEditor.commands.setTextSelection(
            startPos + contentNode.nodeSize - 1
          );
        }
      } else if (contentType === "table") {
        if (placement === "start") {
          this._tiptapEditor.commands.setTextSelection(startPos + 4);
        } else {
          this._tiptapEditor.commands.setTextSelection(
            startPos + contentNode.nodeSize - 4
          );
        }
      } else {
        throw new UnreachableCaseError(contentType);
      }
    }
    /**
     * Gets a snapshot of the current selection.
     */
    getSelection() {
      if (this._tiptapEditor.state.selection.from === this._tiptapEditor.state.selection.to || "node" in this._tiptapEditor.state.selection) {
        return void 0;
      }
      const blocks2 = [];
      this._tiptapEditor.state.doc.descendants((node2, pos) => {
        if (node2.type.spec.group !== "blockContent") {
          return true;
        }
        if (pos + node2.nodeSize < this._tiptapEditor.state.selection.from || pos > this._tiptapEditor.state.selection.to) {
          return true;
        }
        blocks2.push(
          nodeToBlock(
            this._tiptapEditor.state.doc.resolve(pos).node(),
            this.blockSchema,
            this.inlineContentSchema,
            this.styleSchema,
            this.blockCache
          )
        );
        return false;
      });
      return { blocks: blocks2 };
    }
    /**
     * Checks if the editor is currently editable, or if it's locked.
     * @returns True if the editor is editable, false otherwise.
     */
    get isEditable() {
      return this._tiptapEditor.isEditable;
    }
    /**
     * Makes the editor editable or locks it, depending on the argument passed.
     * @param editable True to make the editor editable, or false to lock it.
     */
    set isEditable(editable) {
      this._tiptapEditor.setEditable(editable);
    }
    /**
     * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an
     * error if the reference block could not be found.
     * @param blocksToInsert An array of partial blocks that should be inserted.
     * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.
     * @param placement Whether the blocks should be inserted just before, just after, or nested inside the
     * `referenceBlock`. Inserts the blocks at the start of the existing block's children if "nested" is used.
     */
    insertBlocks(blocksToInsert, referenceBlock, placement = "before") {
      return insertBlocks(blocksToInsert, referenceBlock, placement, this);
    }
    /**
     * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be
     * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could
     * not be found.
     * @param blockToUpdate The block that should be updated.
     * @param update A partial block which defines how the existing block should be changed.
     */
    updateBlock(blockToUpdate, update) {
      return updateBlock(blockToUpdate, update, this);
    }
    /**
     * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.
     * @param blocksToRemove An array of identifiers for existing blocks that should be removed.
     */
    removeBlocks(blocksToRemove) {
      return removeBlocks(blocksToRemove, this);
    }
    /**
     * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or
     * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in
     * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.
     * @param blocksToRemove An array of blocks that should be replaced.
     * @param blocksToInsert An array of partial blocks to replace the old ones with.
     */
    replaceBlocks(blocksToRemove, blocksToInsert) {
      return replaceBlocks(blocksToRemove, blocksToInsert, this);
    }
    /**
     * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.
     */
    getActiveStyles() {
      const styles = {};
      const marks = this._tiptapEditor.state.selection.$to.marks();
      for (const mark2 of marks) {
        const config = this.styleSchema[mark2.type.name];
        if (!config) {
          console.warn("mark not found in styleschema", mark2.type.name);
          continue;
        }
        if (config.propSchema === "boolean") {
          styles[config.type] = true;
        } else {
          styles[config.type] = mark2.attrs.stringValue;
        }
      }
      return styles;
    }
    /**
     * Adds styles to the currently selected content.
     * @param styles The styles to add.
     */
    addStyles(styles) {
      this._tiptapEditor.view.focus();
      for (const [style2, value] of Object.entries(styles)) {
        const config = this.styleSchema[style2];
        if (!config) {
          throw new Error(`style ${style2} not found in styleSchema`);
        }
        if (config.propSchema === "boolean") {
          this._tiptapEditor.commands.setMark(style2);
        } else if (config.propSchema === "string") {
          this._tiptapEditor.commands.setMark(style2, { stringValue: value });
        } else {
          throw new UnreachableCaseError(config.propSchema);
        }
      }
    }
    /**
     * Removes styles from the currently selected content.
     * @param styles The styles to remove.
     */
    removeStyles(styles) {
      this._tiptapEditor.view.focus();
      for (const style2 of Object.keys(styles)) {
        this._tiptapEditor.commands.unsetMark(style2);
      }
    }
    /**
     * Toggles styles on the currently selected content.
     * @param styles The styles to toggle.
     */
    toggleStyles(styles) {
      this._tiptapEditor.view.focus();
      for (const [style2, value] of Object.entries(styles)) {
        const config = this.styleSchema[style2];
        if (!config) {
          throw new Error(`style ${style2} not found in styleSchema`);
        }
        if (config.propSchema === "boolean") {
          this._tiptapEditor.commands.toggleMark(style2);
        } else if (config.propSchema === "string") {
          this._tiptapEditor.commands.toggleMark(style2, { stringValue: value });
        } else {
          throw new UnreachableCaseError(config.propSchema);
        }
      }
    }
    /**
     * Gets the currently selected text.
     */
    getSelectedText() {
      return this._tiptapEditor.state.doc.textBetween(
        this._tiptapEditor.state.selection.from,
        this._tiptapEditor.state.selection.to
      );
    }
    /**
     * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.
     */
    getSelectedLinkUrl() {
      return this._tiptapEditor.getAttributes("link").href;
    }
    /**
     * Creates a new link to replace the selected content.
     * @param url The link URL.
     * @param text The text to display the link with.
     */
    createLink(url, text2) {
      if (url === "") {
        return;
      }
      const { from: from2, to } = this._tiptapEditor.state.selection;
      if (!text2) {
        text2 = this._tiptapEditor.state.doc.textBetween(from2, to);
      }
      const mark2 = this._tiptapEditor.schema.mark("link", { href: url });
      this._tiptapEditor.view.dispatch(
        this._tiptapEditor.view.state.tr.insertText(text2, from2, to).addMark(from2, from2 + text2.length, mark2)
      );
    }
    /**
     * Checks if the block containing the text cursor can be nested.
     */
    canNestBlock() {
      const { startPos, depth } = getBlockInfoFromPos(
        this._tiptapEditor.state.doc,
        this._tiptapEditor.state.selection.from
      );
      return this._tiptapEditor.state.doc.resolve(startPos).index(depth - 1) > 0;
    }
    /**
     * Nests the block containing the text cursor into the block above it.
     */
    nestBlock() {
      this._tiptapEditor.commands.sinkListItem("blockContainer");
    }
    /**
     * Checks if the block containing the text cursor is nested.
     */
    canUnnestBlock() {
      const { depth } = getBlockInfoFromPos(
        this._tiptapEditor.state.doc,
        this._tiptapEditor.state.selection.from
      );
      return depth > 2;
    }
    /**
     * Lifts the block containing the text cursor out of its parent.
     */
    unnestBlock() {
      this._tiptapEditor.commands.liftListItem("blockContainer");
    }
    // TODO: Fix when implementing HTML/Markdown import & export
    /**
     * Serializes blocks into an HTML string. To better conform to HTML standards, children of blocks which aren't list
     * items are un-nested in the output HTML.
     * @param blocks An array of blocks that should be serialized into HTML.
     * @returns The blocks, serialized as an HTML string.
     */
    async blocksToHTMLLossy(blocks2 = this.topLevelBlocks) {
      const exporter = createExternalHTMLExporter(
        this._tiptapEditor.schema,
        this
      );
      return exporter.exportBlocks(blocks2);
    }
    /**
     * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and
     * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote
     * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.
     * @param html The HTML string to parse blocks from.
     * @returns The blocks parsed from the HTML string.
     */
    async tryParseHTMLToBlocks(html2) {
      return HTMLToBlocks(
        html2,
        this.blockSchema,
        this.inlineContentSchema,
        this.styleSchema,
        this._tiptapEditor.schema
      );
    }
    /**
     * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of
     * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.
     * @param blocks An array of blocks that should be serialized into Markdown.
     * @returns The blocks, serialized as a Markdown string.
     */
    async blocksToMarkdownLossy(blocks2 = this.topLevelBlocks) {
      return blocksToMarkdown(blocks2, this._tiptapEditor.schema, this);
    }
    /**
     * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on
     * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it
     * as text.
     * @param markdown The Markdown string to parse blocks from.
     * @returns The blocks parsed from the Markdown string.
     */
    async tryParseMarkdownToBlocks(markdown) {
      return markdownToBlocks(
        markdown,
        this.blockSchema,
        this.inlineContentSchema,
        this.styleSchema,
        this._tiptapEditor.schema
      );
    }
    /**
     * Updates the user info for the current user that's shown to other collaborators.
     */
    updateCollaborationUserInfo(user) {
      if (!this.options.collaboration) {
        throw new Error(
          "Cannot update collaboration user info when collaboration is disabled."
        );
      }
      this._tiptapEditor.commands.updateUser(user);
    }
  }
  function textShorthandToStyledText(content2 = "") {
    if (typeof content2 === "string") {
      return [
        {
          type: "text",
          text: content2,
          styles: {}
        }
      ];
    }
    return content2;
  }
  function partialContentToInlineContent(content2) {
    if (typeof content2 === "string") {
      return textShorthandToStyledText(content2);
    }
    if (Array.isArray(content2)) {
      return content2.flatMap((partialContent) => {
        if (typeof partialContent === "string") {
          return textShorthandToStyledText(partialContent);
        } else if (isPartialLinkInlineContent(partialContent)) {
          return {
            ...partialContent,
            content: textShorthandToStyledText(partialContent.content)
          };
        } else if (isStyledTextInlineContent(partialContent)) {
          return partialContent;
        } else {
          return {
            props: {},
            ...partialContent,
            content: partialContentToInlineContent(partialContent.content)
          };
        }
      });
    }
    return content2;
  }
  function partialBlocksToBlocksForTesting(schema, partialBlocks) {
    return partialBlocks.map(
      (partialBlock) => partialBlockToBlockForTesting(schema, partialBlock)
    );
  }
  function partialBlockToBlockForTesting(schema, partialBlock) {
    const withDefaults = {
      id: "",
      type: partialBlock.type,
      props: {},
      content: schema[partialBlock.type].content === "inline" ? [] : void 0,
      children: [],
      ...partialBlock
    };
    Object.entries(schema[partialBlock.type].propSchema).forEach(
      ([propKey, propValue]) => {
        if (withDefaults.props[propKey] === void 0) {
          withDefaults.props[propKey] = propValue.default;
        }
      }
    );
    return {
      ...withDefaults,
      content: partialContentToInlineContent(withDefaults.content),
      children: withDefaults.children.map((c) => {
        return partialBlockToBlockForTesting(schema, c);
      })
    };
  }
  function addIdsToBlock(block2) {
    if (!block2.id) {
      block2.id = UniqueID.options.generateID();
    }
    if (block2.children) {
      addIdsToBlocks(block2.children);
    }
  }
  function addIdsToBlocks(blocks2) {
    for (const block2 of blocks2) {
      addIdsToBlock(block2);
    }
  }
  exports2.BlockNoteEditor = BlockNoteEditor;
  exports2.FormattingToolbarProsemirrorPlugin = FormattingToolbarProsemirrorPlugin;
  exports2.FormattingToolbarView = FormattingToolbarView;
  exports2.HyperlinkToolbarProsemirrorPlugin = HyperlinkToolbarProsemirrorPlugin;
  exports2.ImageToolbarProsemirrorPlugin = ImageToolbarProsemirrorPlugin;
  exports2.ImageToolbarView = ImageToolbarView;
  exports2.SideMenuProsemirrorPlugin = SideMenuProsemirrorPlugin;
  exports2.SideMenuView = SideMenuView;
  exports2.SlashMenuProsemirrorPlugin = SlashMenuProsemirrorPlugin;
  exports2.TableHandlesProsemirrorPlugin = TableHandlesProsemirrorPlugin;
  exports2.TableHandlesView = TableHandlesView;
  exports2.UniqueID = UniqueID;
  exports2.UnreachableCaseError = UnreachableCaseError;
  exports2.addIdsToBlock = addIdsToBlock;
  exports2.addIdsToBlocks = addIdsToBlocks;
  exports2.addInlineContentAttributes = addInlineContentAttributes;
  exports2.addInlineContentKeyboardShortcuts = addInlineContentKeyboardShortcuts;
  exports2.addStyleAttributes = addStyleAttributes;
  exports2.blockToNode = blockToNode;
  exports2.camelToDataKebab = camelToDataKebab;
  exports2.contentNodeToInlineContent = contentNodeToInlineContent;
  exports2.createBlockSpec = createBlockSpec;
  exports2.createBlockSpecFromStronglyTypedTiptapNode = createBlockSpecFromStronglyTypedTiptapNode;
  exports2.createExternalHTMLExporter = createExternalHTMLExporter;
  exports2.createInlineContentSpec = createInlineContentSpec;
  exports2.createInlineContentSpecFromTipTapNode = createInlineContentSpecFromTipTapNode;
  exports2.createInternalBlockSpec = createInternalBlockSpec;
  exports2.createInternalHTMLSerializer = createInternalHTMLSerializer;
  exports2.createInternalInlineContentSpec = createInternalInlineContentSpec;
  exports2.createInternalStyleSpec = createInternalStyleSpec;
  exports2.createStronglyTypedTiptapNode = createStronglyTypedTiptapNode;
  exports2.createStyleSpec = createStyleSpec;
  exports2.createStyleSpecFromTipTapMark = createStyleSpecFromTipTapMark;
  exports2.defaultBlockSchema = defaultBlockSchema;
  exports2.defaultBlockSpecs = defaultBlockSpecs;
  exports2.defaultInlineContentSchema = defaultInlineContentSchema;
  exports2.defaultInlineContentSpecs = defaultInlineContentSpecs;
  exports2.defaultProps = defaultProps;
  exports2.defaultStyleSchema = defaultStyleSchema;
  exports2.defaultStyleSpecs = defaultStyleSpecs;
  exports2.formatKeyboardShortcut = formatKeyboardShortcut;
  exports2.formattingToolbarPluginKey = formattingToolbarPluginKey;
  exports2.getBlockFromPos = getBlockFromPos;
  exports2.getBlockNoteExtensions = getBlockNoteExtensions;
  exports2.getBlockSchemaFromSpecs = getBlockSchemaFromSpecs;
  exports2.getDefaultSlashMenuItems = getDefaultSlashMenuItems;
  exports2.getDraggableBlockFromCoords = getDraggableBlockFromCoords;
  exports2.getInlineContentParseRules = getInlineContentParseRules;
  exports2.getInlineContentSchemaFromSpecs = getInlineContentSchemaFromSpecs;
  exports2.getParseRules = getParseRules;
  exports2.getStyleParseRules = getStyleParseRules;
  exports2.getStyleSchemaFromSpecs = getStyleSchemaFromSpecs;
  exports2.hyperlinkToolbarPluginKey = hyperlinkToolbarPluginKey;
  exports2.imageToolbarPluginKey = imageToolbarPluginKey;
  exports2.inheritedProps = inheritedProps;
  exports2.inlineContentToNodes = inlineContentToNodes;
  exports2.isAppleOS = isAppleOS;
  exports2.isLinkInlineContent = isLinkInlineContent;
  exports2.isPartialLinkInlineContent = isPartialLinkInlineContent;
  exports2.isStyledTextInlineContent = isStyledTextInlineContent;
  exports2.mergeCSSClasses = mergeCSSClasses;
  exports2.nodeToBlock = nodeToBlock;
  exports2.nodeToCustomInlineContent = nodeToCustomInlineContent;
  exports2.partialBlockToBlockForTesting = partialBlockToBlockForTesting;
  exports2.partialBlocksToBlocksForTesting = partialBlocksToBlocksForTesting;
  exports2.propsToAttributes = propsToAttributes;
  exports2.setupSuggestionsMenu = setupSuggestionsMenu;
  exports2.sideMenuPluginKey = sideMenuPluginKey;
  exports2.slashMenuPluginKey = slashMenuPluginKey;
  exports2.stylePropsToAttributes = stylePropsToAttributes;
  exports2.tableContentToNodes = tableContentToNodes;
  exports2.tableHandlesPluginKey = tableHandlesPluginKey;
  exports2.uploadToTmpFilesDotOrg_DEV_ONLY = uploadToTmpFilesDotOrg_DEV_ONLY;
  exports2.wrapInBlockStructure = wrapInBlockStructure;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
});
//# sourceMappingURL=blocknote.bundled.umd.js.map
